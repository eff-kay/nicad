<source file="systems/py/Django/trunk/django/views/decorators/http.py.pyindent" startline="70" endline="133">
def inner(request, * args, ** kwargs) :
INDENT
    if_modified_since = request.META.get("HTTP_IF_MODIFIED_SINCE")
    if_none_match = request.META.get("HTTP_IF_NONE_MATCH")
    if_match = request.META.get("HTTP_IF_MATCH")
    if if_none_match or if_match :
    INDENT
        try :
        INDENT
            etags = parse_etags(if_none_match or if_match)
        DEDENT
        except ValueError :
        INDENT
            if_none_match = None
            if_match = None

        DEDENT
    DEDENT
    if etag_func :
    INDENT
        res_etag = etag_func(request, * args, ** kwargs)
    DEDENT
    else :
    INDENT
        res_etag = None
    DEDENT
    if last_modified_func :
    INDENT
        dt = last_modified_func(request, * args, ** kwargs)
        if dt :
        INDENT
            res_last_modified = formatdate(timegm(dt.utctimetuple())) [: 26] + 'GMT'
        DEDENT
        else :
        INDENT
            res_last_modified = None
        DEDENT
    DEDENT
    else :
    INDENT
        res_last_modified = None
    DEDENT
    response = None
    if not ((if_match and (if_modified_since or if_none_match)) or
        (if_match and if_none_match)) :
    INDENT
        if ((if_none_match and (res_etag in etags or
                    "*" in etags and res_etag)) and
            (not if_modified_since or
                res_last_modified == if_modified_since)) :
        INDENT
            if request.method in ("GET", "HEAD") :
            INDENT
                response = HttpResponseNotModified()
            DEDENT
            else :
            INDENT
                response = HttpResponse(status = 412)
            DEDENT
        DEDENT
        elif if_match and ((not res_etag and "*" in etags) or
            (res_etag and res_etag not in etags)) :
        INDENT
            response = HttpResponse(status = 412)
        DEDENT
        elif (not if_none_match and if_modified_since and
            request.method == "GET" and
            res_last_modified == if_modified_since) :
        INDENT
            response = HttpResponseNotModified()
        DEDENT
    DEDENT
    if response is None :
    INDENT
        response = func(request, * args, ** kwargs)

    DEDENT
    if res_last_modified and not response.has_header('Last-Modified') :
    INDENT
        response ['Last-Modified'] = res_last_modified
    DEDENT
    if res_etag and not response.has_header('ETag') :
    INDENT
        response ['ETag'] = quote_etag(res_etag)
    DEDENT
    return response
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/decorators/http.py.pyindent" startline="138" endline="140">
def etag(etag_func) :
INDENT
    return condition(etag_func = etag_func)
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/decorators/http.py.pyindent" startline="141" endline="143">
def last_modified(last_modified_func) :
INDENT
    return condition(last_modified_func = last_modified_func)
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/debug.py.pyindent" startline="15" endline="22">
def linebreak_iter(template_source) :
INDENT
    yield 0
    p = template_source.find('\n')
    while p > = 0 :
    INDENT
        yield p + 1
        p = template_source.find('\n', p + 1)
    DEDENT
    yield len(template_source) + 1
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/debug.py.pyindent" startline="23" endline="33">
def get_safe_settings() :
INDENT
    "Returns a dictionary of the settings module, with sensitive settings blurred out."
    settings_dict = {}
    for k in dir(settings) :
    INDENT
        if k.isupper() :
        INDENT
            if HIDDEN_SETTINGS.search(k) :
            INDENT
                settings_dict [k] = '********************'
            DEDENT
            else :
            INDENT
                settings_dict [k] = getattr(settings, k)
            DEDENT
        DEDENT
    DEDENT
    return settings_dict
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/debug.py.pyindent" startline="34" endline="42">
def technical_500_response(request, exc_type, exc_value, tb) :
INDENT
    reporter = ExceptionReporter(request, exc_type, exc_value, tb)
    html = reporter.get_traceback_html()
    return HttpResponseServerError(html, mimetype = 'text/html')
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/debug.py.pyindent" startline="47" endline="61">
def __init__(self, request, exc_type, exc_value, tb) :
INDENT
    self.request = request
    self.exc_type = exc_type
    self.exc_value = exc_value
    self.tb = tb
    self.template_info = None
    self.template_does_not_exist = False
    self.loader_debug_info = None

    if isinstance(self.exc_type, basestring) :
    INDENT
        self.exc_value = Exception('Deprecated String Exception: %r' % self.exc_type)
        self.exc_type = type(self.exc_value)
    DEDENT
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/debug.py.pyindent" startline="62" endline="118">
def get_traceback_html(self) :
INDENT
    "Return HTML code for traceback."
    if issubclass(self.exc_type, TemplateDoesNotExist) :
    INDENT
        from django.template.loader import template_source_loaders
        self.template_does_not_exist = True
        self.loader_debug_info = []
        for loader in template_source_loaders :
        INDENT
            try :
            INDENT
                module = import_module(loader.__module__)
                source_list_func = module.get_template_sources

                template_list = [{'name' : t, 'exists' : os.path.exists(t)} for t in source_list_func(str(self.exc_value))]
            DEDENT
            except (ImportError, AttributeError) :
            INDENT
                template_list = []
            DEDENT
            if hasattr(loader, '__class__') :
            INDENT
                loader_name = loader.__module__ + '.' + loader.__class__.__name__
            DEDENT
            else :
            INDENT
                loader_name = loader.__module__ + '.' + loader.__name__
            DEDENT
            self.loader_debug_info.append({
                    'loader' : loader_name,
                    'templates' : template_list,
                    })
        DEDENT
    DEDENT
    if settings.TEMPLATE_DEBUG and hasattr(self.exc_value, 'source') :
    INDENT
        self.get_template_exception_info()
    DEDENT
    frames = self.get_traceback_frames()
    unicode_hint = ''
    if issubclass(self.exc_type, UnicodeError) :
    INDENT
        start = getattr(self.exc_value, 'start', None)
        end = getattr(self.exc_value, 'end', None)
        if start is not None and end is not None :
        INDENT
            unicode_str = self.exc_value.args [1]
            unicode_hint = smart_unicode(unicode_str [max(start - 5, 0) : min(end + 5, len(unicode_str))], 'ascii', errors = 'replace')
        DEDENT
    DEDENT
    from django import get_version
    t = Template(TECHNICAL_500_TEMPLATE, name = 'Technical 500 template')
    c = Context({
            'exception_type' : self.exc_type.__name__,
            'exception_value' : smart_unicode(self.exc_value, errors = 'replace'),
            'unicode_hint' : unicode_hint,
            'frames' : frames,
            'lastframe' : frames [- 1],
            'request' : self.request,
            'settings' : get_safe_settings(),
            'sys_executable' : sys.executable,
            'sys_version_info' : '%d.%d.%d' % sys.version_info [0 : 3],
            'server_time' : datetime.datetime.now(),
            'django_version_info' : get_version(),
            'sys_path' : sys.path,
            'template_info' : self.template_info,
            'template_does_not_exist' : self.template_does_not_exist,
            'loader_debug_info' : self.loader_debug_info,
            })
    return t.render(c)
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/debug.py.pyindent" startline="119" endline="152">
def get_template_exception_info(self) :
INDENT
    origin, (start, end) = self.exc_value.source
    template_source = origin.reload()
    context_lines = 10
    line = 0
    upto = 0
    source_lines = []
    before = during = after = ""
    for num, next in enumerate(linebreak_iter(template_source)) :
    INDENT
        if start > = upto and end < = next :
        INDENT
            line = num
            before = escape(template_source [upto : start])
            during = escape(template_source [start : end])
            after = escape(template_source [end : next])
        DEDENT
        source_lines.append((num, escape(template_source [upto : next])))
        upto = next
    DEDENT
    total = len(source_lines)
    top = max(1, line - context_lines)
    bottom = min(total, line + 1 + context_lines)
    self.template_info = {
        'message' : self.exc_value.args [0],
        'source_lines' : source_lines [top : bottom],
        'before' : before,
        'during' : during,
        'after' : after,
        'top' : top,
        'bottom' : bottom,
        'total' : total,
        'line' : line,
        'name' : origin.name,
        }
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/debug.py.pyindent" startline="153" endline="193">
def _get_lines_from_file(self, filename, lineno, context_lines, loader = None, module_name = None) :
INDENT
    source = None
    if loader is not None and hasattr(loader, "get_source") :
    INDENT
        source = loader.get_source(module_name)
        if source is not None :
        INDENT
            source = source.splitlines()
        DEDENT
    DEDENT
    if source is None :
    INDENT
        try :
        INDENT
            f = open(filename)
            try :
            INDENT
                source = f.readlines()
            DEDENT
            finally :
            INDENT
                f.close()
            DEDENT
        DEDENT
        except (OSError, IOError) :
        INDENT
            pass
        DEDENT
    DEDENT
    if source is None :
    INDENT
        return None, [], None, []
    DEDENT
    encoding = 'ascii'
    for line in source [: 2] :
    INDENT
        match = re.search(r'coding[:=]\s*([-\w.]+)', line)
        if match :
        INDENT
            encoding = match.group(1)
            break
        DEDENT
    DEDENT
    source = [unicode(sline, encoding, 'replace') for sline in source]
    lower_bound = max(0, lineno - context_lines)
    upper_bound = lineno + context_lines
    pre_context = [line.strip('\n') for line in source [lower_bound : lineno]]
    context_line = source [lineno].strip('\n')
    post_context = [line.strip('\n') for line in source [lineno + 1 : upper_bound]]
    return lower_bound, pre_context, context_line, post_context
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/debug.py.pyindent" startline="194" endline="233">
def get_traceback_frames(self) :
INDENT
    frames = []
    tb = self.tb
    while tb is not None :
    INDENT
        if tb.tb_frame.f_locals.get('__traceback_hide__') :
        INDENT
            tb = tb.tb_next
            continue
        DEDENT
        filename = tb.tb_frame.f_code.co_filename
        function = tb.tb_frame.f_code.co_name
        lineno = tb.tb_lineno - 1
        loader = tb.tb_frame.f_globals.get('__loader__')
        module_name = tb.tb_frame.f_globals.get('__name__')
        pre_context_lineno, pre_context, context_line, post_context = self._get_lines_from_file(filename, lineno, 7, loader, module_name)
        if pre_context_lineno is not None :
        INDENT
            frames.append({
                    'tb' : tb,
                    'filename' : filename,
                    'function' : function,
                    'lineno' : lineno + 1,
                    'vars' : tb.tb_frame.f_locals.items(),
                    'id' : id(tb),
                    'pre_context' : pre_context,
                    'context_line' : context_line,
                    'post_context' : post_context,
                    'pre_context_lineno' : pre_context_lineno + 1,
                    })
        DEDENT
        tb = tb.tb_next
    DEDENT
    if not frames :
    INDENT
        frames = [{
                'filename' : '&lt;unknown&gt;',
                'function' : '?',
                'lineno' : '?',
                'context_line' : '???',
                }]
    DEDENT
    return frames
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/debug.py.pyindent" startline="234" endline="246">
def format_exception(self) :
INDENT
    import traceback
    frames = self.get_traceback_frames()
    tb = [(f ['filename'], f ['lineno'], f ['function'], f ['context_line']) for f in frames]
    list = ['Traceback (most recent call last):\n']
    list += traceback.format_list(tb)
    list += traceback.format_exception_only(self.exc_type, self.exc_value)
    return list

DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/debug.py.pyindent" startline="247" endline="268">
def technical_404_response(request, exception) :
INDENT
    "Create a technical 404 error response. The exception should be the Http404."
    try :
    INDENT
        tried = exception.args [0] ['tried']
    DEDENT
    except (IndexError, TypeError) :
    INDENT
        tried = []
    DEDENT
    else :
    INDENT
        if not tried :
        INDENT
            return empty_urlconf(request)
        DEDENT
    DEDENT
    t = Template(TECHNICAL_404_TEMPLATE, name = 'Technical 404 template')
    c = Context({
            'root_urlconf' : settings.ROOT_URLCONF,
            'request_path' : request.path_info [1 :],
            'urlpatterns' : tried,
            'reason' : smart_str(exception, errors = 'replace'),
            'request' : request,
            'settings' : get_safe_settings(),
            })
    return HttpResponseNotFound(t.render(c), mimetype = 'text/html')
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/debug.py.pyindent" startline="269" endline="281">
def empty_urlconf(request) :
INDENT
    "Create an empty URLconf 404 error response."
    t = Template(EMPTY_URLCONF_TEMPLATE, name = 'Empty URLConf template')
    c = Context({
            'project_name' : settings.SETTINGS_MODULE.split('.') [0]})
    return HttpResponse(t.render(c), mimetype = 'text/html')

DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/static.py.pyindent" startline="19" endline="68">
def serve(request, path, document_root = None, show_indexes = False) :
INDENT
    path = posixpath.normpath(urllib.unquote(path))
    path = path.lstrip('/')
    newpath = ''
    for part in path.split('/') :
    INDENT
        if not part :
        INDENT
            continue
        DEDENT
        drive, part = os.path.splitdrive(part)
        head, part = os.path.split(part)
        if part in (os.curdir, os.pardir) :
        INDENT
            continue
        DEDENT
        newpath = os.path.join(newpath, part).replace('\\', '/')
    DEDENT
    if newpath and path ! = newpath :
    INDENT
        return HttpResponseRedirect(newpath)
    DEDENT
    fullpath = os.path.join(document_root, newpath)
    if os.path.isdir(fullpath) :
    INDENT
        if show_indexes :
        INDENT
            return directory_index(newpath, fullpath)
        DEDENT
        raise Http404, "Directory indexes are not allowed here."
    DEDENT
    if not os.path.exists(fullpath) :
    INDENT
        raise Http404, '"%s" does not exist' % fullpath
    DEDENT
    statobj = os.stat(fullpath)
    mimetype = mimetypes.guess_type(fullpath) [0] or 'application/octet-stream'
    if not was_modified_since(request.META.get('HTTP_IF_MODIFIED_SINCE'),
        statobj [stat.ST_MTIME], statobj [stat.ST_SIZE]) :
    INDENT
        return HttpResponseNotModified(mimetype = mimetype)
    DEDENT
    contents = open(fullpath, 'rb').read()
    response = HttpResponse(contents, mimetype = mimetype)
    response ["Last-Modified"] = http_date(statobj [stat.ST_MTIME])
    response ["Content-Length"] = len(contents)
    return response
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/static.py.pyindent" startline="92" endline="109">
def directory_index(path, fullpath) :
INDENT
    try :
    INDENT
        t = loader.select_template(['static/directory_index.html',
                'static/directory_index'])
    DEDENT
    except TemplateDoesNotExist :
    INDENT
        t = Template(DEFAULT_DIRECTORY_INDEX_TEMPLATE, name = 'Default directory index template')
    DEDENT
    files = []
    for f in os.listdir(fullpath) :
    INDENT
        if not f.startswith('.') :
        INDENT
            if os.path.isdir(os.path.join(fullpath, f)) :
            INDENT
                f += '/'
            DEDENT
            files.append(f)
        DEDENT
    DEDENT
    c = Context({
            'directory' : path + '/',
            'file_list' : files,
            })
    return HttpResponse(t.render(c))
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/static.py.pyindent" startline="110" endline="137">
def was_modified_since(header = None, mtime = 0, size = 0) :
INDENT
    try :
    INDENT
        if header is None :
        INDENT
            raise ValueError
        DEDENT
        matches = re.match(r"^([^;]+)(; length=([0-9]+))?$", header,
            re.IGNORECASE)
        header_mtime = mktime_tz(parsedate_tz(matches.group(1)))
        header_len = matches.group(3)
        if header_len and int(header_len) ! = size :
        INDENT
            raise ValueError
        DEDENT
        if mtime > header_mtime :
        INDENT
            raise ValueError
        DEDENT
    DEDENT
    except (AttributeError, ValueError) :
    INDENT
        return True
    DEDENT
    return False
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/defaults.py.pyindent" startline="4" endline="15">
def page_not_found(request, template_name = '404.html') :
INDENT
    t = loader.get_template(template_name)
    return http.HttpResponseNotFound(t.render(RequestContext(request, {'request_path' : request.path})))
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/defaults.py.pyindent" startline="16" endline="25">
def server_error(request, template_name = '500.html') :
INDENT
    t = loader.get_template(template_name)
    return http.HttpResponseServerError(t.render(Context({})))
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/defaults.py.pyindent" startline="26" endline="35">
def shortcut(request, content_type_id, object_id) :
INDENT
    from django.contrib.contenttypes.views import shortcut as real_shortcut
    return real_shortcut(request, content_type_id, object_id)
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/i18n.py.pyindent" startline="12" endline="37">
def set_language(request) :
INDENT
    next = request.REQUEST.get('next', None)
    if not next :
    INDENT
        next = request.META.get('HTTP_REFERER', None)
    DEDENT
    if not next :
    INDENT
        next = '/'
    DEDENT
    response = http.HttpResponseRedirect(next)
    if request.method == 'POST' :
    INDENT
        lang_code = request.POST.get('language', None)
        if lang_code and check_for_language(lang_code) :
        INDENT
            if hasattr(request, 'session') :
            INDENT
                request.session ['django_language'] = lang_code
            DEDENT
            else :
            INDENT
                response.set_cookie(settings.LANGUAGE_COOKIE_NAME, lang_code)
            DEDENT
        DEDENT
    DEDENT
    return response
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/i18n.py.pyindent" startline="38" endline="64">
def get_formats() :
INDENT
    FORMAT_SETTINGS = (
        'DATE_FORMAT', 'DATETIME_FORMAT', 'TIME_FORMAT',
        'YEAR_MONTH_FORMAT', 'MONTH_DAY_FORMAT', 'SHORT_DATE_FORMAT',
        'SHORT_DATETIME_FORMAT', 'FIRST_DAY_OF_WEEK', 'DECIMAL_SEPARATOR',
        'THOUSAND_SEPARATOR', 'NUMBER_GROUPING',
        'DATE_INPUT_FORMATS', 'TIME_INPUT_FORMATS', 'DATETIME_INPUT_FORMATS')
    result = {}
    for module in [settings] + get_format_modules(reverse = True) :
    INDENT
        for attr in FORMAT_SETTINGS :
        INDENT
            try :
            INDENT
                result [attr] = getattr(module, attr)
            DEDENT
            except AttributeError :
            INDENT
                pass
            DEDENT
        DEDENT
    DEDENT
    src = []
    for k, v in result.items() :
    INDENT
        if isinstance(v, (basestring, int)) :
        INDENT
            src.append("formats['%s'] = '%s';\n" % (javascript_quote(k), javascript_quote(smart_unicode(v))))
        DEDENT
        elif isinstance(v, (tuple, list)) :
        INDENT
            v = [javascript_quote(smart_unicode(value)) for value in v]
            src.append("formats['%s'] = ['%s'];\n" % (javascript_quote(k), "', '".join(v)))
        DEDENT
    DEDENT
    return ''.join(src)
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/i18n.py.pyindent" startline="146" endline="153">
def null_javascript_catalog(request, domain = None, packages = None) :
INDENT
    src = [NullSource, InterPolate, LibFormatHead, get_formats(), LibFormatFoot]
    return http.HttpResponse(''.join(src), 'text/javascript')
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/i18n.py.pyindent" startline="154" endline="248">
def javascript_catalog(request, domain = 'djangojs', packages = None) :
INDENT
    if request.GET :
    INDENT
        if 'language' in request.GET :
        INDENT
            if check_for_language(request.GET ['language']) :
            INDENT
                activate(request.GET ['language'])
            DEDENT
        DEDENT
    DEDENT
    if packages is None :
    INDENT
        packages = ['django.conf']
    DEDENT
    if isinstance(packages, basestring) :
    INDENT
        packages = packages.split('+')
    DEDENT
    packages = [p for p in packages if p == 'django.conf' or p in settings.INSTALLED_APPS]
    default_locale = to_locale(settings.LANGUAGE_CODE)
    locale = to_locale(get_language())
    t = {}
    paths = []
    for package in packages :
    INDENT
        p = importlib.import_module(package)
        path = os.path.join(os.path.dirname(p.__file__), 'locale')
        paths.append(path)
        try :
        INDENT
            catalog = gettext_module.translation(domain, path, ['en'])
            t.update(catalog._catalog)
        DEDENT
        except IOError :
        INDENT
            pass
        DEDENT
    DEDENT
    if default_locale ! = 'en' :
    INDENT
        for path in paths :
        INDENT
            try :
            INDENT
                catalog = gettext_module.translation(domain, path, [default_locale])
            DEDENT
            except IOError :
            INDENT
                catalog = None
            DEDENT
            if catalog is not None :
            INDENT
                t.update(catalog._catalog)
            DEDENT
        DEDENT
    DEDENT
    if locale ! = default_locale :
    INDENT
        for path in paths :
        INDENT
            try :
            INDENT
                catalog = gettext_module.translation(domain, path, [locale])
            DEDENT
            except IOError :
            INDENT
                catalog = None
            DEDENT
            if catalog is not None :
            INDENT
                t.update(catalog._catalog)
            DEDENT
        DEDENT
    DEDENT
    src = [LibHead]
    plural = None
    if '' in t :
    INDENT
        for l in t [''].split('\n') :
        INDENT
            if l.startswith('Plural-Forms:') :
            INDENT
                plural = l.split(':', 1) [1].strip()
            DEDENT
        DEDENT
    DEDENT
    if plural is not None :
    INDENT
        plural = [el.strip() for el in plural.split(';') if el.strip().startswith('plural=')] [0].split('=', 1) [1]
        src.append(PluralIdx % plural)
    DEDENT
    else :
    INDENT
        src.append(SimplePlural)
    DEDENT
    csrc = []
    pdict = {}
    for k, v in t.items() :
    INDENT
        if k == '' :
        INDENT
            continue
        DEDENT
        if isinstance(k, basestring) :
        INDENT
            csrc.append("catalog['%s'] = '%s';\n" % (javascript_quote(k), javascript_quote(v)))
        DEDENT
        elif isinstance(k, tuple) :
        INDENT
            if k [0] not in pdict :
            INDENT
                pdict [k [0]] = k [1]
            DEDENT
            else :
            INDENT
                pdict [k [0]] = max(k [1], pdict [k [0]])
            DEDENT
            csrc.append("catalog['%s'][%d] = '%s';\n" % (javascript_quote(k [0]), k [1], javascript_quote(v)))
        DEDENT
        else :
        INDENT
            raise TypeError, k
        DEDENT
    DEDENT
    csrc.sort()
    for k, v in pdict.items() :
    INDENT
        src.append("catalog['%s'] = [%s];\n" % (javascript_quote(k), ','.join(["''"] * (v + 1))))
    DEDENT
    src.extend(csrc)
    src.append(LibFoot)
    src.append(InterPolate)
    src.append(LibFormatHead)
    src.append(get_formats())
    src.append(LibFormatFoot)
    src = ''.join(src)
    return http.HttpResponse(src, 'text/javascript')
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/generic/list_detail.py.pyindent" startline="7" endline="102">
def object_list(request, queryset, paginate_by = None, page = None,
allow_empty = True, template_name = None, template_loader = loader,
extra_context = None, context_processors = None, template_object_name = 'object',
mimetype = None) :
INDENT
    if extra_context is None : extra_context = {}
    queryset = queryset._clone()
    if paginate_by :
    INDENT
        paginator = Paginator(queryset, paginate_by, allow_empty_first_page = allow_empty)
        if not page :
        INDENT
            page = request.GET.get('page', 1)
        DEDENT
        try :
        INDENT
            page_number = int(page)
        DEDENT
        except ValueError :
        INDENT
            if page == 'last' :
            INDENT
                page_number = paginator.num_pages
            DEDENT
            else :
            INDENT
                raise Http404
            DEDENT
        DEDENT
        try :
        INDENT
            page_obj = paginator.page(page_number)
        DEDENT
        except InvalidPage :
        INDENT
            raise Http404
        DEDENT
        c = RequestContext(request, {
                '%s_list' % template_object_name : page_obj.object_list,
                'paginator' : paginator,
                'page_obj' : page_obj,
                'is_paginated' : page_obj.has_other_pages(),
                'results_per_page' : paginator.per_page,
                'has_next' : page_obj.has_next(),
                'has_previous' : page_obj.has_previous(),
                'page' : page_obj.number,
                'next' : page_obj.next_page_number(),
                'previous' : page_obj.previous_page_number(),
                'first_on_page' : page_obj.start_index(),
                'last_on_page' : page_obj.end_index(),
                'pages' : paginator.num_pages,
                'hits' : paginator.count,
                'page_range' : paginator.page_range,
                }, context_processors)
    DEDENT
    else :
    INDENT
        c = RequestContext(request, {
                '%s_list' % template_object_name : queryset,
                'paginator' : None,
                'page_obj' : None,
                'is_paginated' : False,
                }, context_processors)
        if not allow_empty and len(queryset) == 0 :
        INDENT
            raise Http404
        DEDENT
    DEDENT
    for key, value in extra_context.items() :
    INDENT
        if callable(value) :
        INDENT
            c [key] = value()
        DEDENT
        else :
        INDENT
            c [key] = value
        DEDENT
    DEDENT
    if not template_name :
    INDENT
        model = queryset.model
        template_name = "%s/%s_list.html" % (model._meta.app_label, model._meta.object_name.lower())
    DEDENT
    t = template_loader.get_template(template_name)
    return HttpResponse(t.render(c), mimetype = mimetype)
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/generic/list_detail.py.pyindent" startline="103" endline="145">
def object_detail(request, queryset, object_id = None, slug = None,
slug_field = 'slug', template_name = None, template_name_field = None,
template_loader = loader, extra_context = None,
context_processors = None, template_object_name = 'object',
mimetype = None) :
INDENT
    if extra_context is None : extra_context = {}
    model = queryset.model
    if object_id :
    INDENT
        queryset = queryset.filter(pk = object_id)
    DEDENT
    elif slug and slug_field :
    INDENT
        queryset = queryset.filter(** {slug_field : slug})
    DEDENT
    else :
    INDENT
        raise AttributeError, "Generic detail view must be called with either an object_id or a slug/slug_field."
    DEDENT
    try :
    INDENT
        obj = queryset.get()
    DEDENT
    except ObjectDoesNotExist :
    INDENT
        raise Http404, "No %s found matching the query" % (model._meta.verbose_name)
    DEDENT
    if not template_name :
    INDENT
        template_name = "%s/%s_detail.html" % (model._meta.app_label, model._meta.object_name.lower())
    DEDENT
    if template_name_field :
    INDENT
        template_name_list = [getattr(obj, template_name_field), template_name]
        t = template_loader.select_template(template_name_list)
    DEDENT
    else :
    INDENT
        t = template_loader.get_template(template_name)
    DEDENT
    c = RequestContext(request, {
            template_object_name : obj,
            }, context_processors)
    for key, value in extra_context.items() :
    INDENT
        if callable(value) :
        INDENT
            c [key] = value()
        DEDENT
        else :
        INDENT
            c [key] = value
        DEDENT
    DEDENT
    response = HttpResponse(t.render(c), mimetype = mimetype)
    populate_xheaders(request, response, model, getattr(obj, obj._meta.pk.name))
    return response
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/generic/date_based.py.pyindent" startline="10" endline="50">
def archive_index(request, queryset, date_field, num_latest = 15,
template_name = None, template_loader = loader,
extra_context = None, allow_empty = True, context_processors = None,
mimetype = None, allow_future = False, template_object_name = 'latest') :
INDENT
    if extra_context is None : extra_context = {}
    model = queryset.model
    if not allow_future :
    INDENT
        queryset = queryset.filter(** {'%s__lte' % date_field : datetime.datetime.now()})
    DEDENT
    date_list = queryset.dates(date_field, 'year') [: : - 1]
    if not date_list and not allow_empty :
    INDENT
        raise Http404, "No %s available" % model._meta.verbose_name
    DEDENT
    if date_list and num_latest :
    INDENT
        latest = queryset.order_by('-' + date_field) [: num_latest]
    DEDENT
    else :
    INDENT
        latest = None
    DEDENT
    if not template_name :
    INDENT
        template_name = "%s/%s_archive.html" % (model._meta.app_label, model._meta.object_name.lower())
    DEDENT
    t = template_loader.get_template(template_name)
    c = RequestContext(request, {
            'date_list' : date_list,
            template_object_name : latest,
            }, context_processors)
    for key, value in extra_context.items() :
    INDENT
        if callable(value) :
        INDENT
            c [key] = value()
        DEDENT
        else :
        INDENT
            c [key] = value
        DEDENT
    DEDENT
    return HttpResponse(t.render(c), mimetype = mimetype)
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/generic/date_based.py.pyindent" startline="51" endline="98">
def archive_year(request, year, queryset, date_field, template_name = None,
template_loader = loader, extra_context = None, allow_empty = False,
context_processors = None, template_object_name = 'object', mimetype = None,
make_object_list = False, allow_future = False) :
INDENT
    if extra_context is None : extra_context = {}
    model = queryset.model
    now = datetime.datetime.now()
    lookup_kwargs = {'%s__year' % date_field : year}

    if int(year) > = now.year and not allow_future :
    INDENT
        lookup_kwargs ['%s__lte' % date_field] = now
    DEDENT
    date_list = queryset.filter(** lookup_kwargs).dates(date_field, 'month')
    if not date_list and not allow_empty :
    INDENT
        raise Http404
    DEDENT
    if make_object_list :
    INDENT
        object_list = queryset.filter(** lookup_kwargs)
    DEDENT
    else :
    INDENT
        object_list = []
    DEDENT
    if not template_name :
    INDENT
        template_name = "%s/%s_archive_year.html" % (model._meta.app_label, model._meta.object_name.lower())
    DEDENT
    t = template_loader.get_template(template_name)
    c = RequestContext(request, {
            'date_list' : date_list,
            'year' : year,
            '%s_list' % template_object_name : object_list,
            }, context_processors)
    for key, value in extra_context.items() :
    INDENT
        if callable(value) :
        INDENT
            c [key] = value()
        DEDENT
        else :
        INDENT
            c [key] = value
        DEDENT
    DEDENT
    return HttpResponse(t.render(c), mimetype = mimetype)
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/generic/date_based.py.pyindent" startline="99" endline="174">
def archive_month(request, year, month, queryset, date_field,
month_format = '%b', template_name = None, template_loader = loader,
extra_context = None, allow_empty = False, context_processors = None,
template_object_name = 'object', mimetype = None, allow_future = False) :
INDENT
    if extra_context is None : extra_context = {}
    try :
    INDENT
        tt = time.strptime("%s-%s" % (year, month), '%s-%s' % ('%Y', month_format))
        date = datetime.date(* tt [: 3])
    DEDENT
    except ValueError :
    INDENT
        raise Http404
    DEDENT
    model = queryset.model
    now = datetime.datetime.now()

    first_day = date.replace(day = 1)
    if first_day.month == 12 :
    INDENT
        last_day = first_day.replace(year = first_day.year + 1, month = 1)
    DEDENT
    else :
    INDENT
        last_day = first_day.replace(month = first_day.month + 1)
    DEDENT
    lookup_kwargs = {
        '%s__gte' % date_field : first_day,
        '%s__lt' % date_field : last_day,
        }

    if last_day > = now.date() and not allow_future :
    INDENT
        lookup_kwargs ['%s__lte' % date_field] = now
    DEDENT
    object_list = queryset.filter(** lookup_kwargs)
    if not object_list and not allow_empty :
    INDENT
        raise Http404
    DEDENT
    if allow_future :
    INDENT
        next_month = last_day
    DEDENT
    elif last_day < = datetime.date.today() :
    INDENT
        next_month = last_day
    DEDENT
    else :
    INDENT
        next_month = None

    DEDENT
    if first_day.month == 1 :
    INDENT
        previous_month = first_day.replace(year = first_day.year - 1, month = 12)
    DEDENT
    else :
    INDENT
        previous_month = first_day.replace(month = first_day.month - 1)
    DEDENT
    if not template_name :
    INDENT
        template_name = "%s/%s_archive_month.html" % (model._meta.app_label, model._meta.object_name.lower())
    DEDENT
    t = template_loader.get_template(template_name)
    c = RequestContext(request, {
            '%s_list' % template_object_name : object_list,
            'month' : date,
            'next_month' : next_month,
            'previous_month' : previous_month,
            }, context_processors)
    for key, value in extra_context.items() :
    INDENT
        if callable(value) :
        INDENT
            c [key] = value()
        DEDENT
        else :
        INDENT
            c [key] = value
        DEDENT
    DEDENT
    return HttpResponse(t.render(c), mimetype = mimetype)
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/generic/date_based.py.pyindent" startline="175" endline="226">
def archive_week(request, year, week, queryset, date_field,
template_name = None, template_loader = loader,
extra_context = None, allow_empty = True, context_processors = None,
template_object_name = 'object', mimetype = None, allow_future = False) :
INDENT
    if extra_context is None : extra_context = {}
    try :
    INDENT
        tt = time.strptime(year + '-0-' + week, '%Y-%w-%U')
        date = datetime.date(* tt [: 3])
    DEDENT
    except ValueError :
    INDENT
        raise Http404
    DEDENT
    model = queryset.model
    now = datetime.datetime.now()

    first_day = date
    last_day = date + datetime.timedelta(days = 7)
    lookup_kwargs = {
        '%s__gte' % date_field : first_day,
        '%s__lt' % date_field : last_day,
        }

    if last_day > = now.date() and not allow_future :
    INDENT
        lookup_kwargs ['%s__lte' % date_field] = now
    DEDENT
    object_list = queryset.filter(** lookup_kwargs)
    if not object_list and not allow_empty :
    INDENT
        raise Http404
    DEDENT
    if not template_name :
    INDENT
        template_name = "%s/%s_archive_week.html" % (model._meta.app_label, model._meta.object_name.lower())
    DEDENT
    t = template_loader.get_template(template_name)
    c = RequestContext(request, {
            '%s_list' % template_object_name : object_list,
            'week' : date,
            })
    for key, value in extra_context.items() :
    INDENT
        if callable(value) :
        INDENT
            c [key] = value()
        DEDENT
        else :
        INDENT
            c [key] = value
        DEDENT
    DEDENT
    return HttpResponse(t.render(c), mimetype = mimetype)
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/generic/date_based.py.pyindent" startline="227" endline="292">
def archive_day(request, year, month, day, queryset, date_field,
month_format = '%b', day_format = '%d', template_name = None,
template_loader = loader, extra_context = None, allow_empty = False,
context_processors = None, template_object_name = 'object',
mimetype = None, allow_future = False) :
INDENT
    if extra_context is None : extra_context = {}
    try :
    INDENT
        tt = time.strptime('%s-%s-%s' % (year, month, day),
            '%s-%s-%s' % ('%Y', month_format, day_format))
        date = datetime.date(* tt [: 3])
    DEDENT
    except ValueError :
    INDENT
        raise Http404
    DEDENT
    model = queryset.model
    now = datetime.datetime.now()
    if isinstance(model._meta.get_field(date_field), DateTimeField) :
    INDENT
        lookup_kwargs = {'%s__range' % date_field : (datetime.datetime.combine(date, datetime.time.min), datetime.datetime.combine(date, datetime.time.max))}
    DEDENT
    else :
    INDENT
        lookup_kwargs = {date_field : date}

    DEDENT
    if date > = now.date() and not allow_future :
    INDENT
        lookup_kwargs ['%s__lte' % date_field] = now
    DEDENT
    object_list = queryset.filter(** lookup_kwargs)
    if not allow_empty and not object_list :
    INDENT
        raise Http404
    DEDENT
    if allow_future :
    INDENT
        next_day = date + datetime.timedelta(days = 1)
    DEDENT
    elif date < datetime.date.today() :
    INDENT
        next_day = date + datetime.timedelta(days = 1)
    DEDENT
    else :
    INDENT
        next_day = None
    DEDENT
    if not template_name :
    INDENT
        template_name = "%s/%s_archive_day.html" % (model._meta.app_label, model._meta.object_name.lower())
    DEDENT
    t = template_loader.get_template(template_name)
    c = RequestContext(request, {
            '%s_list' % template_object_name : object_list,
            'day' : date,
            'previous_day' : date - datetime.timedelta(days = 1),
            'next_day' : next_day,
            }, context_processors)
    for key, value in extra_context.items() :
    INDENT
        if callable(value) :
        INDENT
            c [key] = value()
        DEDENT
        else :
        INDENT
            c [key] = value
        DEDENT
    DEDENT
    return HttpResponse(t.render(c), mimetype = mimetype)
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/generic/date_based.py.pyindent" startline="293" endline="304">
def archive_today(request, ** kwargs) :
INDENT
    today = datetime.date.today()
    kwargs.update({
            'year' : str(today.year),
            'month' : today.strftime('%b').lower(),
            'day' : str(today.day),
            })
    return archive_day(request, ** kwargs)
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/generic/date_based.py.pyindent" startline="305" endline="364">
def object_detail(request, year, month, day, queryset, date_field,
month_format = '%b', day_format = '%d', object_id = None, slug = None,
slug_field = 'slug', template_name = None, template_name_field = None,
template_loader = loader, extra_context = None, context_processors = None,
template_object_name = 'object', mimetype = None, allow_future = False) :
INDENT
    if extra_context is None : extra_context = {}
    try :
    INDENT
        tt = time.strptime('%s-%s-%s' % (year, month, day),
            '%s-%s-%s' % ('%Y', month_format, day_format))
        date = datetime.date(* tt [: 3])
    DEDENT
    except ValueError :
    INDENT
        raise Http404
    DEDENT
    model = queryset.model
    now = datetime.datetime.now()
    if isinstance(model._meta.get_field(date_field), DateTimeField) :
    INDENT
        lookup_kwargs = {'%s__range' % date_field : (datetime.datetime.combine(date, datetime.time.min), datetime.datetime.combine(date, datetime.time.max))}
    DEDENT
    else :
    INDENT
        lookup_kwargs = {date_field : date}

    DEDENT
    if date > = now.date() and not allow_future :
    INDENT
        lookup_kwargs ['%s__lte' % date_field] = now
    DEDENT
    if object_id :
    INDENT
        lookup_kwargs ['%s__exact' % model._meta.pk.name] = object_id
    DEDENT
    elif slug and slug_field :
    INDENT
        lookup_kwargs ['%s__exact' % slug_field] = slug
    DEDENT
    else :
    INDENT
        raise AttributeError, "Generic detail view must be called with either an object_id or a slug/slugfield"
    DEDENT
    try :
    INDENT
        obj = queryset.get(** lookup_kwargs)
    DEDENT
    except ObjectDoesNotExist :
    INDENT
        raise Http404, "No %s found for" % model._meta.verbose_name
    DEDENT
    if not template_name :
    INDENT
        template_name = "%s/%s_detail.html" % (model._meta.app_label, model._meta.object_name.lower())
    DEDENT
    if template_name_field :
    INDENT
        template_name_list = [getattr(obj, template_name_field), template_name]
        t = template_loader.select_template(template_name_list)
    DEDENT
    else :
    INDENT
        t = template_loader.get_template(template_name)
    DEDENT
    c = RequestContext(request, {
            template_object_name : obj,
            }, context_processors)
    for key, value in extra_context.items() :
    INDENT
        if callable(value) :
        INDENT
            c [key] = value()
        DEDENT
        else :
        INDENT
            c [key] = value
        DEDENT
    DEDENT
    response = HttpResponse(t.render(c), mimetype = mimetype)
    populate_xheaders(request, response, model, getattr(obj, obj._meta.pk.name))
    return response
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/generic/create_update.py.pyindent" startline="12" endline="22">
def apply_extra_context(extra_context, context) :
INDENT
    for key, value in extra_context.iteritems() :
    INDENT
        if callable(value) :
        INDENT
            context [key] = value()
        DEDENT
        else :
        INDENT
            context [key] = value
        DEDENT
    DEDENT
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/generic/create_update.py.pyindent" startline="23" endline="47">
def get_model_and_form_class(model, form_class) :
INDENT
    if form_class :
    INDENT
        return form_class._meta.model, form_class
    DEDENT
    if model :
    INDENT
        tmp_model = model

        class Meta :
        INDENT
            model = tmp_model
        DEDENT
        class_name = model.__name__ + 'Form'
        form_class = ModelFormMetaclass(class_name, (ModelForm,), {'Meta' : Meta})
        return model, form_class
    DEDENT
    raise GenericViewError("Generic view must be called with either a model or"
        " form_class argument.")
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/generic/create_update.py.pyindent" startline="48" endline="71">
def redirect(post_save_redirect, obj) :
INDENT
    if post_save_redirect :
    INDENT
        return HttpResponseRedirect(post_save_redirect % obj.__dict__)
    DEDENT
    elif hasattr(obj, 'get_absolute_url') :
    INDENT
        return HttpResponseRedirect(obj.get_absolute_url())
    DEDENT
    else :
    INDENT
        raise ImproperlyConfigured(
            "No URL to redirect to.  Either pass a post_save_redirect"
            " parameter to the generic view or define a get_absolute_url"
            " method on the Model.")
    DEDENT
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/generic/create_update.py.pyindent" startline="72" endline="93">
def lookup_object(model, object_id, slug, slug_field) :
INDENT
    lookup_kwargs = {}
    if object_id :
    INDENT
        lookup_kwargs ['%s__exact' % model._meta.pk.name] = object_id
    DEDENT
    elif slug and slug_field :
    INDENT
        lookup_kwargs ['%s__exact' % slug_field] = slug
    DEDENT
    else :
    INDENT
        raise GenericViewError(
            "Generic view must be called with either an object_id or a"
            " slug/slug_field.")
    DEDENT
    try :
    INDENT
        return model.objects.get(** lookup_kwargs)
    DEDENT
    except ObjectDoesNotExist :
    INDENT
        raise Http404("No %s found for %s"
            % (model._meta.verbose_name, lookup_kwargs))
    DEDENT
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/generic/create_update.py.pyindent" startline="94" endline="130">
def create_object(request, model = None, template_name = None,
template_loader = loader, extra_context = None, post_save_redirect = None,
login_required = False, context_processors = None, form_class = None) :
INDENT
    if extra_context is None : extra_context = {}
    if login_required and not request.user.is_authenticated() :
    INDENT
        return redirect_to_login(request.path)
    DEDENT
    model, form_class = get_model_and_form_class(model, form_class)
    if request.method == 'POST' :
    INDENT
        form = form_class(request.POST, request.FILES)
        if form.is_valid() :
        INDENT
            new_object = form.save()
            msg = ugettext("The %(verbose_name)s was created successfully.") % {"verbose_name" : model._meta.verbose_name}
            messages.success(request, msg, fail_silently = True)
            return redirect(post_save_redirect, new_object)
        DEDENT
    DEDENT
    else :
    INDENT
        form = form_class()

    DEDENT
    if not template_name :
    INDENT
        template_name = "%s/%s_form.html" % (model._meta.app_label, model._meta.object_name.lower())
    DEDENT
    t = template_loader.get_template(template_name)
    c = RequestContext(request, {
            'form' : form,
            }, context_processors)
    apply_extra_context(extra_context, c)
    return HttpResponse(t.render(c))
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/generic/create_update.py.pyindent" startline="131" endline="174">
def update_object(request, model = None, object_id = None, slug = None,
slug_field = 'slug', template_name = None, template_loader = loader,
extra_context = None, post_save_redirect = None, login_required = False,
context_processors = None, template_object_name = 'object',
form_class = None) :
INDENT
    if extra_context is None : extra_context = {}
    if login_required and not request.user.is_authenticated() :
    INDENT
        return redirect_to_login(request.path)
    DEDENT
    model, form_class = get_model_and_form_class(model, form_class)
    obj = lookup_object(model, object_id, slug, slug_field)
    if request.method == 'POST' :
    INDENT
        form = form_class(request.POST, request.FILES, instance = obj)
        if form.is_valid() :
        INDENT
            obj = form.save()
            msg = ugettext("The %(verbose_name)s was updated successfully.") % {"verbose_name" : model._meta.verbose_name}
            messages.success(request, msg, fail_silently = True)
            return redirect(post_save_redirect, obj)
        DEDENT
    DEDENT
    else :
    INDENT
        form = form_class(instance = obj)
    DEDENT
    if not template_name :
    INDENT
        template_name = "%s/%s_form.html" % (model._meta.app_label, model._meta.object_name.lower())
    DEDENT
    t = template_loader.get_template(template_name)
    c = RequestContext(request, {
            'form' : form,
            template_object_name : obj,
            }, context_processors)
    apply_extra_context(extra_context, c)
    response = HttpResponse(t.render(c))
    populate_xheaders(request, response, model, getattr(obj, obj._meta.pk.attname))
    return response
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/generic/create_update.py.pyindent" startline="175" endline="212">
def delete_object(request, model, post_delete_redirect, object_id = None,
slug = None, slug_field = 'slug', template_name = None,
template_loader = loader, extra_context = None, login_required = False,
context_processors = None, template_object_name = 'object') :
INDENT
    if extra_context is None : extra_context = {}
    if login_required and not request.user.is_authenticated() :
    INDENT
        return redirect_to_login(request.path)
    DEDENT
    obj = lookup_object(model, object_id, slug, slug_field)
    if request.method == 'POST' :
    INDENT
        obj.delete()
        msg = ugettext("The %(verbose_name)s was deleted.") % {"verbose_name" : model._meta.verbose_name}
        messages.success(request, msg, fail_silently = True)
        return HttpResponseRedirect(post_delete_redirect)
    DEDENT
    else :
    INDENT
        if not template_name :
        INDENT
            template_name = "%s/%s_confirm_delete.html" % (model._meta.app_label, model._meta.object_name.lower())
        DEDENT
        t = template_loader.get_template(template_name)
        c = RequestContext(request, {
                template_object_name : obj,
                }, context_processors)
        apply_extra_context(extra_context, c)
        response = HttpResponse(t.render(c))
        populate_xheaders(request, response, model, getattr(obj, obj._meta.pk.attname))
        return response
    DEDENT
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/generic/simple.py.pyindent" startline="4" endline="19">
def direct_to_template(request, template, extra_context = None, mimetype = None, ** kwargs) :
INDENT
    if extra_context is None : extra_context = {}
    dictionary = {'params' : kwargs}
    for key, value in extra_context.items() :
    INDENT
        if callable(value) :
        INDENT
            dictionary [key] = value()
        DEDENT
        else :
        INDENT
            dictionary [key] = value
        DEDENT
    DEDENT
    c = RequestContext(request, dictionary)
    t = loader.get_template(template)
    return HttpResponse(t.render(c), mimetype = mimetype)
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/generic/simple.py.pyindent" startline="20" endline="41">
def redirect_to(request, url, permanent = True, ** kwargs) :
INDENT
    if url is not None :
    INDENT
        klass = permanent and HttpResponsePermanentRedirect or HttpResponseRedirect
        return klass(url % kwargs)
    DEDENT
    else :
    INDENT
        return HttpResponseGone()
    DEDENT
DEDENT
</source>
<source file="systems/py/Django/trunk/django/conf/__init__.py.pyindent" startline="25" endline="41">
def _setup(self) :
INDENT
    try :
    INDENT
        settings_module = os.environ [ENVIRONMENT_VARIABLE]
        if not settings_module :
        INDENT
            raise KeyError
        DEDENT
    DEDENT
    except KeyError :
    INDENT
        raise ImportError("Settings cannot be imported, because environment variable %s is undefined." % ENVIRONMENT_VARIABLE)
    DEDENT
    self._wrapped = Settings(settings_module)
DEDENT
</source>
<source file="systems/py/Django/trunk/django/conf/__init__.py.pyindent" startline="42" endline="54">
def configure(self, default_settings = global_settings, ** options) :
INDENT
    if self._wrapped ! = None :
    INDENT
        raise RuntimeError, 'Settings already configured.'
    DEDENT
    holder = UserSettingsHolder(default_settings)
    for name, value in options.items() :
    INDENT
        setattr(holder, name, value)
    DEDENT
    self._wrapped = holder
DEDENT
</source>
<source file="systems/py/Django/trunk/django/conf/__init__.py.pyindent" startline="55" endline="59">
def configured(self) :
INDENT
    return bool(self._wrapped)
DEDENT
</source>
<source file="systems/py/Django/trunk/django/conf/__init__.py.pyindent" startline="63" endline="110">
def __init__(self, settings_module) :
INDENT
    for setting in dir(global_settings) :
    INDENT
        if setting == setting.upper() :
        INDENT
            setattr(self, setting, getattr(global_settings, setting))

        DEDENT
    DEDENT
    self.SETTINGS_MODULE = settings_module
    try :
    INDENT
        mod = importlib.import_module(self.SETTINGS_MODULE)
    DEDENT
    except ImportError, e :
    INDENT
        raise ImportError, "Could not import settings '%s' (Is it on sys.path? Does it have syntax errors?): %s" % (self.SETTINGS_MODULE, e)
    DEDENT
    tuple_settings = ("INSTALLED_APPS", "TEMPLATE_DIRS")
    for setting in dir(mod) :
    INDENT
        if setting == setting.upper() :
        INDENT
            setting_value = getattr(mod, setting)
            if setting in tuple_settings and type(setting_value) == str :
            INDENT
                setting_value = (setting_value,)
            DEDENT
            setattr(self, setting, setting_value)

        DEDENT
    DEDENT
    new_installed_apps = []
    for app in self.INSTALLED_APPS :
    INDENT
        if app.endswith('.*') :
        INDENT
            app_mod = importlib.import_module(app [: - 2])
            appdir = os.path.dirname(app_mod.__file__)
            app_subdirs = os.listdir(appdir)
            app_subdirs.sort()
            name_pattern = re.compile(r'[a-zA-Z]\w*')
            for d in app_subdirs :
            INDENT
                if name_pattern.match(d) and os.path.isdir(os.path.join(appdir, d)) :
                INDENT
                    new_installed_apps.append('%s.%s' % (app [: - 2], d))
                DEDENT
            DEDENT
        DEDENT
        else :
        INDENT
            new_installed_apps.append(app)
        DEDENT
    DEDENT
    self.INSTALLED_APPS = new_installed_apps
    if hasattr(time, 'tzset') :
    INDENT
        os.environ ['TZ'] = self.TIME_ZONE
        time.tzset()
    DEDENT
DEDENT
</source>
<source file="systems/py/Django/trunk/django/conf/__init__.py.pyindent" startline="119" endline="125">
def __init__(self, default_settings) :
INDENT
    self.default_settings = default_settings
DEDENT
</source>
<source file="systems/py/Django/trunk/django/conf/__init__.py.pyindent" startline="126" endline="128">
def __getattr__(self, name) :
INDENT
    return getattr(self.default_settings, name)
DEDENT
</source>
<source file="systems/py/Django/trunk/django/conf/__init__.py.pyindent" startline="129" endline="132">
def __dir__(self) :
INDENT
    return self.__dict__.keys() + dir(self.default_settings)

DEDENT
</source>
<source file="systems/py/Django/trunk/django/conf/app_template/tests.py.pyindent" startline="11" endline="16">
def test_basic_addition(self) :
INDENT
    self.failUnlessEqual(1 + 1, 2)
DEDENT
</source>
<source file="systems/py/Django/trunk/django/conf/urls/defaults.py.pyindent" startline="9" endline="19">
def include(arg, namespace = None, app_name = None) :
INDENT
    if isinstance(arg, tuple) :
    INDENT
        if namespace :
        INDENT
            raise ImproperlyConfigured('Cannot override the namespace for a dynamic module that provides a namespace')
        DEDENT
        urlconf_module, app_name, namespace = arg
    DEDENT
    else :
    INDENT
        urlconf_module = arg
    DEDENT
    return (urlconf_module, app_name, namespace)
DEDENT
</source>
<source file="systems/py/Django/trunk/django/conf/urls/defaults.py.pyindent" startline="20" endline="29">
def patterns(prefix, * args) :
INDENT
    pattern_list = []
    for t in args :
    INDENT
        if isinstance(t, (list, tuple)) :
        INDENT
            t = url(prefix = prefix, * t)
        DEDENT
        elif isinstance(t, RegexURLPattern) :
        INDENT
            t.add_prefix(prefix)
        DEDENT
        pattern_list.append(t)
    DEDENT
    return pattern_list
DEDENT
</source>
<source file="systems/py/Django/trunk/django/conf/urls/defaults.py.pyindent" startline="30" endline="42">
def url(regex, view, kwargs = None, name = None, prefix = '') :
INDENT
    if isinstance(view, (list, tuple)) :
    INDENT
        urlconf_module, app_name, namespace = view
        return RegexURLResolver(regex, urlconf_module, kwargs, app_name = app_name, namespace = namespace)
    DEDENT
    else :
    INDENT
        if isinstance(view, basestring) :
        INDENT
            if not view :
            INDENT
                raise ImproperlyConfigured('Empty URL pattern view name not permitted (for pattern %r)' % regex)
            DEDENT
            if prefix :
            INDENT
                view = prefix + '.' + view
            DEDENT
        DEDENT
        return RegexURLPattern(regex, view, kwargs, name)
    DEDENT
DEDENT
</source>
<source file="systems/py/Django/trunk/extras/csrf_migration_helper.py.pyindent" startline="146" endline="159">
def get_template_dirs() :
INDENT
    from django.conf import settings
    dirs = set()
    if 'django.template.loaders.filesystem.load_template_source' in settings.TEMPLATE_LOADERS :
    INDENT
        dirs.update(map(unicode, settings.TEMPLATE_DIRS))
    DEDENT
    if 'django.template.loaders.app_directories.load_template_source' in settings.TEMPLATE_LOADERS :
    INDENT
        from django.template.loaders.app_directories import app_template_dirs
        dirs.update(app_template_dirs)
    DEDENT
    return dirs
DEDENT
</source>
<source file="systems/py/Django/trunk/extras/csrf_migration_helper.py.pyindent" startline="160" endline="168">
def make_template_info(filename, root_dirs) :
INDENT
    return Template(filename,
        [filename [len(d) + 1 :] for d in root_dirs if filename.startswith(d)])

DEDENT
</source>
<source file="systems/py/Django/trunk/extras/csrf_migration_helper.py.pyindent" startline="170" endline="172">
def __init__(self, absolute_filename, relative_filenames) :
INDENT
    self.absolute_filename, self.relative_filenames = absolute_filename, relative_filenames
DEDENT
</source>
<source file="systems/py/Django/trunk/extras/csrf_migration_helper.py.pyindent" startline="173" endline="181">
def content(self) :
INDENT
    try :
    INDENT
        return self._content
    DEDENT
    except AttributeError :
    INDENT
        fd = open(self.absolute_filename)
        content = fd.read().decode(TEMPLATE_ENCODING)
        fd.close()
        self._content = content
        return content
    DEDENT
DEDENT
</source>
<source file="systems/py/Django/trunk/extras/csrf_migration_helper.py.pyindent" startline="184" endline="195">
def post_form_info(self) :
INDENT
    matches = []
    for ln, line in enumerate(self.content.split("\n")) :
    INDENT
        m = _POST_FORM_RE.search(line)
        if m is not None :
        INDENT
            matches.append((ln + 1, _TOKEN_RE.search(line) is not None))
        DEDENT
    DEDENT
    return matches
DEDENT
</source>
<source file="systems/py/Django/trunk/extras/csrf_migration_helper.py.pyindent" startline="196" endline="204">
def includes_template(self, t) :
INDENT
    for r in t.relative_filenames :
    INDENT
        if re.search(r'\{%\s*include\s+"' + re.escape(r) + r'"\s*%\}', self.content) :
        INDENT
            return True
        DEDENT
    DEDENT
    return False
DEDENT
</source>
<source file="systems/py/Django/trunk/extras/csrf_migration_helper.py.pyindent" startline="205" endline="225">
def related_templates(self) :
INDENT
    try :
    INDENT
        return self._related_templates
    DEDENT
    except AttributeError :
    INDENT
        pass
    DEDENT
    retval = set([self])
    for r in self.relative_filenames :
    INDENT
        for t in self.all_templates :
        INDENT
            if t.includes_template(self) :
            INDENT
                retval = retval.union(t.related_templates())
            DEDENT
        DEDENT
    DEDENT
    self._related_templates = retval
    return retval
DEDENT
</source>
<source file="systems/py/Django/trunk/extras/csrf_migration_helper.py.pyindent" startline="226" endline="228">
def __repr__(self) :
INDENT
    return repr(self.absolute_filename)
DEDENT
</source>
<source file="systems/py/Django/trunk/extras/csrf_migration_helper.py.pyindent" startline="229" endline="231">
def __eq__(self, other) :
INDENT
    return self.absolute_filename == other.absolute_filename
DEDENT
</source>
<source file="systems/py/Django/trunk/extras/csrf_migration_helper.py.pyindent" startline="232" endline="234">
def __hash__(self) :
INDENT
    return hash(self.absolute_filename)
DEDENT
</source>
<source file="systems/py/Django/trunk/extras/csrf_migration_helper.py.pyindent" startline="235" endline="250">
def get_templates(dirs) :
INDENT
    templates = set()
    for root in dirs :
    INDENT
        for (dirpath, dirnames, filenames) in os.walk(root) :
        INDENT
            for f in filenames :
            INDENT
                if len([True for e in TEMPLATE_EXTENSIONS if f.endswith(e)]) > 0 :
                INDENT
                    t = make_template_info(os.path.join(dirpath, f), dirs)
                    t.all_templates = templates
                    templates.add(t)
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    return templates
DEDENT
</source>
<source file="systems/py/Django/trunk/extras/csrf_migration_helper.py.pyindent" startline="251" endline="267">
def get_python_code(paths) :
INDENT
    retval = []
    for p in paths :
    INDENT
        for (dirpath, dirnames, filenames) in os.walk(p) :
        INDENT
            for f in filenames :
            INDENT
                if len([True for e in PYTHON_SOURCE_EXTENSIONS if f.endswith(e)]) > 0 :
                INDENT
                    fn = os.path.join(dirpath, f)
                    fd = open(fn)
                    content = [l.decode(PYTHON_ENCODING) for l in fd.readlines()]
                    fd.close()
                    retval.append((fn, content))
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    return retval
DEDENT
</source>
<source file="systems/py/Django/trunk/extras/csrf_migration_helper.py.pyindent" startline="268" endline="280">
def search_python_list(python_code, template_names) :
INDENT
    retval = []
    for tn in template_names :
    INDENT
        retval.extend(search_python(python_code, tn))
    DEDENT
    retval = list(set(retval))
    retval.sort()
    return retval
DEDENT
</source>
<source file="systems/py/Django/trunk/extras/csrf_migration_helper.py.pyindent" startline="281" endline="293">
def search_python(python_code, template_name) :
INDENT
    retval = []
    for fn, content in python_code :
    INDENT
        for ln, line in enumerate(content) :
        INDENT
            if ((u'"%s"' % template_name) in line) or ((u"'%s'" % template_name) in line) :
            INDENT
                retval.append((fn, ln + 1))
            DEDENT
        DEDENT
    DEDENT
    return retval
DEDENT
</source>
<source file="systems/py/Django/trunk/extras/csrf_migration_helper.py.pyindent" startline="294" endline="333">
def main(pythonpaths) :
INDENT
    template_dirs = get_template_dirs()
    templates = get_templates(template_dirs)
    python_code = get_python_code(pythonpaths)
    for t in templates :
    INDENT
        form_matches = t.post_form_info()
        num_post_forms = len(form_matches)
        form_lines_without_token = [ln for (ln, has_token) in form_matches if not has_token]
        if num_post_forms == 0 :
        INDENT
            continue
        DEDENT
        to_search = [rf for rt in t.related_templates() for rf in rt.relative_filenames]
        found = search_python_list(python_code, to_search)

        print t.absolute_filename
        for r in t.relative_filenames :
        INDENT
            print u"  AKA %s" % r
        DEDENT
        print u"  POST forms: %s" % num_post_forms
        print u"  With token: %s" % (num_post_forms - len(form_lines_without_token))
        if form_lines_without_token :
        INDENT
            print u"  Without token:"
            for ln in form_lines_without_token :
            INDENT
                print "%s:%d:" % (t.absolute_filename, ln)
            DEDENT
        DEDENT
        print
        print u"  Searching for:"
        for r in to_search :
        INDENT
            print u"    " + r
        DEDENT
        print
        print u"  Found:"
        if len(found) == 0 :
        INDENT
            print "    Nothing"
        DEDENT
        else :
        INDENT
            for fn, ln in found :
            INDENT
                print "%s:%d:" % (fn, ln)
            DEDENT
        DEDENT
        print
        print "----"
    DEDENT
DEDENT
</source>
