<source file="systems/c/httpd-2.2.8/modules/debug/mod_dumpio.c.ifdefed" startline="1" endline="282">
module AP_MODULE_DECLARE_DATA dumpio_module;
typedef struct dumpio_conf_t {
    int enable_input;
    int enable_output;
    int loglevel;
} dumpio_conf_t;

static void dumpit (ap_filter_t *f, apr_bucket *b) {
    conn_rec *c = f->c;
    dumpio_conf_t *ptr = (dumpio_conf_t *) ap_get_module_config (c->base_server->module_config, &dumpio_module);
    ap_log_error (APLOG_MARK, ptr->loglevel, 0, c->base_server, "mod_dumpio:  %s (%s-%s): %" APR_SIZE_T_FMT " bytes", f->frec->name, (APR_BUCKET_IS_METADATA (b)) ? "metadata" : "data", b->type->name, b->length);
    if (!(APR_BUCKET_IS_METADATA (b))) {
        const char *buf;
        apr_size_t nbytes;
        char *obuf;
        if (apr_bucket_read (b, &buf, &nbytes, APR_BLOCK_READ) == APR_SUCCESS) {
            if (nbytes) {
                obuf = malloc (nbytes + 1);
                memcpy (obuf, buf, nbytes);
                obuf[nbytes] = '\0';
                ap_log_error (APLOG_MARK, ptr->loglevel, 0, c->base_server, "mod_dumpio:  %s (%s-%s): %s", f->frec->name, (APR_BUCKET_IS_METADATA (b)) ? "metadata" : "data", b->type->name, obuf);
                free (obuf);
            }
        }
        else {
            ap_log_error (APLOG_MARK, ptr->loglevel, 0, c->base_server, "mod_dumpio:  %s (%s-%s): %s", f->frec->name, (APR_BUCKET_IS_METADATA (b)) ? "metadata" : "data", b->type->name, "error reading data");
        }
    }
}

static int dumpio_input_filter (ap_filter_t *f, apr_bucket_brigade *bb, ap_input_mode_t mode, apr_read_type_e block, apr_off_t readbytes) {
    apr_bucket *b;
    apr_status_t ret;
    conn_rec *c = f->c;
    dumpio_conf_t *ptr = (dumpio_conf_t *) ap_get_module_config (c->base_server->module_config, &dumpio_module);
    ap_log_error (APLOG_MARK, ptr->loglevel, 0, c->base_server, "mod_dumpio: %s [%s-%s] %" APR_OFF_T_FMT " readbytes", f->frec->name, whichmode (mode), ((block) == APR_BLOCK_READ) ? "blocking" : "nonblocking", readbytes);
    ret = ap_get_brigade (f->next, bb, mode, block, readbytes);
    if (ret == APR_SUCCESS) {
        for (b = APR_BRIGADE_FIRST (bb); b != APR_BRIGADE_SENTINEL (bb); b = APR_BUCKET_NEXT (b)) {
            dumpit (f, b);
        }
    }
    else {
        ap_log_error (APLOG_MARK, ptr->loglevel, 0, c->base_server, "mod_dumpio: %s - %d", f->frec->name, ret);
    }
    return APR_SUCCESS;
}

static int dumpio_output_filter (ap_filter_t *f, apr_bucket_brigade *bb) {
    apr_bucket *b;
    conn_rec *c = f->c;
    dumpio_conf_t *ptr = (dumpio_conf_t *) ap_get_module_config (c->base_server->module_config, &dumpio_module);
    ap_log_error (APLOG_MARK, ptr->loglevel, 0, c->base_server, "mod_dumpio: %s", f->frec->name);
    for (b = APR_BRIGADE_FIRST (bb); b != APR_BRIGADE_SENTINEL (bb); b = APR_BUCKET_NEXT (b)) {
        if (APR_BUCKET_IS_EOS (b)) {
            apr_bucket *flush = apr_bucket_flush_create (f->c->bucket_alloc);
            APR_BUCKET_INSERT_BEFORE (b, flush);
        }
        dumpit (f, b);
    }
    return ap_pass_brigade (f->next, bb);
}

static int dumpio_pre_conn (conn_rec *c, void *csd) {
    dumpio_conf_t *ptr = (dumpio_conf_t *) ap_get_module_config (c->base_server->module_config, &dumpio_module);
    if (ptr->enable_input)
        ap_add_input_filter ("DUMPIO_IN", NULL, NULL, c);
    if (ptr->enable_output)
        ap_add_output_filter ("DUMPIO_OUT", NULL, NULL, c);
    return OK;
}

static void dumpio_register_hooks (apr_pool_t *p) {
    ap_register_output_filter ("DUMPIO_OUT", dumpio_output_filter, NULL, AP_FTYPE_CONNECTION +3);
    ap_register_input_filter ("DUMPIO_IN", dumpio_input_filter, NULL, AP_FTYPE_CONNECTION +3);
    ap_hook_pre_connection (dumpio_pre_conn, NULL, NULL, APR_HOOK_MIDDLE);
}

static void *dumpio_create_sconfig (apr_pool_t *p, server_rec *s) {
    dumpio_conf_t *ptr = apr_pcalloc (p, sizeof *ptr);
    ptr->enable_input = ptr->enable_output = 0;
    ptr->loglevel = APLOG_DEBUG;
    return ptr;
}

static const char *dumpio_enable_input (cmd_parms *cmd, void *dummy, int arg) {
    dumpio_conf_t *ptr = (dumpio_conf_t *) ap_get_module_config (cmd->server->module_config, &dumpio_module);
    ptr->enable_input = arg;
    return NULL;
}

static const char *dumpio_enable_output (cmd_parms *cmd, void *dummy, int arg) {
    dumpio_conf_t *ptr = (dumpio_conf_t *) ap_get_module_config (cmd->server->module_config, &dumpio_module);
    ptr->enable_output = arg;
    return NULL;
}

static const char *set_loglevel (cmd_parms *cmd, void *dummy, const char *arg) {
    char *str;
    dumpio_conf_t *ptr = (dumpio_conf_t *) ap_get_module_config (cmd->server->module_config, &dumpio_module);
    const char *err = ap_check_cmd_context (cmd, NOT_IN_DIR_LOC_FILE | NOT_IN_LIMIT);
    if (err != NULL) {
        return err;
    }
    if ((str = ap_getword_conf (cmd->pool, &arg))) {
        if (!strcasecmp (str, "emerg")) {
            ptr->loglevel = APLOG_EMERG;
        }
        else if (!strcasecmp (str, "alert")) {
            ptr->loglevel = APLOG_ALERT;
        }
        else if (!strcasecmp (str, "crit")) {
            ptr->loglevel = APLOG_CRIT;
        }
        else if (!strcasecmp (str, "error")) {
            ptr->loglevel = APLOG_ERR;
        }
        else if (!strcasecmp (str, "warn")) {
            ptr->loglevel = APLOG_WARNING;
        }
        else if (!strcasecmp (str, "notice")) {
            ptr->loglevel = APLOG_NOTICE;
        }
        else if (!strcasecmp (str, "info")) {
            ptr->loglevel = APLOG_INFO;
        }
        else if (!strcasecmp (str, "debug")) {
            ptr->loglevel = APLOG_DEBUG;
        }
        else {
            return "DumpIOLogLevel requires level keyword: one of " "emerg/alert/crit/error/warn/notice/info/debug";
        }
    }
    else {
        return "DumpIOLogLevel requires level keyword";
    }
    return NULL;
}

static const command_rec dumpio_cmds [] = {AP_INIT_FLAG ("DumpIOInput", dumpio_enable_input, NULL, RSRC_CONF, "Enable I/O Dump on Input Data"), AP_INIT_FLAG ("DumpIOOutput", dumpio_enable_output, NULL, RSRC_CONF, "Enable I/O Dump on Output Data"), AP_INIT_TAKE1 ("DumpIOLogLevel", set_loglevel, NULL, RSRC_CONF, "Level at which DumpIO info is logged"), {NULL}};
module AP_MODULE_DECLARE_DATA dumpio_module = {STANDARD20_MODULE_STUFF, NULL, NULL, dumpio_create_sconfig, NULL, dumpio_cmds, dumpio_register_hooks};

</source>
<source file="systems/c/httpd-2.2.8/modules/debug/mod_bucketeer.c.ifdefed" startline="1" endline="185">
static const char bucketeerFilterName [] = "BUCKETEER";
module AP_MODULE_DECLARE_DATA bucketeer_module;
typedef struct bucketeer_filter_config_t {
    char bucketdelimiter;
    char passdelimiter;
    char flushdelimiter;
} bucketeer_filter_config_t;

static void *create_bucketeer_server_config (apr_pool_t *p, server_rec *s) {
    bucketeer_filter_config_t *c = apr_pcalloc (p, sizeof *c);
    c->bucketdelimiter = 0x02;
    c->passdelimiter = 0x10;
    c->flushdelimiter = 0x06;
    return c;
}

typedef struct bucketeer_ctx_t {
    apr_bucket_brigade *bb;
} bucketeer_ctx_t;

static apr_status_t bucketeer_out_filter (ap_filter_t *f, apr_bucket_brigade *bb) {
    apr_bucket *e;
    request_rec *r = f->r;
    bucketeer_ctx_t *ctx = f->ctx;
    bucketeer_filter_config_t *c;
    c = ap_get_module_config (r->server->module_config, &bucketeer_module);
    if (!ctx) {
        if (!r->content_type || strncmp (r->content_type, "text/", 5)) {
            ap_remove_output_filter (f);
            return ap_pass_brigade (f->next, bb);
        }
        ctx = f->ctx = apr_pcalloc (f->r->pool, sizeof (*ctx));
        ctx->bb = apr_brigade_create (f->r->pool, f->c->bucket_alloc);
        apr_table_unset (f->r->headers_out, "Content-Length");
    }
    for (e = APR_BRIGADE_FIRST (bb); e != APR_BRIGADE_SENTINEL (bb); e = APR_BUCKET_NEXT (e)) {
        const char *data;
        apr_size_t len, i, lastpos;
        if (APR_BUCKET_IS_EOS (e)) {
            APR_BUCKET_REMOVE (e);
            APR_BRIGADE_INSERT_TAIL (ctx->bb, e);
            return ap_pass_brigade (f->next, ctx->bb);
        }
        if (APR_BUCKET_IS_FLUSH (e)) {
            continue;
        }
        if (APR_BUCKET_IS_METADATA (e)) {
            apr_bucket *cpy;
            apr_bucket_copy (e, &cpy);
            APR_BRIGADE_INSERT_TAIL (ctx->bb, cpy);
            continue;
        }
        apr_bucket_read (e, &data, &len, APR_BLOCK_READ);
        if (len > 0) {
            lastpos = 0;
            for (i = 0; i < len; i++) {
                if (data[i] == c->flushdelimiter || data[i] == c->bucketdelimiter || data[i] == c->passdelimiter) {
                    apr_bucket *p;
                    if (i - lastpos > 0) {
                        p = apr_bucket_pool_create (apr_pmemdup (f->r->pool, &data[lastpos], i - lastpos), i - lastpos, f->r->pool, f->c->bucket_alloc);
                        APR_BRIGADE_INSERT_TAIL (ctx->bb, p);
                    }
                    lastpos = i + 1;
                    if (data[i] == c->flushdelimiter) {
                        p = apr_bucket_flush_create (f->c->bucket_alloc);
                        APR_BRIGADE_INSERT_TAIL (ctx->bb, p);
                    }
                    if (data[i] == c->flushdelimiter || data[i] == c->passdelimiter) {
                        ap_pass_brigade (f->next, ctx->bb);
                    }
                }
            }
            if (lastpos < i) {
                apr_bucket *p;
                p = apr_bucket_pool_create (apr_pmemdup (f->r->pool, &data[lastpos], i - lastpos), i - lastpos, f->r->pool, f->c->bucket_alloc);
                lastpos = i;
                APR_BRIGADE_INSERT_TAIL (ctx->bb, p);
            }
        }
    }
    return APR_SUCCESS;
}

static void register_hooks (apr_pool_t *p) {
    ap_register_output_filter (bucketeerFilterName, bucketeer_out_filter, NULL, AP_FTYPE_RESOURCE -1);
}

static const command_rec bucketeer_filter_cmds [] = {{NULL}};
module AP_MODULE_DECLARE_DATA bucketeer_module = {STANDARD20_MODULE_STUFF, NULL, NULL, create_bucketeer_server_config, NULL, bucketeer_filter_cmds, register_hooks};

</source>
