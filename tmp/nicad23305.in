<source file="systems/swift/reperformance_swift/REPerformance/SignUpViewController.swift" startline="1" endline="137">
import UIKit
import SnapKit
import FBSDKLoginKit
enum FacebookPermissions : String {
    case email = "email"
    case publicProfile = "public_profile"
    case userFriends = "user_friends"
}
struct SignUpInfo {
    let first : String
    let last : String
    let email : String
    let password : String
}
let MAX_CHARACTER_LENGTH = 30

class SignUpViewController : UITableViewController, UITextFieldDelegate {
    var facebookLogin : ((String, String) - > ())?
    var showTermsAndConds : (() - > ())?
    var signUp : ((SignUpInfo) - > ())?
    @IBOutlet fileprivate var facebookSignInContainerView : UIView?
    @IBOutlet fileprivate var firstnameTextfield : UITextField?
    @IBOutlet fileprivate var lastnameTextfield : UITextField?
    @IBOutlet fileprivate var emailTextfield : UITextField?
    @IBOutlet fileprivate var passwordTextfield : UITextField?
    @IBOutlet fileprivate var retypePasswordTextfield : UITextField?

    override func viewDidLoad () {
        super.viewDidLoad ()
        title = L10n.signUpTitle
        NotificationCenter.default.addObserver (forName : Notification.Name.AccessTokenDidChange, object : nil, queue : nil) {
            (_) in if let currentAccessToken = AccessToken.current {
                self.facebookLogin? (currentAccessToken.userID, currentAccessToken.tokenString)
            }
        }
        let facebookLoginButton = FBLoginButton ()
        facebookLoginButton.permissions = [FacebookPermissions.email.rawValue, FacebookPermissions.publicProfile.rawValue, FacebookPermissions.userFriends.rawValue]
        facebookSignInContainerView?.addSubview (facebookLoginButton)
        facebookLoginButton.snp.makeConstraints {
            (make) in make.edges.equalToSuperview ()
        }
    }

    override func viewDidAppear (_ animated : Bool) {
        super.viewDidAppear (animated)
        REPAnalytics.trackScreenWithName (screenName : ScreenName.CreateAccount, className : String (describing : self))
    }

    @IBAction fileprivate func termsAndCondsTapped () {
        showTermsAndConds? ()
    }

    @IBAction fileprivate func signupTapped (_ sender : UIButton) {
        guard let firstname = firstnameTextfield?.text, ! firstname.isEmpty else {
            UIAlertController.showAlert (L10n.missingInfo, message : L10n.firstNameMissing, inViewController : self)
            return
        }
        guard let lastname = lastnameTextfield?.text, ! lastname.isEmpty else {
            UIAlertController.showAlert (L10n.missingInfo, message : L10n.lastNameMissing, inViewController : self)
            return
        }
        if firstname.count > MAX_CHARACTER_LENGTH || lastname.count > MAX_CHARACTER_LENGTH {
            UIAlertController.showAlert (L10n.missingInfo, message : L10n.nameTooLong, inViewController : self)
            return
        }
        guard let email = emailTextfield?.text, ! email.isEmpty else {
            UIAlertController.showAlert (L10n.missingInfo, message : L10n.emailMissing, inViewController : self)
            return
        }
        guard isValidEmail (email : email) else {
            UIAlertController.showAlert (L10n.validation, message : L10n.emailInvalid, inViewController : self)
            return
        }
        guard let password = passwordTextfield?.text, ! password.isEmpty else {
            UIAlertController.showAlert (L10n.missingInfo, message : L10n.passwordMissing, inViewController : self)
            return
        }
        guard let retypePassword = retypePasswordTextfield?.text, password == retypePassword else {
            UIAlertController.showAlert (L10n.validation, message : L10n.passwordInvalid, inViewController : self)
            return
        }
        signUp? (SignUpInfo (first : firstname, last : lastname, email : email, password : password))
    }

    func clearAllTextfields () {
        self.firstnameTextfield?.text = ""
        self.lastnameTextfield?.text = ""
        self.emailTextfield?.text = ""
        self.passwordTextfield?.text = ""
        self.retypePasswordTextfield?.text = ""
    }

    func textField (_ textField : UITextField, shouldChangeCharactersIn range : NSRange, replacementString string : String) - > Bool {
        guard let textFieldText = textField.text, let rangeOfTextToReplace = Range (range, in : textFieldText) else {
            return false
        }
        let substringToReplace = textFieldText [rangeOfTextToReplace]
        let count = textFieldText.count-
        substringToReplace.count+
        string.count
        return count<=
        30
    }
}

extension UITextField {
    @IBInspectable var placeHolderColor : UIColor? {
        get {
            return self.placeHolderColor
        }
        set {
            self.attributedPlaceholder = NSAttributedString (string : self.placeholder! = nil? self.placeholder! : "", attributes : [NSAttributedString.Key.foregroundColor : newValue!])
        }
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/LeaderboardSelectionHeaderTableViewCell.swift" startline="1" endline="27">
import UIKit

class LeaderboardSelectionHeaderTableViewCell : UITableViewCell {
    @IBOutlet private var exerciseCategoryLabel : UILabel?
    @IBOutlet private var exerciseCategoryImageView : UIImageView?

    override func awakeFromNib () {
        super.awakeFromNib ()
        exerciseCategoryLabel?.textColor = UIColor.white
    }

    func configureCell (exerciseCategoryText : String, exerciseCategoryImage : UIImage) {
        exerciseCategoryLabel?.text = exerciseCategoryText
        exerciseCategoryImageView?.image = exerciseCategoryImage
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/Constants.swift" startline="1" endline="180">
import NVActivityIndicatorView
struct Constants {
    static let BundleIdentifier = "com.collegemobile.REPerformance"
    static let BugsnagAPIKey = "e43b72289c095e73d7e527ca92397525"
    static let TermsAndConditionsFilename = "termsAndConditions"
    static let PrivacyFilename = "privacy"
    static let GoogleAnalyticsKey = "UA-38460636-6"
    struct UserDefaultsKey {
        static let UserToken = BundleIdentifier + ".USER_TOKEN_DEFAULTS_KEY"
        static let ProfileIsPrivate = BundleIdentifier + ".PROFILE_IS_PRIVATE_DEFAULTS_KEY"
        static let HasViewLifeStyle = BundleIdentifier + ".VIEW_LIFESTYLE_DEFAULTS_KEY"
        static let ProfileIsComplete = BundleIdentifier + ".PROFILE_COMPLETE_DEFAULTS_KEY"
        static let UserLastName = BundleIdentifier + ".USER_LAST_NAME_KEY"
        static let UserFirstName = BundleIdentifier + ".USER_FIRST_NAME_KEY"
        static let LifestyleType = BundleIdentifier + ".LIFESTYLE_TYPE_KEY"
        static let UserID = BundleIdentifier + ".USER_ID_KEY"
        static let UserAge = BundleIdentifier + ".USER_AGE"
        static let UserWeight = BundleIdentifier + ".USER_WEIGHT"
        static let UserGender = BundleIdentifier + ".USER_GENDER"
        static let UserHasRespondedToNotificationsRequest = BundleIdentifier + ".RESPONDED_TO_NOTIFICATIONS_REQUEST_KEY"
        static let UserCurrentLocation = BundleIdentifier + ".REPerformance.USER_CURRENT_LOCATION"
        static let UserCredits = BundleIdentifier + ".USER_CREDITS"
        static let UserDollars = BundleIdentifier + ".USER_DOLLARS"
        static let UserFacebookID = BundleIdentifier + ".USER_FACEBOOK_ID"
        static let ProfileNeverFilledOut = BundleIdentifier + ".PROFILE_NEVER_FILLED_OUT"
        static let ReportCardNeverSeen = BundleIdentifier + ".REPORT_CARD_NEVER_SEEN"
        static let FirstLaunch = BundleIdentifier + ".FIRST_LAUNCH"
        static let LeaderboardNeverSeen = BundleIdentifier + ".LEADERBOARD_NEVER_SEEN"
        static let CurrentGymPlaceID = BundleIdentifier + ".CURRENT_GYM_PLACE_ID"
        static let LastAppVersionCheck = BundleIdentifier + ".LAST_APP_VERSION"
        static let ProfileImage = BundleIdentifier + ".PROFILE_IMAGE"
    }
    struct UIConstants {
        static let CornerRadius : CGFloat = 5.0
        static let LogoutButtonCornerRadius : CGFloat = 20.0
        static let BorderWidth : CGFloat = 2.0
        struct SearchBar {
            static let BackgroundAlpha : CGFloat = 0.2
            static let CornerRadius : CGFloat = 5.0
            static let BorderWidth : CGFloat = 1.0
            static let PlaceholderAlpha : CGFloat = 0.5
        }
    }
    struct ReportCard {
        static let RefreshTimeInterval : TimeInterval = 1800
        static let LeaderboardPositionCellIdentifier = "leaderboardPositionCell"
        static let LeaderboardDividerCellIdentifier = "leaderboardDividerCell"
        static let LeaderboardSelectionHeaderCell = "LeaderboardSelectionHeaderCell"
        static let LeaderboardSelectionCell = "LeaderboardSelectionCell"
        static let LeaderboardErrorCellIdentifier = "leaderboardErrorCellID"
        static let LeaderboardSelectionHeaderCellHeight : CGFloat = 70
        static let GlobalLeaderboardSelectionCellTitleText = "All Tests"
        static let REPerformanceWebsiteURLString = "http://www.reperformanceapp.com"
    }
    struct OurValue {
        static let OurValueTableViewCellIdentifier = "ourValueTableViewCell"
        static let EndorsementsTableViewCellIdentifier = "endorsementsTableViewCell"
        static let EndorsementsVideoYouTubeID = "DrIIBcE1wi4"
    }
    struct Profile {
        static let TitleKey = "title"
        static let SelectedKey = "selected"
        static let PointsKey = "points"
        static let ValueKey = "value"
        static let BasicProfileCellIdentifier = "BasicProfileCellIdentifier"
        static let ValueAndUnitsProfileCellIdentifier = "ValueAndUnitsProfileCellIdentifier"
        static let ValueProfileCellIdentifier = "ValueProfileCellIdentifier"
        static let LocationCellIdentifier = "LocationCellIdentifier"
        static let HeightTableViewCellIdentifier = "HeightTableViewCellIdentifier"
        static let BasicInfoQuestionnaireFilePath = "/basicInfo.dat"
        static let NutritionQuestionnaireFilePath = "/nutrition.dat"
        static let LifestyleQuestionnaireFilePath = "/lifestyle.dat"
        static let ExerciseQuestionnaireFilePath = "/exercise.dat"
        static let BasicInfoQuestionnaireTitle = "Basic Info"
        static let NutritionQuestionnaireTitle = "Nutrition"
        static let LifestyleQuestionnaireTitle = "Lifestyle"
        static let ExerciseQuestionnaireTitle = "Exercise"
        static let LifestyleActionCeiling = 58
        static let LifestyleFitCeiling = 108
        static let LifestyleAthleteCeiling = 147
        static let TableViewHeaderBuffer : CGFloat = 20
        static let TableViewHeaderFontSize : CGFloat = 18
        static let BasicInfoAgeQuestionIndex = 3
        static let BasicInfoCountryQuestionIndex = 4
        static let BasicInfoProvinceQuestionIndex = 5
        static let BasicInfoWeightQuestionIndex = 0
        static let BasicInfoWeightInKGIndex = 2
        static let BasicInfoGenderQuestionIndex = 1
        static let BasicInfoHeightQuestionIndex = 2
        static let PoundsPerKilogram = 2.20463
        static let TableViewFooterHeight : CGFloat = 70
        static let TableViewFooterButtonHeight : CGFloat = 40
        static let ProfileNotificationTimeInterval : TimeInterval = 7776000
    }
    struct Exercises {
        static let InstagramSharedApplicationURL = "instagram://library?LocalIdentifier="
    }
    struct Rewards {
        static let RewardsCellIdentifier = "viewRewardsCell"
        static let RefreshTimeInterval : TimeInterval = 1800
    }
    struct PaidSubscriptionKey {
        static let ProductIdentifierKey = BundleIdentifier + ".ProductIdentifierKey"
        static let PurchaseDateKey = BundleIdentifier + ".PurchaseDateKey"
        static let ExpiresDateKey = BundleIdentifier + ".ExpiresDateKey"
        static let LevelKey = BundleIdentifier + ".LevelKey"
    }
    struct Vimeo {
        static let BackgroundIdentifier = BundleIdentifier + ".Upload"
        #if USE_PRODUCTION
            static let AuthKey = "d2384d9e1264952df06d9354a73f2e85"
            static let VideoExpiration : TimeInterval = 60*
            60*
            24
            static let UploadTimeout : TimeInterval = 60
        #else
            static let AuthKey = "e73bba6bb158aba46e0fb61a5322e729"
            static let VideoExpiration : TimeInterval = 60
            static let UploadTimeout : TimeInterval = 10
        #endif
    }
    static let activityData = ActivityData (type : .ballPulse)
    struct UserData {
        static let Male = "Male"
        static let Female = "Female"
    }
    struct Keychain {
        static let Service = BundleIdentifier + ".KeychainService"
        static let CurrentSubscription = BundleIdentifier + ".CURRENT_SUBSCRIPTION_KEY"
    }
    struct Google {
        static let APIKey = "AIzaSyBGox6E6KaTgf6AsY6KPMXVz08ffAo0_rA"
    }
    struct GymLeaderboard {
        static let MapSearchResultsCellID = "mapSearchResultCellIdentifier"
        static let NearbySearchRadius = 30000
    }
    struct Challenges {
        static let ChallengesCellIdentifier = "ChallengesCellIdentifier"
        static let ChallengeGymCellIdentifier = "ChallengeGymCellIdentifier"
    }
    static let secondsInOneHour : TimeInterval = 60 * 60
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/ChallengeGymLeaderboardViewController.swift" startline="1" endline="64">
import UIKit

class ChallengeGymLeaderboardViewController : UIViewController {
    @IBOutlet fileprivate weak var leaderboardTableView : UITableView! {
        didSet {
            self.leaderboardTableView.backgroundColor = UIColor.clear
        }
    }
    var challenge : Challenge?
    var selectedAthlete : ((Athlete) - > ())?
    var athletes : [Athlete]? {
        didSet {
            self.leaderboardTableView.reloadData ()
        }
    }

    override func viewDidAppear (_ animated : Bool) {
        super.viewDidAppear (animated)
        REPAnalytics.trackScreenWithName (screenName : ScreenName.Challenges.Leaderboard (self.challenge!.name), className : String (describing : self))
    }
}

extension ChallengeGymLeaderboardViewController : UITableViewDataSource, UITableViewDelegate {

    func tableView (_ tableView : UITableView, numberOfRowsInSection section : Int) - > Int {
        return self.athletes?.count??
        0
    }

    func tableView (_ tableView : UITableView, cellForRowAt indexPath : IndexPath) - > UITableViewCell {
        let cell = tableView.dequeueReusableCell (withIdentifier : "Challenge Gym Leaderboard Ranking Cell Identifier", for : indexPath) as! ChallengeGymLeaderboardTableViewCell
        let challengeLeaderboard = self.athletes! [indexPath.row]
        cell.rank = challengeLeaderboard.rank
        cell.name = challengeLeaderboard.name
        cell.score = challengeLeaderboard.score
        cell.profileImageURL = FacebookImage.imageURLWithFacebookID (challengeLeaderboard.facebookIdentifier)
        cell.isPublic = challengeLeaderboard.isPublic
        return cell
    }

    func tableView (_ tableView : UITableView, didSelectRowAt indexPath : IndexPath) {
        tableView.deselectRow (at : indexPath, animated : true)
        let athlete = self.athletes! [indexPath.row]
        self.selectedAthlete? (athlete)
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/OurValueCoordinator.swift" startline="1" endline="71">
import UIKit
protocol OurValueItem {
    var question : String {get}
}
struct OurValueEndorsements : OurValueItem {
    let question : String
    init (question : String) {
        self.question = question
    }
}
struct OurValueQuestion : OurValueItem {
    let question : String
    let answer : String
    init (question : String, answer : String) {
        self.question = question
        self.answer = answer
    }
}

class OurValueCoordinator {
    let ourValueViewController : OurValueTableViewController
    let endorsementsViewController : EndorsementsViewController
    let questions : Array <String> = [L10n.ourValueQuestion1, L10n.ourValueQuestion2, L10n.ourValueQuestion3, L10n.ourValueQuestion4, L10n.ourValueQuestion5]
    let answers : Array <String> = [L10n.ourValueAnswer1, L10n.ourValueAnswer2, L10n.ourValueAnswer3, L10n.ourValueAnswer4, L10n.ourValueAnswer5]
    init () {
        ourValueViewController = StoryboardScene.OurValue.ourValueVC.instantiate ()
        endorsementsViewController = StoryboardScene.OurValue.endorsementsVC.instantiate ()
        ourValueViewController.title = L10n.ourValueTitle
        setUpOurValueTableViewController ()
        setUpEndorsementsViewController ()
    }

    func rootViewController () - > UIViewController {
        return ourValueViewController
    }

    private func setUpOurValueTableViewController () {
        ourValueViewController.viewData = getOurValueContent ()
        ourValueViewController.endorsements = {
            [weak ourValueViewController] in ourValueViewController?.navigationController?.pushViewController (self.endorsementsViewController, animated : true)
        }
    }

    private func setUpEndorsementsViewController () {
        let viewData : EndorsementsViewData = EndorsementsViewData (player1Name : L10n.nickFolignoName, player1Description : L10n.nickFolignoDescription, player2Name : L10n.rebeccaJohnsonName, player2Description : L10n.rebeccaJohnsonDescription,
          player3Name : L10n.marcusFolignoName, player3Description : L10n.marcusFolignoDescription)
        endorsementsViewController.viewData = viewData
    }

    private func getOurValueContent () - > Array <OurValueItem> {
        let items : Array <OurValueItem> = [OurValueEndorsements (question : L10n.endorsementsCellTitle), OurValueQuestion (question : L10n.ourValueQuestion1, answer : L10n.ourValueAnswer1), OurValueQuestion (question : L10n.ourValueQuestion2, answer :
          L10n.ourValueAnswer2), OurValueQuestion (question : L10n.ourValueQuestion3, answer : L10n.ourValueAnswer3), OurValueQuestion (question : L10n.ourValueQuestion4, answer : L10n.ourValueAnswer4), OurValueQuestion (question : L10n.ourValueQuestion5,
          answer : L10n.ourValueAnswer5)]
        return items
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/Strings.swift" startline="1" endline="413">
import Foundation
enum L10n {
    static let accountActivationMessage = L10n.tr ("Localizable", "account_activation_message")
    static let basicProfileTestQuestion = L10n.tr ("Localizable", "basic_profile_test_question")
    static let benchPress = L10n.tr ("Localizable", "bench_press")
    static let camera = L10n.tr ("Localizable", "camera")
    static let cameraPermission = L10n.tr ("Localizable", "camera_permission")
    static let cancel = L10n.tr ("Localizable", "cancel")
    static let challengeButtonTitle = L10n.tr ("Localizable", "challenge_button_title")
    static let challengeDetailsTitle = L10n.tr ("Localizable", "challenge_details_title")
    static let challengeEnded = L10n.tr ("Localizable", "challenge_ended")
    static let challengeGymChallengeJoinErrorMessage = L10n.tr ("Localizable", "challenge_gym_challenge_join_error_message")
    static let challengeGymChallengeJoinErrorTitle = L10n.tr ("Localizable", "challenge_gym_challenge_join_error_title")
    static let challengeGymLeaderboardTitle = L10n.tr ("Localizable", "challenge_gym_leaderboard_title")
    static let challengeJoin = L10n.tr ("Localizable", "challenge_join")
    static let challengeJoined = L10n.tr ("Localizable", "challenge_joined")

    static func challengeJoinedMessage (_ p1 : String, _ p2 : String) - > String {
        return L10n.tr ("Localizable", "challenge_joined_message", p1, p2)
    }
    static let challengeLeaderboardTitle = L10n.tr ("Localizable", "challenge_leaderboard_title")
    static let challengeLeave = L10n.tr ("Localizable", "challenge_leave")
    static let challengeLeavePromptMessage = L10n.tr ("Localizable", "challenge_leave_prompt_message")
    static let challengeLessThenHour = L10n.tr ("Localizable", "challenge_less_then_hour")
    static let challengeStartsInLessThanAnHour = L10n.tr ("Localizable", "challenge_starts_in_less_than_an_hour")
    static let challengeTitle = L10n.tr ("Localizable", "challenge_title")

    static func challengeTotalJoined (_ p1 : String) - > String {
        return L10n.tr ("Localizable", "challenge_total_joined", p1)
    }
    static let chatUsersTitle = L10n.tr ("Localizable", "chat_users_title")
    static let chooseAGymSearchPlaceholder = L10n.tr ("Localizable", "choose_a_gym_search_placeholder")
    static let chooseAGymTitleChange = L10n.tr ("Localizable", "choose_a_gym_title_change")
    static let chooseAGymTitleFind = L10n.tr ("Localizable", "choose_a_gym_title_find")
    static let confirm = L10n.tr ("Localizable", "confirm")
    static let creditsAvailable = L10n.tr ("Localizable", "credits_available")
    static let cuedTime = L10n.tr ("Localizable", "cued_time")
    static let deadlift = L10n.tr ("Localizable", "deadlift")
    static let dollarValue = L10n.tr ("Localizable", "dollar_value")
    static let doneBarItemTitle = L10n.tr ("Localizable", "done_bar_item_title")
    static let emailInvalid = L10n.tr ("Localizable", "email_invalid")
    static let emailMissing = L10n.tr ("Localizable", "email_missing")
    static let endorsementsCellTitle = L10n.tr ("Localizable", "endorsements_cell_title")
    static let endurance = L10n.tr ("Localizable", "endurance")
    static let errorGettingRewards = L10n.tr ("Localizable", "error_getting_rewards")
    static let errorLoadingCredits = L10n.tr ("Localizable", "error_loading_credits")
    static let errorPurchasingReward = L10n.tr ("Localizable", "error_purchasing_reward")
    static let errorRedeemingReward = L10n.tr ("Localizable", "error_redeeming_reward")
    static let exerciseCardioInputInstructions = L10n.tr ("Localizable", "exercise_cardio_input_instructions")
    static let exerciseInfoErrorMessage = L10n.tr ("Localizable", "exercise_info_error_message")
    static let exerciseInfoErrorTitle = L10n.tr ("Localizable", "exercise_info_error_title")
    static let exerciseMileRunButton1Title = L10n.tr ("Localizable", "exercise_mile_run_button1_title")
    static let exerciseMileRunButton2Title = L10n.tr ("Localizable", "exercise_mile_run_button2_title")
    static let exerciseMileRunButton3Title = L10n.tr ("Localizable", "exercise_mile_run_button3_title")
    static let exerciseMileRunInputInstructions = L10n.tr ("Localizable", "exercise_mile_run_input_instructions")
    static let exerciseMileRunTestFormatInstructions = L10n.tr ("Localizable", "exercise_mile_run_test_format_instructions")
    static let exerciseProfileNotLoggedInDescription = L10n.tr ("Localizable", "exercise_profile_not_logged_in_description")
    static let exerciseWeightLiftingButton1Title = L10n.tr ("Localizable", "exercise_weight_lifting_button1_title")
    static let exerciseWeightLiftingButton2Title = L10n.tr ("Localizable", "exercise_weight_lifting_button2_title")
    static let exerciseWeightLiftingButton3Title = L10n.tr ("Localizable", "exercise_weight_lifting_button3_title")
    static let exerciseWeightLiftingButton4Title = L10n.tr ("Localizable", "exercise_weight_lifting_button4_title")
    static let exerciseWeightLiftingInputInstructions = L10n.tr ("Localizable", "exercise_weight_lifting_input_instructions")
    static let exerciseWeightLiftingTestFormatInstructions = L10n.tr ("Localizable", "exercise_weight_lifting_test_format_instructions")
    static let exerciseYardDashButton1Title = L10n.tr ("Localizable", "exercise_yard_dash_button1_title")
    static let exerciseYardDashButton2Title = L10n.tr ("Localizable", "exercise_yard_dash_button2_title")
    static let exerciseYardDashTestFormatInstructionsOne = L10n.tr ("Localizable", "exercise_yard_dash_test_format_instructions_one")
    static let exerciseYardDashTestFormatInstructionsTwo = L10n.tr ("Localizable", "exercise_yard_dash_test_format_instructions_two")
    static let exercisesTitle = L10n.tr ("Localizable", "exercises_title")
    static let firstNameMissing = L10n.tr ("Localizable", "first_name_missing")
    static let fortyYardDash = L10n.tr ("Localizable", "forty_yard_dash")
    static let gallery = L10n.tr ("Localizable", "gallery")
    static let goToSettings = L10n.tr ("Localizable", "go_to_settings")
    static let gymLeaderboardInformationText = L10n.tr ("Localizable", "gym_leaderboard_information_text")
    static let gymLeaderboardTitle = L10n.tr ("Localizable", "gym_leaderboard_title")
    static let heightCheckboxLeftBlank = L10n.tr ("Localizable", "height_checkbox_left_blank")

    static func hrsAgo (_ p1 : Int) - > String {
        return L10n.tr ("Localizable", "hrs ago", p1)
    }
    static let imagePermission = L10n.tr ("Localizable", "image_permission")
    static let imageSource = L10n.tr ("Localizable", "image_source")
    static let lastNameMissing = L10n.tr ("Localizable", "last_name_missing")
    static let leaderboardAllAgeGroupButtonTitle = L10n.tr ("Localizable", "leaderboard_all_age_group_button_title")
    static let leaderboardDefaultErrorMessage = L10n.tr ("Localizable", "leaderboard_default_error_message")
    static let leaderboardFirstTimeView = L10n.tr ("Localizable", "leaderboard_first_time_view")
    static let leaderboardNotLoggedInDescription = L10n.tr ("Localizable", "leaderboard_not_logged_in_description")
    static let leaderboardTabBarItemTitle = L10n.tr ("Localizable", "leaderboard_tab_bar_item_title")
    static let leaderboardTitle = L10n.tr ("Localizable", "leaderboard_title")
    static let leaderboardYourAgeGroupButtonTitle = L10n.tr ("Localizable", "leaderboard_your_age_group_button_title")
    static let learnAboutProCompareWithFriends = L10n.tr ("Localizable", "learn_about_pro_compare_with_friends")
    static let learnAboutProCompareWithFriendsDetail = L10n.tr ("Localizable", "learn_about_pro_compare_with_friends_detail")
    static let learnAboutProExclusiveDeals = L10n.tr ("Localizable", "learn_about_pro_exclusive_deals")
    static let learnAboutProExclusiveDealsDetail = L10n.tr ("Localizable", "learn_about_pro_exclusive_deals_detail")
    static let learnAboutProGet = L10n.tr ("Localizable", "learn_about_pro_get")
    static let learnAboutProHeader = L10n.tr ("Localizable", "learn_about_pro_header")
    static let learnAboutProLeaderboard = L10n.tr ("Localizable", "learn_about_pro_leaderboard")
    static let learnAboutProLeaderboardDetail = L10n.tr ("Localizable", "learn_about_pro_leaderboard_detail")
    static let learnAboutProPurchaseDeferred = L10n.tr ("Localizable", "learn_about_pro_purchase_deferred")
    static let learnAboutProRestorePurchase = L10n.tr ("Localizable", "learn_about_pro_restore_purchase")
    static let learnAboutProSubscriptionExpired = L10n.tr ("Localizable", "learn_about_pro_subscription_expired")
    static let lifestyleActionDetail = L10n.tr ("Localizable", "lifestyle_action_detail")
    static let lifestyleActionTitle = L10n.tr ("Localizable", "lifestyle_action_title")
    static let lifestyleAthleteDetail = L10n.tr ("Localizable", "lifestyle_athlete_detail")
    static let lifestyleAthleteTitle = L10n.tr ("Localizable", "lifestyle_athlete_title")
    static let lifestyleEliteDetail = L10n.tr ("Localizable", "lifestyle_elite_detail")
    static let lifestyleEliteTitle = L10n.tr ("Localizable", "lifestyle_elite_title")
    static let lifestyleFitDetail = L10n.tr ("Localizable", "lifestyle_fit_detail")
    static let lifestyleFitTitle = L10n.tr ("Localizable", "lifestyle_fit_title")
    static let lifestyleTitle = L10n.tr ("Localizable", "lifestyle_title")
    static let lifestyleTutorialSubtitle = L10n.tr ("Localizable", "lifestyle_tutorial_subtitle")
    static let lifestyleTutorialTitle = L10n.tr ("Localizable", "lifestyle_tutorial_title")
    static let marcusFolignoDescription = L10n.tr ("Localizable", "marcus_foligno_description")
    static let marcusFolignoName = L10n.tr ("Localizable", "marcus_foligno_name")
    static let mileRun = L10n.tr ("Localizable", "mile_run")
    static let militaryPress = L10n.tr ("Localizable", "military_press")
    static let missingInfo = L10n.tr ("Localizable", "missing_info")
    static let myBestScoresTitle = L10n.tr ("Localizable", "my_best_scores_title")
    static let myLatestScoresTitle = L10n.tr ("Localizable", "my_latest_scores_title")
    static let nameTooLong = L10n.tr ("Localizable", "name_too_long")
    static let nickFolignoDescription = L10n.tr ("Localizable", "nick_foligno_description")
    static let nickFolignoName = L10n.tr ("Localizable", "nick_foligno_name")
    static let noGymSelectedMessage = L10n.tr ("Localizable", "no_gym_selected_message")
    static let ok = L10n.tr ("Localizable", "ok")
    static let ourValueAnswer1 = L10n.tr ("Localizable", "our_value_answer_1")
    static let ourValueAnswer2 = L10n.tr ("Localizable", "our_value_answer_2")
    static let ourValueAnswer3 = L10n.tr ("Localizable", "our_value_answer_3")
    static let ourValueAnswer4 = L10n.tr ("Localizable", "our_value_answer_4")
    static let ourValueAnswer5 = L10n.tr ("Localizable", "our_value_answer_5")
    static let ourValueQuestion1 = L10n.tr ("Localizable", "our_value_question_1")
    static let ourValueQuestion2 = L10n.tr ("Localizable", "our_value_question_2")
    static let ourValueQuestion3 = L10n.tr ("Localizable", "our_value_question_3")
    static let ourValueQuestion4 = L10n.tr ("Localizable", "our_value_question_4")
    static let ourValueQuestion5 = L10n.tr ("Localizable", "our_value_question_5")
    static let ourValueTitle = L10n.tr ("Localizable", "our_value_title")
    static let outdoor = L10n.tr ("Localizable", "outdoor")
    static let passwordInvalid = L10n.tr ("Localizable", "password_invalid")
    static let passwordMissing = L10n.tr ("Localizable", "password_missing")
    static let power = L10n.tr ("Localizable", "power")
    static let profileNotLoggedInTitle = L10n.tr ("Localizable", "profile_not_logged_in_title")
    static let profileNotificationBody = L10n.tr ("Localizable", "profile_notification_body")
    static let profileTabBarItemTitle = L10n.tr ("Localizable", "profile_tab_bar_item_title")
    static let profileTitle = L10n.tr ("Localizable", "profile_title")
    static let purchaseAlertMessage = L10n.tr ("Localizable", "purchase_alert_message")
    static let purchaseAlertTitle = L10n.tr ("Localizable", "purchase_alert_title")
    static let rebeccaJohnsonDescription = L10n.tr ("Localizable", "rebecca_johnson_description")
    static let rebeccaJohnsonName = L10n.tr ("Localizable", "rebecca_johnson_name")
    static let reportCardFirstViewAlert = L10n.tr ("Localizable", "report_card_first_view_alert")
    static let reportCardNotLoggedInDescription = L10n.tr ("Localizable", "report_card_not_logged_in_description")
    static let reportCardTabBarItemTitle = L10n.tr ("Localizable", "report_card_tab_bar_item_title")
    static let reportCardTitle = L10n.tr ("Localizable", "report_card_title")
    static let requestUsePhotosLibrary = L10n.tr ("Localizable", "request_use_photos_library")
    static let requestUsePhotosLibraryDenied = L10n.tr ("Localizable", "request_use_photos_library_denied")
    static let rewardsGetItNow = L10n.tr ("Localizable", "rewards_get_it_now")
    static let rewardsNotLoggedInDescription = L10n.tr ("Localizable", "rewards_not_logged_in_description")
    static let rewardsRedeem = L10n.tr ("Localizable", "rewards_redeem")
    static let rewardsRedeemInformation = L10n.tr ("Localizable", "rewards_redeem_information")
    static let rewardsTabItemTitle = L10n.tr ("Localizable", "rewards_tab_item_title")
    static let rewardsTitle = L10n.tr ("Localizable", "rewards_title")
    static let rewardsUpgradeToProDescription = L10n.tr ("Localizable", "rewards_upgrade_to_pro_description")
    static let rewardsUpgradeToProTitle = L10n.tr ("Localizable", "rewards_upgrade_to_pro_title")
    static let selfTimed = L10n.tr ("Localizable", "self_timed")
    static let shareReportFacebookInitialText = L10n.tr ("Localizable", "share_report_facebook_initial_text")
    static let signUpTitle = L10n.tr ("Localizable", "sign_up_title")
    static let squat = L10n.tr ("Localizable", "squat")
    static let stamina = L10n.tr ("Localizable", "stamina")
    static let strength = L10n.tr ("Localizable", "strength")
    static let testInformationBenchPressDescription = L10n.tr ("Localizable", "test_information_bench_press_description")
    static let testInformationBenchPressFunFact = L10n.tr ("Localizable", "test_information_bench_press_fun_fact")
    static let testInformationBenchPressTitle = L10n.tr ("Localizable", "test_information_bench_press_title")
    static let testInformationDeadliftDescription = L10n.tr ("Localizable", "test_information_deadlift_description")
    static let testInformationDeadliftFunFact = L10n.tr ("Localizable", "test_information_deadlift_fun_fact")
    static let testInformationDeadliftTitle = L10n.tr ("Localizable", "test_information_deadlift_title")
    static let testInformationMileRunDescription = L10n.tr ("Localizable", "test_information_mile_run_description")
    static let testInformationMileRunFunFact = L10n.tr ("Localizable", "test_information_mile_run_fun_fact")
    static let testInformationMileRunTitle = L10n.tr ("Localizable", "test_information_mile_run_title")
    static let testInformationMilitaryPressDescription = L10n.tr ("Localizable", "test_information_military_press_description")
    static let testInformationMilitaryPressFunFact = L10n.tr ("Localizable", "test_information_military_press_fun_fact")
    static let testInformationMilitaryPressTitle = L10n.tr ("Localizable", "test_information_military_press_title")
    static let testInformationSquatDescription = L10n.tr ("Localizable", "test_information_squat_description")
    static let testInformationSquatFunFact = L10n.tr ("Localizable", "test_information_squat_fun_fact")
    static let testInformationSquatTitle = L10n.tr ("Localizable", "test_information_squat_title")
    static let testInformationYardDashDescription = L10n.tr ("Localizable", "test_information_yard_dash_description")
    static let testInformationYardDashFunFact = L10n.tr ("Localizable", "test_information_yard_dash_fun_fact")
    static let testInformationYardDashTitle = L10n.tr ("Localizable", "test_information_yard_dash_title")
    static let testLeaderboardInformationText = L10n.tr ("Localizable", "test_leaderboard_information_text")
    static let testLeaderboardTitle = L10n.tr ("Localizable", "test_leaderboard_title")
    static let testTabBarItemTitle = L10n.tr ("Localizable", "test_tab_bar_item_title")
    static let totalCredits = L10n.tr ("Localizable", "total_credits")
    static let trackRunning = L10n.tr ("Localizable", "track_running")
    static let treadmill = L10n.tr ("Localizable", "treadmill")
    static let unableDetermineLocationMessage = L10n.tr ("Localizable", "unable_determine_location_message")
    static let unableToShareVideoMessage = L10n.tr ("Localizable", "unable_to_share_video_message")
    static let unknownErrorMessage = L10n.tr ("Localizable", "unknown_error_message")
    static let userGenderMissingMessage = L10n.tr ("Localizable", "user_gender_missing_message")
    static let userLifestyleMissingMessage = L10n.tr ("Localizable", "user_lifestyle_missing_message")
    static let userTokenMissingMessage = L10n.tr ("Localizable", "user_token_missing_message")
    static let userWeightMissingMessage = L10n.tr ("Localizable", "user_weight_missing_message")
    static let validation = L10n.tr ("Localizable", "validation")
    static let videoVerificationInformationMessage = L10n.tr ("Localizable", "video_verification_information_message")
    static let videoVerificationInformationOkButtonTitle = L10n.tr ("Localizable", "video_verification_information_ok_button_title")
    static let videoVerificationInformationTitle = L10n.tr ("Localizable", "video_verification_information_title")
    static let warning = L10n.tr ("Localizable", "warning")
    static let weightCheckboxLeftBlank = L10n.tr ("Localizable", "weight_checkbox_left_blank")
    static let yourDealTitle = L10n.tr ("Localizable", "your_deal_title")
}

extension L10n {

    private static func tr (_ table : String, _ key : String, _ args : CVarArg...) - > String {
        let format = NSLocalizedString (key, tableName : table, bundle : Bundle (for : BundleToken.self), comment : "")
        return String (format : format, locale : Locale.current, arguments : args)
    }
}

private final class BundleToken {
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/ChallengeGymTableViewCell.swift" startline="1" endline="42">
import UIKit

class ChallengeGymTableViewCell : UITableViewCell {
    @IBOutlet fileprivate var positionLabel : UILabel?
    @IBOutlet fileprivate var titleLabel : UILabel?
    @IBOutlet fileprivate var totalRepsLabel : UILabel?

    override func prepareForReuse () {
        super.prepareForReuse ()
        self.positionLabel?.text = nil
        self.titleLabel?.text = nil
        self.totalRepsLabel?.text = nil
    }

    func configure (gym : Gym, postAt pos : Int) {
        self.positionLabel?.text = "\(pos + 1)"
        self.titleLabel?.text = gym.name
        if let totalReps = gym.totalReps {
            let formatLocalizedString = NSLocalizedString ("challenge_total_rep", comment : "")
            let challengeTotalRepsInLocalizedString = String.localizedStringWithFormat (formatLocalizedString, totalReps)
            self.totalRepsLabel?.text = challengeTotalRepsInLocalizedString
        } else {
            self.totalRepsLabel?.text = nil
        }
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/MyScoreSectionHeaderTableViewCell.swift" startline="1" endline="25">
import UIKit

class MyScoreSectionHeaderTableViewCell : UITableViewCell {
    @IBOutlet fileprivate var headerImageView : UIImageView!
    @IBOutlet fileprivate var headerTitleLabel : UILabel!
    @IBOutlet fileprivate var scoreRepLabel : UILabel!

    func configure (with exerciseInfo : ExerciseInfo) {
        self.headerImageView.image = exerciseInfo.image
        self.headerTitleLabel.text = exerciseInfo.title
        self.scoreRepLabel.text = exerciseInfo.isWeightLifting? "Reps" : "Score"
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/GymLeaderboardViewController.swift" startline="1" endline="179">
import UIKit
import NVActivityIndicatorView

class GymLeaderboardViewController : UIViewController {
    @IBOutlet private var tableView : UITableView?
    @IBOutlet private var outOfLabel : UILabel?
    @IBOutlet private var subtitleLabel : UILabel?
    @IBOutlet private var nameLabel : UILabel?
    @IBOutlet private var regionLabel : UILabel?
    var errorableLeaderboardViewModel : ErrorableLeaderboardViewModel?
    var selectedAthlete : ((Athlete) - > ())?

    override func viewDidLoad () {
        super.viewDidLoad ()
        self.tableView?.estimatedRowHeight = 55
        self.tableView?.rowHeight = UITableView.automaticDimension
        self.setUpViewComponents ()
    }

    func showLoadingIndicator (_ show : Bool) {
        if show == true {
            NVActivityIndicatorPresenter.sharedInstance.startAnimating (Constants.activityData)
        } else {
            NVActivityIndicatorPresenter.sharedInstance.stopAnimating ()
        }
    }

    func setUpViewComponents () {
        self.subtitleLabel?.textColor = UIColor.white
        self.nameLabel?.textColor = UIColor (named : .rePerformanceYellow)
        self.regionLabel?.textColor = UIColor (named : .rePerformanceYellow)
        self.outOfLabel?.textColor = UIColor.white
    }

    func setUpView () {
        guard let errorableLeaderboardViewModel = self.errorableLeaderboardViewModel, case let.leaderboard (leaderboardViewModel) = errorableLeaderboardViewModel else {
            return
        }
        self.title = leaderboardViewModel.title
        self.subtitleLabel?.text = leaderboardViewModel.subtitle
        self.nameLabel?.text = leaderboardViewModel.leaderboard.gym?.name
        self.outOfLabel?.text = "out of \(leaderboardViewModel.leaderboard.total)"
        self.tableView?.setContentOffset (CGPoint.zero, animated : true)
    }

    func reloadView () {
        self.setUpView ()
        self.tableView?.reloadData ()
    }

    func reloadRow (row : Int, section : Int) {
        let indexPathToReload = IndexPath (row : row, section : section)
        self.tableView?.reloadRows (at : [indexPathToReload], with : .automatic)
    }
}

extension GymLeaderboardViewController : UITableViewDataSource, UITableViewDelegate {

    func numberOfSections (in tableView : UITableView) - > Int {
        guard let errorableLeaderboardViewModel = self.errorableLeaderboardViewModel, case let.leaderboard (leaderboardViewModel) = errorableLeaderboardViewModel else {
            return 0
        }
        if leaderboardViewModel.leaderboard.isRankingEmpty {
            return 1
        } else {
            return ((leaderboardViewModel.leaderboard.groupedRankings.count * 2) - 1)
        }
    }

    func tableView (_ tableView : UITableView, numberOfRowsInSection section : Int) - > Int {
        guard let errorableLeaderboardViewModel = self.errorableLeaderboardViewModel, case let.leaderboard (leaderboardViewModel) = errorableLeaderboardViewModel else {
            return 0
        }
        if leaderboardViewModel.leaderboard.isRankingEmpty {
            return 1
        } else {
            if (section % 2 == 0) {
                let groupedRankingSection = Int (floor (Double (section) / 2))
                return leaderboardViewModel.leaderboard.groupedRankings [groupedRankingSection].count
            } else {
                return 1
            }
        }
    }

    func tableView (_ tableView : UITableView, cellForRowAt indexPath : IndexPath) - > UITableViewCell {
        guard let errorableLeaderboardViewModel = self.errorableLeaderboardViewModel else {
            fatalError ()
        }
        switch errorableLeaderboardViewModel {
            case.leaderboard (let leaderboardViewModel) :
                if (indexPath.section % 2 == 0) {
                    let leaderboardPositionTableViewCell = tableView.dequeueReusableCell (withIdentifier : Constants.ReportCard.LeaderboardPositionCellIdentifier, for : indexPath) as! LeaderboardPositionTableViewCell
                    let groupedRankingSection = Int (floor (Double (indexPath.section) / 2))
                    let athlete = leaderboardViewModel.leaderboard.groupedRankings [groupedRankingSection] [indexPath.row]
                    let score : String?
                    if leaderboardViewModel.globalLeaderboard == true {
                        score = athlete.lifestyleCategory
                    } else if let athleteScore = athlete.score {
                        if leaderboardViewModel.exerciseCategory==.MileRun, let localScore = FormatMillisecondsForDisplay.convertScoreForDisplayMileRun (score : "\(athleteScore)") {
                            score = localScore
                        } else if leaderboardViewModel.exerciseCategory==.FortyYardDash, let localScore = FormatMillisecondsForDisplay.convertScoreForDisplayFortyYardDash (score : "\(athleteScore)") {
                            score = localScore
                        } else {
                            score = "\(athleteScore)"
                        }
                    } else {
                        score = nil
                    }
                    var athleteRank = ""
                    if let rank = athlete.rank {
                        athleteRank = "\(rank)"
                    }
                    leaderboardPositionTableViewCell.configureCell (rankText : athleteRank, nameText : athlete.name, isPublic : (athlete.isPublic? ? false), rightSideText : score? ? "", medalVisible : athlete.isVerified? ? false, personFacebookID : athlete
                      .facebookIdentifier, profileURL : athlete.imageURL)
                    return leaderboardPositionTableViewCell
                } else {
                    return tableView.dequeueReusableCell (withIdentifier : Constants.ReportCard.LeaderboardDividerCellIdentifier, for : indexPath) as! LeaderboardDividerTableViewCell
                }
            case.error (let message) :
                let leaderboardErrorTableViewCell = tableView.dequeueReusableCell (withIdentifier : Constants.ReportCard.LeaderboardErrorCellIdentifier, for : indexPath) as! LeaderboardErrorTableViewCell
                leaderboardErrorTableViewCell.configureCell (errorMessage : message)
                return leaderboardErrorTableViewCell
        }
    }

    func tableView (_ tableView : UITableView, didSelectRowAt indexPath : IndexPath) {
        tableView.deselectRow (at : indexPath, animated : true)
        guard let errorableLeaderboardViewModel = self.errorableLeaderboardViewModel, case let.leaderboard (leaderboardViewModel) = errorableLeaderboardViewModel else {
            return
        }
        guard indexPath.section % 2 == 0 else {
            return
        }
        let groupedRankingSection = Int (floor (Double (indexPath.section) / 2))
        let athlete = leaderboardViewModel.leaderboard.groupedRankings [groupedRankingSection] [indexPath.row]
        self.selectedAthlete? (athlete)
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/ReportCardViewController.swift" startline="1" endline="430">
import UIKit
import AVKit
import Photos

class ReportCardViewController : UIViewController, UINavigationControllerDelegate {
    @IBOutlet fileprivate var reportCardTableView : UITableView?
    override var preferredStatusBarStyle : UIStatusBarStyle {
        return .lightContent
    }
    var isPublic : Bool = false {
        didSet {
            self.reportCardTableView?.reloadData ()
        }
    }
    var hasUnreadMessages : Bool = false {
        didSet {
            self.reportCardTableView?.reloadData ()
        }
    }
    var profileImage : UIImage? {
        didSet {
            self.reportCardTableView?.reloadData ()
        }
    }
    var name : String? {
        didSet {
            self.reportCardTableView?.reloadData ()
        }
    }
    var age : Int? {
        didSet {
            self.reportCardTableView?.reloadData ()
        }
    }
    var weight : Int? {
        didSet {
            self.reportCardTableView?.reloadData ()
        }
    }
    var isMale : Bool = false {
        didSet {
            self.reportCardTableView?.reloadData ()
        }
    }
    var lifestyleCategoryName : String? {
        didSet {
            self.reportCardTableView?.reloadData ()
        }
    }
    var reportCard : ReportCard? {
        didSet {
            self.reportCardTableView?.reloadData ()
        }
    }
    var isPersonalReportCard : Bool = true {
        didSet {
            self.reportCardTableView?.reloadData ()
        }
    }
    var exerciseScores : ReportCardExerciseScores? {
        didSet {
            if let exerciseScores = self.exerciseScores {
                self.exerciseScoresViewModel = exerciseScores.generateExerciseScoresViewModel ()
            } else {
                self.exerciseScoresViewModel = nil
            }
        }
    }
    fileprivate var exerciseScoresViewModel : [(ExerciseInfo, [ExerciseScoreAthleteCellViewModel])]? {
        didSet {
            if let exerciseScoresViewModel = self.exerciseScoresViewModel {
                var flattenedViewModel = [Any] ()
                for exerciseScoresViewModelTuple in exerciseScoresViewModel {
                    flattenedViewModel.append (exerciseScoresViewModelTuple.0)
                    for exerciseScoreAthleteCellViewModel in exerciseScoresViewModelTuple.1 {
                        flattenedViewModel.append (exerciseScoreAthleteCellViewModel)
                    }
                }
                self.exerciseScoresViewModelCompact = flattenedViewModel
            } else {
                self.exerciseScoresViewModelCompact = nil
            }
        }
    }
    fileprivate var exerciseScoresViewModelCompact : [Any]? {
        didSet {
            self.reportCardTableView?.reloadData ()
        }
    }
    var reportCardWillAppear : (() - > ())?
    var chat : (() - > ())?
    var shareReport : ((UIImage) - > ())?
    var changeProfileVisibility : ((Bool) - > ())?
    var updateProfileImage : ((UIImage) - > ())?
    var onMyLatestScoresPressed : (() - > ())?
    var onMyBestScoresPressed : (() - > ())?
    var onChallengesPressed : (() - > ())?

    override func viewDidLoad () {
        super.viewDidLoad ()
    }

    override func viewWillAppear (_ animated : Bool) {
        super.viewWillAppear (animated)
        self.reportCardWillAppear? ()
    }

    override func viewDidAppear (_ animated : Bool) {
        super.viewDidAppear (animated)
        REPAnalytics.trackScreenWithName (screenName : ScreenName.HomePage.ReportCard, className : String (describing : self))
    }

    func checkCameraStatus () {
        if AVCaptureDevice.authorizationStatus (for : .video)==.authorized {
            openCamera ()
        } else if (AVCaptureDevice.authorizationStatus (for : .video)==.denied)|| (AVCaptureDevice.authorizationStatus (for : .video)==.restricted) {
            self.openDeniedCameraPermission ()
        } else {
            AVCaptureDevice.requestAccess (for : .video, completionHandler : {
                (granted : Bool) in if granted == true {
                    self.openCamera ()
                } else {
                    print ("camera restricted")
                }
            })
        }
    }

    func openDeniedCameraPermission () {
        AVCaptureDevice.requestAccess (for : AVMediaType.video) {
            (_ status : Bool) - > Void in if status! = true {
                let accessDescription = Bundle.main.object (forInfoDictionaryKey : "NSCameraUsageDescription") as? String
                let alertController = UIAlertController (title : accessDescription, message : L10n.cameraPermission, preferredStyle : .alert)
                let cancelAction = UIAlertAction (title : L10n.cancel, style : .cancel, handler : nil)
                alertController.addAction (cancelAction)
                let settingsAction = UIAlertAction (title : L10n.goToSettings, style : .default, handler : {
                    (_ action : UIAlertAction) - > Void in UIApplication.shared.open ((URL (string : UIApplication.openSettingsURLString)!), options : [:], completionHandler : nil)
                })
                alertController.addAction (settingsAction)
                self.present (alertController, animated : true, completion : nil)
            }
        }
    }

    func openCamera () {
        if UIImagePickerController.isSourceTypeAvailable (UIImagePickerController.SourceType.camera) {
            let imagePicker = UIImagePickerController ()
            imagePicker.delegate = self
            imagePicker.allowsEditing = false
            imagePicker.navigationBar.tintColor = .black
            imagePicker.navigationBar.titleTextAttributes = nil
            imagePicker.navigationBar.isTranslucent = false
            imagePicker.sourceType = UIImagePickerController.SourceType.camera
            self.present (imagePicker, animated : true, completion : nil)
        } else {
            let alert = UIAlertController (title : L10n.warning, message : L10n.cameraPermission, preferredStyle : .alert)
            alert.addAction (UIAlertAction (title : L10n.ok, style : .default, handler : nil))
            self.present (alert, animated : true, completion : nil)
        }
    }

    func checkGalleryStatus () {
        let status = PHPhotoLibrary.authorizationStatus ()
        switch status {
            case.authorized :
                openGallery ()
            case.denied,.restricted :
                handleDeniedLibraryPermission ()
            case.notDetermined :
                PHPhotoLibrary.requestAuthorization () {
                    status in switch status {
                        case.authorized :
                            self.openGallery ()
                        case.denied,.restricted :
                            print ("gallery restricted")
                        case.notDetermined :
                            break
                    }
                }
        }
    }

    func handleDeniedLibraryPermission () {
        PHPhotoLibrary.requestAuthorization ({
            (_ status : PHAuthorizationStatus) - > Void in if status!=.authorized {
                let accessDescription = Bundle.main.object (forInfoDictionaryKey : "NSPhotoLibraryUsageDescription") as? String
                let alertController = UIAlertController (title : accessDescription, message : L10n.imagePermission, preferredStyle : .alert)
                let cancelAction = UIAlertAction (title : L10n.cancel, style : .cancel, handler : nil)
                alertController.addAction (cancelAction)
                let settingsAction = UIAlertAction (title : "Go to Settings", style : .default, handler : {
                    (_ action : UIAlertAction) - > Void in UIApplication.shared.open ((URL (string : UIApplication.openSettingsURLString)!), options : [:], completionHandler : nil)
                })
                alertController.addAction (settingsAction)
                self.present (alertController, animated : true, completion : nil)
            }
        })
    }

    func openGallery () {
        if UIImagePickerController.isSourceTypeAvailable (UIImagePickerController.SourceType.photoLibrary) {
            let imagePicker = UIImagePickerController ()
            imagePicker.delegate = self
            imagePicker.allowsEditing = false
            imagePicker.navigationBar.tintColor = .black
            imagePicker.navigationBar.titleTextAttributes = nil
            imagePicker.navigationBar.isTranslucent = false
            imagePicker.sourceType = .photoLibrary
            self.present (imagePicker, animated : true, completion : nil)
        } else {
            let alert = UIAlertController (title : L10n.warning, message : L10n.imagePermission, preferredStyle : .alert)
            alert.addAction (UIAlertAction (title : L10n.ok, style : .default, handler : nil))
            self.present (alert, animated : true, completion : nil)
        }
    }
}

extension ReportCardViewController : UIImagePickerControllerDelegate {

    func imagePickerController (_ picker : UIImagePickerController, didFinishPickingMediaWithInfo info : [UIImagePickerController.InfoKey : Any]) {
        self.profileImage = info [ .originalImage] as? UIImage
        if let image = profileImage {
            self.updateProfileImage? (image)
        }
        picker.dismiss (animated : true, completion : nil)
    }
}

extension ReportCardViewController : UITableViewDataSource, UITableViewDelegate {

    func numberOfSections (in tableView : UITableView) - > Int {
        return 3
    }

    func tableView (_ tableView : UITableView, numberOfRowsInSection section : Int) - > Int {
        if section == 0 {
            return 3
        } else if section == 1 {
            guard let exerciseScoresViewModelCompact = self.exerciseScoresViewModelCompact else {
                return 0
            }
            return exerciseScoresViewModelCompact.count+
            1
        } else if section == 2 {
            return self.isPersonalReportCard==
            true? 1 : 0
        } else {
            fatalError ()
        }
    }

    func tableView (_ tableView : UITableView, cellForRowAt indexPath : IndexPath) - > UITableViewCell {
        if indexPath.section == 0 {
            if indexPath.row == 0 {
                let cell = tableView.dequeueReusableCell (withIdentifier : "Personal Info Cell Identifier", for : indexPath) as! ReportCardPersonalInfoTableViewCell
                cell.isPersonal = self.isPersonalReportCard
                cell.hasUnreadMessages = (self.hasUnreadMessages && self.isPersonalReportCard)
                cell.profileImage = self.profileImage
                cell.name = self.name
                cell.age = self.age
                cell.weight = self.weight
                cell.lifestyleCategoryName = self.lifestyleCategoryName
                cell.chat = {
                    [unowned self] in self.chat? ()
                }
                cell.shareReport = {
                    [unowned self] in guard let reportCardCell = tableView.cellForRow (at : IndexPath (row : 1, section : 0)) as? ReportCardScoreBreakdownTableViewCell, let reportCardSnapshot = reportCardCell.createReportCard () else {
                        return
                    }
                    self.shareReport? (reportCardSnapshot)
                }
                return cell
            } else if indexPath.row == 1 {
                let cell = tableView.dequeueReusableCell (withIdentifier : "Report Card Cell Identifier", for : indexPath) as! ReportCardScoreBreakdownTableViewCell
                cell.isPersonal = self.isPersonalReportCard
                cell.isMale = self.isMale
                cell.reportCard = self.reportCard
                cell.isPublic = self.isPublic
                cell.changeProfileVisibility = {
                    [unowned self] (isPrivate) in self.changeProfileVisibility? (isPrivate)
                }
                cell.updateProfileImage = {
                    let alert = UIAlertController (title : L10n.imageSource, message : nil, preferredStyle : .actionSheet)
                    alert.addAction (UIAlertAction (title : L10n.camera, style : .default, handler : {
                        _ in self.checkCameraStatus ()
                    }))
                    alert.addAction (UIAlertAction (title : L10n.gallery, style : .default, handler : {
                        _ in self.checkGalleryStatus ()
                    }))
                    alert.addAction (UIAlertAction.init (title : L10n.cancel, style : .cancel, handler : nil))
                    self.present (alert, animated : true, completion : nil)
                }
                return cell
            } else if indexPath.row == 2 {
                let cell = tableView.dequeueReusableCell (withIdentifier : "Total Reps Volume Cell Identifier", for : indexPath) as! ReportCardTotalRepsVolumeTableViewCell
                cell.totalReps = self.reportCard?.totalReps
                cell.totalVolume = self.reportCard?.totalVolume
                return cell
            } else {
                fatalError ()
            }
        } else if indexPath.section == 1 {
            if indexPath.row == 0 {
                let cell = tableView.dequeueReusableCell (withIdentifier : "Best Scores Cell Identifier", for : indexPath)
                return cell
            } else if let exerciseInfo = self.exerciseScoresViewModelCompact! [(indexPath.row - 1)] as? ExerciseInfo {
                let cell = tableView.dequeueReusableCell (withIdentifier : "Score Section Header", for : indexPath) as! MyScoreSectionHeaderTableViewCell
                cell.configure (with : exerciseInfo)
                return cell
            } else if let exerciseScoreAthleteCellViewModel = self.exerciseScoresViewModelCompact! [(indexPath.row - 1)] as? ExerciseScoreAthleteCellViewModel {
                let cell = tableView.dequeueReusableCell (withIdentifier : "Score Cell Identifier", for : indexPath) as! ExerciseScoreAthleteTableViewCell
                cell.configure (with : exerciseScoreAthleteCellViewModel)
                return cell
            }
            fatalError ()
        } else if indexPath.section == 2 {
            let cell = tableView.dequeueReusableCell (withIdentifier : "Score Options Cell Identifier", for : indexPath) as! ReportCardScoreOptionsTableViewCell
            cell.viewLatestScores = {
                [unowned self] in self.onMyLatestScoresPressed? ()
            }
            cell.viewBestScores = {
                [unowned self] in self.onMyBestScoresPressed? ()
            }
            cell.viewChallenges = {
                [unowned self] in self.onChallengesPressed? ()
            }
            return cell
        } else {
            fatalError ()
        }
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/AchievementsViewController.swift" startline="1" endline="363">
import UIKit
import NVActivityIndicatorView

class AchievementTypeTableViewCell : UITableViewCell {
    @IBOutlet private var typeTitleLabel : UILabel!
    @IBOutlet private var typeImageView : UIImageView!
    @IBOutlet private var dropDownIconImageView : UIImageView!
    var title : String? {
        didSet {
            self.typeTitleLabel.text = title
        }
    }
    var typeImage : UIImage? {
        didSet {
            self.typeImageView.image = typeImage
        }
    }

    override func prepareForReuse () {
        super.prepareForReuse ()
        self.title = nil
        self.typeImage = nil
    }

    override func setSelected (_ selected : Bool, animated : Bool) {
        super.setSelected (selected, animated : animated)
        let degrees : CGFloat = selected? 0 : 180
        let radians : CGFloat = degrees*.pi/
        180
        UIView.animate (withDuration : 0.4) {
            self.dropDownIconImageView.transform = CGAffineTransform (rotationAngle : radians)
        }
    }
}

class AchievementItemTableViewCell : UITableViewCell {
    @IBOutlet private var achievementTitleLabel : UILabel!
    @IBOutlet private var creditsWorthLabel : UILabel!
    @IBOutlet private var pointsLabel : UILabel!
    var achievementTitle : String? {
        didSet {
            self.achievementTitleLabel.text = achievementTitle
        }
    }
    var creditsWorth : Int? {
        didSet {
            if let creditsWorth = creditsWorth {
                self.creditsWorthLabel.text = "worth \(creditsWorth) credits"
            } else {
                self.creditsWorthLabel.text = nil
            }
        }
    }
    var points : Int? {
        didSet {
            if let points = points {
                self.pointsLabel.text = "\(points)"
            } else {
                self.pointsLabel.text = nil
            }
        }
    }

    override func prepareForReuse () {
        super.prepareForReuse ()
        self.achievementTitle = nil
        self.creditsWorth = nil
        self.points = nil
    }
}

class AchievementsViewController : UIViewController {
    @IBOutlet fileprivate var achievementsTableView : UITableView!
    fileprivate var achievement : Achievements? {
        didSet {
            self.achievementsTableView.reloadData ()
        }
    }
    fileprivate var selectedIndexPath : IndexPath? {
        didSet {
            if selectedIndexPath?.row! = 0 {
                selectedIndexPath = oldValue
                return
            }
            self.achievementsTableView.beginUpdates ()
            if let oldValue = oldValue, oldValue! = selectedIndexPath {
                var indexPathsToRemove : [IndexPath] = []
                for indexPathRowIterator in 1 ...(self.achievementsTableView.numberOfRows (inSection : oldValue.section) - 1) {
                    let indexPathToRemove = IndexPath (row : indexPathRowIterator, section : oldValue.section)
                    indexPathsToRemove.append (indexPathToRemove)
                }
                self.achievementsTableView.deleteRows (at : indexPathsToRemove, with : .automatic)
            }
            if let selectedIndexPath = selectedIndexPath, oldValue! = selectedIndexPath {
                var indexPathsToAdd : [IndexPath] = []
                var upperRange = 3
                if selectedIndexPath.section == 6 {
                    upperRange = 2
                } else if selectedIndexPath.section == 7 {
                    upperRange = 1
                }
                for indexPathRowIterator in 1 ...upperRange {
                    let indexPathToAdd = IndexPath (row : indexPathRowIterator, section : selectedIndexPath.section)
                    indexPathsToAdd.append (indexPathToAdd)
                }
                self.achievementsTableView.insertRows (at : indexPathsToAdd, with : .automatic)
            }
            self.achievementsTableView.endUpdates ()
        }
    }

    override func viewDidLoad () {
        super.viewDidLoad ()
        self.achievementsTableView?.rowHeight = UITableView.automaticDimension
        self.achievementsTableView?.estimatedRowHeight = 44
    }

    override func viewWillAppear (_ animated : Bool) {
        super.viewWillAppear (animated)
        self.retrieveAchievements ()
    }

    override func viewDidAppear (_ animated : Bool) {
        super.viewDidAppear (animated)
        REPAnalytics.trackScreenWithName (screenName : ScreenName.Achievements, className : String (describing : self))
    }

    private func retrieveAchievements () {
        NVActivityIndicatorPresenter.sharedInstance.startAnimating (Constants.activityData)
        let achievementsDataProvider = AchievementsDataProvider ()
        achievementsDataProvider.retrieveAchievements {
            [weak self] (achievements, _) in NVActivityIndicatorPresenter.sharedInstance.stopAnimating ()
            self?.achievement = achievements
        }
    }
}

extension AchievementsViewController : UITableViewDataSource {

    func numberOfSections (in tableView : UITableView) - > Int {
        guard let _ = self.achievement else {
            return 0
        }
        return 8
    }

    func tableView (_ tableView : UITableView, numberOfRowsInSection section : Int) - > Int {
        if self.selectedIndexPath?.section == section && self.selectedIndexPath?.section == 6 {
            return 3
        } else if self.selectedIndexPath?.section == section && self.selectedIndexPath?.section == 7 {
            return 2
        } else if self.selectedIndexPath?.section == section {
            return 4
        }
        return 1
    }

    func tableView (_ tableView : UITableView, willSelectRowAt indexPath : IndexPath) - > IndexPath? {
        if indexPath.row! = 0 {
            return nil
        }
        return indexPath
    }

    func tableView (_ tableView : UITableView, cellForRowAt indexPath : IndexPath) - > UITableViewCell {
        var cell : UITableViewCell!
        if indexPath.row == 0 {
            let achievementTypeTableViewCell = tableView.dequeueReusableCell (withIdentifier : "Achievement Type Cell Identifier", for : indexPath) as! AchievementTypeTableViewCell
            switch indexPath.section {
                case 0 :
                    achievementTypeTableViewCell.title = "Mile run"
                    achievementTypeTableViewCell.typeImage = Asset.ReportCard.scoreHeaderMileRun.image
                case 1 :
                    achievementTypeTableViewCell.title = "40 Yard Dash"
                    achievementTypeTableViewCell.typeImage = Asset.ReportCard.scoreHeaderFortyYardDash.image
                case 2 :
                    achievementTypeTableViewCell.title = "Bench Press"
                    achievementTypeTableViewCell.typeImage = Asset.ReportCard.scoreHeaderBenchPress.image
                case 3 :
                    achievementTypeTableViewCell.title = "Deadlift"
                    achievementTypeTableViewCell.typeImage = Asset.ReportCard.scoreHeaderDeadlift.image
                case 4 :
                    achievementTypeTableViewCell.title = "Squat"
                    achievementTypeTableViewCell.typeImage = Asset.ReportCard.scoreHeaderSquat.image
                case 5 :
                    achievementTypeTableViewCell.title = "Military Press"
                    achievementTypeTableViewCell.typeImage = Asset.ReportCard.scoreHeaderMilitaryPress.image
                case 6 :
                    achievementTypeTableViewCell.title = "Challenges"
                    achievementTypeTableViewCell.typeImage = Asset.Assets.Profile.challengeIcon.image
                case 7 :
                    achievementTypeTableViewCell.title = "Loyalty"
                    achievementTypeTableViewCell.typeImage = Asset.Assets.Profile.loyaltyIcon.image
                default :
                    break
            }
            cell = achievementTypeTableViewCell
        } else {
            let achievementItemTableViewCell = tableView.dequeueReusableCell (withIdentifier : "Achievement Item Cell Identifier", for : indexPath) as! AchievementItemTableViewCell
            var currentAchievement : Achievement?
            var challengeAchievement : Achievement_Challenge?
            var loyaltyAchievement : Achievement_Loyalty?
            switch indexPath.section {
                case 0 :
                    currentAchievement = self.achievement?.mileRun
                case 1 :
                    currentAchievement = self.achievement?.fourtyYardDash
                case 2 :
                    currentAchievement = self.achievement?.benchPress
                case 3 :
                    currentAchievement = self.achievement?.deadlift
                case 4 :
                    currentAchievement = self.achievement?.squat
                case 5 :
                    currentAchievement = self.achievement?.militaryPress
                case 6 :
                    challengeAchievement = self.achievement?.challenge
                case 7 :
                    loyaltyAchievement = self.achievement?.loyalty
                default :
                    break
            }
            if challengeAchievement! = nil {
                switch indexPath.row {
                    case 1 :
                        achievementItemTableViewCell.achievementTitle = "Join Challenge"
                        if let challengeAchievement = challengeAchievement {
                            achievementItemTableViewCell.points = challengeAchievement.joinChallengeCount
                            achievementItemTableViewCell.creditsWorth = challengeAchievement.joinChallengeCreditWorth
                        }
                    case 2 :
                        achievementItemTableViewCell.achievementTitle = "Join Challenge Streak"
                        if let challengeAchievement = challengeAchievement {
                            achievementItemTableViewCell.points = challengeAchievement.challengeStreakCount
                            achievementItemTableViewCell.creditsWorth = challengeAchievement.challgeneStreakCreditWorth
                        }
                    default :
                        break
                }
            } else if loyaltyAchievement! = nil {
                switch indexPath.row {
                    case 1 :
                        achievementItemTableViewCell.achievementTitle = "Daily Visit"
                        if let loyaltyAchievement = loyaltyAchievement {
                            achievementItemTableViewCell.points = loyaltyAchievement.dailyVisitCount
                            achievementItemTableViewCell.creditsWorth = loyaltyAchievement.dailyVisitCreditWorth
                        }
                    default :
                        break
                }
            } else if currentAchievement! = nil {
                switch indexPath.row {
                    case 1 :
                        achievementItemTableViewCell.achievementTitle = "Personal Best"
                        if let currentAchievement = currentAchievement {
                            achievementItemTableViewCell.points = currentAchievement.personalBestCount
                            achievementItemTableViewCell.creditsWorth = currentAchievement.personalBestCreditWorth
                        }
                    case 2 :
                        achievementItemTableViewCell.achievementTitle = "Video Approval"
                        if let currentAchievement = currentAchievement {
                            achievementItemTableViewCell.points = currentAchievement.videoCount
                            achievementItemTableViewCell.creditsWorth = currentAchievement.videoCreditWorth
                        }
                    case 3 :
                        achievementItemTableViewCell.achievementTitle = "Submission"
                        if let currentAchievement = currentAchievement {
                            achievementItemTableViewCell.points = currentAchievement.submissionCount
                            achievementItemTableViewCell.creditsWorth = currentAchievement.submissionCreditWorth
                        }
                    default :
                        break
                }
            }
            cell = achievementItemTableViewCell
        }
        return cell
    }
}

extension AchievementsViewController : UITableViewDelegate {

    func tableView (_ tableView : UITableView, didSelectRowAt indexPath : IndexPath) {
        self.selectedIndexPath = indexPath
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/OnboardingCoordinator.swift" startline="1" endline="169">
import Moya
import NVActivityIndicatorView
protocol OnboardingHandler {

    func userHasLoggedIn (token : String, userID : String, userLastName : String, userFirstName : String, userFacebookID : String?)

    func userHasViewLifestyleTutorial ()
}

class OnboardingCoordinator {
    let onboardingNavigationController : UINavigationController
    let onboardingDataProvider : OnboardingDataProvider
    let welcomeViewController = StoryboardScene.Onboarding.initialScene.instantiate ()
    let signUpViewController = StoryboardScene.Onboarding.signUpVC.instantiate ()
    var onboardingHandler : OnboardingHandler?
    init (navigationController : UINavigationController, dataProvider : OnboardingDataProvider) {
        self.onboardingNavigationController = navigationController
        self.onboardingDataProvider = dataProvider
        setupWelcomeViewController ()
        setupSignUpViewController ()
        setupFacebookLogin ()
    }

    fileprivate func setupWelcomeViewController () {
        welcomeViewController.login = {
            (email, password) in NVActivityIndicatorPresenter.sharedInstance.startAnimating (Constants.activityData)
            self.onboardingDataProvider.login (email : email, password : password, completion : {
                (loginData, errorMsg) in NVActivityIndicatorPresenter.sharedInstance.stopAnimating ()
                if let loginData = loginData {
                    self.onboardingHandler?.userHasLoggedIn (token : loginData.token, userID : loginData.userID, userLastName : loginData.lastName, userFirstName : loginData.firstName, userFacebookID : nil)
                } else {
                    let errorMsg = errorMsg??
                    L10n.unknownErrorMessage
                    UIAlertController.showAlert ("Login", message : errorMsg, inViewController : self.welcomeViewController)
                }
            })
        }
        welcomeViewController.createAccount = {
            self.onboardingNavigationController.setNavigationBarHidden (false, animated : false)
            self.onboardingNavigationController.pushViewController (self.signUpViewController, animated : true)
        }
        welcomeViewController.submitForgotPassword = {
            email in NVActivityIndicatorPresenter.sharedInstance.startAnimating (ActivityData ())
            self.onboardingDataProvider.forgotPassword (email : email, completion : {
                (success, errorMsg) in NVActivityIndicatorPresenter.sharedInstance.stopAnimating ()
                if success {
                    let alertController = UIAlertController (title : "Forgot password", message : "An email has been sent with a link to reset your password", preferredStyle : .alert)
                    let ok = UIAlertAction (title : "OK", style : .default, handler : {
                        alertAction in self.start ()
                    })
                    alertController.addAction (ok)
                    self.welcomeViewController.present (alertController, animated : true, completion : nil)
                } else {
                    let errorMsg = errorMsg??
                    L10n.unknownErrorMessage
                    UIAlertController.showAlert ("Forgot password", message : errorMsg, inViewController : self.welcomeViewController)
                }
            })
        }
    }

    fileprivate func setupSignUpViewController () {
        signUpViewController.showTermsAndConds = {
            let termsAndCondsViewController = StoryboardScene.Onboarding.termsAndCondVC.instantiate ()
            termsAndCondsViewController.dismiss = {
                termsAndCondsViewController.dismiss (animated : true, completion : nil)
            }
            self.onboardingNavigationController.present (termsAndCondsViewController, animated : true, completion : nil)
        }
        signUpViewController.signUp = {
            signupInfo in NVActivityIndicatorPresenter.sharedInstance.startAnimating (Constants.activityData)
            self.onboardingDataProvider.createAccount (first : signupInfo.first, last : signupInfo.last, email : signupInfo.email, password : signupInfo.password, completion : {
                (success, errorMessage) in NVActivityIndicatorPresenter.sharedInstance.stopAnimating ()
                if success {
                    UserDefaults.standard.userLastName = signupInfo.last
                    UserDefaults.standard.userFirstName = signupInfo.first
                    let alertController = UIAlertController (title : "Sign up", message : L10n.accountActivationMessage, preferredStyle : .alert)
                    let ok = UIAlertAction (title : "OK", style : .default, handler : {
                        alertAction in self.signUpViewController.clearAllTextfields ()
                        self.start ()
                    })
                    alertController.addAction (ok)
                    self.signUpViewController.present (alertController, animated : true, completion : nil)
                } else {
                    let errorMessage = errorMessage??
                    L10n.unknownErrorMessage
                    UIAlertController.showAlert ("Sign up", message : errorMessage, inViewController : self.signUpViewController)
                }
            })
        }
    }

    fileprivate func setupFacebookLogin () {
        let facebookLogin : ((String, String) - > ()) = {
            (userID, token) in NVActivityIndicatorPresenter.sharedInstance.startAnimating (Constants.activityData)
            self.onboardingDataProvider.signInWithFacebook (userID : userID, token : token, completion : {
                (loginData, errorMsg) in NVActivityIndicatorPresenter.sharedInstance.stopAnimating ()
                if let loginData = loginData {
                    self.onboardingHandler?.userHasLoggedIn (token : loginData.token, userID : loginData.userID, userLastName : loginData.lastName, userFirstName : loginData.firstName, userFacebookID : userID)
                } else {
                    let errorMsg = errorMsg??
                    L10n.unknownErrorMessage
                    UIAlertController.showAlert ("Login", message : errorMsg, inViewController : self.signUpViewController)
                }
            })
        }
        welcomeViewController.facebookLogin = facebookLogin
        signUpViewController.facebookLogin = facebookLogin
    }

    func start () {
        welcomeViewController.presentWelcomeLayout ()
        self.onboardingNavigationController.setViewControllers ([welcomeViewController], animated : false)
    }

    func startLifeCategories () {
        let lifestyleTutorialController = StoryboardScene.Onboarding.lifestyleTutorialVC.instantiate ()
        let lifestyleController = StoryboardScene.Onboarding.lifestyleVC.instantiate ()
        lifestyleTutorialController.selectedLifestyleType = {
            lifestyleType in var lifestyle : Lifestyle?
            switch lifestyleType {
                case.Action :
                    lifestyle = Lifestyle (title : L10n.lifestyleActionTitle, detail : L10n.lifestyleActionDetail, backgroundImage : Asset.Assets.LifestyleTutorial.lifestyleActionBG.image)
                case.Fit :
                    lifestyle = Lifestyle (title : L10n.lifestyleFitTitle, detail : L10n.lifestyleFitDetail, backgroundImage : Asset.Assets.LifestyleTutorial.lifestyleFitBG.image)
                case.Athlete :
                    lifestyle = Lifestyle (title : L10n.lifestyleAthleteTitle, detail : L10n.lifestyleAthleteDetail, backgroundImage : Asset.Assets.LifestyleTutorial.lifestyleAthleteBG.image)
                case.Elite :
                    lifestyle = Lifestyle (title : L10n.lifestyleEliteTitle, detail : L10n.lifestyleEliteDetail, backgroundImage : Asset.Assets.LifestyleTutorial.lifestyleEliteBG.image)
            }
            lifestyleController.lifestyle = lifestyle
            let navigationController = UINavigationController (rootViewController : lifestyleController)
            navigationController.setNavigationBarHidden (true, animated : false)
            lifestyleTutorialController.present (navigationController, animated : true, completion : nil)
        }
        lifestyleController.exit = {
            lifestyleTutorialController.dismiss (animated : true, completion : nil)
        }
        lifestyleTutorialController.exit = {
            self.onboardingHandler?.userHasViewLifestyleTutorial ()
        }
        self.onboardingNavigationController.setNavigationBarHidden (false, animated : false)
        self.onboardingNavigationController.setViewControllers ([lifestyleTutorialController], animated : false)
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/Leaderboard.swift" startline="1" endline="68">
import Foundation
struct Leaderboard : Decodable {
    private enum CodingKeys : String, CodingKey {
        case gym = "gym"
        case topRanking = "top_ranking"
        case localRanking = "local_ranking"
        case total = "total"
    }
    var gym : Gym?
    var topRanking : [Athlete]
    var localRanking : [Athlete]
    var total : Int
    init (from decoder : Decoder) throws {
        let container = try decoder.container (keyedBy : CodingKeys.self)
        self.gym = try? container.decode (Gym.self, forKey : .gym)
        self.topRanking = try container.decode ([Athlete].self, forKey : .topRanking)
        self.localRanking = try container.decode ([Athlete].self, forKey : .localRanking)
        self.total = try container.decode (Int.self, forKey : .total)
    }
}

extension Leaderboard {
    var userIsTopRanking : Bool {
        get {
            guard let currentUserIdentifier = UserDefaults.standard.userID, let currentUserIdentifierInt = Int (currentUserIdentifier) else {
                return false
            }
            return self.topRanking.map ({
                return $0.userIdentifier
            }).contains (currentUserIdentifierInt)
        }
    }
    var groupedRankings : [[Athlete]] {
        get {
            var groupedRankingsToReturn = [[Athlete]] ()
            groupedRankingsToReturn.append (self.topRanking)
            if self.userIsTopRanking == false {
                groupedRankingsToReturn.append (self.localRanking)
            }
            return groupedRankingsToReturn
        }
    }
    var isRankingEmpty : Bool {
        get {
            return (self.topRanking + self.localRanking).count==
            0
        }
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/ViewControllerBackgroundImage.swift" startline="1" endline="56">
import UIKit
import SnapKit

@IBDesignable class ViewControllerBackgroundImage : NSObject {
    private var backgroundImageView : UIImageView?
    @IBOutlet private weak var viewController : UIViewController?
    @IBInspectable var backgroundImageName : String? {
        didSet {
            if let backgroundImageName = backgroundImageName {
                backgroundImageView?.image = UIImage (named : backgroundImageName)
            }
        }
    }

    override func awakeFromNib () {
        if backgroundImageView == nil {
            let backgroundImageViewToSet = UIImageView ()
            if viewController?.view is UITableView {
                let tableView = viewController?.view as! UITableView
                tableView.backgroundView = backgroundImageViewToSet
            } else if viewController?.view is UICollectionView {
                let collectionView = viewController?.view as! UICollectionView
                collectionView.backgroundView = backgroundImageViewToSet
            } else {
                if let view = viewController?.view {
                    view.insertSubview (backgroundImageViewToSet, at : 0)
                    backgroundImageViewToSet.snp.makeConstraints ({
                        (make) in make.edges.equalTo (view)
                    })
                }
            }
            backgroundImageView = backgroundImageViewToSet
        }
        if let backgroundImageName = backgroundImageName {
            backgroundImageView?.image = UIImage (named : backgroundImageName)
        }
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/CircularImageView.swift" startline="1" endline="55">
import UIKit

@IBDesignable class CircularImageView : UIImageView {

    private func commonInit () {
        self.layer.masksToBounds = true
        self.layer.cornerRadius = min (self.frame.size.width, self.frame.size.height)/
        2
    }

    override func awakeFromNib () {
        super.awakeFromNib ()
        self.commonInit ()
    }
    convenience init () {
        self.init (frame : CGRect.zero)
    }
    override init (frame : CGRect) {
        super.init (frame : frame)
        self.commonInit ()
    }
    required init? (coder aDecoder : NSCoder) {
        super.init (coder : aDecoder)
        self.commonInit ()
    }

    override func prepareForInterfaceBuilder () {
        super.prepareForInterfaceBuilder ()
        self.commonInit ()
    }

    override func layoutSubviews () {
        super.layoutSubviews ()
        self.layer.cornerRadius = min (self.frame.size.width, self.frame.size.height)/
        2
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/ChatConversation.swift" startline="1" endline="121">
import Foundation
import Firebase
struct ChatConversation {
    let documentIdentifier : String
    let participants : [String : ChatParticipant]
    let participantIdentifiers : [String]
    let lastMessage : String?
    let lastMessageDate : Date?
    var otherParticipantIdentifier : String? {
        get {
            guard let userIdentifier = UserDefaults.standard.userID else {
                return nil
            }
            return self.participantIdentifiers.filter ({
                return userIdentifier!=
                $0
            }).first
        }
    }
    var me : ChatParticipant? {
        get {
            guard let userIdentifier = UserDefaults.standard.userID else {
                return nil
            }
            return self.participants.filter ({
                return "\($0.key)"==
                userIdentifier
            }).first?.value
        }
    }
    var otherParticipant : ChatParticipant? {
        get {
            guard let otherParticipantIdentifier = self.otherParticipantIdentifier else {
                return nil
            }
            return self.participants.filter ({
                return "\($0.key)"==
                otherParticipantIdentifier
            }).first?.value
        }
    }
    init (snapshot : DocumentSnapshot) {
        let snapshotData = snapshot.data ()!
        self.documentIdentifier = snapshot.documentID
        self.participantIdentifiers = snapshotData ["user_ids"] as! [String]
        self.lastMessage = snapshotData ["last_message_text"] as? String
        var participantsList = [String : ChatParticipant] ()
        let participantsDictionary = (snapshotData ["participants"] as! [String : [String : Any]])
        participantsDictionary.forEach ({
            participantsList [$0.key] = ChatParticipant (json : $0.value)
        })
        assert (participantsList.count == 2)
        self.participants = participantsList
        let timestamp = snapshotData ["last_message_timestamp"] as? Timestamp
        self.lastMessageDate = timestamp?.dateValue ()
    }
}
struct ChatParticipant {
    let firstName : String
    let lastName : String
    let unreadMessageCount : Int?
    let profileURL : String?
    var fullName : String {
        get {
            return "\(self.firstName) \(self.lastName)"
        }
    }
    init (json : [String : Any]) {
        self.firstName = json ["first_name"] as! String
        self.lastName = json ["last_name"] as! String
        self.unreadMessageCount = json ["unread_count"] as? Int
        self.profileURL = json ["profile_image"] as? String
    }
}
struct ChatMessage {
    let documentIdentifier : String
    let text : String
    let ownerIdentifier : String
    let date : Date
    var isOwner : Bool? {
        get {
            guard let userIdentifier = UserDefaults.standard.userID else {
                return nil
            }
            return self.ownerIdentifier==
            userIdentifier
        }
    }
    init (snapshot : DocumentSnapshot) {
        let snapshotData = snapshot.data ()!
        self.documentIdentifier = snapshot.documentID
        self.text = snapshotData ["text"] as! String
        self.ownerIdentifier = snapshotData ["owner_id"] as! String
        let timestamp = snapshotData ["timestamp"] as! Timestamp
        self.date = timestamp.dateValue ()
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/CreditsUpdater.swift" startline="1" endline="30">
import Foundation

class CreditsUpdater {

    static func updateCredits (completion : ((Bool) - > ())?) {
        let dataProvider = CreditsDataProvider ()
        dataProvider.retrieveCredits () {
            (retrieveCreditsResult) in switch retrieveCreditsResult {
                case.success (let credits) :
                    UserDefaults.standard.userCredits = "\(credits.totalCredits)"
                    UserDefaults.standard.userDollars = Float (credits.dollarValue)
                    completion? (true)
                case.failure (let error) :
                    UserDefaults.standard.userCredits = error.localizedDescription
                    completion? (false)
            }
        }
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/UIView+Designable.swift" startline="1" endline="119">
import UIKit

@IBDesignable class RewardsCostView : UIView {

    func commonInit () {
        self.layer.borderWidth = 2.0
        self.layer.borderColor = UIColor (named : .rePerformanceRewardsGrey).cgColor
    }
    override init (frame : CGRect) {
        super.init (frame : frame)
        self.commonInit ()
    }
    required init? (coder aDecoder : NSCoder) {
        super.init (coder : aDecoder)
        self.commonInit ()
    }

    override func prepareForInterfaceBuilder () {
        super.prepareForInterfaceBuilder ()
        self.commonInit ()
    }
}

@IBDesignable class ChoseLocationNavBarView : UIView {

    func commonInit () {
    }
    override init (frame : CGRect) {
        super.init (frame : frame)
        self.commonInit ()
    }
    required init? (coder aDecoder : NSCoder) {
        super.init (coder : aDecoder)
        self.commonInit ()
    }

    override func prepareForInterfaceBuilder () {
        super.prepareForInterfaceBuilder ()
        self.commonInit ()
    }

    override func willMove (toWindow newWindow : UIWindow?) {
        super.willMove (toWindow : newWindow)
        self.layer.shadowOffset = CGSize (width : 0, height : (CGFloat (1) / UIScreen.main.scale))
        self.layer.shadowRadius = 0
        self.layer.shadowColor = #colorLiteral (red : 0, green : 0, blue : 0, alpha : 1).cgColor
        self.layer.shadowOpacity = 0.25
    }

    override func layoutSubviews () {
        super.layoutSubviews ()
        let frame = bounds
        let gradient = CAGradientLayer ()
        gradient.frame = frame
        gradient.colors = [UIColor (named : .rePerformanceNavGradientMiddle).cgColor, UIColor (named : .rePerformanceNavGradientEnd).cgColor]
        gradient.locations = [0.0, 1.0]
        gradient.startPoint = CGPoint (x : 0.5, y : 0.0)
        gradient.endPoint = CGPoint (x : 0.5, y : 1.0)
        self.layer.insertSublayer (gradient, at : 0)
    }
}

@IBDesignable class DropShadowView : UIView {

    func commonInit () {
        self.layer.shadowColor = UIColor.lightGray.cgColor
        self.layer.shadowOffset = CGSize.zero
        self.layer.shadowOpacity = 0.7
        self.layer.shadowRadius = 4.0
    }
    override init (frame : CGRect) {
        super.init (frame : frame)
        self.commonInit ()
    }
    required init? (coder aDecoder : NSCoder) {
        super.init (coder : aDecoder)
        self.commonInit ()
    }

    override func prepareForInterfaceBuilder () {
        super.prepareForInterfaceBuilder ()
        self.commonInit ()
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/CreditsDataProvider.swift" startline="1" endline="36">
import Foundation
import Result
import Moya

class CreditsDataProvider {
    let retrieveProvider = MoyaProvider <RetrieveService> ()

    func retrieveCredits (completion :@escaping (Result <RepCredits, REPerformanceError>) - > ()) {
        guard let token = UserDefaults.standard.userToken else {
            completion ( .failure ( .userTokenMissing))
            return
        }
        self.retrieveProvider.request ( .getCredits (token : token)) {
            (result) in do {
                let response = try result.dematerialize ()
                let repCredits = try response.map (RepCredits.self, atKeyPath : "data")
                completion ( .success (repCredits))
            } catch {
                completion ( .failure ( .requestFailed (error.localizedDescription)))
            }
        }
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/ReportCardIndicatorView.swift" startline="1" endline="68">
import UIKit

@IBDesignable class ReportCardIndicatorView : UIView {

    func commonInit () {
    }
    override init (frame : CGRect) {
        super.init (frame : frame)
        commonInit ()
    }
    required init? (coder aDecoder : NSCoder) {
        super.init (coder : aDecoder)
        commonInit ()
    }

    override func prepareForInterfaceBuilder () {
        super.prepareForInterfaceBuilder ()
        commonInit ()
    }

    func addCircleDashedBorder (fillColor : UIColor) {
        self.layoutIfNeeded ()
        let dottedCircleLayer : CAShapeLayer = CAShapeLayer ()
        let frameSize = self.frame.size
        let shapeRect = CGRect (x : 0, y : 0, width : frameSize.width, height : frameSize.height)
        dottedCircleLayer.bounds = shapeRect
        dottedCircleLayer.position = CGPoint (x : (frameSize.width / 2), y : (frameSize.height / 2))
        dottedCircleLayer.fillColor = UIColor.clear.cgColor
        dottedCircleLayer.strokeColor = UIColor.white.cgColor
        dottedCircleLayer.lineWidth = 1.0
        dottedCircleLayer.lineDashPattern = [3, 3]
        dottedCircleLayer.path = UIBezierPath (roundedRect : CGRect (x : 0, y : 0, width : shapeRect.width, height : shapeRect.height), cornerRadius : self.layer.cornerRadius).cgPath
        self.layer.addSublayer (dottedCircleLayer)
        let fillCircleLayer = CAShapeLayer ()
        let fillFrameSize = CGSize (width : (frameSize.width / 2), height : (frameSize.height / 2))
        let fillShapeRect = CGRect (x : 0, y : 0, width : fillFrameSize.width, height : fillFrameSize.height)
        fillCircleLayer.bounds = fillShapeRect
        fillCircleLayer.fillColor = fillColor.cgColor
        fillCircleLayer.position = CGPoint (x : (frameSize.width / 2), y : (frameSize.height / 2))
        fillCircleLayer.path = UIBezierPath (roundedRect : CGRect (x : 0, y : 0, width : fillShapeRect.width, height : fillShapeRect.height), cornerRadius : (self.layer.cornerRadius / 2)).cgPath
        self.layer.addSublayer (fillCircleLayer)
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/LearnAboutProViewController.swift" startline="1" endline="217">
import UIKit
import WebKit

class LearnAboutProViewController : UIViewController {
    @IBOutlet fileprivate var headerLabel : UILabel!
    @IBOutlet fileprivate var leaderTitleLabel : UILabel!
    @IBOutlet fileprivate var leaderDetailLabel : UILabel!
    @IBOutlet fileprivate var friendsTitleLabel : UILabel!
    @IBOutlet fileprivate var friendsDetailLabel : UILabel!
    @IBOutlet fileprivate var dealsTitleLabel : UILabel!
    @IBOutlet fileprivate var dealsDetailLabel : UILabel!
    @IBOutlet fileprivate var leftContainerView : UIView!
    @IBOutlet fileprivate var rightContainerView : UIView!
    @IBOutlet fileprivate var exclusiveDealsContainerViewConstraint : NSLayoutConstraint!
    @IBOutlet fileprivate var leftIndicatorView : UIActivityIndicatorView!
    @IBOutlet fileprivate var rightIndicatorView : UIActivityIndicatorView!
    @IBOutlet fileprivate var leftTitleLabel : UILabel!
    @IBOutlet fileprivate var rightTitleLabel : UILabel!
    @IBOutlet fileprivate var leftDollarLabel : UILabel!
    @IBOutlet fileprivate var rightDollarLabel : UILabel!
    @IBOutlet fileprivate var leftGetButton : UIButton!
    @IBOutlet fileprivate var rightGetButton : UIButton!
    @IBOutlet fileprivate var restorePurchaseButton : UIButton!
    var dismissWithSuccessfulPurchase : (() - > ())?
    var firstSub : Subscription? {
        didSet {
            self.rightIndicatorView.stopAnimating ()
            if let unwrappedFirstSub = firstSub {
                self.rightTitleLabel.isHidden = false
                self.rightDollarLabel.isHidden = false
                self.rightGetButton.isHidden = false
                self.rightTitleLabel.text = unwrappedFirstSub.product.localizedTitle
                self.rightDollarLabel.text = unwrappedFirstSub.formattedPrice
            }
        }
    }
    var secondSub : Subscription? {
        didSet {
            self.leftIndicatorView.stopAnimating ()
            if let unwrappedSecondSub = secondSub {
                self.leftTitleLabel.isHidden = false
                self.leftDollarLabel.isHidden = false
                self.leftGetButton.isHidden = false
                self.leftTitleLabel.text = unwrappedSecondSub.product.localizedTitle
                self.leftDollarLabel.text = unwrappedSecondSub.formattedPrice
            }
        }
    }

    override func viewDidLoad () {
        super.viewDidLoad ()
        setupNotificationCenter ()
        loadLayouts ()
        loadSubscriptions ()
    }

    override func viewDidAppear (_ animated : Bool) {
        super.viewDidAppear (animated)
        REPAnalytics.trackScreenWithName (screenName : ScreenName.UpgradeToPro, className : String (describing : self))
    }

    fileprivate func setupNotificationCenter () {
        NotificationCenter.default.addObserver (self, selector : #selector (handleOptionsLoaded (notification :)), name : SubscriptionService.optionsLoadedNotification, object : nil)
        NotificationCenter.default.addObserver (self, selector : #selector (handleSuccessfulPurchase (notification :)), name : SubscriptionService.purchaseSuccessfulNotification, object : nil)
        NotificationCenter.default.addObserver (self, selector : #selector (handlePurchaseIncomplete (notification :)), name : SubscriptionService.purchaseIncompleteNotification, object : nil)
    }

    fileprivate func loadLayouts () {
        self.headerLabel.text = L10n.learnAboutProHeader
        self.leaderTitleLabel.text = L10n.learnAboutProLeaderboard
        self.leaderTitleLabel.textColor = UIColor (named : .rePerformanceOrange)
        self.leaderDetailLabel.text = L10n.learnAboutProLeaderboardDetail
        self.friendsTitleLabel.text = L10n.learnAboutProCompareWithFriends
        self.friendsTitleLabel.textColor = UIColor (named : .rePerformanceOrange)
        self.friendsDetailLabel.text = L10n.learnAboutProCompareWithFriendsDetail
        self.dealsTitleLabel.text = L10n.learnAboutProExclusiveDeals
        self.dealsTitleLabel.textColor = UIColor (named : .rePerformanceOrange)
        self.dealsDetailLabel.text = L10n.learnAboutProExclusiveDealsDetail
        let kHeightOfHeaderAndBuffer : CGFloat = 40
        let kPercentageOfWidthUsedByLabel : CGFloat = 0.85
        let widthOfExclusiveLabel = kPercentageOfWidthUsedByLabel*
        UIScreen.main.bounds.width
        let boundingRect : CGSize = CGSize (width : widthOfExclusiveLabel, height : CGFloat.greatestFiniteMagnitude)
        let heightOfEnclosingContainer : CGFloat = NSString (string : L10n.learnAboutProExclusiveDealsDetail).boundingRect (with : boundingRect, options : NSStringDrawingOptions.usesLineFragmentOrigin, attributes : [NSAttributedString.Key.font : self.
          dealsDetailLabel.font], context : nil).size.height
        self.exclusiveDealsContainerViewConstraint.constant = heightOfEnclosingContainer+
        kHeightOfHeaderAndBuffer
        self.leftContainerView.addDashedBorder (strokeColor : .white, lineWidth : 1.0)
        self.rightContainerView.addDashedBorder (strokeColor : .white, lineWidth : 1.0)
        self.leftGetButton.setTitle (L10n.learnAboutProGet, for : .normal)
        self.leftGetButton.backgroundColor = UIColor (named : .rePerformanceOrange)
        self.rightGetButton.setTitle (L10n.learnAboutProGet, for : .normal)
        self.rightGetButton.backgroundColor = UIColor (named : .rePerformanceOrange)
        self.restorePurchaseButton.setTitle (L10n.learnAboutProRestorePurchase, for : .normal)
        self.restorePurchaseButton.backgroundColor = UIColor (named : .rePerformanceOrange)
    }

    fileprivate func loadSubscriptions () {
        SubscriptionService.shared.loadSubscriptionOptions ()
    }

    @objc func handleOptionsLoaded (notification : Notification) {
        DispatchQueue.main.async {
            [weak self] in guard SubscriptionService.shared.options! = nil, SubscriptionService.shared.options!.count > 1, let firstSub = SubscriptionService.shared.options? [0], let secondSub = SubscriptionService.shared.options? [1] else {
                self?.rightIndicatorView.stopAnimating ()
                self?.leftIndicatorView.stopAnimating ()
                return
            }
            self?.firstSub = firstSub
            self?.secondSub = secondSub
        }
    }

    @objc func handleSuccessfulPurchase (notification : Notification) {
        DispatchQueue.main.async {
            [weak self] in self?.setPurchaseButtonsEnabled (true)
            self?.dismissWithSuccessfulPurchase? ()
        }
    }

    @objc func handlePurchaseIncomplete (notification : Notification) {
        DispatchQueue.main.async {
            self.setPurchaseButtonsEnabled (true)
            guard let message = notification.userInfo? ["message"] as? String else {
                return
            }
            UIAlertController.showAlert (nil, message : message, inViewController : self)
        }
    }

    @IBAction fileprivate func leftButtonTapped (_ sender : UIButton) {
        if let unwrappedSecondSub = secondSub {
            setPurchaseButtonsEnabled (false)
            SubscriptionService.shared.purchase (subscription : unwrappedSecondSub)
        }
    }

    @IBAction fileprivate func rightButtonTapped (_ sender : UIButton) {
        if let unwrappedFirstSub = firstSub {
            setPurchaseButtonsEnabled (false)
            SubscriptionService.shared.purchase (subscription : unwrappedFirstSub)
        }
    }

    @IBAction fileprivate func restorePurchaseTapped (_ sender : UIButton) {
        setPurchaseButtonsEnabled (false)
        SubscriptionService.shared.restorePurchases ()
    }

    fileprivate func setPurchaseButtonsEnabled (_ enabled : Bool) {
        let alpha : CGFloat = enabled? 1.0 : 0.5
        self.leftGetButton.isEnabled = enabled
        self.leftGetButton.alpha = alpha
        self.rightGetButton.isEnabled = enabled
        self.rightGetButton.alpha = alpha
        self.restorePurchaseButton.isEnabled = enabled
        self.restorePurchaseButton.alpha = alpha
    }

    @IBAction fileprivate func termsAndConditionsButtonTapped () {
        let vc = StoryboardScene.Onboarding.termsAndCondVC.instantiate ()
        vc.setBackgroundColor (colorToUse : UIColor.black)
        vc.hideCloseButton ()
        self.navigationController?.pushViewController (vc, animated : true)
    }

    @IBAction fileprivate func privacyButtonTapped () {
        let vc = StoryboardScene.Onboarding.termsAndCondVC.instantiate ()
        vc.setBackgroundColor (colorToUse : UIColor.black)
        vc.hideCloseButton ()
        vc.setURLToLoad (url : Constants.PrivacyFilename)
        self.navigationController?.pushViewController (vc, animated : true)
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/HeightTableViewCell.swift" startline="1" endline="214">
import UIKit
import M13Checkbox

class HeightTableViewCell : UITableViewCell {
    @IBOutlet private var checkboxFeetInchesLabel : UILabel?
    @IBOutlet private var checkboxCmLabel : UILabel?
    @IBOutlet private var leftCheckbox : M13Checkbox?
    @IBOutlet private var rightCheckbox : M13Checkbox?
    @IBOutlet private var ftLabel : UILabel?
    @IBOutlet private var inLabel : UILabel?
    @IBOutlet private var cmLabel : UILabel?
    @IBOutlet private var feetInchesView : UIView?
    @IBOutlet private var cmView : UIView?
    @IBOutlet private var ftTextField : REPCustomTextField?
    @IBOutlet private var inTextField : REPCustomTextField?
    @IBOutlet private var cmTextField : REPCustomTextField?
    var checkboxChanged : (() - > ())?
    var valueChanged : ((String) - > ())?
    var feet : Int = 0
    var inches : Int = 0
    let ftTextFieldUpperBounds = 9
    let inTextFieldUpperBounds = 11
    let cmTextFieldUpperBounds = 303

    override func awakeFromNib () {
        super.awakeFromNib ()
        checkboxFeetInchesLabel?.textColor = UIColor.white
        checkboxCmLabel?.textColor = UIColor.white
        ftLabel?.textColor = UIColor (named : .rePerformanceOrange)
        inLabel?.textColor = UIColor (named : .rePerformanceOrange)
        cmLabel?.textColor = UIColor (named : .rePerformanceOrange)
        leftCheckbox?.addTarget (self, action : #selector (checkboxValueChanged (checkbox :)), for : UIControl.Event.valueChanged)
        rightCheckbox?.addTarget (self, action : #selector (checkboxValueChanged (checkbox :)), for : UIControl.Event.valueChanged)
        ftTextField?.keyboardType = .numberPad
        ftTextField?.addTarget (self, action : #selector (textFieldDidChange (textField :)), for : .editingChanged)
        ftTextField?.applyProfileWhiteUnderline ()
        inTextField?.keyboardType = .numberPad
        inTextField?.addTarget (self, action : #selector (textFieldDidChange (textField :)), for : .editingChanged)
        inTextField?.applyProfileWhiteUnderline ()
        cmTextField?.keyboardType = .numberPad
        cmTextField?.addTarget (self, action : #selector (textFieldDidChange (textField :)), for : .editingChanged)
        cmTextField?.applyProfileWhiteUnderline ()
    }

    func setUp (valueText : String, leftCheckboxChecked : Bool, rightCheckboxChecked : Bool) {
        if leftCheckboxChecked && valueText! = "" {
            if valueText! = "" {
                if let valueInt = Int (valueText) {
                    feet = valueInt/
                    12
                    inches = valueInt- (feet * 12)
                    ftTextField?.text = String (feet)
                    inTextField?.text = String (inches)
                    setLeftCheckBoxChecked (leftCheckboxChecked)
                    cmView?.isHidden = true
                    feetInchesView?.isHidden = false
                }
            }
        } else if rightCheckboxChecked && valueText! = "" {
            cmTextField?.text = valueText
            setRightCheckBoxChecked (rightCheckboxChecked)
            feetInchesView?.isHidden = true
            cmView?.isHidden = false
        } else {
            feetInchesView?.isHidden = false
            cmView?.isHidden = true
        }
        if ! self.getLeftCheckboxChecked ()&& ! self.getRightCheckboxChecked () {
            self.setLeftCheckBoxChecked (true)
            checkboxChanged? ()
        }
    }

    func getLeftCheckboxChecked () - > Bool {
        guard let leftCheckbox = leftCheckbox else {
            return false
        }
        return checkState (checkbox : leftCheckbox)
    }

    func getRightCheckboxChecked () - > Bool {
        guard let rightCheckbox = rightCheckbox else {
            return false
        }
        return checkState (checkbox : rightCheckbox)
    }

    func checkState (checkbox : M13Checkbox) - > Bool {
        return checkbox._IBCheckState==
        "Checked"
    }

    func setLeftCheckBoxChecked (_ checked : Bool) {
        guard let leftCheckbox = leftCheckbox else {
            return
        }
        setCheckboxValueWith (checkbox : leftCheckbox, checked : checked)
    }

    func setRightCheckBoxChecked (_ checked : Bool) {
        guard let rightCheckbox = rightCheckbox else {
            return
        }
        setCheckboxValueWith (checkbox : rightCheckbox, checked : checked)
    }

    @objc func checkboxValueChanged (checkbox : M13Checkbox) {
        if checkbox == leftCheckbox {
            if getLeftCheckboxChecked () {
                setRightCheckBoxChecked (false)
                feetInchesView?.isHidden = false
                cmView?.isHidden = true
                setZero ()
            } else {
                setLeftCheckBoxChecked (true)
            }
        } else if checkbox == rightCheckbox {
            if (getRightCheckboxChecked ()) {
                setLeftCheckBoxChecked (false)
                feetInchesView?.isHidden = true
                cmView?.isHidden = false
                setZero ()
            } else {
                setRightCheckBoxChecked (true)
            }
        } else {
            setRightCheckBoxChecked (false)
            setLeftCheckBoxChecked (false)
            feetInchesView?.isHidden = true
            cmView?.isHidden = true
            setZero ()
        }
        checkboxChanged? ()
    }

    private func setZero () {
        valueChanged? (String (0))
        ftTextField?.text = "0"
        inTextField?.text = "0"
        cmTextField?.text = "0"
        feet = 0
        inches = 0
    }

    private func setCheckboxValueWith (checkbox : M13Checkbox, checked : Bool) {
        if (checked) {
            checkbox.setCheckState ( .checked, animated : true)
        } else {
            checkbox.setCheckState ( .unchecked, animated : true)
        }
    }

    @objc func textFieldDidChange (textField : UITextField) {
        if textField == ftTextField {
            if let sanitized : Int = ftTextField?.sanitizeIntegerInput (upperBounds : ftTextFieldUpperBounds) {
                ftTextField?.text = String (sanitized)
                feet = sanitized
                valueChanged? (String ((feet * 12) + inches))
            } else {
                ftTextField?.text = ""
                feet = 0
                valueChanged? (String (0))
            }
        } else if textField == inTextField {
            if let sanitized : Int = inTextField?.sanitizeIntegerInput (upperBounds : inTextFieldUpperBounds) {
                inTextField?.text = String (sanitized)
                inches = sanitized
                valueChanged? (String ((feet * 12) + inches))
            } else {
                inTextField?.text = ""
                inches = 0
                valueChanged? (String (0))
            }
        } else if textField == cmTextField {
            if let sanitized : Int = cmTextField?.sanitizeIntegerInput (upperBounds : cmTextFieldUpperBounds) {
                cmTextField?.text = String (sanitized)
                valueChanged? (String (sanitized))
            } else {
                cmTextField?.text = ""
                valueChanged? (String (0))
            }
        }
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/UIButton+Designable.swift" startline="1" endline="134">
import UIKit

@IBDesignable class OrangeButtonWhiteTitle : UIButton {

    func commonInit () {
        backgroundColor = UIColor (named : .rePerformanceOrange)
        textColor = UIColor.white
        titleLabel?.font = UIFont.boldSystemFont (ofSize : 15)
        layer.cornerRadius = Constants.UIConstants.CornerRadius
        layer.masksToBounds = true
    }
    override init (frame : CGRect) {
        super.init (frame : frame)
        commonInit ()
    }
    required init? (coder aDecoder : NSCoder) {
        super.init (coder : aDecoder)
        commonInit ()
    }

    override func prepareForInterfaceBuilder () {
        super.prepareForInterfaceBuilder ()
        commonInit ()
    }
}

@IBDesignable class WhiteButtonYellowTitle : UIButton {

    func commonInit () {
        backgroundColor = UIColor.white
        textColor = UIColor (named : .rePerformanceOrange)
        titleLabel?.font = UIFont.boldSystemFont (ofSize : 15)
        layer.cornerRadius = Constants.UIConstants.CornerRadius
        layer.masksToBounds = true
    }
    override init (frame : CGRect) {
        super.init (frame : frame)
        commonInit ()
    }
    required init? (coder aDecoder : NSCoder) {
        super.init (coder : aDecoder)
        commonInit ()
    }

    override func prepareForInterfaceBuilder () {
        super.prepareForInterfaceBuilder ()
        commonInit ()
    }
}

@IBDesignable class ChangeGymBlueButton : UIButton {

    func commonInit () {
        backgroundColor = UIColor (named : .rePerformanceOrange)
        textColor = UIColor.white
        titleLabel?.font = UIFont.systemFont (ofSize : 17)
        layer.cornerRadius = Constants.UIConstants.CornerRadius
        layer.masksToBounds = true
    }
    override init (frame : CGRect) {
        super.init (frame : frame)
        commonInit ()
    }
    required init? (coder aDecoder : NSCoder) {
        super.init (coder : aDecoder)
        commonInit ()
    }

    override func prepareForInterfaceBuilder () {
        super.prepareForInterfaceBuilder ()
        commonInit ()
    }
}

@IBDesignable class BlueButton : UIButton {

    func commonInit () {
        self.backgroundColor = UIColor (named : .rePerformanceRewardsBlue)
        self.textColor = UIColor.white
        self.titleLabel?.font = UIFont.systemFont (ofSize : 17)
        self.layer.cornerRadius = Constants.UIConstants.CornerRadius
        self.layer.masksToBounds = true
    }
    override init (frame : CGRect) {
        super.init (frame : frame)
        self.commonInit ()
    }
    required init? (coder aDecoder : NSCoder) {
        super.init (coder : aDecoder)
        self.commonInit ()
    }

    override func prepareForInterfaceBuilder () {
        super.prepareForInterfaceBuilder ()
        self.commonInit ()
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/ReportCardScoreBreakdownTableViewCell.swift" startline="1" endline="263">
import UIKit
enum ExerciseType {
    case mileRun
    case fourtyYardDash
    case benchPress
    case deadlift
    case squat
    case militaryPress
    var indicatorColor : UIColor {
        get {
            switch self {
                case.mileRun :
                    return UIColor.white
                case.fourtyYardDash :
                    return UIColor (red : (243 / 255), green : (71 / 255), blue : (57 / 255), alpha : 1)
                case.benchPress :
                    return UIColor (red : (23 / 255), green : (249 / 255), blue : (255 / 255), alpha : 1)
                case.deadlift :
                    return UIColor (red : (255 / 255), green : (255 / 255), blue : (0 / 255), alpha : 1)
                case.squat :
                    return UIColor (red : (222 / 255), green : (54 / 255), blue : (232 / 255), alpha : 1)
                case.militaryPress :
                    return UIColor (red : (255 / 255), green : (0 / 255), blue : (91 / 255), alpha : 1)
            }
        }
    }
}

class ReportCardScoreBreakdownTableViewCell : UITableViewCell {
    @IBOutlet fileprivate var privacyContainerView : UIView!
    @IBOutlet fileprivate var isPublicSwitch : UISwitch!
    @IBOutlet fileprivate var reportCardView : UIView!
    @IBOutlet fileprivate var athleteImageView : UIImageView!
    @IBOutlet fileprivate var mileRunGradeIndicatorView : ReportCardIndicatorView!
    @IBOutlet fileprivate var mileRunGradeBodyIndicatorView : ReportCardIndicatorView!
    @IBOutlet fileprivate var mileRunGradeBodyIndicatorViewFemale : ReportCardIndicatorView!
    @IBOutlet fileprivate var mileRunGradeTitleLabel : UILabel!
    @IBOutlet fileprivate var mileRunGradeLabel : UILabel!
    @IBOutlet fileprivate var fourtyYardDashGradeIndicatorView : ReportCardIndicatorView!
    @IBOutlet fileprivate var fourtyYardDashGradeBodyIndicatorView : ReportCardIndicatorView!
    @IBOutlet fileprivate var fourtyYardDashGradeBodyIndicatorViewFemale : ReportCardIndicatorView!
    @IBOutlet fileprivate var fourtyYardDashGradeTitleLabel : UILabel!
    @IBOutlet fileprivate var fourtyYardDashGradeLabel : UILabel!
    @IBOutlet fileprivate var benchPressGradeIndicatorView : ReportCardIndicatorView!
    @IBOutlet fileprivate var benchPressGradeBodyIndicatorView : ReportCardIndicatorView!
    @IBOutlet fileprivate var benchPressGradeBodyIndicatorViewFemale : ReportCardIndicatorView!
    @IBOutlet fileprivate var benchPressGradeTitleLabel : UILabel!
    @IBOutlet fileprivate var benchPressGradeLabel : UILabel!
    @IBOutlet fileprivate var deadliftGradeIndicatorView : ReportCardIndicatorView!
    @IBOutlet fileprivate var deadliftGradeBodyIndicatorView : ReportCardIndicatorView!
    @IBOutlet fileprivate var deadliftGradeBodyIndicatorViewFemale : ReportCardIndicatorView!
    @IBOutlet fileprivate var deadliftGradeTitleLabel : UILabel!
    @IBOutlet fileprivate var deadliftGradeLabel : UILabel!
    @IBOutlet fileprivate var squatGradeIndicatorView : ReportCardIndicatorView!
    @IBOutlet fileprivate var squatGradeBodyIndicatorView : ReportCardIndicatorView!
    @IBOutlet fileprivate var squatGradeBodyIndicatorViewFemale : ReportCardIndicatorView!
    @IBOutlet fileprivate var squatGradeTitleLabel : UILabel!
    @IBOutlet fileprivate var squatGradeLabel : UILabel!
    @IBOutlet fileprivate var militaryPressGradeIndicatorView : ReportCardIndicatorView!
    @IBOutlet fileprivate var militaryPressGradeBodyIndicatorView : ReportCardIndicatorView!
    @IBOutlet fileprivate var militaryPressGradeBodyIndicatorViewFemale : ReportCardIndicatorView!
    @IBOutlet fileprivate var militaryPressGradeTitleLabel : UILabel!
    @IBOutlet fileprivate var militaryPressGradeLabel : UILabel!

    @IBAction private func changedProfileVisibility (_ sender : Any?) {
        guard let visibilitySwitch = sender as? UISwitch, visibilitySwitch == self.isPublicSwitch else {
            return
        }
        self.changeProfileVisibility? (visibilitySwitch.isOn)
    }

    @IBAction func updateProfileImagePressed (_ sender : Any) {
        self.updateProfileImage? ()
    }
    fileprivate var lines : [CALayer] = []
    var isPersonal : Bool = true {
        didSet {
            self.privacyContainerView.isHidden = (self.isPersonal == false)
        }
    }
    var isMale : Bool = true {
        didSet {
            self.athleteImageView?.image = self.isMale? UIImage (named : "ReportCardAthleteMale") : UIImage (named : "ReportCardAthleteFemale")
        }
    }
    var reportCard : ReportCard? {
        didSet {
            self.configureViews ()
            self.configureLineView ()
        }
    }
    var isPublic : Bool = false {
        didSet {
            self.isPublicSwitch.setOn (self.isPublic, animated : false)
        }
    }
    fileprivate var genderBasedMileRunBodyIndicatorView : ReportCardIndicatorView {
        get {
            return self.isMale? self.mileRunGradeBodyIndicatorView : self.mileRunGradeBodyIndicatorViewFemale
        }
    }
    fileprivate var genderBasedFourtyYardDashBodyIndicatorView : ReportCardIndicatorView {
        get {
            return self.isMale? self.fourtyYardDashGradeBodyIndicatorView : self.fourtyYardDashGradeBodyIndicatorViewFemale
        }
    }
    fileprivate var genderBasedBenchPressBodyIndicatorView : ReportCardIndicatorView {
        get {
            return self.isMale? self.benchPressGradeBodyIndicatorView : self.benchPressGradeBodyIndicatorViewFemale
        }
    }
    fileprivate var genderBasedDeadliftBodyIndicatorView : ReportCardIndicatorView {
        get {
            return self.isMale? self.deadliftGradeBodyIndicatorView : self.deadliftGradeBodyIndicatorViewFemale
        }
    }
    fileprivate var genderBasedSquatBodyIndicatorView : ReportCardIndicatorView {
        get {
            return self.isMale? self.squatGradeBodyIndicatorView : self.squatGradeBodyIndicatorViewFemale
        }
    }
    fileprivate var genderBasedMilitaryPressBodyIndicatorView : ReportCardIndicatorView {
        get {
            return self.isMale? self.militaryPressGradeBodyIndicatorView : self.militaryPressGradeBodyIndicatorViewFemale
        }
    }
    var changeProfileVisibility : ((Bool) - > ())?
    var updateProfileImage : (() - > ())?

    override func awakeFromNib () {
        super.awakeFromNib ()
    }

    override func prepareForReuse () {
        self.isPersonal = false
        self.reportCard = nil
        self.isPublic = false
        super.prepareForReuse ()
    }

    func createReportCard () - > UIImage? {
        return self.reportCardView.snapshot (backgroundColor : UIColor (named : .rePerformanceBlue))
    }

    private func configureViews () {
        guard let reportCard = self.reportCard else {
            return
        }
        self.configureViewsGrade (grade : reportCard.mileRunGrade, startDot : self.mileRunGradeIndicatorView, endDot : self.genderBasedMileRunBodyIndicatorView, gradeLabel : self.mileRunGradeLabel, titleLabel : self.mileRunGradeTitleLabel, color :
          ExerciseType.mileRun.indicatorColor)
        self.configureViewsGrade (grade : reportCard.fourtyYardDashGrade, startDot : self.fourtyYardDashGradeIndicatorView, endDot : self.genderBasedFourtyYardDashBodyIndicatorView, gradeLabel : self.fourtyYardDashGradeLabel, titleLabel : self.
          fourtyYardDashGradeTitleLabel, color : ExerciseType.fourtyYardDash.indicatorColor)
        self.configureViewsGrade (grade : reportCard.benchPressGrade, startDot : self.benchPressGradeIndicatorView, endDot : self.genderBasedBenchPressBodyIndicatorView, gradeLabel : self.benchPressGradeLabel, titleLabel : self.benchPressGradeTitleLabel,
          color : ExerciseType.benchPress.indicatorColor)
        self.configureViewsGrade (grade : reportCard.deadliftGrade, startDot : self.deadliftGradeIndicatorView, endDot : self.genderBasedDeadliftBodyIndicatorView, gradeLabel : self.deadliftGradeLabel, titleLabel : self.deadliftGradeTitleLabel, color :
          ExerciseType.deadlift.indicatorColor)
        self.configureViewsGrade (grade : reportCard.squatGrade, startDot : self.squatGradeIndicatorView, endDot : self.genderBasedSquatBodyIndicatorView, gradeLabel : self.squatGradeLabel, titleLabel : self.squatGradeTitleLabel, color : ExerciseType.
          squat.indicatorColor)
        self.configureViewsGrade (grade : reportCard.militaryPressGrade, startDot : self.militaryPressGradeIndicatorView, endDot : self.genderBasedMilitaryPressBodyIndicatorView, gradeLabel : self.militaryPressGradeLabel, titleLabel : self.
          militaryPressGradeTitleLabel, color : ExerciseType.militaryPress.indicatorColor)
    }

    private func configureViewsGrade (grade : String?, startDot : ReportCardIndicatorView?, endDot : ReportCardIndicatorView?, gradeLabel : UILabel?, titleLabel : UILabel?, color : UIColor) {
        var gradeText : String = "N/A"
        var textColor : UIColor = .lightGray
        var fillColor : UIColor = .lightGray
        if let grade = grade {
            gradeText = grade
            textColor = .white
            fillColor = color
            endDot?.alpha = 1
            endDot?.addCircleDashedBorder (fillColor : fillColor)
        } else {
            endDot?.alpha = 0
        }
        startDot?.addCircleDashedBorder (fillColor : fillColor)
        gradeLabel?.text = gradeText
        gradeLabel?.textColor = textColor
        titleLabel?.textColor = textColor
    }

    private func configureLineView () {
        self.lines.forEach ({
            $0.removeFromSuperlayer ()
        })
        self.lines = []
        guard let reportCard = self.reportCard else {
            return
        }
        if reportCard.mileRunGrade! = nil {
            let line = self.reportCardView.addDashline (startView : self.mileRunGradeIndicatorView, endView : self.genderBasedMileRunBodyIndicatorView, color : ExerciseType.mileRun.indicatorColor)
            self.lines.append (line)
        }
        if reportCard.fourtyYardDashGrade! = nil {
            let line = self.reportCardView.addDashline (startView : self.fourtyYardDashGradeIndicatorView, endView : self.genderBasedFourtyYardDashBodyIndicatorView, color : ExerciseType.fourtyYardDash.indicatorColor)
            self.lines.append (line)
        }
        if reportCard.benchPressGrade! = nil {
            let line = self.reportCardView.addDashline (startView : self.benchPressGradeIndicatorView, endView : self.genderBasedBenchPressBodyIndicatorView, color : ExerciseType.benchPress.indicatorColor)
            self.lines.append (line)
        }
        if reportCard.deadliftGrade! = nil {
            let line = self.reportCardView.addDashline (startView : self.deadliftGradeIndicatorView, endView : self.genderBasedDeadliftBodyIndicatorView, color : ExerciseType.deadlift.indicatorColor)
            self.lines.append (line)
        }
        if reportCard.squatGrade! = nil {
            let line = self.reportCardView.addDashline (startView : self.squatGradeIndicatorView, endView : self.genderBasedSquatBodyIndicatorView, color : ExerciseType.squat.indicatorColor)
            self.lines.append (line)
        }
        if reportCard.militaryPressGrade! = nil {
            let line = self.reportCardView.addDashline (startView : self.militaryPressGradeIndicatorView, endView : self.genderBasedMilitaryPressBodyIndicatorView, color : ExerciseType.militaryPress.indicatorColor)
            self.lines.append (line)
        }
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/ChatMessagesViewController.swift" startline="1" endline="188">
import UIKit
import FirebaseFirestore
import FirebaseFunctions

class ChatMessagesViewController : UIViewController {
    @IBOutlet fileprivate var messagesTableView : UITableView?
    @IBOutlet fileprivate var messageTextField : UITextField?
    var myProfileImage : UIImage? = nil
    var otherProfileImage : UIImage? = nil

    @IBAction private func tappedSendButton (_ sender : Any?) {
        guard let messageToSend = self.messageTextField?.text, messageToSend.isEmpty == false else {
            return
        }
        guard let conversationIdentifier = self.messagingIdentifiers?.conversationIdentifier else {
            return
        }
        self.sendMessage (converstationIdentifier : conversationIdentifier, message : messageToSend)
        self.messageTextField?.text = nil
        self.messageTextField?.resignFirstResponder ()
    }
    deinit {
        self.snapshotListener?.remove ()
        self.conversationSnapshotListener?.remove ()
    }
    fileprivate let functions = Functions.functions ()
    var messagingIdentifiers : (firebaseIdentifier : String, conversationIdentifier : String)? = nil {
        didSet {
            self.snapshotListener?.remove ()
            guard let messagingIdentifiers = self.messagingIdentifiers else {
                return
            }
            let conversationReference = Firestore.firestore ().collection ("conversations").document (messagingIdentifiers.conversationIdentifier)
            self.conversationSnapshotListener = conversationReference.addSnapshotListener {
                [weak self] (snapshot, error) in guard let snapshot = snapshot else {
                    return
                }
                let chatConversation = ChatConversation (snapshot : snapshot)
                if let myProfileURL = chatConversation.me?.profileURL {
                    if let image = UIImage.getSavedProfileImage () {
                        self?.myProfileImage = image
                    } else {
                        UIImage.userProfileImage (url : URL (string : myProfileURL), completion : {
                            (image) in guard let image = image else {
                                return
                            }
                            self?.myProfileImage = image
                        })
                    }
                }
                if let otherProfileURL = chatConversation.otherParticipant?.profileURL {
                    UIImage.userProfileImage (url : URL (string : otherProfileURL), completion : {
                        (image) in guard let image = image else {
                            return
                        }
                        self?.otherProfileImage = image
                    })
                }
            }
            let conversationMessagesReference = Firestore.firestore ().collection ("conversations").document (messagingIdentifiers.conversationIdentifier).collection ("messages").whereField (FieldPath (["user_ids"]), arrayContains : messagingIdentifiers.
              firebaseIdentifier)
            self.snapshotListener = conversationMessagesReference.addSnapshotListener () {
                [weak self] (snapshot, error) in guard let snapshot = snapshot else {
                    return
                }
                var messages = [ChatMessage] ()
                for document in snapshot.documents {
                    let message = ChatMessage (snapshot : document)
                    messages.append (message)
                }
                self?.messages = messages.sorted (by : {
                    $0.date<
                    $1.date
                })
                self?.markMessagesRead (for : messagingIdentifiers.conversationIdentifier)
            }
        }
    }
    fileprivate var snapshotListener : ListenerRegistration?
    fileprivate var conversationSnapshotListener : ListenerRegistration?
    fileprivate var messages : [ChatMessage]? = nil {
        didSet {
            self.messagesTableView?.reloadData ()
            self.messagesTableView?.scrollToBottom ()
        }
    }

    fileprivate func sendMessage (converstationIdentifier : String, message : String, completion : ((REPerformanceError?) - > ())? = nil) {
        let param = ["conversation_id" : converstationIdentifier, "text" : message]
        self.functions.httpsCallable ("sendMessage").call (param) {
            (_, error) in if let error = error {
                completion? (REPerformanceError.requestFailed (error.localizedDescription))
            } else {
                completion? (nil)
            }
        }
    }

    fileprivate func markMessagesRead (for conversationIdentifier : String, completion : ((REPerformanceError?) - > ())? = nil) {
        let param = ["conversation_id" : conversationIdentifier]
        self.functions.httpsCallable ("markMessagesAsRead").call (param) {
            (result, error) in if let error = error {
                completion? (REPerformanceError.requestFailed (error.localizedDescription))
            } else {
                (UIApplication.shared.delegate as? AppDelegate)?.appCoordinator?.mainCoordinator.reportCardCoordinator.refreshChatUnreadMessagesStatus ()
                completion? (nil)
            }
        }
    }
}

extension ChatMessagesViewController : UITableViewDataSource {

    func numberOfSections (in tableView : UITableView) - > Int {
        return 1
    }

    func tableView (_ tableView : UITableView, numberOfRowsInSection section : Int) - > Int {
        guard let messages = self.messages else {
            return 0
        }
        return messages.count
    }

    func tableView (_ tableView : UITableView, cellForRowAt indexPath : IndexPath) - > UITableViewCell {
        let message = self.messages! [indexPath.row]
        let cellIdentifier = message.isOwner!? "Chat Message Sent Cell Identifier" : "Chat Message Received Cell Identifier"
        let cell = tableView.dequeueReusableCell (withIdentifier : cellIdentifier, for : indexPath) as! ChatMessageTableViewCell
        cell.messageContent = message.text
        if message.isOwner! {
            cell.messageImage.image = self.myProfileImage??
            Asset.Assets.nonFacebook.image
        } else {
            cell.messageImage.image = self.otherProfileImage??
            Asset.Assets.nonFacebook.image
        }
        return cell
    }
}

extension ChatMessagesViewController : UITextFieldDelegate {

    func textFieldShouldEndEditing (_ textField : UITextField) - > Bool {
        textField.resignFirstResponder ()
        return true
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/ChallengesViewController.swift" startline="1" endline="66">
import UIKit

class ChallengesViewController : UIViewController {
    @IBOutlet private var tableView : UITableView? {
        didSet {
            self.tableView?.estimatedRowHeight = 85
            self.tableView?.rowHeight = UITableView.automaticDimension
            self.tableView?.backgroundColor = UIColor.clear
            self.tableView?.tableFooterView = UIView ()
        }
    }
    var challenges : [Challenge]? {
        didSet {
            self.tableView?.reloadData ()
        }
    }
    var challengesWillAppear : (() - > ())?
    var selectedChallenge : ((Challenge) - > ())?

    override func viewWillAppear (_ animated : Bool) {
        super.viewWillAppear (animated)
        self.challengesWillAppear? ()
    }
}

extension ChallengesViewController : UITableViewDataSource, UITableViewDelegate {

    func tableView (_ tableView : UITableView, numberOfRowsInSection section : Int) - > Int {
        return challenges?.count??
        0
    }

    func tableView (_ tableView : UITableView, cellForRowAt indexPath : IndexPath) - > UITableViewCell {
        guard let cell = tableView.dequeueReusableCell (withIdentifier : Constants.Challenges.ChallengesCellIdentifier, for : indexPath) as? ChallengesTableViewCell, let challenge = self.challenges? [indexPath.row] else {
            fatalError ()
        }
        cell.configure (challenge : challenge)
        return cell
    }

    func tableView (_ tableView : UITableView, didSelectRowAt indexPath : IndexPath) {
        tableView.deselectRow (at : indexPath, animated : true)
        guard let challenge = self.challenges? [indexPath.row] else {
            return
        }
        self.selectedChallenge? (challenge)
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/ChallengeGymsViewController.swift" startline="1" endline="255">
import UIKit
import AlamofireImage

class ChallengeGymsViewController : UIViewController {
    @IBOutlet fileprivate var tableView : UITableView?
    @IBOutlet fileprivate var bannerImageView : UIImageView?
    @IBOutlet fileprivate var titleLabel : UILabel?
    @IBOutlet fileprivate var subtitleLabel : UILabel?
    @IBOutlet fileprivate var challengeDateRangeLabel : UILabel?
    @IBOutlet fileprivate var remainingLabel : UILabel?
    @IBOutlet fileprivate var joinedTotalLabel : UILabel?
    @IBOutlet fileprivate var actionButton : UIButton?
    var challengeAction : (() - > ())?
    var challengeInfo : (() - > ())?
    var viewLeaderboard : ((Gym) - > ())?
    var changeGym : (() - > ())?
    var selectedAthlete : ((Athlete) - > ())?
    var challenge : Challenge? {
        didSet {
            guard let challenge = self.challenge else {
                return
            }
            self.titleLabel?.text = challenge.name
            self.subtitleLabel?.text = challenge.subtitle
            self.challengeDateRangeLabel?.text = challenge.startToEndDateDisplay ()
            self.joinedTotalLabel?.text = L10n.challengeTotalJoined ("\(challenge.joinedTotal)")
            self.remainingLabel?.text = challenge.timeRemaining ()
            self.actionButton?.setTitle (challenge.actionTitle (), for : .normal)
            self.actionButton?.isHidden = ! challenge.shouldShowActionButton ()
            if let bannerImageURL = challenge.imageURL {
                self.bannerImageView?.af_setImage (withURL : bannerImageURL)
            } else {
                self.bannerImageView?.image = UIImage (asset : Asset.Assets.torontoSkylineDELETE)
            }
        }
    }
    var athletes : [Athlete]? {
        didSet {
            self.tableView?.reloadData ()
        }
    }

    override func viewDidAppear (_ animated : Bool) {
        super.viewDidAppear (animated)
        REPAnalytics.trackScreenWithName (screenName : ScreenName.Challenges.Gyms (self.challenge!.name), className : String (describing : self))
    }

    @IBAction private func actionTapped (_ sender : UIButton) {
        guard let challenge = self.challenge else {
            return
        }
        switch challenge.type {
            case.personal :
                self.challengeAction? ()
            case.gym :
                self.challengeAction? ()
        }
    }

    @IBAction private func infoTapped (_ sender : UIButton) {
        self.challengeInfo? ()
    }

    func showChallengeJoinedAlert (challenge : Challenge) {
        guard challenge.hasJoined == true else {
            return
        }
        guard let exercise = challenge.exercise?.readable else {
            return
        }
        let message = L10n.challengeJoinedMessage (exercise, challenge.format.capitalized)
        UIAlertController.showAlert ("Challenge Joined", message : message, inViewController : self)
    }
}

extension ChallengeGymsViewController : UITableViewDataSource, UITableViewDelegate {

    func tableView (_ tableView : UITableView, numberOfRowsInSection section : Int) - > Int {
        guard let challenge = self.challenge else {
            return 0
        }
        switch challenge.type {
            case.personal :
                return self.athletes?.count??
                0
            case.gym :
                return challenge.gyms?.count??
                0
        }
    }

    func tableView (_ tableView : UITableView, cellForRowAt indexPath : IndexPath) - > UITableViewCell {
        guard let challenge = self.challenge else {
            fatalError ()
        }
        switch challenge.type {
            case.personal :
                let cell = tableView.dequeueReusableCell (withIdentifier : "Challenge Gym Leaderboard Ranking Cell Identifier", for : indexPath) as! ChallengeGymLeaderboardTableViewCell
                let athlete = self.athletes! [indexPath.row]
                cell.rank = athlete.rank
                cell.name = athlete.name
                cell.score = athlete.score
                cell.profileImageURL = (athlete.imageURL! = nil)? athlete.imageURL : FacebookImage.imageURLWithFacebookID (athlete.facebookIdentifier)
                cell.isPublic = athlete.isPublic
                return cell
            case.gym :
                let cell = tableView.dequeueReusableCell (withIdentifier : Constants.Challenges.ChallengeGymCellIdentifier, for : indexPath) as! ChallengeGymTableViewCell
                if let gym = challenge.gyms? [indexPath.row] {
                    cell.configure (gym : gym, postAt : indexPath.row)
                }
                return cell
        }
    }

    func tableView (_ tableView : UITableView, didSelectRowAt indexPath : IndexPath) {
        tableView.deselectRow (at : indexPath, animated : true)
        guard let challenge = self.challenge else {
            return
        }
        if challenge.type==.gym {
            if let gym = challenge.gyms? [indexPath.row] {
                self.viewLeaderboard? (gym)
            }
        } else if challenge.type==.personal {
            let athlete = self.athletes! [indexPath.row]
            self.selectedAthlete? (athlete)
        }
    }
}

fileprivate extension Challenge {

    func actionTitle () - > String {
        return self.hasJoined? L10n.challengeLeave : L10n.challengeJoin
    }

    func timeRemaining () - > String {
        guard let startDate = self.startDate?.toLocalTime (), let endDate = self.endDate?.toLocalTime () else {
            return ""
        }
        let now = Date ().toLocalTime ()
        guard endDate.compare (now)!=.orderedAscending else {
            return L10n.challengeEnded
        }
        if startDate.compare (now)==.orderedDescending {
            var daysRemaining = 0
            if let nowDay = Calendar.current.ordinality (of : .day, in : .era, for : now), let startDay = Calendar.current.ordinality (of : .day, in : .era, for : startDate) {
                daysRemaining = startDay-
                nowDay
            }
            if daysRemaining > 0 {
                let challengeStartsInDaysFormatLocalizedString = NSLocalizedString ("challenge_starts_in_days", comment : "")
                let challengeStartsInDaysLocalizedString = String.localizedStringWithFormat (challengeStartsInDaysFormatLocalizedString, daysRemaining)
                return challengeStartsInDaysLocalizedString
            } else {
                let secondsRemaining = startDate.timeIntervalSince (now)
                let hoursRemaining = Int (floor (secondsRemaining / Constants.secondsInOneHour))
                if hoursRemaining > 0 {
                    let challengeStartsInHoursFormatLocalizedString = NSLocalizedString ("challenge_starts_in_hours", comment : "")
                    let challengeStartsInHoursLocalizedString = String.localizedStringWithFormat (challengeStartsInHoursFormatLocalizedString, hoursRemaining)
                    return challengeStartsInHoursLocalizedString
                } else {
                    return L10n.challengeStartsInLessThanAnHour
                }
            }
        } else {
            var daysRemaining = 0
            if let nowDay = Calendar.current.ordinality (of : .day, in : .era, for : now), let endDay = Calendar.current.ordinality (of : .day, in : .era, for : endDate) {
                daysRemaining = endDay-
                nowDay
            }
            if daysRemaining > 0 {
                let challengeStartsInDaysFormatLocalizedString = NSLocalizedString ("challenge_days_remaining", comment : "")
                let challengeStartsInDaysLocalizedString = String.localizedStringWithFormat (challengeStartsInDaysFormatLocalizedString, daysRemaining)
                return challengeStartsInDaysLocalizedString
            } else {
                let secondsRemaining = endDate.timeIntervalSince (now)
                let hoursRemaining = Int (floor (secondsRemaining / Constants.secondsInOneHour))
                if hoursRemaining > 0 {
                    let challengeHoursRemainingFormatLocalizedString = NSLocalizedString ("challenge_hours_remaining", comment : "")
                    let challengeHoursRemainingLocalizedString = String.localizedStringWithFormat (challengeHoursRemainingFormatLocalizedString, hoursRemaining)
                    return challengeHoursRemainingLocalizedString
                } else {
                    return L10n.challengeLessThenHour
                }
            }
        }
    }

    func shouldShowActionButton () - > Bool {
        guard let endDate = self.endDate else {
            return true
        }
        let shouldShow = Calendar.current.compare (Date (), to : endDate, toGranularity : .second)==.orderedAscending
        return shouldShow
    }

    func userBelongInGyms () - > Bool {
        guard let currentGymPlaceID = UserDefaults.standard.currentGymPlaceID, currentGymPlaceID.isEmpty == false else {
            return false
        }
        return self.gyms?.filter ({
            $0.placeIdentifier==
            currentGymPlaceID
        }).count??
        0>
        0
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/AppCoordinator.swift" startline="1" endline="220">
import Foundation
import UIKit
import Moya
import Bugsnag
import Firebase
import FirebaseMessaging
import IQKeyboardManagerSwift
import FBSDKLoginKit
import KeychainAccess
import GoogleMaps
import GooglePlaces

class AppCoordinator : NSObject {
    let appDelegate : UIApplicationDelegate
    let navigationController : UINavigationController
    let onboardingCoordinator : OnboardingCoordinator
    let mainCoordinator : MainCoordinator
    init (appDelegate : UIApplicationDelegate) {
        guard let window = appDelegate.window? ? nil else {
            fatalError ("The App Delegate didn't have a window.")
        }
        self.appDelegate = appDelegate
        self.navigationController = StoryboardScene.Main.initialScene.instantiate ()
        self.onboardingCoordinator = OnboardingCoordinator (navigationController : self.navigationController, dataProvider : OnboardingDataProvider ())
        self.mainCoordinator = MainCoordinator (window : window)
        super.init ()
        FirebaseApp.configure ()
        Bugsnag.start (withApiKey : Constants.BugsnagAPIKey)
        Bugsnag.configuration ()?.setUser (UserDefaults.standard.userID, withName : nil, andEmail : nil)
        self.onboardingCoordinator.onboardingHandler = self
        self.setupAppearances ()
        self.registerUserDefaults ()
        self.setUpGoogleMaps ()
        self.setupIQKeyboardManager ()
        self.checkFirstLaunch ()
        self.setUpMainCoordinator ()
        self.start ()
    }

    private func checkFirstLaunch () {
        if let firstLaunch = UserDefaults.standard.firstLaunch, firstLaunch == true {
            self.removeSubscriptionInformationFromKeychain (completion : {
                (success) in UserDefaults.standard.firstLaunch = false
            })
        }
    }

    private func setUpMainCoordinator () {
        self.mainCoordinator.logout = {
            LifestyleDataProvider.wipeAllQuestionnaireDataFromPersistenceLayer (completion : nil)
            self.logoutOfFacebook ()
            self.clearData ()
            self.clearOnboardingTextFields ()
            self.start ()
        }
    }

    private func logoutOfFacebook () {
        let manager = LoginManager ()
        manager.logOut ()
    }

    private func registerUserDefaults () {
        var defaults = [String : Any] ()
        defaults [Constants.UserDefaultsKey.UserToken] = ""
        defaults [Constants.UserDefaultsKey.UserID] = ""
        defaults [Constants.UserDefaultsKey.HasViewLifeStyle] = false
        defaults [Constants.UserDefaultsKey.ProfileIsComplete] = false
        defaults [Constants.UserDefaultsKey.UserFirstName] = ""
        defaults [Constants.UserDefaultsKey.UserLastName] = ""
        defaults [Constants.UserDefaultsKey.LifestyleType] = ""
        defaults [Constants.UserDefaultsKey.UserHasRespondedToNotificationsRequest] = false
        defaults [Constants.UserDefaultsKey.UserCredits] = "0"
        defaults [Constants.UserDefaultsKey.UserWeight] = 0
        defaults [Constants.UserDefaultsKey.UserGender] = ""
        defaults [Constants.UserDefaultsKey.UserFacebookID] = ""
        defaults [Constants.UserDefaultsKey.UserCurrentLocation] = ""
        defaults [Constants.UserDefaultsKey.ProfileNeverFilledOut] = true
        defaults [Constants.UserDefaultsKey.FirstLaunch] = true
        defaults [Constants.UserDefaultsKey.ReportCardNeverSeen] = true
        defaults [Constants.UserDefaultsKey.LeaderboardNeverSeen] = true
        defaults [Constants.UserDefaultsKey.CurrentGymPlaceID] = ""
        defaults [Constants.UserDefaultsKey.ProfileIsPrivate] = false
        UserDefaults.standard.register (defaults : defaults)
    }

    private func clearUserDefaultsData () {
        UserDefaults.standard.userToken = nil
        UserDefaults.standard.userID = nil
        UserDefaults.standard.hasViewLifeStyle = false
        UserDefaults.standard.profileIsComplete = false
        UserDefaults.standard.userLastName = nil
        UserDefaults.standard.userFirstName = nil
        UserDefaults.standard.lifestyleType = ""
        UserDefaults.standard.userCredits = "0"
        UserDefaults.standard.userWeight = 0
        UserDefaults.standard.userGender = ""
        UserDefaults.standard.userFacebookID = nil
        UserDefaults.standard.userCurrentLocation = nil
        UserDefaults.standard.profileNeverFilledOut = true
        UserDefaults.standard.reportCardNeverSeen = true
        UserDefaults.standard.leaderboardNeverSeen = true
        UserDefaults.standard.currentGymPlaceID = ""
        UserDefaults.standard.isProfilePrivate = false
    }

    private func clearData () {
        self.clearUserDefaultsData ()
        self.removeSubscriptionInformationFromKeychain (completion : nil)
        self.mainCoordinator.setViewControllers ()
        self.mainCoordinator.profileCoordinator.loadLifeStyle ()
    }

    func removeSubscriptionInformationFromKeychain (completion : ((Bool) - > ())?) {
        let keychain = Keychain (service : Constants.Keychain.Service)
        do {
            try keychain.remove (Constants.Keychain.CurrentSubscription)
            completion? (true)
        } catch let error {
            print ("error: \(error)")
            completion? (false)
        }
    }

    private func clearOnboardingTextFields () {
        self.onboardingCoordinator.signUpViewController.clearAllTextfields ()
        self.onboardingCoordinator.welcomeViewController.clearUsernameAndPassword ()
    }

    private func setupAppearances () {
        UINavigationBar.appearance ().tintColor = UIColor.white
        UINavigationBar.appearance ().titleTextAttributes = [NSAttributedString.Key.foregroundColor : UIColor.white]
        UINavigationBar.appearance ().setBackgroundImage (UIImage (), for : .default)
        UINavigationBar.appearance ().shadowImage = UIImage ()
        UINavigationBar.appearance ().isTranslucent = true
        UITabBar.appearance ().backgroundColor = UIColor.white
        UITabBar.appearance ().tintColor = UIColor (named : .rePerformanceOrange)
        UISwitch.appearance ().onTintColor = UIColor (named : .rePerformanceOrange)
    }

    private func setupIQKeyboardManager () {
        IQKeyboardManager.shared.enable = true
        IQKeyboardManager.shared.enableAutoToolbar = true
    }

    func setUpGoogleMaps () {
        GMSServices.provideAPIKey (Constants.Google.APIKey)
        GMSPlacesClient.provideAPIKey (Constants.Google.APIKey)
    }

    func registerUserForPushNotification () {
        guard let appDelegate = self.appDelegate as? AppDelegate else {
            fatalError ()
        }
        appDelegate.configureNotifications ()
    }

    func start () {
        guard let window = self.appDelegate.window? ? nil else {
            fatalError ("The App Delegate didn't have a window.")
        }
        window.rootViewController = self.navigationController
        if let userToken = UserDefaults.standard.userToken, userToken.isEmpty {
            self.onboardingCoordinator.start ()
        } else if UserDefaults.standard.hasViewLifeStyle == false {
            self.onboardingCoordinator.startLifeCategories ()
        } else {
            self.registerUserForPushNotification ()
            self.mainCoordinator.start ()
        }
    }
}

extension AppCoordinator : OnboardingHandler {

    func userHasLoggedIn (token : String, userID : String, userLastName : String, userFirstName : String, userFacebookID : String?) {
        UserDefaults.standard.userToken = token
        UserDefaults.standard.userID = userID
        UserDefaults.standard.userLastName = userLastName
        UserDefaults.standard.userFirstName = userFirstName
        UserDefaults.standard.userFacebookID = userFacebookID
        self.start ()
    }

    func userHasViewLifestyleTutorial () {
        UserDefaults.standard.hasViewLifeStyle = true
        self.start ()
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/DateFormats.swift" startline="1" endline="42">
import Foundation

extension DateFormatter {

    static func exercisesResultsDateFormatter () - > DateFormatter {
        let dateFormatter : DateFormatter = DateFormatter ()
        dateFormatter.dateFormat = "MMMM d, y"
        return dateFormatter
    }

    static func displayScoreResultsDateFormatter () - > DateFormatter {
        let dateFormatter = DateFormatter ()
        dateFormatter.dateFormat = "MM/dd/yyyy"
        return dateFormatter
    }

    static func serverDateFormatter () - > DateFormatter {
        let dateFormatter = DateFormatter ()
        dateFormatter.dateFormat = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'Z'"
        dateFormatter.timeZone = TimeZone (abbreviation : "UTC")
        return dateFormatter
    }

    static func storedDateFormatter () - > DateFormatter {
        let dateFormatter = DateFormatter ()
        dateFormatter.dateFormat = "MM-dd-yyyy-HH-mm-ss"
        return dateFormatter
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/LeaderboardDataProvider.swift" startline="1" endline="81">
import Moya
import SwiftyJSON

class LeaderboardDataProvider {
    let retrieveProvider = MoyaProvider <RetrieveService> ()
    let submitProvider = MoyaProvider <SubmitService> ()

    func retreiveLeaderboard (group : LeaderboardGroup, filterAge : Bool, exercise : ExerciseCategory?, testFormat : ExerciseTestFormat?, completion :@escaping (Leaderboard?, String?) - > ()) {
        guard let token = UserDefaults.standard.userToken else {
            completion (nil, L10n.userTokenMissingMessage)
            return
        }
        if let exercise = exercise, let testFormat = testFormat {
            self.retrieveProvider.request ( .getLeaderboard (token : token, group : group, filter_age : filterAge, exercise : exercise, test_format : testFormat)) {
                (result) in do {
                    let response = try result.dematerialize ()
                    let leaderboard = try response.map (Leaderboard.self, atKeyPath : "data")
                    completion (leaderboard, nil)
                } catch {
                    completion (nil, error.localizedDescription)
                }
            }
        } else {
            self.retrieveProvider.request ( .getDefaultLeaderboard (token : token, group : group, filter_age : filterAge)) {
                (result) in do {
                    let response = try result.dematerialize ()
                    let leaderboard = try response.map (Leaderboard.self, atKeyPath : "data")
                    completion (leaderboard, nil)
                } catch {
                    completion (nil, error.localizedDescription)
                }
            }
        }
    }

    func retreiveGymLeaderboard (exercise : ExerciseCategory, testFormat : ExerciseTestFormat, completion :@escaping (Leaderboard?, String?) - > ()) {
        guard let token = UserDefaults.standard.userToken else {
            completion (nil, L10n.userTokenMissingMessage)
            return
        }
        self.retrieveProvider.request ( .getGymLeaderboard (token : token, exercise : exercise, test_format : testFormat)) {
            (result) in do {
                let response = try result.dematerialize ()
                let leaderboard = try response.map (Leaderboard.self, atKeyPath : "data")
                completion (leaderboard, nil)
            } catch {
                completion (nil, error.localizedDescription)
            }
        }
    }

    func submitGym (placeID : String, name : String, region : String, completion :@escaping (Bool, String?) - > ()) {
        guard let token = UserDefaults.standard.userToken else {
            completion (false, L10n.userTokenMissingMessage)
            return
        }
        self.submitProvider.request ( .submitGym (token : token, placeID : placeID, name : name, region : region)) {
            (result) in do {
                let _ = try result.dematerialize ()
                completion (true, nil)
            } catch {
                completion (false, error.localizedDescription)
            }
        }
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/EndorsementsTableViewCell.swift" startline="1" endline="27">
import UIKit

class EndorsementsTableViewCell : UITableViewCell {
    @IBOutlet private var titleLabel : UILabel?
    @IBOutlet private var disclosureIndicator : UIImageView?

    override func awakeFromNib () {
        super.awakeFromNib ()
        titleLabel?.textColor = UIColor.white
        disclosureIndicator?.image = #imageLiteral (resourceName : "OrangeDisclosureIndicatorRight")
    }

    func setTitleLabelWithText (_ text : String) {
        titleLabel?.text = text
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/LocationsDataProvider.swift" startline="1" endline="83">
import UIKit
import SwiftyJSON
struct Locations {
    let countries : Array <Country>
    init (countries : Array <Country>) {
        self.countries = countries
    }
}
struct Country {
    let name : String
    let id : String
    let provinces : Array <Province>
    init (name : String, id : String, provinces : Array <Province>) {
        self.name = name
        self.id = id
        self.provinces = provinces
    }
}
struct Province {
    let name : String
    let id : String
    init (name : String, id : String) {
        self.name = name
        self.id = id
    }
}

class LocationsDataProvider : NSObject {

    class func loadLoactionsFromFile () - > Locations? {
        guard let path = Bundle.main.path (forResource : "locations", ofType : "json") else {
            return nil
        }
        var json : JSON?
        do {
            let data = try Data (contentsOf : URL (fileURLWithPath : path), options : .alwaysMapped)
            json = try JSON (data : data)
            if json == JSON.null {
                return nil
            }
        } catch let error {
            print (error.localizedDescription)
            return nil
        }
        guard let unwrappedJson : JSON = json else {
            return nil
        }
        var countries : Array <Country> = []
        for (_, countriesJson) : (String, JSON) in unwrappedJson {
            let countryName = countriesJson ["name"].stringValue
            let countryID = countriesJson ["code"].stringValue
            let regions = countriesJson ["regions"]
            var provinces : Array <Province> = []
            for (_, provincesJson) : (String, JSON) in regions {
                let provinceName = provincesJson ["name"].stringValue
                let provinceID = provincesJson ["code"].stringValue
                let province = Province (name : provinceName, id : provinceID)
                provinces.append (province)
            }
            let country = Country (name : countryName, id : countryID, provinces : provinces)
            countries.append (country)
        }
        return Locations (countries : countries)
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/LeaderboardErrorTableViewCell.swift" startline="1" endline="26">
import UIKit

class LeaderboardErrorTableViewCell : UITableViewCell {
    @IBOutlet private var errorLabel : UILabel?

    override func awakeFromNib () {
        super.awakeFromNib ()
        errorLabel?.textColor = UIColor.white
        selectionStyle = .none
    }

    func configureCell (errorMessage : String) {
        errorLabel?.text = errorMessage
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/Buttons.swift" startline="1" endline="177">
import UIKit

extension UIView {
    @IBInspectable var borderWidth : CGFloat {
        get {
            return layer.borderWidth
        }
        set {
            layer.borderWidth = newValue
        }
    }
    @IBInspectable var borderColor : UIColor {
        get {
            return layer.borderColor!=
            nil? UIColor.init (cgColor : layer.borderColor!) : UIColor.black
        }
        set {
            layer.borderColor = newValue.cgColor
        }
    }
    @IBInspectable var cornerRadius : CGFloat {
        get {
            return layer.cornerRadius
        }
        set {
            layer.cornerRadius = newValue
        }
    }
}

extension UIButton {
    @IBInspectable var textColor : UIColor {
        get {
            return titleColor (for : .normal)??
            UIColor.clear
        }
        set {
            setTitleColor (newValue, for : .normal)
        }
    }
}

extension UIButton {

    public func setUpWhiteLogoutButton () {
        textColor = UIColor.white
        layer.cornerRadius = Constants.UIConstants.LogoutButtonCornerRadius
        layer.borderColor = UIColor.white.cgColor
        layer.borderWidth = Constants.UIConstants.BorderWidth
        layer.masksToBounds = true
        backgroundColor = UIColor.clear
    }

    public func setUpOrangeREPerformanceButton () {
        textColor = UIColor.white
        layer.cornerRadius = Constants.UIConstants.CornerRadius
        layer.masksToBounds = true
        backgroundColor = UIColor.init (named : .rePerformanceOrange)
        setEnabled (enabled : isEnabled)
    }

    public func setEnabled (enabled : Bool) {
        isEnabled = enabled
        if isEnabled {
            alpha = 1.0
        } else {
            alpha = 0.5
        }
    }

    public func setUpWhiteREPerformanceButton () {
        textColor = UIColor.white
        layer.cornerRadius = Constants.UIConstants.CornerRadius
        layer.masksToBounds = true
        backgroundColor = UIColor.clear
        borderWidth = Constants.UIConstants.BorderWidth
        borderColor = UIColor.white
    }

    public func setUpBlueButton () {
        textColor = UIColor (named : .rePerformanceBlueText)
        borderWidth = Constants.UIConstants.BorderWidth
        borderColor = UIColor (named : .rePerformanceBlueText)
        layer.cornerRadius = Constants.UIConstants.CornerRadius
        layer.masksToBounds = true
    }

    public func setUpShareOnInstagramButton () {
        textColor = UIColor (named : .rePerformanceBlueText)
        layer.cornerRadius = Constants.UIConstants.CornerRadius
        layer.masksToBounds = true
        backgroundColor = UIColor.white
        setEnabled (enabled : isEnabled)
        imageView?.contentMode = .scaleAspectFit
        semanticContentAttribute = .forceRightToLeft
    }
}

extension UIImage {

    static func imageFromColor (color : UIColor) - > UIImage? {
        let rect = CGRect (x : 0, y : 0, width : 1, height : 1)
        UIGraphicsBeginImageContext (rect.size)
        let context = UIGraphicsGetCurrentContext ()
        context?.setFillColor (color.cgColor)
        context?.fill (rect)
        let image = UIGraphicsGetImageFromCurrentImageContext ()
        return image
    }
}

class BorderButton : UIButton {

    func commonInit () {
        borderWidth = 2
        borderColor = UIColor.clear
        textColor = UIColor.black
    }
    override init (frame : CGRect) {
        super.init (frame : frame)
        commonInit ()
    }
    required init? (coder aDecoder : NSCoder) {
        super.init (coder : aDecoder)
        commonInit ()
    }

    override func prepareForInterfaceBuilder () {
        super.prepareForInterfaceBuilder ()
        commonInit ()
    }
}

class RoundButton : UIButton {

    func commonInit () {
        borderWidth = 0
        cornerRadius = 5
        textColor = UIColor.black
    }
    override init (frame : CGRect) {
        super.init (frame : frame)
        commonInit ()
    }
    required init? (coder aDecoder : NSCoder) {
        super.init (coder : aDecoder)
        commonInit ()
    }

    override func prepareForInterfaceBuilder () {
        super.prepareForInterfaceBuilder ()
        commonInit ()
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/CAGradientLayer+REPerformance.swift" startline="1" endline="37">
import UIKit

extension CAGradientLayer {
    convenience init (frame : CGRect, colors : [UIColor]) {
        self.init ()
        self.frame = frame
        self.colors = []
        for color in colors {
            self.colors?.append (color.cgColor)
        }
        startPoint = CGPoint (x : 0.5, y : 0)
        endPoint = CGPoint (x : 0.5, y : 1)
    }

    func createGradientImage () - > UIImage? {
        var image : UIImage? = nil
        UIGraphicsBeginImageContext (bounds.size)
        if let context = UIGraphicsGetCurrentContext () {
            render (in : context)
            image = UIGraphicsGetImageFromCurrentImageContext ()
        }
        UIGraphicsEndImageContext ()
        return image
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/SubscriptionService.swift" startline="1" endline="219">
import StoreKit
import KeychainAccess
import Moya

class SubscriptionService : NSObject {
    static let optionsLoadedNotification = Notification.Name ("SubscriptionServiceOptionsLoadedNotification")
    static let purchaseSuccessfulNotification = Notification.Name ("SubscriptionServicePurchaseSuccessfulNotification")
    static let purchaseIncompleteNotification = Notification.Name ("SubscriptionServicePurchaseIncompleteNotification")
    static let shared = SubscriptionService ()

    static func checkIsInConferenceMode (completion :@escaping ((Bool) - > ())) {
        let provider = MoyaProvider <RetrieveService> ()
        provider.request ( .conferenceMode ()) {
            result in do {
                let response = try result.dematerialize ()
                let isConferenceModeEnabled = try response.mapConferenceMode ()
                completion (isConferenceModeEnabled)
            } catch {
                completion (false)
            }
        }
    }
    var currentSubscription : PaidSubscription? {
        get {
            let keychain = Keychain (service : Constants.Keychain.Service)
            guard let data = try! keychain.getData (Constants.Keychain.CurrentSubscription), let subscription = NSKeyedUnarchiver.unarchiveObject (with : data) as? PaidSubscription else {
                return nil
            }
            return subscription
        }
        set {
            if let subscription = newValue, subscription.isActive == true {
                let encodedData = NSKeyedArchiver.archivedData (withRootObject : subscription)
                let keychain = Keychain (service : Constants.Keychain.Service)
                do {
                    try keychain.set (encodedData, key : Constants.Keychain.CurrentSubscription)
                } catch let error {
                    print (error)
                }
            }
        }
    }
    var isActive : Bool {
        get {
            #if USE_PRODUCTION
                if let subscription = currentSubscription, subscription.isActive == true {
                    return true
                }
                return false
            #else
                return true
            #endif
        }
    }
    var options : [Subscription]? {
        didSet {
            NotificationCenter.default.post (name : SubscriptionService.optionsLoadedNotification, object : options)
        }
    }

    func loadSubscriptionOptions () {
        let productIDPrefix = Bundle.main.bundleIdentifier!+
        ".sub."
        let proMonthly = productIDPrefix+
        "pro.monthly2"
        let proAnnually = productIDPrefix+
        "pro.annually2"
        let productIDs = Set ([proMonthly, proAnnually])
        let request = SKProductsRequest (productIdentifiers : productIDs)
        request.delegate = self
        request.start ()
    }

    func purchase (subscription : Subscription) {
        let payment = SKPayment (product : subscription.product)
        SKPaymentQueue.default ().add (payment)
    }

    func restorePurchases () {
        SKPaymentQueue.default ().restoreCompletedTransactions ()
    }
    fileprivate var purchaseTimer : Timer?
}

extension SubscriptionService : SKProductsRequestDelegate {

    func productsRequest (_ request : SKProductsRequest, didReceive response : SKProductsResponse) {
        options = response.products.map {
            Subscription (product : $0)
        }
    }
}

extension SubscriptionService : SKPaymentTransactionObserver {

    func paymentQueue (_ queue : SKPaymentQueue, updatedTransactions transactions : [SKPaymentTransaction]) {
        for transaction in transactions {
            switch transaction.transactionState {
                case.purchasing :
                    handlePurchasingState (for : transaction, in : queue)
                case.purchased :
                    handlePurchasedState (for : transaction, in : queue)
                case.restored :
                    handleRestoredState (for : transaction, in : queue)
                case.failed :
                    handleFailedState (for : transaction, in : queue)
                case.deferred :
                    handleDeferredState (for : transaction, in : queue)
            }
        }
    }

    fileprivate func handlePurchasingState (for transaction : SKPaymentTransaction, in queue : SKPaymentQueue) {
    }

    fileprivate func handlePurchasedState (for transaction : SKPaymentTransaction, in queue : SKPaymentQueue) {
        saveSubscriptionFromTransaction (transaction)
        purchaseTimer?.invalidate ()
        purchaseTimer = Timer.scheduledTimer (withTimeInterval : 2.0, repeats : false, block : {
            timer in NotificationCenter.default.post (name : SubscriptionService.purchaseSuccessfulNotification, object : nil)
        })
        queue.finishTransaction (transaction)
    }

    fileprivate func handleRestoredState (for transaction : SKPaymentTransaction, in queue : SKPaymentQueue) {
        saveSubscriptionFromTransaction (transaction)
        queue.finishTransaction (transaction)
    }

    fileprivate func handleFailedState (for transaction : SKPaymentTransaction, in queue : SKPaymentQueue) {
        purchaseTimer?.invalidate ()
        if let error = transaction.error {
            let userInfo : [AnyHashable : Any]?
            if let storeError = error as? SKError, storeError._nsError.domain == SKErrorDomain && storeError.code==.paymentCancelled {
                userInfo = nil
            } else {
                userInfo = ["message" : error.localizedDescription]
            }
            NotificationCenter.default.post (name : SubscriptionService.purchaseIncompleteNotification, object : nil, userInfo : userInfo)
        }
        queue.finishTransaction (transaction)
    }

    fileprivate func handleDeferredState (for transaction : SKPaymentTransaction, in queue : SKPaymentQueue) {
        NotificationCenter.default.post (name : SubscriptionService.purchaseIncompleteNotification, object : nil, userInfo : ["message" : L10n.learnAboutProPurchaseDeferred])
    }

    fileprivate func saveSubscriptionFromTransaction (_ transaction : SKPaymentTransaction) {
        if (currentSubscription == nil) {
            currentSubscription = PaidSubscription (transaction : transaction)
        } else if let purchaseDate = currentSubscription?.purchaseDate, let transactionDate = transaction.transactionDate, transactionDate> = purchaseDate {
            currentSubscription = PaidSubscription (transaction : transaction)
        }
    }

    func paymentQueueRestoreCompletedTransactionsFinished (_ queue : SKPaymentQueue) {
        if currentSubscription == nil {
            NotificationCenter.default.post (name : SubscriptionService.purchaseIncompleteNotification, object : nil, userInfo : ["message" : L10n.learnAboutProSubscriptionExpired])
        } else {
            NotificationCenter.default.post (name : SubscriptionService.purchaseSuccessfulNotification, object : nil)
        }
    }

    func paymentQueue (_ queue : SKPaymentQueue, restoreCompletedTransactionsFailedWithError error : Error) {
        NotificationCenter.default.post (name : SubscriptionService.purchaseIncompleteNotification, object : nil, userInfo : ["message" : error.localizedDescription])
    }
}

extension Moya.Response {

    func mapConferenceMode () throws - > Bool {
        let responseObject = try self.map (to : REPerformanceResponse.self)
        guard responseObject.success else {
            throw REPerformanceError.requestFailed (responseObject.message)
        }
        let jsonData = responseObject.data
        guard let isConferenceModeOn = jsonData ["conference_mode_on"]?.boolValue else {
            throw MoyaError.jsonMapping (self)
        }
        return isConferenceModeOn
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/REPAnalytics.swift" startline="1" endline="142">
import Foundation
import Firebase
import FirebaseAnalytics
struct ScreenName {
    struct HomePage {
        static let Test = "Home Page - Tests"
        static let ReportCard = "Home Page - Report Card"
        static let Rewards = "Home Page - Rewards"
        static let OurValue = "Home Page - Our Value"
        static let Profile = "Home Page - Profile"
    }
    struct TestsMileRun {
        static let Description = "Tests - Mile Run Description"
        static let Setup = "Tests - Mile Run Setup"
        static let Input = "Tests - Mile Run Input"
        static let Score = "Tests - Mile Run Score"
    }
    struct TestsFortyYardDash {
        static let Description = "Tests - 40 Yard Dash Description"
        static let Setup = "Tests - 40 Yard Dash Setup"
        static let Input = "Tests - 40 Yard Dash Input"
        static let Score = "Tests - 40 Yard Dash Score"
    }
    struct TestsBenchPress {
        static let Description = "Tests - Bench Press Description"
        static let Setup = "Tests - Bench Press Setup"
        static let Input = "Tests - Bench Press Input"
        static let Score = "Tests - Bench Press Score"
    }
    struct TestsDeadlift {
        static let Description = "Tests - Deadlift Description"
        static let Setup = "Tests - Deadlift Setup"
        static let Input = "Tests - Deadlift Input"
        static let Score = "Tests - Deadlift Score"
    }
    struct TestsSquat {
        static let Description = "Tests - Squat Description"
        static let Setup = "Tests - Squat Setup"
        static let Input = "Tests - Squat Input"
        static let Score = "Tests - Squat Score"
    }
    struct TestsMilitaryPress {
        static let Description = "Tests - Military Press Description"
        static let Setup = "Tests - Military Press Setup"
        static let Input = "Tests - Military Press Input"
        static let Score = "Tests - Military Press Score"
    }
    static let MyScores = "My Scores"
    struct LeaderBoard {
        static let Global = "Leaderboard - Global"
        static let MileRun = "Leaderboard - Mile Run"
        static let FortyYardDash = "Leaderboard - 40 Yard Dash"
        static let BenchPress = "Leaderboard - Bench Press"
        static let Deadlift = "Leaderboard - Deadlift"
        static let Squat = "Leaderboard - Squat"
        static let MilitaryPress = "Leaderboard - Military Press"
    }
    enum Challenges {

        static func Leaderboard (_ name : String) - > String {
            return "Challenge - \(name) - Leaderboard"
        }

        static func Gyms (_ name : String) - > String {
            return "Challenge - \(name) - Gyms"
        }

        static func Details (_ name : String) - > String {
            return "Challenge - \(name) - Details"
        }
    }
    static let UpgradeToPro = "Upgrade To Pro"
    static let ViewRewards = "View Reward"
    static let RedeemReward = "Redeem Reward"
    static let OurValueEndorsements = "Our Value - Endorsements"
    struct Profile {
        static let Default = "Profile"
        static let BasicInfo = "Profile - Basic Info"
        static let Nutrition = "Profile - Nutrition"
        static let Lifestyle = "Profile - Lifestyle"
        static let Exercise = "Profile - Exercise"
    }
    static let Achievements = "Achievements"
    static let Login = "Login"
    static let CreateAccount = "Create Account"
}
struct EventAnalytics {
    enum Challenges {

        static func Join (_ challenge : Challenge) - > String {
            return challenge.hasJoined? "Join" : "Leave"
        }

        static func ChallengeType (_ challenge : Challenge) - > String {
            switch challenge.type {
                case.gym :
                    return "Gym Challenge"
                case.personal :
                    return "Personal Challenge"
            }
        }
    }
}

class REPAnalytics {

    class func trackScreenWithName (screenName : String, className : String) {
        Analytics.setScreenName (screenName, screenClass : className)
    }

    class func trackEvent (name : String, parameters : [String : Any]? = nil) {
        Analytics.logEvent (name, parameters : parameters)
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/ReportCardCoordinator.swift" startline="1" endline="521">
import UIKit
import Social
import Alamofire
import AlamofireImage
import NVActivityIndicatorView
import FBSDKCoreKit

class ReportCardCoordinator {
    let reportCardDataProvider = ReportCardDataProvider ()
    let challengesCoordinator = ChallengesCoordinator ()
    let chatCoordinator = ChatCoordinator ()
    let athlete : Athlete?
    var reportCardViewController : ReportCardViewController
    var leaderboardCoordinator : LeaderboardCoordinator?
    var updateReportCardRequired : Bool = true
    var lastUpdate : Date = Date ()
    static var canShareReport : Bool {
        get {
            if SLComposeViewController.isAvailable (forServiceType : SLServiceTypeFacebook) {
                return true
            }
            return false
        }
    }
    init (athlete : Athlete? = nil) {
        self.athlete = athlete
        self.reportCardViewController = StoryboardScene.ReportCard.reportCardVC.instantiate ()
        self.setupReportCardViewController ()
    }

    func setupReportCardViewController () {
        self.reportCardViewController.tabBarController?.navigationItem.title = L10n.reportCardTitle
        self.reportCardViewController.tabBarItem = UITabBarItem (title : L10n.reportCardTabBarItemTitle, image : #imageLiteral (resourceName : "TabBar_ReportCard"), tag : 0)
        if let athlete = athlete {
            self.setupReportCardForAthleteViewController (athlete)
        } else {
            self.setupReportCardForUserViewController ()
        }
    }

    func setupReportCardForUserViewController () {
        self.reportCardViewController.chat = {
            self.chatCoordinator.start (presenting : self.reportCardViewController)
        }
        self.reportCardViewController.shareReport = {
            [weak self] (reportCard) in self?.shareReportCardOnFacebook (reportCardImage : reportCard)
        }
        self.reportCardViewController.reportCardWillAppear = {
            self.reportCardViewController.age = UserDefaults.standard.userAge
            self.reportCardViewController.weight = UserDefaults.standard.userWeight
            self.reportCardViewController.isPersonalReportCard = true
            self.reportCardViewController.isMale = (UserDefaults.standard.userGender == Constants.UserData.Male)
            self.reportCardViewController.isPublic = (UserDefaults.standard.isProfilePrivate == false)
            self.reportCardViewController.lifestyleCategoryName = UserDefaults.standard.lifestyleType
            if let firstName = UserDefaults.standard.userFirstName, let lastName = UserDefaults.standard.userLastName {
                self.reportCardViewController.name = "\(firstName) \(lastName)"
            } else {
                self.reportCardViewController.name = ""
            }
            let elapsedTimeSinceLastRetrieval = Date ().timeIntervalSince (self.lastUpdate)
            if self.updateReportCardRequired|| (elapsedTimeSinceLastRetrieval > Constants.ReportCard.RefreshTimeInterval) {
                self.retrieveReportCard ()
                self.updateReportCardRequired = false
                self.lastUpdate = Date ()
                self.setUserProfileImage (userFacebookID : UserDefaults.standard.userFacebookID, lifestyle : UserDefaults.standard.lifestyleType)
            }
            if let reportCardNeverSeen = UserDefaults.standard.reportCardNeverSeen {
                if reportCardNeverSeen {
                    UIAlertController.showAlert (nil, message : L10n.reportCardFirstViewAlert, inViewController : self.reportCardViewController)
                    UserDefaults.standard.reportCardNeverSeen = false
                }
            }
            self.refreshChatUnreadMessagesStatus ()
        }
        self.reportCardViewController.changeProfileVisibility = {
            (isPublic) in let currentProfileVisibilityIsPrivate = UserDefaults.standard.isProfilePrivate
            self.reportCardDataProvider.updateProfileVisibility (isPrivate : ! isPublic) {
                (errorMessage) in if let _ = errorMessage {
                    UserDefaults.standard.isProfilePrivate = currentProfileVisibilityIsPrivate
                } else {
                    UserDefaults.standard.isProfilePrivate = (isPublic == false)
                }
                self.reportCardViewController.isPublic = (UserDefaults.standard.isProfilePrivate == false)
            }
        }
        self.reportCardViewController.updateProfileImage = {
            (profileImage) in _ = UIImage.saveProfileImage (image : profileImage)
            self.reportCardDataProvider.updateProfileImage () {
                (errorMessage) in if let _ = errorMessage {
                    print (errorMessage?.description? ? "error setting profile image")
                }
            }
        }
        self.reportCardViewController.onMyLatestScoresPressed = {
            self.showScores ()
        }
        self.reportCardViewController.onMyBestScoresPressed = {
            self.showBestScores ()
        }
        self.reportCardViewController.onChallengesPressed = {
            self.moveToChallenges ()
        }
    }

    func setupReportCardForAthleteViewController (_ athlete : Athlete) {
        self.reportCardViewController.chat = {
            self.chatCoordinator.start (presenting : self.reportCardViewController, athlete : athlete)
        }
        self.reportCardViewController.reportCardWillAppear = {
            self.reportCardViewController.name = athlete.name
            self.reportCardViewController.age = athlete.age
            self.reportCardViewController.weight = athlete.weight
            self.reportCardViewController.isMale = (athlete.gender? ? "male").lowercased ()==
            "male"
            self.reportCardViewController.lifestyleCategoryName = athlete.lifestyleCategory
            self.reportCardViewController.isPersonalReportCard = false
            self.retrieveAthleteReportCard (identifier : "\(athlete.userIdentifier)")
            self.setAthleteProfileImage (userFacebookID : athlete.facebookIdentifier, lifestyle : athlete.lifestyleCategory, athleteID : athlete.userIdentifier)
        }
        self.reportCardDataProvider.retrieveAthleteScores (identifier : "\(athlete.userIdentifier)") {
            (allExercisesResult : ReportCardExerciseScores?, errorMessage : String?) in DispatchQueue.main.async {
                self.reportCardViewController.exerciseScores = allExercisesResult
            }
        }
    }

    func recreateReportCard () {
        self.reportCardViewController = StoryboardScene.ReportCard.reportCardVC.instantiate ()
        self.setupReportCardViewController ()
    }

    func retrieveReportCard () {
        self.reportCardDataProvider.retrievePersonalReportCard () {
            (reportCard, _) in self.reportCardViewController.reportCard = reportCard
        }
    }

    func retrieveAthleteReportCard (identifier : String) {
        self.reportCardDataProvider.retrieveAthleteReportCard (identifier : identifier) {
            (reportCard, _) in self.reportCardViewController.reportCard = reportCard
        }
    }

    func setUserProfileImage (userFacebookID : String?, lifestyle : String?) {
        if let profileImage = UIImage.getSavedProfileImage () {
            self.reportCardViewController.profileImage = profileImage
        } else {
            self.setProfileImageFromFacebook (userFacebookID : userFacebookID, lifestyle : lifestyle)
        }
    }

    func setAthleteProfileImage (userFacebookID : String?, lifestyle : String?, athleteID : Int) {
        self.reportCardDataProvider.getProfileImage (athleteID : athleteID) {
            (profileURL) in if let profileURL = profileURL {
                UIImage.userProfileImage (url : profileURL, completion : {
                    (image) in self.reportCardViewController.profileImage = image
                })
            } else {
                self.setProfileImageFromFacebook (userFacebookID : userFacebookID, lifestyle : lifestyle)
            }
        }
    }

    func setProfileImageFromFacebook (userFacebookID : String?, lifestyle : String?) {
        if let userFacebookID = userFacebookID, userFacebookID.isEmpty == false {
            let imageSize = UIScreen.main.bounds.width
            if let imageURL = FacebookImage.imageURLWithFacebookID (userFacebookID, size : CGSize (width : imageSize, height : imageSize)) {
                UIImage.userProfileImage (url : imageURL, completion : {
                    (image) in if let profileImage = image {
                        self.reportCardViewController.profileImage = profileImage
                    } else {
                        self.setDefaultImage (lifestyleType : lifestyle)
                    }
                })
            } else {
                self.setDefaultImage (lifestyleType : lifestyle)
            }
        } else {
            self.setDefaultImage (lifestyleType : lifestyle)
        }
    }

    func setDefaultImage (lifestyleType : String?) {
        let profileImage : UIImage
        switch (lifestyleType? ? "").lowercased () {
            case "fit" :
                profileImage = Asset.Assets.Profile.fitProfile.image
            case "action" :
                profileImage = Asset.Assets.Profile.actionProfile.image
            case "athlete" :
                profileImage = Asset.Assets.Profile.athleteProfile.image
            case "elite" :
                profileImage = Asset.Assets.Profile.eliteProfile.image
            default :
                profileImage = Asset.Assets.Profile.fitProfile.image
        }
        self.reportCardViewController.profileImage = profileImage
    }

    func tabBarViewController () - > UIViewController {
        return self.reportCardViewController
    }

    func refreshChatUnreadMessagesStatus (completion : (() - > ())? = nil) {
        ChatCoordinator.getUnreadMessageCount () {
            (getUnreadMessageCountResult) in if case.success (let count) = getUnreadMessageCountResult {
                let hasUnreadMessages = count>
                0
                self.reportCardViewController.hasUnreadMessages = hasUnreadMessages
                self.reportCardViewController.tabBarItem.badgeValue = hasUnreadMessages? "" : nil
                UIApplication.shared.applicationIconBadgeNumber = count
            }
            completion? ()
        }
    }

    func showScores () {
        let myScoresViewController = StoryboardScene.ReportCard.myScoresViewController.instantiate ()
        myScoresViewController.title = L10n.myLatestScoresTitle
        myScoresViewController.navigationItem.leftBarButtonItem = UIBarButtonItem (title : L10n.doneBarItemTitle, style : .plain, target : self, action : #selector (self.closeButtonTapped (sender :)))
        myScoresViewController.showVideoStatusLegend = (athlete == nil)
        let navigationController = UINavigationController ()
        navigationController.viewControllers = [myScoresViewController]
        navigationController.view.backgroundColor = UIColor.clear
        self.reportCardDataProvider.retrieveScores () {
            (allExercisesResult : ReportCardExerciseScores?, errorMessage : String?) in DispatchQueue.main.async {
                let scores : MyScores?
                if let allExercisesResult = allExercisesResult {
                    scores = MyScores (isPersonal : true, myScoresAllExerciseResult : allExercisesResult)
                } else {
                    scores = nil
                }
                myScoresViewController.viewData = scores
                myScoresViewController.scoresTableView?.reloadData ()
            }
        }
        self.reportCardViewController.present (navigationController, animated : true, completion : nil)
    }

    func showBestScores () {
        guard let userID = UserDefaults.standard.userID else {
            return
        }
        let myBestScoresViewController = StoryboardScene.ReportCard.myBestScoresViewControllerStoryboardIdentifier.instantiate ()
        myBestScoresViewController.title = L10n.myBestScoresTitle
        myBestScoresViewController.navigationItem.leftBarButtonItem = BlockBarButtonItem (title : L10n.doneBarItemTitle, style : .plain) {
            self.reportCardViewController.dismiss (animated : true)
        }
        let navigationController = UINavigationController ()
        navigationController.viewControllers = [myBestScoresViewController]
        navigationController.view.backgroundColor = UIColor.clear
        self.reportCardViewController.present (navigationController, animated : true, completion : nil)
        self.reportCardDataProvider.retrieveAthleteScores (identifier : "\(userID)") {
            (allExercisesResult : ReportCardExerciseScores?, errorMessage : String?) in DispatchQueue.main.async {
                myBestScoresViewController.exerciseScores = allExercisesResult
            }
        }
    }

    func moveToChallenges () {
        let vc = self.challengesCoordinator.rootViewController ()
        vc.navigationItem.leftBarButtonItem = UIBarButtonItem (image : Asset.Assets.xIcon.image, style : .plain, target : self, action : #selector (self.closeButtonTapped (sender :)))
        let navigationController = UINavigationController (rootViewController : vc)
        self.reportCardViewController.present (navigationController, animated : true, completion : nil)
    }

    private func shareReportCardOnFacebook (reportCardImage : Image) {
        let shareReportCardActivityViewController = UIActivityViewController (activityItems : [reportCardImage], applicationActivities : nil)
        self.reportCardViewController.present (shareReportCardActivityViewController, animated : true, completion : nil)
    }

    @IBAction func closeButtonTapped (sender : Any) {
        self.reportCardViewController.dismiss (animated : true, completion : nil)
    }
}
struct MyScores : MyScoresProviding {
    var isPersonal : Bool
    let myScoresAllExerciseResult : ReportCardExerciseScores
    private let weightScores : [ReportCardExerciseWeightScores]
    init (isPersonal : Bool, myScoresAllExerciseResult : ReportCardExerciseScores) {
        self.isPersonal = isPersonal
        self.myScoresAllExerciseResult = myScoresAllExerciseResult
        self.weightScores = [myScoresAllExerciseResult.benchPress, myScoresAllExerciseResult.deadlift, myScoresAllExerciseResult.squat, myScoresAllExerciseResult.militaryPress]
    }

    func numberOfSections () - > Int {
        return 6
    }

    func numberOfRows (for section : Int) - > Int {
        switch section {
            case 0, 1, 2, 3 :
                return 4
            case 4 :
                return 3
            case 5 :
                return 2
            default :
                return 0
        }
    }

    func exercise (for section : Int) - > ExerciseInfo {
        switch section {
            case 0 :
                return ExerciseInfo (image : Asset.ReportCard.scoreHeaderBenchPress.image, title : "Bench Press", isWeightLifting : true)
            case 1 :
                return ExerciseInfo (image : Asset.ReportCard.scoreHeaderDeadlift.image, title : "Deadlift", isWeightLifting : true)
            case 2 :
                return ExerciseInfo (image : Asset.ReportCard.scoreHeaderSquat.image, title : "Squat", isWeightLifting : true)
            case 3 :
                return ExerciseInfo (image : Asset.ReportCard.scoreHeaderMilitaryPress.image, title : "Military Press", isWeightLifting : true)
            case 4 :
                return ExerciseInfo (image : Asset.ReportCard.scoreHeaderMileRun.image, title : "Mile Run", isWeightLifting : false)
            case 5 :
                return ExerciseInfo (image : Asset.ReportCard.scoreHeaderFortyYardDash.image, title : "40 Yard Dash", isWeightLifting : false)
            default :
                fatalError ()
        }
    }

    func score (for indexPath : IndexPath) - > ExerciseScorePersonalCellViewModel {
        let dateFormatter = DateFormatter.displayScoreResultsDateFormatter ()
        switch indexPath.section {
            case 0, 1, 2, 3 :
                switch indexPath.row {
                    case 0 :
                        if let staminaDate = self.weightScores [indexPath.section].stamina.date, let staminaScore = self.weightScores [indexPath.section].stamina.score {
                            return ExerciseScorePersonalCellViewModel (exerciseSubCategoryName : "Stamina", dateDisplay : dateFormatter.string (from : staminaDate), scoreDisplay : "\(staminaScore)", videoStatusImage : self.weightScores [indexPath.section]
                              .stamina.video.statusImage)
                        } else {
                            return ExerciseScorePersonalCellViewModel (exerciseSubCategoryName : "Stamina", dateDisplay : nil, scoreDisplay : nil, videoStatusImage : nil)
                        }
                    case 1 :
                        if let enduranceDate = self.weightScores [indexPath.section].endurance.date, let enduranceScore = self.weightScores [indexPath.section].endurance.score {
                            return ExerciseScorePersonalCellViewModel (exerciseSubCategoryName : "Endurance", dateDisplay : dateFormatter.string (from : enduranceDate), scoreDisplay : "\(enduranceScore)", videoStatusImage : self.weightScores [indexPath.
                              section].endurance.video.statusImage)
                        } else {
                            return ExerciseScorePersonalCellViewModel (exerciseSubCategoryName : "Endurance", dateDisplay : nil, scoreDisplay : nil, videoStatusImage : nil)
                        }
                    case 2 :
                        if let strengthDate = self.weightScores [indexPath.section].strength.date, let strengthScore = self.weightScores [indexPath.section].strength.score {
                            return ExerciseScorePersonalCellViewModel (exerciseSubCategoryName : "Strength", dateDisplay : dateFormatter.string (from : strengthDate), scoreDisplay : "\(strengthScore)", videoStatusImage : self.weightScores [indexPath.
                              section].strength.video.statusImage)
                        } else {
                            return ExerciseScorePersonalCellViewModel (exerciseSubCategoryName : "Strength", dateDisplay : nil, scoreDisplay : nil, videoStatusImage : nil)
                        }
                    case 3 :
                        if let powerDate = self.weightScores [indexPath.section].power.date, let powerScore = self.weightScores [indexPath.section].power.score {
                            return ExerciseScorePersonalCellViewModel (exerciseSubCategoryName : "Power", dateDisplay : dateFormatter.string (from : powerDate), scoreDisplay : "\(powerScore)", videoStatusImage : self.weightScores [indexPath.section].power
                              .video.statusImage)
                        } else {
                            return ExerciseScorePersonalCellViewModel (exerciseSubCategoryName : "Power", dateDisplay : nil, scoreDisplay : nil, videoStatusImage : nil)
                        }
                    default :
                        fatalError ()
                }
            case 4 :
                switch indexPath.row {
                    case 0 :
                        if let trackDate = self.myScoresAllExerciseResult.mileRun.trackRunning.date, let score = self.myScoresAllExerciseResult.mileRun.trackRunning.score, let trackScore = FormatMillisecondsForDisplay.convertScoreForDisplayMileRun (score :
                          "\(score)") {
                            return ExerciseScorePersonalCellViewModel (exerciseSubCategoryName : "Track Running", dateDisplay : dateFormatter.string (from : trackDate), scoreDisplay : "\(trackScore)", videoStatusImage : self.myScoresAllExerciseResult.
                              mileRun.trackRunning.video.statusImage)
                        } else {
                            return ExerciseScorePersonalCellViewModel (exerciseSubCategoryName : "Track Running", dateDisplay : nil, scoreDisplay : nil, videoStatusImage : nil)
                        }
                    case 1 :
                        if let outdoorDate = self.myScoresAllExerciseResult.mileRun.outdoor.date, let score = self.myScoresAllExerciseResult.mileRun.outdoor.score, let outdoorScore = FormatMillisecondsForDisplay.convertScoreForDisplayMileRun (score :
                          "\(score)") {
                            return ExerciseScorePersonalCellViewModel (exerciseSubCategoryName : "Outdoor", dateDisplay : dateFormatter.string (from : outdoorDate), scoreDisplay : "\(outdoorScore)", videoStatusImage : self.myScoresAllExerciseResult.
                              mileRun.outdoor.video.statusImage)
                        } else {
                            return ExerciseScorePersonalCellViewModel (exerciseSubCategoryName : "Outdoor", dateDisplay : nil, scoreDisplay : nil, videoStatusImage : nil)
                        }
                    case 2 :
                        if let treadmillDate = self.myScoresAllExerciseResult.mileRun.treadmill.date, let score = self.myScoresAllExerciseResult.mileRun.treadmill.score, let treadmillScore = FormatMillisecondsForDisplay.convertScoreForDisplayMileRun (
                          score : "\(score)") {
                            return ExerciseScorePersonalCellViewModel (exerciseSubCategoryName : "Treadmill", dateDisplay : dateFormatter.string (from : treadmillDate), scoreDisplay : "\(treadmillScore)", videoStatusImage : self.myScoresAllExerciseResult.
                              mileRun.treadmill.video.statusImage)
                        } else {
                            return ExerciseScorePersonalCellViewModel (exerciseSubCategoryName : "Treadmill", dateDisplay : nil, scoreDisplay : nil, videoStatusImage : nil)
                        }
                    default :
                        fatalError ()
                }
            case 5 :
                switch indexPath.row {
                    case 0 :
                        if let selfTimedDate = self.myScoresAllExerciseResult.fortyYardDash.selfTimed.date, let score = self.myScoresAllExerciseResult.fortyYardDash.selfTimed.score, let selfTimedScore = FormatMillisecondsForDisplay.
                          convertScoreForDisplayFortyYardDash (score : "\(score)") {
                            return ExerciseScorePersonalCellViewModel (exerciseSubCategoryName : "Self Timed", dateDisplay : dateFormatter.string (from : selfTimedDate), scoreDisplay : "\(selfTimedScore)", videoStatusImage : self.myScoresAllExerciseResult
                              .fortyYardDash.selfTimed.video.statusImage)
                        } else {
                            return ExerciseScorePersonalCellViewModel (exerciseSubCategoryName : "Self Timed", dateDisplay : nil, scoreDisplay : nil, videoStatusImage : nil)
                        }
                    case 1 :
                        if let cuedTimeDate = self.myScoresAllExerciseResult.fortyYardDash.cuedTime.date, let score = self.myScoresAllExerciseResult.fortyYardDash.cuedTime.score, let cuedTimeScore = FormatMillisecondsForDisplay.
                          convertScoreForDisplayFortyYardDash (score : "\(score)") {
                            return ExerciseScorePersonalCellViewModel (exerciseSubCategoryName : "Cued Time", dateDisplay : dateFormatter.string (from : cuedTimeDate), scoreDisplay : "\(cuedTimeScore)", videoStatusImage : self.myScoresAllExerciseResult.
                              fortyYardDash.cuedTime.video.statusImage)
                        } else {
                            return ExerciseScorePersonalCellViewModel (exerciseSubCategoryName : "Cued Time", dateDisplay : nil, scoreDisplay : nil, videoStatusImage : nil)
                        }
                    default :
                        fatalError ()
                }
            default :
                fatalError ()
        }
    }
}

extension VideoStatus {
    var statusImage : UIImage {
        get {
            switch self {
                case.Reviewing :
                    return Asset.Assets.VideoStatus.reviewingIcon.image
                case.Approved :
                    return Asset.Assets.VideoStatus.approveIcon.image
                case.Declined :
                    return Asset.Assets.VideoStatus.declinedIcon.image
                case.NoVideo :
                    return Asset.Assets.VideoStatus.novideoIcon.image
            }
        }
    }
}
struct MileRunResult {
    let trackDate : Date?
    let trackScore : String?
    let trackVideoStatus : VideoStatus?
    let outdoorDate : Date?
    let outdoorScore : String?
    let outdoorVideoStatus : VideoStatus?
    let treadmillDate : Date?
    let treadmillScore : String?
    let treadmillVideoStatus : VideoStatus?
}
struct FortyYardDashResult {
    let selfTimedDate : Date?
    let selfTimedScore : String?
    let selfTimedVideoStatus : VideoStatus?
    let cuedTimeDate : Date?
    let cuedTimeScore : String?
    let cuedTimeVideoStatus : VideoStatus?
}
struct WeightLiftingResult {
    let staminaDate : Date?
    let staminaScore : String?
    let staminaVideoStatus : VideoStatus?
    let enduranceDate : Date?
    let enduranceScore : String?
    let enduranceVideoStatus : VideoStatus?
    let strengthDate : Date?
    let strengthScore : String?
    let strengthVideoStatus : VideoStatus?
    let powerDate : Date?
    let powerScore : String?
    let powerVideoStatus : VideoStatus?
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/REPerformanceAPIs.swift" startline="1" endline="580">
import Moya
#if USE_PRODUCTION
    fileprivate let BaseURL = URL (string : "https://reperformance-live.appspot.com/api/v1")!
#else
    fileprivate let BaseURL = URL (string : "https://reperformance-beta.appspot.com/api/v1")!
#endif
enum ExerciseCategory : String, Decodable {
    case MileRun = "mile_run"
    case FortyYardDash = "forty_yard_dash"
    case BenchPress = "bench_press"
    case DeadLift = "deadlift"
    case Squat = "squat"
    case MilitaryPress = "military_press"
    var readable : String {
        get {
            switch self {
                case.MileRun :
                    return L10n.mileRun
                case.FortyYardDash :
                    return L10n.fortyYardDash
                case.BenchPress :
                    return L10n.benchPress
                case.DeadLift :
                    return L10n.deadlift
                case.Squat :
                    return L10n.squat
                case.MilitaryPress :
                    return L10n.militaryPress
            }
        }
    }
}
enum ExerciseTestFormat : String {
    case TrackRunning = "track_running"
    case Outdoor = "outdoor"
    case Treadmill = "treadmill"
    case SelfTimed = "self_timed"
    case CuedTime = "cued_time"
    case Stamina = "stamina"
    case Endurance = "endurance"
    case Strength = "strength"
    case Power = "power"
}
enum LeaderboardGroup : String {
    case Everyone = "everyone"
    case Friends = "friends"
    case Nearby = "nearby"
    case Gym = "gym"
}
enum OnboardingService {
    case login (email : String, password : String)
    case createAccount (first : String, last : String, email : String, password : String)
    case signupWithFacebook (facebookID : String, facebookToken : String)
    case forgotPassword (email : String)
}
enum SubmitService {
    case submitProfile (token : String, lifestyle_category : LifestyleType, gender : String, weight : Int, age : Int, country_code : String, region_code : String)
    case submitExercise (token : String, exercise : String, testFormat : String, score : Int, vimeoID : String?)
    case purchaseReward (token : String, rewardID : String, proUser : Bool)
    case redeemReward (token : String, rewardID : String)
    case submitGym (token : String, placeID : String, name : String, region : String)
    case submitCacheVimeo (token : String, vimeoID : String, submissionID : Int)
    case submitChallengeJoin (token : String, challenge : Challenge)
    case submitChallengeLeave (token : String, challenge : Challenge)
}
enum RetrieveService {
    case conferenceMode ()
    case getPersonalReportCard (token : String)
    case getAthleteReportCard (token : String, athlete : String)
    case getScores (token : String)
    case getAthleteScores (token : String, athlete : String)
    case getLeaderboard (token : String, group : LeaderboardGroup, filter_age : Bool, exercise : ExerciseCategory, test_format : ExerciseTestFormat)
    case getChallengeLeaderboard (challenge : Challenge, gym : Gym?)
    case getDefaultLeaderboard (token : String, group : LeaderboardGroup, filter_age : Bool)
    case getGymLeaderboard (token : String, exercise : ExerciseCategory, test_format : ExerciseTestFormat)
    case getCredits (token : String)
    case getRewards (token : String)
    case getChallenges (token : String)
    case getWeights (token : String, lifestyle : String, gender : String, weight : Int, exercise : ExerciseCategory)
}
enum AchievementsService {
    case getAchievements (token : String)
}
enum ReportCardService {
    case setProfilePrivacy (token : String, isPublic : Bool)
    case setProfileImage (token : String, profileImage : UIImage)
    case profileImage (token : String, athleteId : String)
}
enum NotificationService {
    case registerDevice (token : String, deviceToken : String)
    case unregisterDevice (token : String, deviceToken : String)
    case registerFirebaseToken (token : String, firebaseToken : String)
}
enum ChatService {
    case generateAuthToken (token : String)
}

extension OnboardingService : TargetType {
    var baseURL : URL {
        return BaseURL
    }
    var path : String {
        switch self {
            case.login,.signupWithFacebook :
                return "/login/"
            case.createAccount :
                return "/create-account/"
            case.forgotPassword :
                return "/reset-password/"
        }
    }
    var method : Moya.Method {
        switch self {
            case.login,.createAccount,.signupWithFacebook,.forgotPassword :
                return .get
        }
    }
    var sampleData : Data {
        switch self {
            case.login :
                return "{\"email\": \"edward.boone@pushinteractions.com\", \"password\": \"password\"}".data (using : String.Encoding.utf8)!
            case.createAccount :
                return "{\"first_name\": \"edward\", \"last_name\": \"boone\", \"email\": \"edward.boone@pushinteractions.com\", \"password\": \"password\"}".data (using : String.Encoding.utf8)!
            case.forgotPassword :
                return "{\"email\": \"edward.boone@pushinteractions.com\"}".data (using : String.Encoding.utf8)!
            default :
                return Data ()
        }
    }
    var task : Task {
        switch self {
            case.login (let email, let password) :
                return .requestParameters (parameters : ["email" : email, "password" : password], encoding : URLEncoding.default)
            case.createAccount (let first, let last, let email, let password) :
                return .requestParameters (parameters : ["first_name" : first, "last_name" : last, "email" : email, "password" : password], encoding : URLEncoding.default)
            case.signupWithFacebook (let facebookID, let facebookToken) :
                return .requestParameters (parameters : ["facebook_id" : facebookID, "facebook_token" : facebookToken], encoding : URLEncoding.default)
            case.forgotPassword (let email) :
                return .requestParameters (parameters : ["email" : email], encoding : URLEncoding.default)
        }
    }
    var headers : [String : String]? {
        switch self {
            case.login,.createAccount,.signupWithFacebook,.forgotPassword :
                return nil
        }
    }
}

extension SubmitService : TargetType {
    var baseURL : URL {
        return BaseURL
    }
    var path : String {
        switch self {
            case.submitProfile :
                return "/submit-profile/"
            case.submitExercise :
                return "/submit-exercise/"
            case.purchaseReward :
                return "/purchase-reward/"
            case.redeemReward :
                return "/redeem-reward/"
            case.submitGym :
                return "/submit-gym/"
            case.submitCacheVimeo :
                return "/submit-video/"
            case.submitChallengeJoin (_, let challenge) :
                return "/challenges/\(challenge.uniqueIdentifier)/join/"
            case.submitChallengeLeave (_, let challenge) :
                return "/challenges/\(challenge.uniqueIdentifier)/leave/"
        }
    }
    var method : Moya.Method {
        switch self {
            case.submitProfile,.submitExercise,.purchaseReward,.redeemReward,.submitGym,.submitCacheVimeo,.submitChallengeJoin,.submitChallengeLeave :
                return .post
        }
    }
    var sampleData : Data {
        switch self {
            case.submitProfile :
                return "{\"token\": \"faketoken\", \"lifestyle_category\": \"lifestyle_category\", \"age\": \"age\", \"country_code\": \"country_code\", \"region_code\":\"region_code\"}".data (using : String.Encoding.utf8)!
            case.submitExercise :
                return "{\"token\": \"faketoken\", \"exercise\": \"exercise\", \"test_format\": \"test_format\", \"score\": \"score\"}".data (using : String.Encoding.utf8)!
            case.purchaseReward :
                return "{\"token\": \"faketoken\", \"reward_id\": \"1\", \"proUser\":\"true\"}".data (using : String.Encoding.utf8)!
            case.redeemReward :
                return "{\"token\": \"faketoken\", \"reward_id\": \"1\"}".data (using : String.Encoding.utf8)!
            case.submitGym :
                return "{\"token\": \"faketoken\", \"place_id\": \"placeid\", \"name\": \"testGym\", \"region\": \"testRegion\",}".data (using : String.Encoding.utf8)!
            case.submitCacheVimeo :
                return "{\"token\": \"faketoken\", \"vimeo_id\": \"0\", \"submission_id\": \"0\"}".data (using : String.Encoding.utf8)!
            case.submitChallengeJoin,.submitChallengeLeave :
                return "{\"token\": \"faketoken\"}".data (using : String.Encoding.utf8)!
        }
    }
    var task : Task {
        switch self {
            case.submitProfile (let token, let lifestyleCategory, let gender, let weight, let age, let countryCode, let regionCode) :
                var parameters = [String : Any] ()
                parameters ["token"] = token
                parameters ["lifestyle_category"] = lifestyleCategory.rawValue.lowercased ()
                parameters ["gender"] = gender.lowercased ()
                parameters ["weight"] = weight
                parameters ["age"] = age
                parameters ["country_code"] = countryCode
                parameters ["region_code"] = regionCode
                return .requestParameters (parameters : parameters, encoding : JSONEncoding.default)
            case.submitExercise (let token, let exercise, let testFormat, let score, let vimeoID) :
                if let vimeoID = vimeoID {
                    return .requestParameters (parameters : ["token" : token, "exercise" : exercise, "test_format" : testFormat, "score" : score, "vimeo_id" : vimeoID], encoding : JSONEncoding.default)
                } else {
                    return .requestParameters (parameters : ["token" : token, "exercise" : exercise, "test_format" : testFormat, "score" : score], encoding : JSONEncoding.default)
                }
            case.purchaseReward (let token, let rewardID, let proUser) :
                return .requestParameters (parameters : ["token" : token, "reward_id" : rewardID, "pro_user" : proUser], encoding : JSONEncoding.default)
            case.redeemReward (let token, let rewardID) :
                return .requestParameters (parameters : ["token" : token, "reward_id" : rewardID], encoding : JSONEncoding.default)
            case.submitGym (let token, let placeID, let name, let region) :
                return .requestParameters (parameters : ["token" : token, "place_id" : placeID, "name" : name, "region" : region], encoding : JSONEncoding.default)
            case.submitCacheVimeo (let token, let vimeoID, let submissionID) :
                return .requestParameters (parameters : ["token" : token, "vimeo_id" : vimeoID, "submission_id" : submissionID], encoding : JSONEncoding.default)
            case.submitChallengeJoin (let token, _),.submitChallengeLeave (let token, _) :
                return .requestParameters (parameters : ["token" : token], encoding : JSONEncoding.default)
        }
    }
    var headers : [String : String]? {
        switch self {
            case.submitProfile,.submitExercise,.purchaseReward,.redeemReward,.submitGym,.submitCacheVimeo,.submitChallengeJoin,.submitChallengeLeave :
                return nil
        }
    }
}

extension RetrieveService : TargetType {
    var baseURL : URL {
        return BaseURL
    }
    var path : String {
        switch self {
            case.conferenceMode :
                return "/get-conference-mode/"
            case.getPersonalReportCard :
                return "/report-card/"
            case.getAthleteReportCard (_, let identifier) :
                return "/report-card/\(identifier)/"
            case.getScores :
                return "/scores/"
            case.getAthleteScores (_, let identifier) :
                return "/scores/\(identifier)/"
            case.getLeaderboard,.getDefaultLeaderboard,.getGymLeaderboard :
                return "/leader-board/"
            case.getCredits :
                return "/get-credits/"
            case.getRewards :
                return "/get-rewards/"
            case.getChallenges :
                return "/challenges/"
            case.getChallengeLeaderboard (let challenge, _) :
                return "/challenges/\(challenge.uniqueIdentifier)/leaderboard/"
            case.getWeights :
                return "/exercise-weights/"
        }
    }
    var method : Moya.Method {
        switch self {
            case.conferenceMode,.getPersonalReportCard,.getAthleteReportCard,.getScores,.getAthleteScores,.getLeaderboard,.getDefaultLeaderboard,.getGymLeaderboard,.getCredits,.getRewards,.getChallenges,.getChallengeLeaderboard,.getWeights :
                return .get
        }
    }
    var sampleData : Data {
        switch self {
            case.conferenceMode :
                return "{\"message\": \"Conference mode\", \"data\": {\"conference_mode_on\" : false}, \"success\": 1}".data (using : String.Encoding.utf8)!
            case.getPersonalReportCard,.getAthleteReportCard,.getScores,.getAthleteScores,.getCredits,.getRewards,.getChallenges :
                return "{\"token\": \"faketoken\"}".data (using : String.Encoding.utf8)!
            case.getLeaderboard :
                return "{\"token\": \"faketoken\", \"group\": \"group\", \"filter_age\": \"filter_age\", \"exercise\": \"exercise\", \"test_format\": \"test_format\"}".data (using : String.Encoding.utf8)!
            case.getDefaultLeaderboard :
                return "{\"token\": \"faketoken\", \"group\": \"group\", \"filter_age\": \"filter_age\"}".data (using : String.Encoding.utf8)!
            case.getGymLeaderboard :
                return "{\"token\": \"faketoken\", \"exercise\": \"exercise\", \"test_format\": \"test_format\"}".data (using : String.Encoding.utf8)!
            case.getWeights :
                return "{\"token\": \"faketoken\", \"exercise\": \"exercise\", \"lifestyle_category\": \"test_lifestyle_category\", \"gender\": \"female\", \"weight\": \"0\"}".data (using : String.Encoding.utf8)!
            default :
                return Data ()
        }
    }
    var task : Task {
        switch self {
            case.conferenceMode :
                return .requestPlain
            case.getPersonalReportCard (let token),.getAthleteReportCard (let token, _),.getScores (let token),.getAthleteScores (let token, _),.getCredits (let token),.getRewards (let token),.getChallenges (let token) :
                return .requestParameters (parameters : ["token" : token], encoding : URLEncoding.default)
            case.getLeaderboard (let token, let group, let filter_age, let exercise, let test_format) :
                return .requestParameters (parameters : ["token" : token, "group" : group.rawValue, "filter_age" : filter_age, "exercise" : exercise.rawValue, "test_format" : test_format.rawValue], encoding : URLEncoding.default)
            case.getDefaultLeaderboard (let token, let group, let filter_age) :
                return .requestParameters (parameters : ["token" : token, "group" : group.rawValue, "filter_age" : filter_age], encoding : URLEncoding.default)
            case.getGymLeaderboard (let token, let exercise, let test_format) :
                return .requestParameters (parameters : ["token" : token, "group" : "gym", "filter_age" : false, "exercise" : exercise.rawValue, "test_format" : test_format.rawValue], encoding : URLEncoding.default)
            case.getChallengeLeaderboard (_, let gym) :
                var parameters : [String : Any] = [:]
                if let gym = gym {
                    parameters ["gym_id"] = gym.id
                }
                return .requestParameters (parameters : parameters, encoding : URLEncoding.default)
            case.getWeights (let token, let lifestyleCategory, let gender, let weight, let exercise) :
                return .requestParameters (parameters : ["token" : token, "lifestyle_category" : lifestyleCategory.lowercased (), "gender" : gender.lowercased (), "weight" : weight, "exercise" : exercise.rawValue], encoding : URLEncoding.default)
        }
    }
    var headers : [String : String]? {
        switch self {
            case.conferenceMode,.getPersonalReportCard,.getAthleteReportCard,.getScores,.getAthleteScores,.getCredits,.getRewards,.getLeaderboard,.getDefaultLeaderboard,.getGymLeaderboard,.getChallenges,.getChallengeLeaderboard,.getWeights :
                return nil
        }
    }
}

extension AchievementsService : TargetType {
    var baseURL : URL {
        return BaseURL
    }
    var path : String {
        switch self {
            case.getAchievements :
                return "/get-achievements/"
        }
    }
    var method : Moya.Method {
        switch self {
            case.getAchievements :
                return .get
        }
    }
    var sampleData : Data {
        switch self {
            case.getAchievements :
                let squatJSON = ["personal_best" : 100, "video" : 10, "submission" : 200] as [String : Any]
                let benchPressJSON = ["personal_best" : 100, "video" : 10, "submission" : 200] as [String : Any]
                let militaryPressJSON = ["personal_best" : 100, "video" : 10, "submission" : 200] as [String : Any]
                let fortyYardDashJSON = ["personal_best" : 100, "video" : 10, "submission" : 200] as [String : Any]
                let deadliftJSON = ["personal_best" : 100, "video" : 10, "submission" : 200] as [String : Any]
                let mileRunJSON = ["personal_best" : 100, "video" : 10, "submission" : 200] as [String : Any]
                let dataJson = ["squat" : squatJSON, "bench_press" : benchPressJSON, "military_press" : militaryPressJSON, "forty_yard_dash" : fortyYardDashJSON, "deadlift" : deadliftJSON, "mile_run" : mileRunJSON] as [String : Any]
                let json = ["message" : "Achievements", "data" : dataJson, "success" : 1] as [String : Any]
                let jsonText = try! JSONSerialization.data (withJSONObject : json, options : .prettyPrinted)
                return jsonText
        }
    }
    var task : Task {
        switch self {
            case.getAchievements (let token) :
                return .requestParameters (parameters : ["token" : token], encoding : URLEncoding.default)
        }
    }
    var headers : [String : String]? {
        switch self {
            case.getAchievements :
                return nil
        }
    }
}

extension ReportCardService : TargetType {
    var baseURL : URL {
        return BaseURL
    }
    var path : String {
        switch self {
            case.setProfilePrivacy :
                return "/report-card/visibility/"
            case.setProfileImage :
                return "/submit-profile-image/"
            case.profileImage (_, let athleteId) :
                return "profile-image/\(athleteId)/"
        }
    }
    var method : Moya.Method {
        switch self {
            case.setProfilePrivacy,.setProfileImage :
                return .post
            case.profileImage :
                return .get
        }
    }
    var sampleData : Data {
        return Data ()
    }
    var task : Task {
        switch self {
            case.setProfilePrivacy (let token, let isPublic) :
                return .requestParameters (parameters : ["token" : token, "public" : isPublic], encoding : URLEncoding.default)
            case.setProfileImage (let token, let profileImage) :
                let parameters = ["token" : token]
                let profileImageMultipartFormData = MultipartFormData (provider : .data (profileImage.jpegData (compressionQuality : 0.7)!), name : "image", fileName : "photo.jpg", mimeType : "image/jpeg")
                return .uploadCompositeMultipart ([profileImageMultipartFormData], urlParameters : parameters)
            case.profileImage (let token, _) :
                return .requestParameters (parameters : ["token" : token], encoding : URLEncoding.default)
        }
    }
    var headers : [String : String]? {
        switch self {
            case.setProfilePrivacy :
                return nil
            case.setProfileImage :
                return nil
            case.profileImage :
                return nil
        }
    }
}

extension NotificationService : TargetType {
    var baseURL : URL {
        return BaseURL
    }
    var path : String {
        switch self {
            case.registerDevice :
                return "/register_notifications/"
            case.unregisterDevice :
                return "/unregister_notifications/"
            case.registerFirebaseToken :
                return "/register_ios_firebase_token/"
        }
    }
    var method : Moya.Method {
        switch self {
            case.registerDevice,.unregisterDevice,.registerFirebaseToken :
                return .post
        }
    }
    var sampleData : Data {
        return Data ()
    }
    var task : Task {
        switch self {
            case.registerDevice (let token, let deviceToken),.unregisterDevice (let token, let deviceToken) :
                return .requestParameters (parameters : ["token" : token, "device_token" : deviceToken, "device_type" : 1], encoding : URLEncoding.default)
            case.registerFirebaseToken (let token, let firebaseToken) :
                var parameters = [String : Any] ()
                parameters ["token"] = token
                parameters ["firebase_ios_token"] = firebaseToken
                return .requestParameters (parameters : parameters, encoding : URLEncoding.default)
        }
    }
    var headers : [String : String]? {
        return nil
    }
}

extension ChatService : TargetType {
    var baseURL : URL {
        return BaseURL
    }
    var path : String {
        switch self {
            case.generateAuthToken :
                return "/auth-token/"
        }
    }
    var method : Moya.Method {
        switch self {
            case.generateAuthToken :
                return .get
        }
    }
    var sampleData : Data {
        return Data ()
    }
    var task : Task {
        switch self {
            case.generateAuthToken (let token) :
                return .requestParameters (parameters : ["token" : token], encoding : URLEncoding.default)
        }
    }
    var headers : [String : String]? {
        return nil
    }
}

extension Moya.Response {

    func mapSuccess () throws - > Bool {
        let responseObject = try self.map (to : REPerformanceResponse.self)
        if responseObject.success {
            return true
        } else {
            throw REPerformanceError.requestFailed (responseObject.message)
        }
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/ProfileCoordinator.swift" startline="1" endline="373">
import UIKit
import NVActivityIndicatorView
enum LifestyleQuizType : Int {
    case BasicInfo = 0
    case Nutrition = 1
    case LifeStyle = 2
    case Exercise = 3
}

class ProfileCoordinator {
    let navigationController : UINavigationController
    let profileDataProvider : ProfileDataProvider
    let profileViewController : ProfileViewController
    var profileLifeStyle : LifestyleType?
    let zero : NSNumber = 0 as NSNumber
    let lifestyleDataProvider : LifestyleDataProvider
    var profileNeedsSumission : Bool = false
    var userGender : String
    var profileCompletionChanged : (() - > ())?
    var logout : (() - > ())?
    var setReportCardNeedsUpdate : (() - > ())?
    var profileNotification : (() - > ())?
    var profileFilledOutFirstTime : (() - > ())?
    var genderChanged : (() - > ())?
    let challengesCoordinator = ChallengesCoordinator ()
    init (dataProvider : ProfileDataProvider) {
        if let gender = UserDefaults.standard.userGender {
            userGender = gender
        } else {
            userGender = ""
        }
        self.navigationController = UINavigationController ()
        self.profileDataProvider = dataProvider
        self.navigationController.title = L10n.profileTitle
        self.profileViewController = StoryboardScene.Profile.profileVC.instantiate ()
        self.profileViewController.tabBarItem = UITabBarItem (title : L10n.profileTabBarItemTitle, image : #imageLiteral (resourceName : "TabBar_Profile"), tag : 0)
        self.navigationController.viewControllers = [profileViewController]
        self.lifestyleDataProvider = LifestyleDataProvider ()
        self.setupProfileViewController ()
        self.loadLifeStyle ()
    }

    func tabBarViewController () - > UIViewController {
        return self.navigationController
    }

    private func setupProfileViewController () {
        self.profileViewController.profileWillAppear = {
            self.setProfileCreditsLabel ()
            if self.profileNeedsSumission {
                self.setLifestyle ()
            }
            CreditsUpdater.updateCredits {
                (success) in self.setProfileCreditsLabel ()
            }
        }
        self.profileViewController.chooseProfile = {
            lifestyleQuizType in if lifestyleQuizType==.BasicInfo {
                let basicInfoProfileViewController = StoryboardScene.Profile.basicInfoQuestionnaireVC.instantiate ()
                basicInfoProfileViewController.updateProfile = {
                    basicInfoData in self.lifestyleDataProvider.saveBasicInfoData (basicInfoData)
                    let units = self.lifestyleDataProvider.checkUnitsComplete (basicInfoQuestionnaire : basicInfoData)
                    if ! units.weightComplete {
                        UIAlertController.showAlert (nil, message : L10n.weightCheckboxLeftBlank, inViewController : self.profileViewController)
                    } else if ! units.heightComplete {
                        UIAlertController.showAlert (nil, message : L10n.heightCheckboxLeftBlank, inViewController : self.profileViewController)
                    }
                    if let gender = UserDefaults.standard.userGender {
                        if gender! = self.userGender {
                            self.userGender = gender
                            self.genderChanged? ()
                        }
                    }
                    self.setLifestyle ()
                }
                basicInfoProfileViewController.dismiss = {
                    self.navigationController.popViewController (animated : true)
                }
                basicInfoProfileViewController.locationCell = {
                    locationDisplay in let locationSearchViewController = StoryboardScene.Profile.locationSearchVC.instantiate ()
                    locationSearchViewController.dismiss = {
                        locationSearchViewController.dismiss (animated : true, completion : nil)
                    }
                    locationSearchViewController.selectedCountry = {
                        countryID in for index in basicInfoProfileViewController.internalData.singleValueQuestions.indices {
                            if basicInfoProfileViewController.basicInfoData?.singleValueQuestions [index].index == Constants.Profile.BasicInfoCountryQuestionIndex {
                                basicInfoProfileViewController.basicInfoData = self.lifestyleDataProvider.loadBasicInfoData ()
                                if basicInfoProfileViewController.basicInfoData?.singleValueQuestions [index].valueAnswer.value! = countryID {
                                    basicInfoProfileViewController.basicInfoData?.singleValueQuestions [index].valueAnswer.value = countryID
                                    for index in basicInfoProfileViewController.internalData.singleValueQuestions.indices {
                                        if basicInfoProfileViewController.basicInfoData?.singleValueQuestions [index].index == Constants.Profile.BasicInfoProvinceQuestionIndex {
                                            basicInfoProfileViewController.basicInfoData?.singleValueQuestions [index].valueAnswer.value = ""
                                            break
                                        }
                                    }
                                }
                                break
                            }
                            basicInfoProfileViewController.tableView?.reloadData ()
                        }
                        if locationSearchViewController.searchController.isActive {
                            locationSearchViewController.searchController.dismiss (animated : true, completion : {
                            })
                        }
                        locationSearchViewController.dismiss (animated : true, completion : nil)
                    }
                    locationSearchViewController.selectedProvince = {
                        provinceID in for index in basicInfoProfileViewController.internalData.singleValueQuestions.indices {
                            if basicInfoProfileViewController.basicInfoData?.singleValueQuestions [index].index == Constants.Profile.BasicInfoProvinceQuestionIndex {
                                basicInfoProfileViewController.basicInfoData = self.lifestyleDataProvider.loadBasicInfoData ()
                                basicInfoProfileViewController.basicInfoData?.singleValueQuestions [index].valueAnswer.value = provinceID
                                basicInfoProfileViewController.tableView?.reloadData ()
                            }
                        }
                        if locationSearchViewController.searchController.isActive {
                            locationSearchViewController.searchController.dismiss (animated : true, completion : {
                                locationSearchViewController.dismiss (animated : true, completion : nil)
                            })
                        }
                        locationSearchViewController.dismiss (animated : true, completion : nil)
                    }
                    guard let locations : Locations = LocationsDataProvider.loadLoactionsFromFile () else {
                        UIAlertController.showAlert (nil, message : "There was an error loading the list of locations", inViewController : basicInfoProfileViewController)
                        return
                    }
                    var viewData : LocationsSearchViewData?
                    var currentCountryID : String? = ""
                    var currentProvinceID : String? = ""
                    for question in basicInfoProfileViewController.internalData.singleValueQuestions {
                        if question.index == Constants.Profile.BasicInfoCountryQuestionIndex {
                            currentCountryID = question.valueAnswer.value
                        }
                        if question.index == Constants.Profile.BasicInfoProvinceQuestionIndex {
                            currentProvinceID = question.valueAnswer.value
                        }
                    }
                    switch locationDisplay {
                        case.Country :
                            viewData = LocationsSearchViewData (locationDisplay : locationDisplay, locations : locations, countryID : currentCountryID, provinceID : nil)
                        case.Province :
                            if currentCountryID == "" || currentCountryID == nil {
                                UIAlertController.showAlert (nil, message : "Please select a country before selecting a province", inViewController : basicInfoProfileViewController)
                                return
                            } else {
                                viewData = LocationsSearchViewData (locationDisplay : locationDisplay, locations : locations, countryID : currentCountryID, provinceID : currentProvinceID)
                            }
                    }
                    locationSearchViewController.viewData = viewData
                    let enclosingNav = UINavigationController (rootViewController : locationSearchViewController)
                    self.navigationController.present (enclosingNav, animated : true, completion : nil)
                }
                basicInfoProfileViewController.basicInfoData = self.lifestyleDataProvider.loadBasicInfoData ()
                basicInfoProfileViewController.locations = LocationsDataProvider.loadLoactionsFromFile ()
                self.navigationController.pushViewController (basicInfoProfileViewController, animated : true)
            } else {
                let baseProfileViewController = StoryboardScene.Profile.questionnaireVC.instantiate ()
                baseProfileViewController.updateProfile = {
                    lifestyleQuizType, questionnaireData in self.lifestyleDataProvider.saveQuestionnaireData (questionnaireData, lifestyleQuizType : lifestyleQuizType)
                    self.setLifestyle ()
                }
                baseProfileViewController.dismiss = {
                    self.navigationController.popViewController (animated : true)
                }
                baseProfileViewController.questionnaireData = self.lifestyleDataProvider.loadQuestionnaireData (lifestyleQuizType : lifestyleQuizType)
                baseProfileViewController.lifestyleQuizType = lifestyleQuizType
                self.navigationController.pushViewController (baseProfileViewController, animated : true)
            }
        }
        self.profileViewController.showCompleteLifestyle = {
            lifestyleQuizType in switch lifestyleQuizType {
                case.BasicInfo :
                    return self.lifestyleDataProvider.basicInfoQuizComplete ()
                case.Nutrition,.LifeStyle,.Exercise :
                    if (self.lifestyleDataProvider.totalPointsForLifestyleQuizType (lifestyleQuizType)! = nil) {
                        return true
                    } else {
                        return false
                    }
            }
        }
        self.profileViewController.showAchievements = {
            let achievementsViewController = StoryboardScene.Profile.achievementsViewControllerStoryboardIdentifier.instantiate ()
            achievementsViewController.navigationItem.leftBarButtonItem = UIBarButtonItem (title : L10n.doneBarItemTitle, style : .plain, target : self, action : #selector (self.doneButtonTapped))
            achievementsViewController.navigationItem.title = "Achievements"
            let navigationController = UINavigationController (rootViewController : achievementsViewController)
            self.navigationController.present (navigationController, animated : true, completion : nil)
        }
        self.profileViewController.showOurValue = {
            let ourValueCoordinator = OurValueCoordinator ()
            let vc = ourValueCoordinator.rootViewController ()
            vc.navigationItem.leftBarButtonItem = UIBarButtonItem (title : L10n.doneBarItemTitle, style : .plain, target : self, action : #selector (self.doneButtonTapped))
            let navigationController = UINavigationController (rootViewController : vc)
            self.navigationController.present (navigationController, animated : true, completion : nil)
        }
        self.profileViewController.logout = {
            self.logout? ()
        }
        self.profileViewController.onChallengesPressed = {
            let vc = self.challengesCoordinator.rootViewController ()
            vc.navigationItem.leftBarButtonItem = UIBarButtonItem (image : Asset.Assets.xIcon.image, style : .plain, target : self, action : #selector (self.doneButtonTapped))
            let navigationController = UINavigationController (rootViewController : vc)
            self.navigationController.present (navigationController, animated : true, completion : nil)
        }
    }

    @IBAction func doneButtonTapped (_ : Any) {
        self.profileViewController.dismiss (animated : true, completion : nil)
    }

    private func setLifestyle () {
        guard let totalPoints = lifestyleDataProvider.sumAllPoints (), let gender = UserDefaults.standard.userGender, let weight = UserDefaults.standard.userWeight, let age = UserDefaults.standard.userAge, let countryID = lifestyleDataProvider.
          getCountryID (), let provinceID = lifestyleDataProvider.getProvinceID () else {
            saveLifestyle ()
            return
        }
        let lifestyleType : LifestyleType = getLifestyleTypeWithPoints (totalPoints)
        submitProfileToServerFromViewController (viewController : self.profileViewController, lifestyleType : lifestyleType, gender : gender, weight : weight, age : age, countryID : countryID, provinceID : provinceID) {
            (success) in if success {
                self.profileNeedsSumission = false
                self.saveLifestyle ()
                if let profileNeverFilledOut = UserDefaults.standard.profileNeverFilledOut {
                    if profileNeverFilledOut {
                        UserDefaults.standard.profileNeverFilledOut = false
                        self.profileFilledOutFirstTime? ()
                    }
                }
            } else {
                self.profileNeedsSumission = true
            }
        }
    }

    private func setProfileCreditsLabel () {
        if let userCredits = UserDefaults.standard.userCredits {
            profileViewController.totalCreditsText = String (format : "%@: %@", L10n.totalCredits, userCredits)
        } else {
            profileViewController.totalCreditsText = L10n.errorLoadingCredits
        }
        if let dollars = UserDefaults.standard.userDollars {
            profileViewController.totalDollarsText = String (format : "%@: $%.2f", L10n.dollarValue, dollars)
        } else {
            profileViewController.totalDollarsText = ""
        }
        profileViewController.setCreditsLabel ()
    }

    func loadLifeStyle () {
        var lifestyleType : LifestyleType?
        if let totalPoints = lifestyleDataProvider.sumAllPoints () {
            if lifestyleDataProvider.basicInfoQuizComplete () {
                UserDefaults.standard.profileIsComplete = true
                lifestyleType = getLifestyleTypeWithPoints (totalPoints)
            } else {
                UserDefaults.standard.profileIsComplete = false
                lifestyleType = nil
            }
        } else {
            UserDefaults.standard.profileIsComplete = false
            lifestyleType = nil
        }
        self.profileLifeStyle = lifestyleType
        self.profileViewController.lifestyleType = self.profileLifeStyle
        self.profileViewController.loadLifestyle ()
        setLifestyleTypeToUserDefaults (lifestyleType : lifestyleType)
        setReportCardNeedsUpdate? ()
        self.profileCompletionChanged? ()
    }

    private func saveLifestyle () {
        self.profileNotification? ()
        loadLifeStyle ()
    }

    private func setLifestyleTypeToUserDefaults (lifestyleType : LifestyleType?) {
        guard let type = lifestyleType else {
            UserDefaults.standard.lifestyleType = ""
            return
        }
        UserDefaults.standard.lifestyleType = type.rawValue
    }

    private func getLifestyleTypeWithPoints (_ totalPoints : Int) - > LifestyleType {
        if totalPoints< = Constants.Profile.LifestyleActionCeiling {
            return .Action
        } else if totalPoints > Constants.Profile.LifestyleActionCeiling && totalPoints< = Constants.Profile.LifestyleFitCeiling {
            return .Fit
        } else if totalPoints > Constants.Profile.LifestyleFitCeiling && totalPoints< = Constants.Profile.LifestyleAthleteCeiling {
            return .Athlete
        } else if totalPoints > Constants.Profile.LifestyleAthleteCeiling {
            return .Elite
        } else {
            return .Action
        }
    }

    func silentlySubmitProfile () {
        if let profileNeverFilledOut = UserDefaults.standard.profileNeverFilledOut, profileNeverFilledOut == true {
            return
        }
        guard let totalPoints = lifestyleDataProvider.sumAllPoints (), let gender = UserDefaults.standard.userGender, let weight = UserDefaults.standard.userWeight, let age = UserDefaults.standard.userAge, let countryID = lifestyleDataProvider.
          getCountryID (), let provinceID = lifestyleDataProvider.getProvinceID () else {
            return
        }
        let lifestyleType = getLifestyleTypeWithPoints (totalPoints)
        self.submitProfileToServerFromViewController (viewController : self.profileViewController, lifestyleType : lifestyleType, gender : gender, weight : weight, age : age, countryID : countryID, provinceID : provinceID) {
            (success) in if ! success {
                self.profileNeedsSumission = true
            }
        }
    }

    func submitProfileToServerFromViewController (viewController : ProfileViewController, lifestyleType : LifestyleType, gender : String, weight : Int, age : Int, countryID : String, provinceID : String, completion :@escaping (Bool) - > ()) {
        NVActivityIndicatorPresenter.sharedInstance.startAnimating (Constants.activityData)
        profileDataProvider.submitProfile (lifestyle : lifestyleType, gender : gender, weight : weight, age : age, countryCode : countryID, regionCode : provinceID) {
            (success, errorMessage) in NVActivityIndicatorPresenter.sharedInstance.stopAnimating ()
            if success {
                completion (success)
            } else {
                let errorMessage = errorMessage??
                L10n.unknownErrorMessage
                UIAlertController.showAlert ("Submit to Server", message : errorMessage, inViewController : viewController)
                completion (false)
            }
        }
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/UINavigationBar+REPerformance.swift" startline="1" endline="41">
import UIKit

extension UINavigationBar {

    func setHalfLeaderboardGradientBackground () {
        setGradientBackground (colors : [UIColor (named : .rePerformanceNavGradientStart), UIColor (named : .rePerformanceNavGradientMiddle)])
    }

    func setFullLeaderboardGradientBackground () {
        setGradientBackground (colors : [UIColor (named : .rePerformanceNavGradientStart), UIColor (named : .rePerformanceNavGradientEnd)])
    }

    private func setGradientBackground (colors : [UIColor]) {
        var updatedFrame = bounds
        updatedFrame.size.height+=
        20
        updatedFrame.size.width = UIScreen.main.bounds.width
        let gradientLayer = CAGradientLayer (frame : updatedFrame, colors : colors)
        setBackgroundImage (gradientLayer.createGradientImage (), for : UIBarMetrics.default)
        isTranslucent = false
    }

    func removeHairline () {
        shadowImage = UIImage.oneByOneImage (with : UIColor.clear)
    }

    func addHairline () {
        shadowImage = nil
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/DashedLineView.swift" startline="1" endline="79">
import UIKit

@IBDesignable class DashedLineView : UIView {
    @IBInspectable var dashColor : UIColor = .white {
        didSet {
            self.updateColor ()
        }
    }
    @IBInspectable var lineWidth : CGFloat = 2 {
        didSet {
            self.updateLineWidth ()
        }
    }
    @IBInspectable var paintedLengthSegment : CGFloat = 9 {
        didSet {
            self.updateLineDashPattern ()
        }
    }
    @IBInspectable var unpaintedLengthSegment : CGFloat = 6 {
        didSet {
            self.updateLineDashPattern ()
        }
    }
    override class var layerClass : AnyClass {
        return CAShapeLayer.self
    }
    var dashedLayer : CAShapeLayer {
        return self.layer as! CAShapeLayer
    }

    override func layoutSubviews () {
        super.layoutSubviews ()
        self.updateSize ()
        self.updateLineWidth ()
        self.updateLineDashPattern ()
        self.updateColor ()
    }

    func updateSize () {
        let rect = CGRect (x : 0, y : 0, width : self.frame.size.width, height : self.frame.size.height)
        self.dashedLayer.bounds = rect
        self.dashedLayer.position = self.center
        self.dashedLayer.lineJoin = CAShapeLayerLineJoin.round
        self.dashedLayer.path = UIBezierPath (roundedRect : rect, cornerRadius : 0).cgPath
    }

    func updateColor () {
        self.dashedLayer.strokeColor = self.dashColor.cgColor
    }

    func updateLineWidth () {
        self.dashedLayer.lineWidth = self.lineWidth
    }

    func updateLineDashPattern () {
        self.dashedLayer.fillColor = UIColor.clear.cgColor
        self.dashedLayer.lineDashPattern = [NSNumber (value : Float (self.paintedLengthSegment)), NSNumber (value : Float (self.unpaintedLengthSegment))]
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/LeaderboardCoordinator.swift" startline="1" endline="331">
import UIKit
import NVActivityIndicatorView
import GoogleMaps
enum LeaderboardPresentationStyle : Int {
    case push
    case present
}

class LeaderboardCoordinator : NSObject {
    let navigationController : UINavigationController = UINavigationController ()
    let leaderboardDataProvider : LeaderboardDataProvider = LeaderboardDataProvider ()
    var leaderboardInitialViewController : LeaderboardInitialViewController
    override init () {
        self.leaderboardInitialViewController = StoryboardScene.Leaderboard.leaderboardInitialVC.instantiate ()
        self.leaderboardInitialViewController.tabBarItem = UITabBarItem (title : L10n.leaderboardTabBarItemTitle, image : #imageLiteral (resourceName : "TabBar_Leaderboard"), tag : 0)
        self.navigationController.setViewControllers ([self.leaderboardInitialViewController], animated : true)
        super.init ()
        self.start ()
    }

    func tabBarViewController () - > UIViewController {
        return self.navigationController
    }

    func start () {
        self.moveToLeaderboardInitialVC ()
    }

    func moveToLeaderboardInitialVC () {
        self.leaderboardInitialViewController.compareToOthers = {
            self.startGlobal (presentingViewController : self.navigationController)
        }
        self.leaderboardInitialViewController.compareWithYourGym = {
            [unowned self] in self.startGym ()
        }
    }

    public func startGlobal (presentingViewController viewController : UIViewController) {
        if SubscriptionService.shared.isActive {
            self.moveToLeaderboard (presentingViewController : viewController)
        } else {
            SubscriptionService.checkIsInConferenceMode (completion : {
                (isConferenceMode) in if isConferenceMode {
                    self.moveToLeaderboard (presentingViewController : viewController)
                } else {
                    self.moveToLearnAboutPro (presentingViewController : viewController)
                }
            })
        }
    }

    fileprivate func moveToLearnAboutPro (presentingViewController viewController : UIViewController) {
        let learnAboutProViewController = StoryboardScene.Leaderboard.learnAboutProVC.instantiate ()
        learnAboutProViewController.title = "Upgrade to Pro"
        learnAboutProViewController.navigationItem.leftBarButtonItem = UIBarButtonItem (title : L10n.doneBarItemTitle, style : .plain, target : self, action : #selector (dismissLearnAboutPro))
        learnAboutProViewController.dismissWithSuccessfulPurchase = {
            self.dismissLearnAboutPro ()
            self.startGlobal (presentingViewController : viewController)
        }
        let enclosingNav = UINavigationController (rootViewController : learnAboutProViewController)
        viewController.present (enclosingNav, animated : true, completion : nil)
    }

    fileprivate func moveToLeaderboard (presentingViewController viewController : UIViewController) {
        let leaderboardViewController = StoryboardScene.Leaderboard.leaderboardVC.instantiate ()
        let enclosingNav = UINavigationController (rootViewController : leaderboardViewController)
        leaderboardViewController.dismiss = {
            leaderboardViewController.dismiss (animated : true, completion : nil)
        }
        leaderboardViewController.willAppear = {
            if let neverSeen = UserDefaults.standard.leaderboardNeverSeen, neverSeen == true {
                UIAlertController.showAlert (nil, message : L10n.leaderboardFirstTimeView, inViewController : leaderboardViewController)
                UserDefaults.standard.leaderboardNeverSeen = false
            }
        }
        var leaderboardGroup : LeaderboardGroup = .Everyone
        var exerciseCategory : ExerciseCategory?
        var exerciseTestFormat : ExerciseTestFormat?
        var filterAge : Bool = false
        let refreshLeaderboardContent = {
            (completion : (() - > ())?) in leaderboardViewController.showLoadingIndicator (true)
            self.leaderboardDataProvider.retreiveLeaderboard (group : leaderboardGroup, filterAge : filterAge, exercise : exerciseCategory, testFormat : exerciseTestFormat) {
                (leaderboard, errorMessage) in leaderboardViewController.showLoadingIndicator (false)
                let errorableLeaderboardViewModel : ErrorableLeaderboardViewModel
                if let leaderboard = leaderboard {
                    let leaderboardViewModel = LeaderboardViewModel (leaderboard : leaderboard, globalLeaderboard : false, exerciseCategory : exerciseCategory, exerciseTestFormat : exerciseTestFormat, filteredByAge : filterAge)
                    errorableLeaderboardViewModel = .leaderboard (viewModel : leaderboardViewModel)
                } else {
                    errorableLeaderboardViewModel = .error (message : errorMessage? ? L10n.leaderboardDefaultErrorMessage)
                }
                leaderboardViewController.errorableLeaderboardViewModel = errorableLeaderboardViewModel
                leaderboardViewController.setUpView ()
                leaderboardViewController.reloadView ()
                leaderboardViewController.selectedAthlete = {
                    (athlete) in guard athlete.isPublic == true else {
                        return
                    }
                    self.showAthleteReportCard (viewController : leaderboardViewController, athlete : athlete)
                }
            }
            completion? ()
        }
        leaderboardViewController.segmentChanged = {
            (group) in leaderboardGroup = group
            refreshLeaderboardContent () {
            }
        }
        leaderboardViewController.byTest = {
            self.moveToFilterByTest (presentingViewController : leaderboardViewController, selection : {
                (category, testFormat) in exerciseCategory = category
                exerciseTestFormat = testFormat
                refreshLeaderboardContent () {
                }
            })
        }
        leaderboardViewController.byAge = {
            filterAge.toggle ()
            refreshLeaderboardContent () {
            }
        }
        refreshLeaderboardContent () {
            viewController.present (enclosingNav, animated : true, completion : nil)
        }
    }

    fileprivate func moveToFilterByTest (presentingViewController : UIViewController, selection :@escaping (ExerciseCategory, ExerciseTestFormat) - > ()) {
        let leaderboardSelectionViewController = StoryboardScene.Leaderboard.leaderboardSelectionVC.instantiate ()
        leaderboardSelectionViewController.setUpView ()
        leaderboardSelectionViewController.cancel = {
            leaderboardSelectionViewController.dismiss (animated : true, completion : nil)
        }
        leaderboardSelectionViewController.selectionMade = {
            (exerciseCategory, exerciseTestFormat) in if let exerciseCategory = exerciseCategory, let exerciseTestFormat = exerciseTestFormat {
                selection (exerciseCategory, exerciseTestFormat)
            }
            leaderboardSelectionViewController.dismiss (animated : true, completion : nil)
        }
        let enclosingNav = UINavigationController (rootViewController : leaderboardSelectionViewController)
        presentingViewController.present (enclosingNav, animated : true, completion : nil)
    }

    @IBAction func dismissLearnAboutPro () {
        navigationController.dismiss (animated : true, completion : nil)
    }

    private func startGym () {
        self.startGymLeaderboard ()
    }

    private func moveToChooseAGym () {
        self.presentChooseAGym (from : self.navigationController)
    }

    func presentChooseAGym (from viewController : UIViewController) {
        let chooseAGymVC = StoryboardScene.Leaderboard.chooseAGymVC.instantiate ()
        if let currentGymPlaceID = UserDefaults.standard.currentGymPlaceID, currentGymPlaceID! = "" {
            chooseAGymVC.title = L10n.chooseAGymTitleChange
        } else {
            chooseAGymVC.title = L10n.chooseAGymTitleFind
        }
        chooseAGymVC.didLoad = {
            NVActivityIndicatorPresenter.sharedInstance.startAnimating (Constants.activityData)
        }
        let googleDataProvider = GoogleDataProvider ()
        chooseAGymVC.findNearbyGyms = {
            (userLocation, pageToken) in googleDataProvider.findNearbyGyms (location : userLocation, pageToken : pageToken, completion : {
                (REPPlaces, nextPageToken, attributions, error) in if let error = error {
                    print ("Error searching: \(error)")
                    NVActivityIndicatorPresenter.sharedInstance.stopAnimating ()
                } else {
                    if let repPlaces = REPPlaces {
                        var placesToAdd : [(REPPlace, GMSMarker?)] = []
                        for place in repPlaces {
                            let placeToAdd : (REPPlace, GMSMarker?) = (place, nil)
                            placesToAdd.append (placeToAdd)
                        }
                        chooseAGymVC.nearbyGyms = chooseAGymVC.nearbyGyms+
                        placesToAdd
                        chooseAGymVC.showGyms ()
                    }
                    if let attributions = attributions, attributions.count > 0 {
                        if chooseAGymVC.attributions == nil || chooseAGymVC.attributions?.count == 0 {
                            chooseAGymVC.attributions = attributions
                        } else {
                            chooseAGymVC.attributions = chooseAGymVC.attributions!+
                            attributions
                        }
                    }
                    chooseAGymVC.loadAttributions ()
                    if let nextPageToken = nextPageToken, nextPageToken! = "" {
                        DispatchQueue.main.asyncAfter (deadline : .now () + 3.0, execute : {
                            chooseAGymVC.searchForNearbyGyms (pageToken : nextPageToken)
                        })
                    } else {
                        NVActivityIndicatorPresenter.sharedInstance.stopAnimating ()
                    }
                }
            })
        }
        chooseAGymVC.selectGym = {
            [unowned self] (repPlace) in NVActivityIndicatorPresenter.sharedInstance.startAnimating (Constants.activityData)
            self.leaderboardDataProvider.submitGym (placeID : repPlace.placeID, name : repPlace.name, region : repPlace.vicinity, completion : {
                (isSuccess, errorMessage) in NVActivityIndicatorPresenter.sharedInstance.stopAnimating ()
                if isSuccess == true {
                    UserDefaults.standard.currentGymPlaceID = repPlace.placeID
                    chooseAGymVC.dismiss (animated : true, completion : nil)
                } else {
                    UIAlertController.showAlert (nil, message : errorMessage, inViewController : chooseAGymVC)
                }
            })
        }
        let enclosingNav = UINavigationController (rootViewController : chooseAGymVC)
        enclosingNav.navigationBar.setHalfLeaderboardGradientBackground ()
        viewController.present (enclosingNav, animated : true, completion : nil)
    }

    private func startGymLeaderboard () {
        let leaderboardSelectionViewController = StoryboardScene.Leaderboard.leaderboardSelectionVC.instantiate ()
        leaderboardSelectionViewController.navigationItem.backBarButtonItem = UIBarButtonItem (title : "", style : .plain, target : nil, action : nil)
        leaderboardSelectionViewController.isGymType = true
        leaderboardSelectionViewController.setUpView ()
        leaderboardSelectionViewController.selectionMade = {
            [weak navigationController, weak leaderboardDataProvider] (exerciseCategory, exerciseTestFormat) in guard let exerciseCategory = exerciseCategory, let exerciseTestFormat = exerciseTestFormat else {
                return
            }
            let gymLeaderboardViewController = StoryboardScene.Leaderboard.gymLeaderboardVC.instantiate ()
            gymLeaderboardViewController.showLoadingIndicator (true)
            leaderboardDataProvider?.retreiveGymLeaderboard (exercise : exerciseCategory, testFormat : exerciseTestFormat, completion : {
                (leaderboard, errorMessage) in gymLeaderboardViewController.showLoadingIndicator (false)
                let errorableLeaderboardViewModel : ErrorableLeaderboardViewModel
                if let leaderboard = leaderboard {
                    let leaderboardViewModel = LeaderboardViewModel (leaderboard : leaderboard, globalLeaderboard : false, exerciseCategory : exerciseCategory, exerciseTestFormat : exerciseTestFormat, filteredByAge : false)
                    errorableLeaderboardViewModel = .leaderboard (viewModel : leaderboardViewModel)
                } else {
                    errorableLeaderboardViewModel = .error (message : errorMessage? ? L10n.leaderboardDefaultErrorMessage)
                }
                gymLeaderboardViewController.errorableLeaderboardViewModel = errorableLeaderboardViewModel
                gymLeaderboardViewController.reloadView ()
                gymLeaderboardViewController.selectedAthlete = {
                    (athlete) in guard athlete.isPublic == true else {
                        return
                    }
                    self.showAthleteReportCard (viewController : gymLeaderboardViewController, athlete : athlete)
                }
                navigationController?.pushViewController (gymLeaderboardViewController, animated : true)
            })
        }
        leaderboardSelectionViewController.changeGym = {
            self.moveToChooseAGym ()
        }
        if UserDefaults.standard.currentGymPlaceID == nil || UserDefaults.standard.currentGymPlaceID == "" {
            self.moveToChooseAGym ()
        }
        self.navigationController.pushViewController (leaderboardSelectionViewController, animated : true)
    }

    fileprivate func showAthleteReportCard (viewController presentingViewController : UIViewController, athlete : Athlete) {
        assert (athlete.isPublic == true)
        let coordinator = ReportCardCoordinator (athlete : athlete)
        let reportCardViewController = coordinator.reportCardViewController
        let navigationController = UINavigationController.init (rootViewController : reportCardViewController)
        reportCardViewController.navigationItem.leftBarButtonItem = BlockBarButtonItem (barButtonSystemItem : .done) {
            presentingViewController.dismiss (animated : true)
        }
        presentingViewController.present (navigationController, animated : true)
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/FacebookImage.swift" startline="1" endline="54">
import UIKit
import FBSDKCoreKit
enum FacebookImageSize {
    case square
    case small
    case normal
    case large
    fileprivate var typeArgument : String {
        get {
            switch self {
                case.square :
                    return "type=square"
                case.small :
                    return "type=small"
                case.normal :
                    return "type=normal"
                case.large :
                    return "type=large"
            }
        }
    }
}

class FacebookImage : NSObject {

    static func imageURLWithFacebookID (_ facebookID : String?, imageSize : FacebookImageSize = .square) - > URL? {
        guard let facebookID = facebookID, facebookID! = "" else {
            return nil
        }
        return URL (string : "http://graph.facebook.com/\(facebookID)/picture?\(imageSize.typeArgument)")
    }

    static func imageURLWithFacebookID (_ facebookID : String?, size : CGSize) - > URL? {
        guard let facebookID = facebookID, facebookID! = "" else {
            return nil
        }
        return URL (string : "http://graph.facebook.com/\(facebookID)/picture?width=\(Int(size.width))&height=\(Int(size.height))")
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/ProfileHeaderView.swift" startline="1" endline="39">
import UIKit

class ProfileHeaderView : NSObject {

    static func getHeaderView (text : String) - > UIView {
        let titleTextFont : UIFont = UIFont.boldSystemFont (ofSize : Constants.Profile.TableViewHeaderFontSize)
        let constraintSize : CGSize = CGSize (width : UIScreen.main.bounds.width - 16, height : CGFloat.greatestFiniteMagnitude)
        let labelSize : CGSize = text.boundingRect (with : constraintSize, options : .usesLineFragmentOrigin, attributes : [NSAttributedString.Key.font : titleTextFont], context : nil).size
        let label : UILabel = UILabel ()
        label.frame = CGRect (x : 8, y : 0, width : labelSize.width, height : labelSize.height + Constants.Profile.TableViewHeaderBuffer)
        label.font = titleTextFont
        label.textColor = UIColor (named : .rePerformanceOrange)
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.text = text
        let headerView : UIView = UIView ()
        headerView.addSubview (label)
        return headerView
    }

    static func getHeightForHeaderView (text : String) - > CGFloat {
        let titleTextFont : UIFont = UIFont.boldSystemFont (ofSize : Constants.Profile.TableViewHeaderFontSize)
        let constraintSize : CGSize = CGSize (width : UIScreen.main.bounds.width - 16, height : CGFloat.greatestFiniteMagnitude)
        let labelSize : CGSize = text.boundingRect (with : constraintSize, options : .usesLineFragmentOrigin, attributes : [NSAttributedString.Key.font : titleTextFont], context : nil).size
        return labelSize.height+
        Constants.Profile.TableViewHeaderBuffer
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/GoogleResponse.swift" startline="1" endline="29">
import Foundation
import Moya_SwiftyJSONMapper
import SwiftyJSON

final class GoogleResponse : ALSwiftyJSONAble {
    let status : String
    let results : [JSON]
    let success : Bool
    let nextPageToken : String
    let attributions : [String]
    required init? (jsonData : JSON) {
        self.status = jsonData ["status"].stringValue
        self.results = jsonData ["results"].arrayValue
        self.nextPageToken = jsonData ["next_page_token"].stringValue
        self.attributions = jsonData ["html_attributions"].arrayObject as? [String]?? [String]
        ()
        self.success = status==
        "OK"
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/LeaderboardPositionTableViewCell.swift" startline="1" endline="66">
import UIKit
import AlamofireImage

class LeaderboardPositionTableViewCell : UITableViewCell {
    @IBOutlet private var rankLabel : UILabel?
    @IBOutlet private var personImageView : UIImageView?
    @IBOutlet private var nameLabel : UILabel?
    @IBOutlet private var medalImageView : UIImageView?
    @IBOutlet private var rightSideLabel : UILabel?
    @IBOutlet private var isPublicIndicatorView : UIView?

    override func awakeFromNib () {
        super.awakeFromNib ()
        self.selectionStyle = .none
        self.rankLabel?.textColor = UIColor.white
        self.nameLabel?.textColor = UIColor.white
        self.rightSideLabel?.textColor = UIColor.white
    }

    override func prepareForReuse () {
        super.prepareForReuse ()
        self.rankLabel?.text = nil
        self.nameLabel?.text = nil
        self.rightSideLabel?.text = nil
        self.isPublicIndicatorView?.isHidden = true
        self.medalImageView?.isHidden = true
        self.personImageView?.af_cancelImageRequest ()
        self.personImageView?.image = nil
    }

    func configureCell (rankText : String, nameText : String, isPublic : Bool, rightSideText : String, medalVisible : Bool, personFacebookID : String?, profileURL : URL?) {
        self.rankLabel?.text = rankText
        self.nameLabel?.text = nameText
        self.rightSideLabel?.text = rightSideText
        self.medalImageView?.isHidden = (medalVisible == false)
        self.isPublicIndicatorView?.isHidden = (isPublic == false)
        if let profileImage = profileURL {
            self.personImageView?.af_setImage (withURL : profileImage, placeholderImage : Asset.Assets.nonFacebook.image)
        } else {
            if let imageURL = FacebookImage.imageURLWithFacebookID (personFacebookID) {
                self.personImageView?.af_setImage (withURL : imageURL, placeholderImage : Asset.Assets.nonFacebook.image)
            } else {
                self.personImageView?.image = Asset.Assets.nonFacebook.image
            }
        }
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/ExercisesSubmissionResultsViewController.swift" startline="1" endline="256">
import UIKit
struct SubmissionResultsViewData {
    let titleText : String
    let dateText : String
    let scoreText : String
    let hideTimeLabel : Bool
    let yourCurrentRankText : String
    let totalRanksText : String
    let exerciseCategoryText : String
    let creditsEarnedText : String
    let personalRecord : Bool
    let videoExists : Bool
    init (exerciseCategory : ExerciseCategory, exerciseTestFormat : ExerciseTestFormat, exerciseResult : ExerciseResult, exerciseScore : ExerciseScore, videoExists : Bool) {
        switch exerciseCategory {
            case.MileRun :
                titleText = L10n.testInformationMileRunTitle
            case.FortyYardDash :
                titleText = L10n.testInformationYardDashTitle
            case.BenchPress :
                titleText = L10n.testInformationBenchPressTitle
            case.DeadLift :
                titleText = L10n.testInformationDeadliftTitle
            case.Squat :
                titleText = L10n.testInformationSquatTitle
            case.MilitaryPress :
                titleText = L10n.testInformationMilitaryPressTitle
        }
        dateText = DateFormatter.exercisesResultsDateFormatter ().string (from : Date ())
        switch exerciseCategory {
            case.MileRun :
                let minutes : Int
                let seconds : Int
                let milliseconds : Int
                if exerciseScore.minutes == nil {
                    minutes = 0
                } else {
                    minutes = (exerciseScore.minutes)!
                }
                if exerciseScore.seconds == nil {
                    seconds = 0
                } else {
                    seconds = (exerciseScore.seconds)!
                }
                if exerciseScore.milliseconds == nil {
                    milliseconds = 0
                } else {
                    milliseconds = (exerciseScore.milliseconds)!
                }
                let formattedMinutes = String (format : "%01d", minutes)
                let formattedSeconds = String (format : "%02d", seconds)
                let formattedMilliseconds = String (format : "%02d", milliseconds)
                scoreText = "\(formattedMinutes):\(formattedSeconds).\(formattedMilliseconds)"
                hideTimeLabel = false
            case.FortyYardDash :
                let seconds : Int
                let milliseconds : Int
                if exerciseScore.seconds == nil {
                    seconds = 0
                } else {
                    seconds = (exerciseScore.seconds)!
                }
                if exerciseScore.milliseconds == nil {
                    milliseconds = 0
                } else {
                    milliseconds = (exerciseScore.milliseconds)!
                }
                let formattedSeconds = String (format : "%02d", seconds)
                let formattedMilliseconds = String (format : "%02d", milliseconds)
                scoreText = "\(formattedSeconds).\(formattedMilliseconds)"
                hideTimeLabel = false
            case.BenchPress,.DeadLift,.Squat,.MilitaryPress :
                if let reps = exerciseScore.reps {
                    scoreText = "\(reps)"
                } else {
                    scoreText = ""
                }
                hideTimeLabel = true
        }
        yourCurrentRankText = "\(exerciseResult.rank)"
        totalRanksText = "out of \(exerciseResult.totalRank)"
        switch exerciseTestFormat {
            case.TrackRunning :
                exerciseCategoryText = "Track Running"
            case.Outdoor :
                exerciseCategoryText = "Outdoor Running"
            case.Treadmill :
                exerciseCategoryText = "Treadmill Running"
            case.SelfTimed :
                exerciseCategoryText = "Self Timed"
            case.CuedTime :
                exerciseCategoryText = "Cued Time"
            case.Stamina :
                exerciseCategoryText = "Stamina"
            case.Endurance :
                exerciseCategoryText = "Endurance"
            case.Strength :
                exerciseCategoryText = "Strength"
            case.Power :
                exerciseCategoryText = "Power"
        }
        creditsEarnedText = "\(exerciseResult.creditsEarned) credits earned"
        personalRecord = exerciseResult.personalRecord
        self.videoExists = videoExists
    }
}

class ExercisesSubmissionResultsViewController : UIViewController {
    @IBOutlet private var titleLabel : UILabel?
    @IBOutlet private var exerciseCategoryTitleLabel : UILabel?
    @IBOutlet private var dateLabel : UILabel?
    @IBOutlet private var yourScoreTitleLabel : UILabel?
    @IBOutlet private var timeLabel : UILabel?
    @IBOutlet private var scoreLabel : UILabel?
    @IBOutlet private var personalRecordLabel : UILabel?
    @IBOutlet private var currentRankingTitleLabel : UILabel?
    @IBOutlet private var yourCurrentRankLabel : UILabel?
    @IBOutlet private var totalRanksLabel : UILabel?
    @IBOutlet private var creditsEarnedLabel : UILabel?
    @IBOutlet private var shareVideoInstagramButton : UIButton?
    @IBOutlet private var shareVideoSocialMediaButton : UIButton?
    @IBOutlet private var doneButton : UIButton?
    @IBOutlet private var scrollView : UIScrollView?
    @IBOutlet private var creditsEarnedImageView : UIImageView?
    @IBOutlet private var sharingView : UIView?
    @IBOutlet private var shareVideoLabel : UILabel?
    var viewData : SubmissionResultsViewData?
    var exerciseCategory : ExerciseCategory?
    var compareToOthers : (() - > ())?
    var shareVideoInstagram : (() - > ())?
    var shareVideoSocialMedia : (() - > ())?
    var done : (() - > ())?
    override var preferredStatusBarStyle : UIStatusBarStyle {
        return .lightContent
    }

    override func viewDidLoad () {
        super.viewDidLoad ()
        setUpView ()
    }

    override func viewWillAppear (_ animated : Bool) {
        super.viewWillAppear (animated)
        setLabels ()
    }

    override func viewDidAppear (_ animated : Bool) {
        super.viewDidAppear (animated)
        guard let exerciseCategory = exerciseCategory else {
            return
        }
        switch exerciseCategory {
            case.MileRun :
                REPAnalytics.trackScreenWithName (screenName : ScreenName.TestsMileRun.Score, className : String (describing : self))
            case.FortyYardDash :
                REPAnalytics.trackScreenWithName (screenName : ScreenName.TestsFortyYardDash.Score, className : String (describing : self))
            case.BenchPress :
                REPAnalytics.trackScreenWithName (screenName : ScreenName.TestsBenchPress.Score, className : String (describing : self))
            case.DeadLift :
                REPAnalytics.trackScreenWithName (screenName : ScreenName.TestsDeadlift.Score, className : String (describing : self))
            case.Squat :
                REPAnalytics.trackScreenWithName (screenName : ScreenName.TestsSquat.Score, className : String (describing : self))
            case.MilitaryPress :
                REPAnalytics.trackScreenWithName (screenName : ScreenName.TestsMilitaryPress.Score, className : String (describing : self))
        }
    }

    func setUpView () {
        titleLabel?.textColor = UIColor.white
        exerciseCategoryTitleLabel?.textColor = UIColor.white
        dateLabel?.textColor = UIColor.init (named : .rePerformanceOrange)
        yourScoreTitleLabel?.textColor = UIColor.white
        timeLabel?.textColor = UIColor.white
        scoreLabel?.textColor = UIColor.init (named : .rePerformanceOrange)
        personalRecordLabel?.textColor = UIColor.init (named : .rePerformanceOrange)
        currentRankingTitleLabel?.textColor = UIColor.white
        yourCurrentRankLabel?.textColor = UIColor.white
        totalRanksLabel?.textColor = UIColor.white
        creditsEarnedLabel?.textColor = UIColor.init (named : .rePerformanceOrange)
        doneButton?.textColor = UIColor.white
        shareVideoSocialMediaButton?.imageView?.contentMode = .scaleAspectFit
        shareVideoInstagramButton?.imageView?.contentMode = .scaleAspectFit
    }

    func setLabels () {
        let scrollViewTop = CGPoint.zero
        scrollView?.setContentOffset (scrollViewTop, animated : false)
        guard let viewData = self.viewData else {
            return
        }
        titleLabel?.text = viewData.titleText
        dateLabel?.text = viewData.dateText
        scoreLabel?.text = viewData.scoreText
        timeLabel?.isHidden = viewData.hideTimeLabel
        personalRecordLabel?.isHidden = ! viewData.personalRecord
        yourCurrentRankLabel?.text = viewData.yourCurrentRankText
        totalRanksLabel?.text = viewData.totalRanksText
        exerciseCategoryTitleLabel?.text = viewData.exerciseCategoryText
        creditsEarnedLabel?.text = viewData.creditsEarnedText
        if ! viewData.videoExists {
            sharingView?.isHidden = true
            shareVideoLabel?.isHidden = true
        }
    }

    @IBAction private func compareToOthersTapped (_ sender : UIButton?) {
        self.compareToOthers? ()
    }

    @IBAction func shareVideoInstagramButtonTapped (_ sender : UIButton) {
        shareVideoInstagram? ()
    }

    @IBAction func shareVideoSocialMediaButtonTapped (_ sender : UIButton) {
        shareVideoSocialMedia? ()
    }

    @IBAction func doneButtonTapped (_ sender : UIButton) {
        done? ()
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/YourDealViewController.swift" startline="1" endline="91">
import UIKit
import NVActivityIndicatorView
struct YourDealViewData {
    let singleRewardViewData : SingleRewardViewData
    let informationLabelText : String
}

class YourDealViewController : UIViewController {
    @IBOutlet private var informationLabel : UILabel?
    @IBOutlet private var logoImageView : UIImageView?
    @IBOutlet private var itemImageView : UIImageView?
    @IBOutlet private var discountDescriptionLabel : UILabel?
    @IBOutlet private var productDescriptionlabel : UILabel?
    @IBOutlet private var nonProCreditsLabel : UILabel?
    @IBOutlet private var proCreditsLabel : UILabel?
    @IBOutlet private var redeemButton : UIButton?
    var redeem : ((SingleRewardViewData) - > ())?
    var viewData : YourDealViewData?

    override func viewDidLoad () {
        super.viewDidLoad ()
        setUpView ()
    }

    override func viewWillAppear (_ animated : Bool) {
        super.viewWillAppear (animated)
        configureView ()
    }

    override func viewDidAppear (_ animated : Bool) {
        super.viewDidAppear (animated)
        REPAnalytics.trackScreenWithName (screenName : ScreenName.ViewRewards, className : String (describing : self))
    }

    func setUpView () {
        redeemButton?.setUpOrangeREPerformanceButton ()
        informationLabel?.textColor = UIColor.white
        itemImageView?.backgroundColor = UIColor (named : .rePerformanceRewardsBlue)
    }

    func configureView () {
        if let viewData = viewData {
            informationLabel?.text = viewData.informationLabelText
            logoImageView?.image = viewData.singleRewardViewData.companyLogoImage
            itemImageView?.image = viewData.singleRewardViewData.itemImage
            discountDescriptionLabel?.text = viewData.singleRewardViewData.discountDescription
            productDescriptionlabel?.text = viewData.singleRewardViewData.productDescription
            nonProCreditsLabel?.text = viewData.singleRewardViewData.costNonMembers
            proCreditsLabel?.text = viewData.singleRewardViewData.costProMembers
        } else {
            informationLabel?.text = L10n.rewardsRedeemInformation
            logoImageView?.image = nil
            itemImageView?.image = nil
            discountDescriptionLabel?.text = "Error"
            productDescriptionlabel?.text = ""
            nonProCreditsLabel?.text = ""
            proCreditsLabel?.text = ""
        }
    }

    @IBAction private func redeemTapped (_ sender : UIButton) {
        if let viewData = viewData {
            redeem? (viewData.singleRewardViewData)
        }
    }

    func showActivity (_ show : Bool) {
        if show {
            NVActivityIndicatorPresenter.sharedInstance.startAnimating (Constants.activityData)
        } else {
            NVActivityIndicatorPresenter.sharedInstance.stopAnimating ()
        }
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/LocationSearchTableViewController.swift" startline="1" endline="209">
import UIKit
enum LocationDisplay : Int {
    case Country
    case Province
}
struct LocationsSearchViewData {
    let locationDisplay : LocationDisplay
    let locations : Locations
    let countryID : String?
    let provinceID : String?
}

class LocationSearchTableViewController : UIViewController, UITableViewDelegate, UITableViewDataSource {
    @IBOutlet private var tableView : UITableView?
    var viewData : LocationsSearchViewData?
    var filteredCountries : Array <Country> = []
    var filteredProvinces : Array <Province> = []
    let searchController : UISearchController = UISearchController (searchResultsController : nil)
    var dismiss : (() - > ())?
    var selectedCountry : ((_ countryID : String) - > ())?
    var selectedProvince : ((_ provinceID : String) - > ())?

    override func viewDidLoad () {
        super.viewDidLoad ()
        navigationItem.rightBarButtonItem = UIBarButtonItem (barButtonSystemItem : .done, target : self, action : #selector (doneTapped))
    }

    override func viewWillAppear (_ animated : Bool) {
        super.viewWillAppear (animated)
        guard let viewData = self.viewData else {
            doneTapped ()
            return
        }
        switch viewData.locationDisplay {
            case.Country :
                self.title = "Select a Country"
            case.Province :
                self.title = "Select a Province"
        }
        setUpSearchController ()
    }

    func setUpSearchController () {
        searchController.searchResultsUpdater = self
        searchController.dimsBackgroundDuringPresentation = false
        definesPresentationContext = true
        tableView?.tableHeaderView = searchController.searchBar
        searchController.searchBar.barTintColor = UIColor (named : .rePerformanceBlue)
        searchController.searchBar.tintColor = UIColor (named : .rePerformanceOrange)
        self.tableView?.backgroundView = UIView ()
        self.tableView?.backgroundView?.backgroundColor = UIColor.clear
        self.tableView?.backgroundColor = UIColor.clear
    }

    @objc func doneTapped () {
        dismiss? ()
    }

    func numberOfSections (in tableView : UITableView) - > Int {
        return 1
    }

    func tableView (_ tableView : UITableView, numberOfRowsInSection section : Int) - > Int {
        guard let viewData = self.viewData else {
            return 0
        }
        switch viewData.locationDisplay {
            case.Country :
                if searchController.isActive && searchController.searchBar.text! = "" {
                    return filteredCountries.count
                }
                return viewData.locations.countries.count
            case.Province :
                if searchController.isActive && searchController.searchBar.text! = "" {
                    return self.filteredProvinces.count
                }
                for country in viewData.locations.countries {
                    if country.id == viewData.countryID {
                        return country.provinces.count
                    }
                }
        }
        return 0
    }

    func tableView (_ tableView : UITableView, cellForRowAt indexPath : IndexPath) - > UITableViewCell {
        let locationCell = tableView.dequeueReusableCell (withIdentifier : Constants.Profile.LocationCellIdentifier, for : indexPath)
        locationCell.textLabel?.textColor = UIColor (named : .rePerformanceOrange)
        guard let viewData = self.viewData else {
            locationCell.textLabel?.text = "Error"
            return locationCell
        }
        var text : String = ""
        var checkmark : Bool = false
        switch viewData.locationDisplay {
            case.Country :
                if searchController.isActive && searchController.searchBar.text! = "" {
                    text = filteredCountries [indexPath.row].name
                    if filteredCountries [indexPath.row].name == viewData.countryID {
                        checkmark = true
                    }
                } else {
                    text = viewData.locations.countries [indexPath.row].name
                    if viewData.locations.countries [indexPath.row].id == viewData.countryID {
                        checkmark = true
                    }
                }
            case.Province :
                if searchController.isActive && searchController.searchBar.text! = "" {
                    text = filteredProvinces [indexPath.row].name
                    if filteredProvinces [indexPath.row].id == viewData.provinceID {
                        checkmark = true
                    }
                } else {
                    for country in viewData.locations.countries {
                        if country.id == viewData.countryID {
                            text = country.provinces [indexPath.row].name
                            if country.provinces [indexPath.row].id == viewData.provinceID {
                                checkmark = true
                            }
                        }
                    }
                }
        }
        locationCell.textLabel?.text = text
        if checkmark {
            locationCell.accessoryType = .checkmark
        } else {
            locationCell.accessoryType = .none
        }
        return locationCell
    }

    func tableView (_ tableView : UITableView, didSelectRowAt indexPath : IndexPath) {
        guard let viewData = self.viewData else {
            return
        }
        switch viewData.locationDisplay {
            case.Country :
                if searchController.isActive && searchController.searchBar.text! = "" {
                    selectedCountry? (filteredCountries [indexPath.row].id)
                } else {
                    selectedCountry? (viewData.locations.countries [indexPath.row].id)
                }
            case.Province :
                if searchController.isActive && searchController.searchBar.text! = "" {
                    selectedProvince? (filteredProvinces [indexPath.row].id)
                } else {
                    for country in viewData.locations.countries {
                        if country.id == viewData.countryID {
                            selectedProvince? (country.provinces [indexPath.row].id)
                        }
                    }
                }
        }
    }

    func filterLocationsWithSearch (_ searchText : String) {
        guard let viewData = self.viewData else {
            return
        }
        switch viewData.locationDisplay {
            case.Country :
                filteredCountries = viewData.locations.countries.filter ({
                    (country : Country) - > Bool in return country.name.lowercased ().contains (searchText.lowercased ())||
                    country.id.lowercased ().contains (searchText.lowercased ())
                })
            case.Province :
                for country in viewData.locations.countries {
                    if country.id == viewData.countryID {
                        filteredProvinces = country.provinces.filter ({
                            (province : Province) - > Bool in return province.name.lowercased ().contains (searchText.lowercased ())||
                            province.id.lowercased ().contains (searchText.lowercased ())
                        })
                    }
                }
        }
        tableView?.reloadData ()
    }
}

extension LocationSearchTableViewController : UISearchResultsUpdating {

    func updateSearchResults (for searchController : UISearchController) {
        guard let searchBarText = searchController.searchBar.text else {
            return
        }
        filterLocationsWithSearch (searchBarText)
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/RewardsViewController.swift" startline="1" endline="206">
import UIKit
import NVActivityIndicatorView
struct SingleRewardViewData {
    let costNonMembers : String
    let costProMembers : String
    var itemImage : UIImage?
    var companyLogoImage : UIImage?
    let couponCode : String
    let discountDescription : String
    let productDescription : String
    let canRedeem : Bool
    let rightLabelText : String
    let rightViewColor : UIColor
    let rewardID : String
    let discount : Int
    let proDiscount : Int
}
struct RewardsViewData {
    var rewards : Array <SingleRewardViewData>
    let proUser : Bool
    var creditsText : String
    let upgradeToProText : String
}

class RewardsViewController : UIViewController, UITableViewDataSource, UITableViewDelegate {
    @IBOutlet var tableView : UITableView?
    @IBOutlet private var upgradeToProLabel : UILabel?
    @IBOutlet private var upgradeButton : UIButton?
    @IBOutlet weak var tableTopView : UIView!
    var creditLabel = UILabel ()
    var dollarLabel = UILabel ()
    var viewData : RewardsViewData?
    var rewardsWillAppear : (() - > ())?
    var upgrade : (() - > ())?
    var purchase : ((_ rewardID : String) - > ())?
    var viewRewardInformation : ((SingleRewardViewData) - > ())?

    override func viewDidLoad () {
        super.viewDidLoad ()
        setUpView ()
    }

    override func viewWillAppear (_ animated : Bool) {
        super.viewWillAppear (animated)
        rewardsWillAppear? ()
        adjustView ()
    }

    override func viewDidAppear (_ animated : Bool) {
        super.viewDidAppear (animated)
        REPAnalytics.trackScreenWithName (screenName : ScreenName.HomePage.Rewards, className : String (describing : self))
    }

    func setUpView () {
        tableView?.estimatedRowHeight = 206
        tableView?.rowHeight = UITableView.automaticDimension
        upgradeToProLabel?.textColor = UIColor.white
        upgradeButton?.setUpWhiteREPerformanceButton ()
    }

    func adjustView () {
        if let viewData = self.viewData {
            upgradeToProLabel?.text = viewData.upgradeToProText
            let viewHeight : CGFloat = (viewData.proUser? 0.0 : 119.0)
            self.tableTopView.frame.size = CGSize (width : self.tableTopView.frame.size.width, height : viewHeight)
            UIView.animate (withDuration : 0.3) {
                self.upgradeToProLabel?.isHidden = viewData.proUser
                self.upgradeButton?.isHidden = viewData.proUser
            }
        } else {
            upgradeToProLabel?.text = "Error"
            UIView.animate (withDuration : 0.3) {
                self.upgradeToProLabel?.isHidden = false
                self.upgradeButton?.isHidden = false
            }
        }
        self.creditLabel.text = String (format : "%@: %@", L10n.creditsAvailable, UserDefaults.standard.userCredits? ? 0)
        self.dollarLabel.text = String (format : "%@: $%.2f", L10n.dollarValue, UserDefaults.standard.userDollars? ? 0.00)
    }

    @IBAction private func upgradeTapped (_ sender : UIButton) {
        upgrade? ()
    }

    func showActivity (_ show : Bool) {
        if show {
            NVActivityIndicatorPresenter.sharedInstance.startAnimating (Constants.activityData)
        } else {
            NVActivityIndicatorPresenter.sharedInstance.stopAnimating ()
        }
    }

    func numberOfSections (in tableView : UITableView) - > Int {
        return 1
    }

    func tableView (_ tableView : UITableView, numberOfRowsInSection section : Int) - > Int {
        guard let viewData = self.viewData else {
            return 0
        }
        return viewData.rewards.count
    }

    func tableView (_ tableView : UITableView, viewForHeaderInSection section : Int) - > UIView? {
        let headerView = UIView (frame : CGRect.init (x : 0, y : 0, width : tableView.frame.width, height : 50))
        creditLabel.frame = CGRect (x : 5, y : 5, width : headerView.frame.width - 10, height : 25)
        dollarLabel.frame = CGRect (x : 5, y : 25, width : headerView.frame.width - 10, height : 25)
        headerView.backgroundColor = UIColor (named : .rePerformanceBlue)
        if let viewData = self.viewData {
            creditLabel.text = viewData.creditsText
            dollarLabel.text = String (format : "%@: %.2f", L10n.dollarValue, UserDefaults.standard.userDollars? ? 0.00)
            creditLabel.font = UIFont.systemFont (ofSize : 15.0)
            creditLabel.textColor = .white
            creditLabel.textAlignment = .center
            dollarLabel.font = UIFont.systemFont (ofSize : 15.0)
            dollarLabel.textColor = .white
            dollarLabel.textAlignment = .center
            headerView.addSubview (creditLabel)
            headerView.addSubview (dollarLabel)
        }
        return headerView
    }

    func tableView (_ tableView : UITableView, heightForHeaderInSection section : Int) - > CGFloat {
        return 50
    }

    func tableView (_ tableView : UITableView, cellForRowAt indexPath : IndexPath) - > UITableViewCell {
        let defaultCell : UITableViewCell = UITableViewCell.init (style : .default, reuseIdentifier : "default")
        defaultCell.textLabel?.text = "Error"
        guard let viewData = self.viewData else {
            return defaultCell
        }
        guard let cell : RewardsTableViewCell = tableView.dequeueReusableCell (withIdentifier : Constants.Rewards.RewardsCellIdentifier, for : indexPath) as? RewardsTableViewCell else {
            return defaultCell
        }
        cell.selectionStyle = .none
        let cellData = viewData.rewards [indexPath.row]
        cell.configureCell (logoImage : cellData.companyLogoImage, discountDescription : cellData.discountDescription, productDescription : cellData.productDescription, percentNonMembers : cellData.discount, percentProMembers : cellData.proDiscount,
          dollarNonMembers : cellData.costNonMembers, dollarProMembers : cellData.costProMembers, itemImage : cellData.itemImage, rightLabelText : cellData.rightLabelText, rightViewColor : cellData.rightViewColor)
        return cell
    }

    func tableView (_ tableView : UITableView, didSelectRowAt indexPath : IndexPath) {
        if let reward = viewData?.rewards [indexPath.row] {
            if reward.canRedeem == false {
                let alertController = UIAlertController (title : L10n.purchaseAlertTitle, message : L10n.purchaseAlertMessage, preferredStyle : .alert)
                let cancelAction = UIAlertAction (title : L10n.cancel, style : .cancel, handler : nil)
                let okAction = UIAlertAction (title : L10n.ok, style : .default, handler : {
                    (_) in self.purchase? (reward.rewardID)
                })
                alertController.addAction (cancelAction)
                alertController.addAction (okAction)
                DispatchQueue.main.async {
                    self.present (alertController, animated : true, completion : nil)
                }
            } else {
                viewRewardInformation? (reward)
            }
        }
    }

    func reloadRow (row : Int) {
        let indexPathToReload : IndexPath = IndexPath (row : row, section : 0)
        if let visibleIndexPaths = tableView?.indexPathsForVisibleRows {
            if visibleIndexPaths.contains (indexPathToReload) {
                tableView?.reloadRows (at : [indexPathToReload], with : .automatic)
            }
        }
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/REPCustomTextField.swift" startline="1" endline="65">
import UIKit

class REPCustomTextField : UITextField {

    override func canPerformAction (_ action : Selector, withSender sender : Any?) - > Bool {
        if action == #selector (UIResponderStandardEditActions.paste (_ :)) {
            return false
        }
        return super.canPerformAction (action, withSender : sender)
    }

    func applyProfileWhiteUnderline () {
        let border = CALayer ()
        let borderWidth = CGFloat (Constants.UIConstants.BorderWidth)
        border.borderColor = UIColor.white.cgColor
        let borderFrameWidth = frame.size.width
        border.frame = CGRect (x : 0, y : frame.size.height - borderWidth, width : borderFrameWidth, height : frame.size.height)
        border.borderWidth = borderWidth
        layer.addSublayer (border)
        layer.masksToBounds = true
    }

    func sanitizeIntegerInput (upperBounds : Int) - > Int? {
        guard let input = text else {
            return nil
        }
        guard let inputValue : Int = Int (input) else {
            return nil
        }
        let absoluteInput = abs (inputValue)
        var output : String = ""
        if absoluteInput > upperBounds {
            let offset : Int = absoluteInput.digitCount-
            upperBounds.digitCount==
            0? 1 : absoluteInput.digitCount-
            upperBounds.digitCount
            let index = input.index (input.startIndex, offsetBy : absoluteInput.digitCount - offset)
            output = String (input [ ..< index])
            if output == "" {
                return nil
            } else {
                return Int (output)
            }
        } else {
            return absoluteInput
        }
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/Double+Rounding.swift" startline="1" endline="20">
import UIKit
import Foundation

extension Double {

    public func roundToNearestFive () - > Int {
        let test = self
        return 5*
        Int (Darwin.round (test / 5.0))
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/ChatUserListViewController.swift" startline="1" endline="105">
import UIKit
import FirebaseFirestore
import FirebaseFunctions

class ChatUserListViewController : UIViewController {
    @IBOutlet fileprivate var usersTableView : UITableView?
    deinit {
        self.snapshotListener?.remove ()
    }
    var firebaseIdentifier : String? = nil {
        didSet {
            self.snapshotListener?.remove ()
            guard let firebaseIdentifier = self.firebaseIdentifier else {
                return
            }
            let userConversationsReference = Firestore.firestore ().collection ("conversations").whereField (FieldPath (["user_ids"]), arrayContains : firebaseIdentifier)
            self.snapshotListener = userConversationsReference.addSnapshotListener () {
                [weak self] (snapshot, error) in guard let snapshot = snapshot else {
                    return
                }
                self?.chatConversations = snapshot.documents.compactMap ({
                    (document) in let chatConversation = ChatConversation (snapshot : document)
                    if chatConversation.lastMessageDate == nil || chatConversation.participants.count < 2 {
                        return nil
                    } else {
                        return chatConversation
                    }
                }).sorted {
                    $0.lastMessageDate!>
                    $1.lastMessageDate!
                }
            }
        }
    }
    fileprivate var snapshotListener : ListenerRegistration?
    fileprivate var chatConversations : [ChatConversation]? = nil {
        didSet {
            self.usersTableView?.reloadData ()
        }
    }
    var selectedConversation : ((ChatConversation) - > ())?
}

extension ChatUserListViewController : UITableViewDataSource, UITableViewDelegate {

    func numberOfSections (in tableView : UITableView) - > Int {
        return 1
    }

    func tableView (_ tableView : UITableView, numberOfRowsInSection section : Int) - > Int {
        guard let users = self.chatConversations else {
            return 0
        }
        return users.count
    }

    func tableView (_ tableView : UITableView, cellForRowAt indexPath : IndexPath) - > UITableViewCell {
        let conversation = self.chatConversations! [indexPath.row]
        let cell = tableView.dequeueReusableCell (withIdentifier : "Chat User Cell Identifier", for : indexPath) as! ChatUserTableViewCell
        cell.athleteName = conversation.otherParticipant?.fullName
        cell.userProfileURL = conversation.otherParticipant?.profileURL
        cell.unreadMessagesCount = conversation.me?.unreadMessageCount??
        0
        if let lastMessageDate = conversation.lastMessageDate {
            let timeIntervalSinceLastMessage = Date ().timeIntervalSince (lastMessageDate)
            let hoursSinceLastMessage = Int (timeIntervalSinceLastMessage / 60 / 60)
            cell.lastMessageTimeInterval = L10n.hrsAgo (hoursSinceLastMessage)
        } else {
            cell.lastMessageTimeInterval = nil
        }
        return cell
    }

    func tableView (_ tableView : UITableView, didSelectRowAt indexPath : IndexPath) {
        tableView.deselectRow (at : indexPath, animated : true)
        let conversation = self.chatConversations! [indexPath.row]
        self.selectedConversation? (conversation)
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/ChatMessageTableViewCell.swift" startline="1" endline="32">
import UIKit

class ChatMessageTableViewCell : UITableViewCell {
    @IBOutlet fileprivate var messageContentLabel : UILabel?
    @IBOutlet weak var messageImage : UIImageView!
    var messageContent : String? = nil {
        didSet {
            self.messageContentLabel?.text = self.messageContent
        }
    }

    override func prepareForReuse () {
        self.messageContent = nil
        super.prepareForReuse ()
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/Validator.swift" startline="1" endline="17">
import Foundation

func isValidEmail (email : String) - > Bool {
    let emailRegEx = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}"
    let emailTest = NSPredicate (format : "SELF MATCHES %@", emailRegEx)
    return emailTest.evaluate (with : email)
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/BasicInfoProfileTableViewController.swift" startline="1" endline="380">
import UIKit

class BasicInfoProfileTableViewController : UIViewController, UITableViewDataSource, UITableViewDelegate {
    @IBOutlet var tableView : UITableView?
    var basicInfoData : BasicInfoData?
    var internalData : BasicInfoData = BasicInfoData (questionnaireTitle : "", valueAndUnitsQuestions : [], singleValueQuestions : [], normalQuestions : [])
    var locations : Locations?
    var updateProfile : ((BasicInfoData) - > ())?
    var locationCell : ((LocationDisplay) - > ())?
    var dismiss : (() - > ())?

    override func viewDidLoad () {
        super.viewDidLoad ()
        self.tableView?.estimatedRowHeight = 44
        self.tableView?.rowHeight = UITableView.automaticDimension
        setUpDoneButton ()
    }

    func setUpDoneButton () {
        let bottomViewFrame = CGRect (x : 0, y : 0, width : UIScreen.main.bounds.width, height : Constants.Profile.TableViewFooterHeight)
        let bottomView : UIView = UIView (frame : bottomViewFrame)
        let buttonWidth = UIScreen.main.bounds.width*
        0.75
        let buttonX = (UIScreen.main.bounds.width / 2)- (buttonWidth / 2)
        let buttonY = (Constants.Profile.TableViewFooterHeight / 2)- (Constants.Profile.TableViewFooterButtonHeight / 2)
        let doneButton : UIButton = UIButton (frame : CGRect (x : buttonX, y : buttonY, width : buttonWidth, height : Constants.Profile.TableViewFooterButtonHeight))
        doneButton.setUpOrangeREPerformanceButton ()
        doneButton.setTitle ("Done", for : .normal)
        doneButton.isUserInteractionEnabled = true
        doneButton.addTarget (self, action : #selector (doneTapped (_ :)), for : .touchUpInside)
        bottomView.addSubview (doneButton)
        self.tableView?.tableFooterView = bottomView
    }

    @IBAction private func doneTapped (_ sender : UIButton) {
        dismiss? ()
    }

    override func viewWillAppear (_ animated : Bool) {
        super.viewWillAppear (animated)
        if let basicInfoData = self.basicInfoData {
            internalData = basicInfoData
        }
        self.title = internalData.questionnaireTitle
    }

    override func viewWillDisappear (_ animated : Bool) {
        super.viewWillDisappear (animated)
        updateProfile? (internalData)
    }

    func numberOfSections (in tableView : UITableView) - > Int {
        return internalData.valueAndUnitsQuestions.count+
        internalData.singleValueQuestions.count+
        internalData.normalQuestions.count
    }

    func tableView (_ tableView : UITableView, numberOfRowsInSection section : Int) - > Int {
        switch section {
            case 0, 2, 3, 4, 5 :
                return 1
            case 1, 6 :
                for question in internalData.normalQuestions {
                    if question.index == section {
                        return question.possibleAnswers.count
                    }
                }
            default :
                return 0
        }
        return 0
    }

    func tableView (_ tableView : UITableView, cellForRowAt indexPath : IndexPath) - > UITableViewCell {
        let defaultCell : UITableViewCell = UITableViewCell.init (style : .default, reuseIdentifier : "default")
        defaultCell.textLabel?.text = "Error"
        switch indexPath.section {
            case 0 :
                guard let valueAndUnitsCell : ValueAndUnitsTableViewCell = tableView.dequeueReusableCell (withIdentifier : Constants.Profile.ValueAndUnitsProfileCellIdentifier, for : indexPath) as? ValueAndUnitsTableViewCell else {
                    return defaultCell
                }
                valueAndUnitsCell.valueFieldChanged = {
                    newValue in for index in self.internalData.valueAndUnitsQuestions.indices {
                        if self.internalData.valueAndUnitsQuestions [index].index == indexPath.section {
                            self.internalData.valueAndUnitsQuestions [index].valueAnswer.value = newValue
                        }
                    }
                }
                valueAndUnitsCell.checkboxChanged = {
                    for index in self.internalData.valueAndUnitsQuestions.indices {
                        if self.internalData.valueAndUnitsQuestions [index].index == indexPath.section {
                            self.internalData.valueAndUnitsQuestions [index].units [0].selected = valueAndUnitsCell.getLeftCheckboxChecked ()
                            self.internalData.valueAndUnitsQuestions [index].units [1].selected = valueAndUnitsCell.getRightCheckboxChecked ()
                        }
                    }
                }
                for question in internalData.valueAndUnitsQuestions {
                    if question.index == indexPath.section {
                        if let currentValue = question.valueAnswer.value {
                            valueAndUnitsCell.setUp (valueText : currentValue, leftLabelText : question.units [0].title, rightLabelText : question.units [1].title, leftCheckboxChecked : question.units [0].selected, rightCheckboxChecked : question.units [1
                              ].selected)
                        } else {
                            valueAndUnitsCell.setUp (valueText : "", leftLabelText : question.units [0].title, rightLabelText : question.units [1].title, leftCheckboxChecked : question.units [0].selected, rightCheckboxChecked : question.units [1].selected
                              )
                        }
                    }
                }
                return valueAndUnitsCell
            case 2 :
                guard let heightTableViewCell : HeightTableViewCell = tableView.dequeueReusableCell (withIdentifier : Constants.Profile.HeightTableViewCellIdentifier, for : indexPath) as? HeightTableViewCell else {
                    return defaultCell
                }
                heightTableViewCell.valueChanged = {
                    newValue in for index in self.internalData.valueAndUnitsQuestions.indices {
                        if self.internalData.valueAndUnitsQuestions [index].index == indexPath.section {
                            self.internalData.valueAndUnitsQuestions [index].valueAnswer.value = newValue
                        }
                    }
                }
                heightTableViewCell.checkboxChanged = {
                    for index in self.internalData.valueAndUnitsQuestions.indices {
                        if self.internalData.valueAndUnitsQuestions [index].index == indexPath.section {
                            self.internalData.valueAndUnitsQuestions [index].units [0].selected = heightTableViewCell.getLeftCheckboxChecked ()
                            self.internalData.valueAndUnitsQuestions [index].units [1].selected = heightTableViewCell.getRightCheckboxChecked ()
                        }
                    }
                }
                for question in internalData.valueAndUnitsQuestions {
                    if question.index == indexPath.section {
                        if let currentValue = question.valueAnswer.value {
                            heightTableViewCell.setUp (valueText : currentValue, leftCheckboxChecked : question.units [0].selected, rightCheckboxChecked : question.units [1].selected)
                        } else {
                            heightTableViewCell.setUp (valueText : "", leftCheckboxChecked : question.units [0].selected, rightCheckboxChecked : question.units [1].selected)
                        }
                    }
                }
                return heightTableViewCell
            case 3 :
                guard let valueCell : ValueTableViewCell = tableView.dequeueReusableCell (withIdentifier : Constants.Profile.ValueProfileCellIdentifier, for : indexPath) as? ValueTableViewCell else {
                    return defaultCell
                }
                valueCell.valueFieldChanged = {
                    newValue in for index in self.internalData.singleValueQuestions.indices {
                        if self.internalData.singleValueQuestions [index].index == indexPath.section {
                            self.internalData.singleValueQuestions [index].valueAnswer.value = newValue
                        }
                    }
                }
                for question in internalData.singleValueQuestions {
                    if question.index == indexPath.section {
                        if let currentValue = question.valueAnswer.value {
                            valueCell.setUp (valueText : currentValue)
                        } else {
                            valueCell.setUp (valueText : "")
                        }
                    }
                }
                return valueCell
            case 4 :
                let locationCell = tableView.dequeueReusableCell (withIdentifier : Constants.Profile.BasicProfileCellIdentifier, for : indexPath)
                locationCell.accessoryType = .none
                locationCell.backgroundColor = UIColor.clear
                locationCell.textLabel?.textColor = UIColor (named : .rePerformanceWhite)
                guard let locations = self.locations else {
                    return locationCell
                }
                for question in internalData.singleValueQuestions {
                    if question.index == indexPath.section {
                        for country in locations.countries {
                            if country.id == question.valueAnswer.value {
                                locationCell.textLabel?.text = country.name
                                return locationCell
                            }
                        }
                        locationCell.textLabel?.text = question.valueAnswer.value
                    }
                }
                return locationCell
            case 5 :
                let locationCell = tableView.dequeueReusableCell (withIdentifier : Constants.Profile.BasicProfileCellIdentifier, for : indexPath)
                locationCell.accessoryType = .none
                locationCell.backgroundColor = UIColor.clear
                locationCell.textLabel?.textColor = UIColor (named : .rePerformanceWhite)
                guard let locations = self.locations else {
                    return locationCell
                }
                var countryID : String? = ""
                for question in internalData.singleValueQuestions {
                    if question.index == 4 {
                        for country in locations.countries {
                            if country.id == question.valueAnswer.value {
                                countryID = question.valueAnswer.value
                            }
                        }
                    }
                }
                for question in internalData.singleValueQuestions {
                    if question.index == indexPath.section {
                        for country in locations.countries {
                            if country.id == countryID {
                                for province in country.provinces {
                                    if province.id == question.valueAnswer.value {
                                        locationCell.textLabel?.text = province.name
                                        return locationCell
                                    }
                                }
                            }
                        }
                        locationCell.textLabel?.text = question.valueAnswer.value
                    }
                }
                return locationCell
            case 1, 6 :
                let basicProfileCell = tableView.dequeueReusableCell (withIdentifier : Constants.Profile.BasicProfileCellIdentifier, for : indexPath)
                for question in internalData.normalQuestions {
                    if question.index == indexPath.section {
                        let answer = question.possibleAnswers [indexPath.row]
                        basicProfileCell.textLabel?.text = answer.title
                        if (answer.selected) {
                            basicProfileCell.accessoryType = .checkmark
                            basicProfileCell.backgroundColor = UIColor.white
                            basicProfileCell.textLabel?.textColor = UIColor.black
                        } else {
                            basicProfileCell.accessoryType = .none
                            basicProfileCell.backgroundColor = UIColor.clear
                            basicProfileCell.textLabel?.textColor = UIColor (named : .rePerformanceWhite)
                        }
                    }
                }
                return basicProfileCell
            default :
                return defaultCell
        }
    }

    func tableView (_ tableView : UITableView, heightForHeaderInSection section : Int) - > CGFloat {
        var titleText : String = ""
        switch section {
            case 0, 2 :
                for question in internalData.valueAndUnitsQuestions {
                    if question.index == section {
                        titleText = question.title
                    }
                }
            case 3, 4, 5 :
                for question in internalData.singleValueQuestions {
                    if question.index == section {
                        titleText = question.title
                    }
                }
            case 1, 6 :
                for question in internalData.normalQuestions {
                    if question.index == section {
                        titleText = question.questionTitle
                    }
                }
            default :
                titleText = ""
        }
        return ProfileHeaderView.getHeightForHeaderView (text : titleText)
    }

    func tableView (_ tableView : UITableView, viewForHeaderInSection section : Int) - > UIView? {
        var titleText : String = ""
        switch section {
            case 0, 2 :
                for question in internalData.valueAndUnitsQuestions {
                    if question.index == section {
                        titleText = question.title
                    }
                }
            case 3, 4, 5 :
                for question in internalData.singleValueQuestions {
                    if question.index == section {
                        titleText = question.title
                    }
                }
            case 1, 6 :
                for question in internalData.normalQuestions {
                    if question.index == section {
                        titleText = question.questionTitle
                    }
                }
            default :
                titleText = ""
        }
        return ProfileHeaderView.getHeaderView (text : titleText)
    }

    func tableView (_ tableView : UITableView, titleForHeaderInSection section : Int) - > String? {
        return "Section Title"
    }

    func tableView (_ tableView : UITableView, willSelectRowAt indexPath : IndexPath) - > IndexPath? {
        switch indexPath.section {
            case 0, 2 :
                return indexPath
            case 3 :
                return indexPath
            case 4 :
                locationCell? ( .Country)
                return indexPath
            case 5 :
                locationCell? ( .Province)
                return indexPath
            case 1, 6 :
                for questionIndex in internalData.normalQuestions.indices {
                    if internalData.normalQuestions [questionIndex].index == indexPath.section {
                        var deselectCurrentSelection : Bool = false
                        if (internalData.normalQuestions [questionIndex].possibleAnswers [indexPath.row].selected) {
                            deselectCurrentSelection = true
                        }
                        for index in internalData.normalQuestions [questionIndex].possibleAnswers.indices {
                            internalData.normalQuestions [questionIndex].possibleAnswers [index].selected = false
                        }
                        var indexPathsInSection : [IndexPath] = []
                        for currentRow in 0 ..< tableView.numberOfRows (inSection : indexPath.section) {
                            indexPathsInSection.append (IndexPath (row : currentRow, section : indexPath.section))
                        }
                        for currentIndexPath in indexPathsInSection {
                            tableView.cellForRow (at : currentIndexPath)?.accessoryType = .none
                            tableView.cellForRow (at : currentIndexPath)?.backgroundColor = UIColor.clear
                            tableView.cellForRow (at : currentIndexPath)?.textLabel?.textColor = UIColor (named : .rePerformanceWhite)
                        }
                        if (deselectCurrentSelection) {
                            tableView.cellForRow (at : indexPath)?.accessoryType = .none
                            tableView.cellForRow (at : indexPath)?.backgroundColor = UIColor.clear
                            tableView.cellForRow (at : indexPath)?.textLabel?.textColor = UIColor (named : .rePerformanceWhite)
                        } else {
                            internalData.normalQuestions [questionIndex].possibleAnswers [indexPath.row].selected = true
                            tableView.cellForRow (at : indexPath)?.accessoryType = .checkmark
                            tableView.cellForRow (at : indexPath)?.backgroundColor = UIColor.white
                            tableView.cellForRow (at : indexPath)?.textLabel?.textColor = UIColor.black
                        }
                    }
                }
            default :
                return indexPath
        }
        return indexPath
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/DisplayAlert.swift" startline="1" endline="21">
import UIKit

extension UIAlertController {

    class func showAlert (_ title : String?, message : String?, inViewController : UIViewController) {
        let alertController = UIAlertController (title : title, message : message, preferredStyle : .alert)
        let ok = UIAlertAction (title : "OK", style : .default, handler : nil)
        alertController.addAction (ok)
        inViewController.present (alertController, animated : true, completion : nil)
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/RewardsCoordinator.swift" startline="1" endline="285">
import UIKit

class RewardsCoordinator {
    let navigationController : UINavigationController
    let rewardsDataProvider = RewardsDataProvider ()
    let rewardsViewController : RewardsViewController
    var lastUpdate : Date = Date ()
    var rewardsNeedsUpdate : Bool = true
    init () {
        navigationController = UINavigationController ()
        rewardsViewController = StoryboardScene.Rewards.rewardsVC.instantiate ()
        rewardsViewController.title = L10n.rewardsTitle
        rewardsViewController.tabBarItem = UITabBarItem (title : L10n.rewardsTabItemTitle, image : #imageLiteral (resourceName : "TabBar_Rewards"), tag : 0)
        navigationController.viewControllers = [rewardsViewController]
        setUpRewardsViewController ()
    }

    func tabBarViewController () - > UIViewController {
        return navigationController
    }

    func setUpRewardsViewController () {
        rewardsViewController.rewardsWillAppear = {
            let elapsedTimeSinceLastRetrieval = Date ().timeIntervalSince (self.lastUpdate)
            if elapsedTimeSinceLastRetrieval > Constants.Rewards.RefreshTimeInterval || self.rewardsViewController.viewData?.rewards.count == 0 || self.rewardsNeedsUpdate {
                self.retreiveRewards ()
            }
            var newViewData = RewardsViewData (rewards : [], proUser : SubscriptionService.shared.isActive, creditsText : self.getCreditsText (), upgradeToProText : L10n.rewardsUpgradeToProDescription)
            if let rewards = self.rewardsViewController.viewData?.rewards {
                newViewData = RewardsViewData (rewards : rewards, proUser : SubscriptionService.shared.isActive, creditsText : self.getCreditsText (), upgradeToProText : L10n.rewardsUpgradeToProDescription)
            }
            self.rewardsViewController.viewData = newViewData
            self.rewardsViewController.adjustView ()
            self.updateCreditsInVC ()
        }
        rewardsViewController.upgrade = {
            if ! SubscriptionService.shared.isActive {
                let learnAboutProViewController = StoryboardScene.Leaderboard.learnAboutProVC.instantiate ()
                learnAboutProViewController.title = L10n.rewardsUpgradeToProTitle
                learnAboutProViewController.navigationItem.leftBarButtonItem = UIBarButtonItem (title : L10n.doneBarItemTitle, style : .plain, target : self, action : #selector (self.dismissLearnAboutPro))
                learnAboutProViewController.dismissWithSuccessfulPurchase = {
                    [weak self] in self?.dismissLearnAboutPro ()
                    self?.retreiveRewards ()
                }
                let enclosingNav = UINavigationController (rootViewController : learnAboutProViewController)
                self.rewardsViewController.present (enclosingNav, animated : true, completion : nil)
            }
        }
        rewardsViewController.purchase = {
            rewardID in self.rewardsViewController.showActivity (true)
            self.rewardsDataProvider.purchaseReward (rewardID : rewardID, proUser : SubscriptionService.shared.isActive, completion : {
                (rewardServerFormat, errorMessage) in self.rewardsViewController.showActivity (false)
                self.handleSingleRewardPurchaseResponse (rewardServerFormat : rewardServerFormat, errorMessage : errorMessage)
            })
        }
        rewardsViewController.viewRewardInformation = {
            reward in self.moveToYourDeal (singleRewardViewData : reward)
        }
    }

    func moveToYourDeal (singleRewardViewData : SingleRewardViewData) {
        let yourDealViewController : YourDealViewController = StoryboardScene.Rewards.yourDealVC.instantiate ()
        yourDealViewController.title = L10n.yourDealTitle
        yourDealViewController.viewData = YourDealViewData (singleRewardViewData : singleRewardViewData, informationLabelText : L10n.rewardsRedeemInformation)
        yourDealViewController.redeem = {
            singleRewardViewData in self.moveToRedeem (singleRewardViewData : singleRewardViewData, yourDealViewController : yourDealViewController)
        }
        navigationController.pushViewController (yourDealViewController, animated : true)
    }

    func moveToRedeem (singleRewardViewData : SingleRewardViewData, yourDealViewController : YourDealViewController) {
        let redeemViewController : RedeemViewController = StoryboardScene.Rewards.redeemVC.instantiate ()
        redeemViewController.title = L10n.yourDealTitle
        let redeemNav = UINavigationController (rootViewController : redeemViewController)
        yourDealViewController.showActivity (true)
        redeemViewController.done = {
            redeemViewController.dismiss (animated : true, completion : {
                self.navigationController.popToViewController (self.rewardsViewController, animated : true)
            })
        }
        self.rewardsDataProvider.redeemReward (rewardID : singleRewardViewData.rewardID, completion : {
            (rewardServerFormat, errorMessage) in yourDealViewController.showActivity (false)
            self.handleSingleRewardRedeemResponse (rewardServerFormat : rewardServerFormat, errorMessage : errorMessage, redeemViewController : redeemViewController, serverCallSuccessful : {
                (success) in yourDealViewController.present (redeemNav, animated : true, completion : nil)
            })
        })
    }

    func retreiveRewards () {
        rewardsViewController.showActivity (true)
        rewardsDataProvider.retreiveListOfRewards {
            (rewardsServerFormat, errorMessage) in self.rewardsViewController.showActivity (false)
            if let _ = rewardsServerFormat {
                self.rewardsNeedsUpdate = false
            }
            self.handleServerResponse (rewardsServerFormat : rewardsServerFormat, errorMessage : errorMessage)
        }
    }

    private func handleSingleRewardRedeemResponse (rewardServerFormat : RewardServerFormat?, errorMessage : String?, redeemViewController : RedeemViewController, serverCallSuccessful :@escaping (Bool) - > ()) {
        if let rewardServerFormat = rewardServerFormat {
            let reward : SingleRewardViewData = getSingleRewardViewData (serverReward : rewardServerFormat)
            if let rewardsViewData = rewardsViewController.viewData?.rewards {
                for index in rewardsViewData.indices {
                    if rewardsViewData [index].rewardID == reward.rewardID {
                        rewardsViewController.viewData?.rewards [index] = reward
                        rewardsViewController.reloadRow (row : index)
                        redeemViewController.viewData = RedeemViewData (logoImage : nil, couponCode : reward.couponCode, discountDescription : reward.discountDescription, productDescription : reward.productDescription)
                        serverCallSuccessful (true)
                    }
                }
                DispatchQueue.global (qos : .userInitiated).async {
                    let images = self.loadImages (serverReward : rewardServerFormat)
                    DispatchQueue.main.async {
                        redeemViewController.viewData?.logoImage = images.companyLogoImage
                        redeemViewController.configureView ()
                        for index in rewardsViewData.indices {
                            if rewardsViewData [index].rewardID == reward.rewardID {
                                self.rewardsViewController.viewData?.rewards [index].itemImage = images.itemImage
                                self.rewardsViewController.viewData?.rewards [index].companyLogoImage = images.companyLogoImage
                                self.rewardsViewController.reloadRow (row : index)
                            }
                        }
                    }
                }
            }
        } else {
            UIAlertController.showAlert (L10n.errorRedeemingReward, message : errorMessage, inViewController : self.rewardsViewController)
            serverCallSuccessful (false)
        }
        self.updateCreditsInVC ()
    }

    private func handleSingleRewardPurchaseResponse (rewardServerFormat : RewardServerFormat?, errorMessage : String?) {
        if let rewardServerFormat = rewardServerFormat {
            let reward : SingleRewardViewData = getSingleRewardViewData (serverReward : rewardServerFormat)
            if let rewardsViewData = rewardsViewController.viewData?.rewards {
                for index in rewardsViewData.indices {
                    if rewardsViewData [index].rewardID == reward.rewardID {
                        rewardsViewController.viewData?.rewards [index] = reward
                        rewardsViewController.reloadRow (row : index)
                    }
                }
                DispatchQueue.global (qos : .userInitiated).async {
                    let images = self.loadImages (serverReward : rewardServerFormat)
                    DispatchQueue.main.async {
                        for index in rewardsViewData.indices {
                            if rewardsViewData [index].rewardID == reward.rewardID {
                                self.rewardsViewController.viewData?.rewards [index].itemImage = images.itemImage
                                self.rewardsViewController.viewData?.rewards [index].companyLogoImage = images.companyLogoImage
                                self.rewardsViewController.reloadRow (row : index)
                            }
                        }
                    }
                }
            }
        } else {
            UIAlertController.showAlert (L10n.errorPurchasingReward, message : errorMessage, inViewController : self.rewardsViewController)
        }
        self.updateCreditsInVC ()
    }

    private func handleServerResponse (rewardsServerFormat : Array <RewardServerFormat>?, errorMessage : String?) {
        let creditsText : String = self.getCreditsText ()
        var rewardsViewData = RewardsViewData (rewards : [], proUser : SubscriptionService.shared.isActive, creditsText : creditsText, upgradeToProText : L10n.rewardsUpgradeToProDescription)
        if let rewardsServerFormat = rewardsServerFormat {
            var rewards : Array <SingleRewardViewData> = []
            for serverReward in rewardsServerFormat {
                rewards.append (getSingleRewardViewData (serverReward : serverReward))
            }
            rewardsViewData = RewardsViewData (rewards : rewards, proUser : SubscriptionService.shared.isActive, creditsText : creditsText, upgradeToProText : L10n.rewardsUpgradeToProDescription)
            DispatchQueue.global (qos : .userInitiated).async {
                for serverReward in rewardsServerFormat {
                    let images = self.loadImages (serverReward : serverReward)
                    DispatchQueue.main.async {
                        for index in rewardsViewData.rewards.indices {
                            if rewardsViewData.rewards [index].rewardID == serverReward.rewardID {
                                self.rewardsViewController.viewData?.rewards [index].itemImage = images.itemImage
                                self.rewardsViewController.viewData?.rewards [index].companyLogoImage = images.companyLogoImage
                                self.rewardsViewController.reloadRow (row : index)
                            }
                        }
                    }
                }
            }
            self.lastUpdate = Date ()
        } else {
            UIAlertController.showAlert (L10n.errorGettingRewards, message : errorMessage, inViewController : self.rewardsViewController)
        }
        self.rewardsViewController.viewData = rewardsViewData
        self.rewardsViewController.tableView?.reloadData ()
        self.updateCreditsInVC ()
    }

    private func loadImages (serverReward : RewardServerFormat) - > (itemImage : UIImage?, companyLogoImage : UIImage?) {
        var itemImage : UIImage? = nil
        if let itemImageURL = serverReward.itemImageURL {
            itemImage = self.getImageWithURLString (itemImageURL)
        }
        var companyLogoImage : UIImage? = nil
        if let companyLogoImageURL = serverReward.logoURL {
            companyLogoImage = self.getImageWithURLString (companyLogoImageURL)
        }
        return (itemImage, companyLogoImage)
    }

    private func getSingleRewardViewData (serverReward : RewardServerFormat) - > SingleRewardViewData {
        var rightLabelText : String = L10n.rewardsGetItNow
        var rightViewColor : UIColor = UIColor (named : .rePerformanceRewardsBlue)
        if serverReward.canRedeem {
            rightLabelText = L10n.rewardsRedeem
            rightViewColor = UIColor (named : .rePerformanceRewardsOrange)
        }
        return SingleRewardViewData (costNonMembers : serverReward.costNonMembers, costProMembers : serverReward.costProMembers, itemImage : nil, companyLogoImage : nil, couponCode : serverReward.couponCode, discountDescription : serverReward.
          discountDescription, productDescription : serverReward.productDescription, canRedeem : serverReward.canRedeem, rightLabelText : rightLabelText, rightViewColor : rightViewColor, rewardID : serverReward.rewardID, discount : serverReward.discount,
          proDiscount : serverReward.proDiscount)
    }

    private func getImageWithURLString (_ url : String) - > UIImage? {
        if let imageURL = URL (string : url) {
            do {
                let imageData = try Data (contentsOf : imageURL)
                if let image : UIImage = UIImage (data : imageData) {
                    return image
                }
            } catch {
                return nil
            }
        }
        return nil
    }

    fileprivate func getCreditsText () - > String {
        var creditsText : String = L10n.errorLoadingCredits
        if let totalCredits = UserDefaults.standard.userCredits {
            creditsText = "\(L10n.creditsAvailable): \(totalCredits)"
        }
        return creditsText
    }

    private func updateCreditsInVC () {
        CreditsUpdater.updateCredits {
            (success) in if success {
                self.rewardsViewController.viewData?.creditsText = self.getCreditsText ()
                self.rewardsViewController.adjustView ()
            }
        }
    }

    @IBAction func dismissLearnAboutPro () {
        rewardsViewController.dismiss (animated : true, completion : nil)
    }

    @IBAction func dismissYourDeal () {
        rewardsViewController.dismiss (animated : true, completion : nil)
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/OurValueTableViewController.swift" startline="1" endline="103">
import UIKit

class OurValueTableViewController : UIViewController, UITableViewDataSource, UITableViewDelegate {
    @IBOutlet private var tableView : UITableView?
    var viewData : Array <OurValueItem>?
    var endorsements : (() - > ())?

    override func viewDidLoad () {
        super.viewDidLoad ()
        tableView?.estimatedRowHeight = 73
        tableView?.rowHeight = UITableView.automaticDimension
        tableView?.backgroundColor = UIColor.clear
        tableView?.tableFooterView = UIView ()
    }

    override func viewDidAppear (_ animated : Bool) {
        super.viewDidAppear (animated)
        REPAnalytics.trackScreenWithName (screenName : ScreenName.HomePage.OurValue, className : String (describing : self))
    }

    func numberOfSections (in tableView : UITableView) - > Int {
        return 1
    }

    func tableView (_ tableView : UITableView, numberOfRowsInSection section : Int) - > Int {
        guard let count = viewData?.count else {
            return 0
        }
        return count
    }

    func tableView (_ tableView : UITableView, cellForRowAt indexPath : IndexPath) - > UITableViewCell {
        let defaultCell : UITableViewCell = UITableViewCell.init (style : .default, reuseIdentifier : "default")
        defaultCell.textLabel?.text = "Error"
        guard let viewData = self.viewData else {
            return defaultCell
        }
        if let endorsement : OurValueEndorsements = viewData [indexPath.row] as? OurValueEndorsements {
            guard let cell : EndorsementsTableViewCell = tableView.dequeueReusableCell (withIdentifier : Constants.OurValue.EndorsementsTableViewCellIdentifier, for : indexPath) as? EndorsementsTableViewCell else {
                return defaultCell
            }
            cell.selectionStyle = .none
            cell.setTitleLabelWithText (endorsement.question)
            return cell
        } else if let question : OurValueQuestion = viewData [indexPath.row] as? OurValueQuestion {
            guard let cell : OurValueTableViewCell = tableView.dequeueReusableCell (withIdentifier : Constants.OurValue.OurValueTableViewCellIdentifier, for : indexPath) as? OurValueTableViewCell else {
                return defaultCell
            }
            cell.selectionStyle = .none
            cell.setQuestionLabelWithText (question.question)
            cell.setAnswerLabelWithText (question.answer)
            if cell.expanded {
                cell.setAnswerLabelExpanded (true)
            } else {
                cell.setAnswerLabelExpanded (false)
            }
            return cell
        } else {
            return defaultCell
        }
    }

    func tableView (_ tableView : UITableView, didSelectRowAt indexPath : IndexPath) {
        if viewData? [indexPath.row] is OurValueEndorsements {
            endorsements? ()
        } else if viewData? [indexPath.row] is OurValueQuestion {
            guard let cell : OurValueTableViewCell = tableView.cellForRow (at : indexPath) as? OurValueTableViewCell else {
                return
            }
            if cell.expanded {
                cell.setAnswerLabelExpanded (false)
                cell.rotateDisclosure (forwards : false)
            } else {
                cell.setAnswerLabelExpanded (true)
                cell.rotateDisclosure (forwards : true)
            }
            tableView.beginUpdates ()
            tableView.endUpdates ()
        }
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/ProfileDataProvider.swift" startline="1" endline="34">
import Moya

class ProfileDataProvider {
    let submitProvider = MoyaProvider <SubmitService> ()

    func submitProfile (lifestyle : LifestyleType, gender : String, weight : Int, age : Int, countryCode : String, regionCode : String, completion :@escaping (Bool, String?) - > ()) {
        guard let token = UserDefaults.standard.userToken else {
            completion (false, L10n.userTokenMissingMessage)
            return
        }
        self.submitProvider.request ( .submitProfile (token : token, lifestyle_category : lifestyle, gender : gender, weight : weight, age : age, country_code : countryCode, region_code : regionCode)) {
            result in do {
                let response = try result.dematerialize ()
                let success = try response.mapSuccess ()
                completion (success, nil)
            } catch {
                completion (false, error.localizedDescription)
            }
        }
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/LifestyleDataProvider.swift" startline="1" endline="757">
import UIKit
struct QuestionnaireData {
    let questionnaireTitle : String
    var questions : Array <Question>
    init (questions : Array <Question>, questionnaireTitle : String) {
        self.questions = questions
        self.questionnaireTitle = questionnaireTitle
    }
}
struct Question {
    let questionTitle : String
    var possibleAnswers : Array <Answer>
    let index : Int
    init (possibleAnswers : Array <Answer>, questionTitle : String, index : Int) {
        self.questionTitle = questionTitle
        self.possibleAnswers = possibleAnswers
        self.index = index
    }
}
struct Answer {
    let title : String
    var selected : Bool
    let index : Int
    let points : Int
    init (answerTitle : String, answerSelected : Bool, index : Int, points : Int) {
        self.title = answerTitle
        self.selected = answerSelected
        self.index = index
        self.points = points
    }
}
struct BasicInfoData {
    let questionnaireTitle : String
    var valueAndUnitsQuestions : Array <ValueAndUnitsQuestion>
    var singleValueQuestions : Array <SingleValueQuestion>
    var normalQuestions : Array <Question>
    init (questionnaireTitle : String, valueAndUnitsQuestions : Array <ValueAndUnitsQuestion>, singleValueQuestions : Array <SingleValueQuestion>, normalQuestions : Array <Question>) {
        self.questionnaireTitle = questionnaireTitle
        self.valueAndUnitsQuestions = valueAndUnitsQuestions
        self.singleValueQuestions = singleValueQuestions
        self.normalQuestions = normalQuestions
    }
}
struct ValueAndUnitsQuestion {
    let title : String
    let index : Int
    var valueAnswer : ValueAnswer
    var units : Array <Answer>
    init (title : String, index : Int, valueAnswer : ValueAnswer, units : Array <Answer>) {
        self.title = title
        self.index = index
        self.valueAnswer = valueAnswer
        self.units = units
    }

    func unitSelected () - > Bool {
        var isSelected : Bool = false
        for unit in self.units {
            if unit.selected {
                isSelected = true
                break
            }
        }
        return isSelected
    }
}
struct SingleValueQuestion {
    let title : String
    let index : Int
    var valueAnswer : ValueAnswer
    init (title : String, index : Int, valueAnswer : ValueAnswer) {
        self.title = title
        self.index = index
        self.valueAnswer = valueAnswer
    }
}
struct ValueAnswer {
    let index : Int
    var value : String?
    init (index : Int, value : String?) {
        self.index = index
        self.value = value
    }
}

class LifestyleDataProvider : NSObject {
    let basicInfoContent = [0 : ["Weight" : [0 : ["value" : ""], 1 : ["title" : "lbs", "selected" : false, "points" : 0], 2 : ["title" : "Kg", "selected" : false, "points" : 0]]], 1 : ["Gender" : [0 : ["title" : "Male", "selected" : false, "points" : 0], 1
      : ["title" : "Female", "selected" : false, "points" : 0]]], 2 : ["Height" : [0 : ["value" : ""], 1 : ["title" : "in", "selected" : false, "points" : 0], 2 : ["title" : "cm", "selected" : false, "points" : 0]]], 3 : ["Age" : [0 : ["value" : ""]]], 4 :
      ["Country" : [0 : ["value" : ""]]], 5 : ["State/Province" : [0 : ["value" : ""]]], 6 : ["Where do you work out?" : [0 : ["title" : "Commercial gym", "selected" : false, "points" : 0], 1 : ["title" : "Recreation center", "selected" : false, "points" :
      0], 2 : ["title" : "Private gym", "selected" : false, "points" : 0], 3 : ["title" : "Home", "selected" : false, "points" : 0]]]]
    let nutritionContent = [0 : ["How many days a week do you pack food?" : [0 : ["title" : "1", "selected" : false, "points" : 0], 1 : ["title" : "2", "selected" : false, "points" : 2], 2 : ["title" : "3", "selected" : false, "points" : 4], 3 : ["title" :
      "4+", "selected" : false, "points" : 6]]], 1 : ["Rate you nutritional intake?" : [0 : ["title" : "I eat a balanced diet", "selected" : false, "points" : 6], 1 : ["title" : "I think I eat well", "selected" : false, "points" : 4], 2 : ["title" :
      "I don't care what I eat", "selected" : false, "points" : 2], 3 : ["title" : "I measure and weigh all my food", "selected" : false, "points" : 8]]], 2 : ["How many times a day do you eat protein?" : [0 : ["title" : "1", "selected" : false, "points" :
      0], 1 : ["title" : "2", "selected" : false, "points" : 2], 2 : ["title" : "3", "selected" : false, "points" : 8], 3 : ["title" : "4+", "selected" : false, "points" : 12]]], 3 : [
      "How many times a week do you eat sugary or salty snacks and/or desserts" : [0 : ["title" : "0", "selected" : false, "points" : 12], 1 : ["title" : "1-2", "selected" : false, "points" : 10], 2 : ["title" : "3-4", "selected" : false, "points" : 4], 3
      : ["title" : "5-6", "selected" : false, "points" : 2], 4 : ["title" : "5+", "selected" : false, "points" : 0]]], 4 : ["Which best describes your appetite:" : [0 : ["title" : "I eat big meals", "selected" : false, "points" : 6], 1 : ["title" :
      "I eat sparsely", "selected" : false, "points" : 2], 2 : ["title" : "I eat small amounts frequently", "selected" : false, "points" : 6], 3 : ["title" : "I practise portion control", "selected" : false, "points" : 10]]], 5 : [
      "How many times a week do you eat out?" : [0 : ["title" : "0-1", "selected" : false, "points" : 10], 1 : ["title" : "2-3", "selected" : false, "points" : 8], 2 : ["title" : "4-5", "selected" : false, "points" : 4], 3 : ["title" : "6-7", "selected" :
      false, "points" : 2], 4 : ["title" : "8+", "selected" : false, "points" : 0]]], 6 : ["Rate your water intake:" : [0 : ["title" : "I don't really like water", "selected" : false, "points" : 2], 1 : ["title" : "I never drink water", "selected" : false
      , "points" : 0], 2 : ["title" : "Water is my go to", "selected" : false, "points" : 8]]]]
    let lifestyleContent = [0 : ["What best describes your sleep?" : [0 : ["title" : "I sleep okay", "selected" : false, "points" : 4], 1 : ["title" : "I'm a restless sleeper", "selected" : false, "points" : 2], 2 : ["title" : "I wake up tired", "selected"
      : false, "points" : 0], 3 : ["title" : "I'm a sound sleeper", "selected" : false, "points" : 12]]], 1 : ["How many times per week do you feel stressed?" : [0 : ["title" : "Rarely", "selected" : false, "points" : 12], 1 : ["title" : "Sometimes",
      "selected" : false, "points" : 8], 2 : ["title" : "Often", "selected" : false, "points" : 4], 3 : ["title" : "Always", "selected" : false, "points" : 2]]], 2 : ["How many alcoholic drinks do you have per week?" : [0 : ["title" : "0-2", "selected" :
      false, "points" : 12], 1 : ["title" : "3-7", "selected" : false, "points" : 6], 2 : ["title" : "8-10", "selected" : false, "points" : 4], 3 : ["title" : "11+", "selected" : false, "points" : 0]]], 3 : [
      "Do you play recreational sports or have active hobbies?" : [0 : ["title" : "Yes", "selected" : false, "points" : 8], 1 : ["title" : "No", "selected" : false, "points" : 0]]], 4 : ["Do you smoke" : [0 : ["title" : "Yes", "selected" : false, "points"
      : 0], 1 : ["title" : "No", "selected" : false, "points" : 8]]], 5 : ["Do you play a sport at the collegiate or professional level?" : [0 : ["title" : "Yes", "selected" : false, "points" : 12], 1 : ["title" : "No", "selected" : false, "points" : 0]]]
      ]
    let exerciseContent = [0 : ["How long have you been exercising?" : [0 : ["title" : "0-3 months", "selected" : false, "points" : 0], 1 : ["title" : "3 months to 1 year", "selected" : false, "points" : 2], 2 : ["title" : "1-3 years", "selected" : false,
      "points" : 12], 3 : ["title" : "3 years plus", "selected" : false, "points" : 18]]], 2 : ["How many times per week do you exercise?" : [0 : ["title" : "1", "selected" : false, "points" : 0], 1 : ["title" : "2", "selected" : false, "points" : 2], 2 :
      ["title" : "3", "selected" : false, "points" : 10], 3 : ["title" : "4", "selected" : false, "points" : 8], 4 : ["title" : "5+", "selected" : false, "points" : 4]]], 3 : ["Which best describes your level of intensity?" : [0 : ["title" :
      "I don't generally sweat", "selected" : false, "points" : 10], 1 : ["title" : "I sweat on and off", "selected" : false, "points" : 2], 2 : ["title" : "I sweat the whole time", "selected" : false, "points" : 4]]], 4 : ["How long is your workout" : [0
      : ["title" : "0 to 20 minutes", "selected" : false, "points" : 2], 1 : ["title" : "20 to 40 minutes", "selected" : false, "points" : 4], 2 : ["title" : "40 minutes to 1 hour", "selected" : false, "points" : 6], 3 : ["title" : "1 hour +", "selected" :
      false, "points" : 12]]], 5 : ["Does your workout include any of the following?" : [0 : ["title" : "A personal trainer", "selected" : false, "points" : 3], 1 : ["title" : "A work out partner", "selected" : false, "points" : 4], 2 : ["title" :
      "Group class", "selected" : false, "points" : 2], 3 : ["title" : "Solo mission", "selected" : false, "points" : 1], 4 : ["title" : "Strength and conditioning coach", "selected" : false, "points" : 4]]], 6 : ["Describe the way you workout:" : [0 : [
      "title" : "Steady state/interval based cardio", "selected" : false, "points" : 2], 1 : ["title" : "Cross training/functional fitness", "selected" : false, "points" : 3], 2 : ["title" : "Body building", "selected" : false, "points" : 6], 3 : ["title"
      : "Power lifting/olympic lifting", "selected" : false, "points" : 50], 4 : ["title" : "Sport specific", "selected" : false, "points" : 8]]]]

    private func constructQuestionnaireData (content : [Int : Dictionary <String, Dictionary <Int, Dictionary <String, Any>>>], questionnaireTitle : String) - > QuestionnaireData? {
        var questions : Array <Question> = []
        for (currentQuestionIndex, currentQuestion) in content {
            for (currentQuestionTitle, currentAnswer) in currentQuestion {
                var possibleAnswers : Array <Answer> = []
                for (currentAnswerIndex, currentAnswerBody) in currentAnswer {
                    guard let title : String = currentAnswerBody [Constants.Profile.TitleKey] as? String else {
                        return nil
                    }
                    guard let selected : Bool = currentAnswerBody [Constants.Profile.SelectedKey] as? Bool else {
                        return nil
                    }
                    guard let points : Int = currentAnswerBody [Constants.Profile.PointsKey] as? Int else {
                        return nil
                    }
                    let possibleAnswer : Answer = Answer (answerTitle : title, answerSelected : selected, index : currentAnswerIndex, points : points)
                    possibleAnswers.append (possibleAnswer)
                }
                possibleAnswers.sort (by : sorterForAnswers (a1 : a2 :))
                let question : Question = Question (possibleAnswers : possibleAnswers, questionTitle : currentQuestionTitle, index : currentQuestionIndex)
                questions.append (question)
            }
        }
        questions.sort (by : sorterForQuestions (q1 : q2 :))
        return QuestionnaireData (questions : questions, questionnaireTitle : questionnaireTitle)
    }

    private func constructPersistenceLayerData (questionnaireData : QuestionnaireData) - > [Int : Dictionary <String, Dictionary <Int, Dictionary <String, Any>>>] {
        var content : [Int : Dictionary <String, Dictionary <Int, Dictionary <String, Any>>>] = [:]
        for question in questionnaireData.questions {
            var answersToSave : Dictionary <Int, Dictionary <String, Any>> = [:]
            for possibleAnswer in question.possibleAnswers {
                answersToSave [possibleAnswer.index] = [Constants.Profile.TitleKey : possibleAnswer.title, Constants.Profile.SelectedKey : possibleAnswer.selected, Constants.Profile.PointsKey : possibleAnswer.points]
            }
            content [question.index] = [question.questionTitle : answersToSave]
        }
        return content
    }

    private func constructBasicInfoContent (content : [Int : Dictionary <String, Dictionary <Int, Dictionary <String, Any>>>]) - > BasicInfoData? {
        var valueAndUnitsQuestions : Array <ValueAndUnitsQuestion> = []
        var singleValueQuestions : Array <SingleValueQuestion> = []
        var questions : Array <Question> = []
        for (currentQuestionIndex, currentQuestion) in content {
            for (currentQuestionTitle, currentAnswer) in currentQuestion {
                switch currentQuestionIndex {
                    case 0, 2 :
                        var units : Array <Answer> = []
                        var questionValueAnswer : ValueAnswer?
                        for (currentAnswerIndex, currentAnswerBody) in currentAnswer {
                            switch currentAnswerIndex {
                                case 0 :
                                    guard let answerValue : String = currentAnswerBody [Constants.Profile.ValueKey] as? String else {
                                        return nil
                                    }
                                    questionValueAnswer = ValueAnswer (index : currentAnswerIndex, value : answerValue)
                                case 1, 2 :
                                    guard let title : String = currentAnswerBody [Constants.Profile.TitleKey] as? String else {
                                        return nil
                                    }
                                    guard let selected : Bool = currentAnswerBody [Constants.Profile.SelectedKey] as? Bool else {
                                        return nil
                                    }
                                    guard let points : Int = currentAnswerBody [Constants.Profile.PointsKey] as? Int else {
                                        return nil
                                    }
                                    let possibleAnswer : Answer = Answer (answerTitle : title, answerSelected : selected, index : currentAnswerIndex, points : points)
                                    units.append (possibleAnswer)
                                default :
                                    return nil
                            }
                        }
                        guard let valueAnswer : ValueAnswer = questionValueAnswer else {
                            return nil
                        }
                        units.sort (by : sorterForAnswers (a1 : a2 :))
                        valueAndUnitsQuestions.append (ValueAndUnitsQuestion (title : currentQuestionTitle, index : currentQuestionIndex, valueAnswer : valueAnswer, units : units))
                    case 1, 6 :
                        var possibleAnswers : Array <Answer> = []
                        for (currentAnswerIndex, currentAnswerBody) in currentAnswer {
                            guard let title : String = currentAnswerBody [Constants.Profile.TitleKey] as? String else {
                                return nil
                            }
                            guard let selected : Bool = currentAnswerBody [Constants.Profile.SelectedKey] as? Bool else {
                                return nil
                            }
                            guard let points : Int = currentAnswerBody [Constants.Profile.PointsKey] as? Int else {
                                return nil
                            }
                            let possibleAnswer : Answer = Answer (answerTitle : title, answerSelected : selected, index : currentAnswerIndex, points : points)
                            possibleAnswers.append (possibleAnswer)
                        }
                        possibleAnswers.sort (by : sorterForAnswers (a1 : a2 :))
                        questions.append (Question (possibleAnswers : possibleAnswers, questionTitle : currentQuestionTitle, index : currentQuestionIndex))
                    case 3, 4, 5 :
                        var questionValueAnswer : ValueAnswer?
                        for (currentAnswerIndex, currentAnswerBody) in currentAnswer {
                            guard let answerValue : String = currentAnswerBody [Constants.Profile.ValueKey] as? String else {
                                return nil
                            }
                            questionValueAnswer = ValueAnswer (index : currentAnswerIndex, value : answerValue)
                        }
                        guard let valueAnswer = questionValueAnswer else {
                            return nil
                        }
                        singleValueQuestions.append (SingleValueQuestion (title : currentQuestionTitle, index : currentQuestionIndex, valueAnswer : valueAnswer))
                    default :
                        return nil
                }
            }
        }
        valueAndUnitsQuestions.sort (by : sorterForValueAndUnitsQuestions (q1 : q2 :))
        singleValueQuestions.sort (by : sorterForSingleValueQuestions (q1 : q2 :))
        questions.sort (by : sorterForQuestions (q1 : q2 :))
        return BasicInfoData (questionnaireTitle : "Basic Info", valueAndUnitsQuestions : valueAndUnitsQuestions, singleValueQuestions : singleValueQuestions, normalQuestions : questions)
    }

    private func constructPersistenceLayerBasicInfoData (basicInfoData : BasicInfoData) - > [Int : Dictionary <String, Dictionary <Int, Dictionary <String, Any>>>] {
        var basicInfoContent : [Int : Dictionary <String, Dictionary <Int, Dictionary <String, Any>>>] = [:]
        for valueAndUnitsQuestion in basicInfoData.valueAndUnitsQuestions {
            var valueAnswer : Dictionary <Int, Dictionary <String, Any>> = [:]
            guard let value = valueAndUnitsQuestion.valueAnswer.value else {
                return [:]
            }
            valueAnswer [valueAndUnitsQuestion.valueAnswer.index] = [Constants.Profile.ValueKey : value]
            for possibleAnswer in valueAndUnitsQuestion.units {
                valueAnswer [possibleAnswer.index] = [Constants.Profile.TitleKey : possibleAnswer.title, Constants.Profile.SelectedKey : possibleAnswer.selected, Constants.Profile.PointsKey : possibleAnswer.points]
            }
            basicInfoContent [valueAndUnitsQuestion.index] = [valueAndUnitsQuestion.title : valueAnswer]
        }
        for singleValueQuestion in basicInfoData.singleValueQuestions {
            var singleValueAnswer : Dictionary <Int, Dictionary <String, Any>> = [:]
            guard let value = singleValueQuestion.valueAnswer.value else {
                return [:]
            }
            singleValueAnswer [singleValueQuestion.valueAnswer.index] = [Constants.Profile.ValueKey : value]
            basicInfoContent [singleValueQuestion.index] = [singleValueQuestion.title : singleValueAnswer]
        }
        for question in basicInfoData.normalQuestions {
            var answersToSave : Dictionary <Int, Dictionary <String, Any>> = [:]
            for possibleAnswer in question.possibleAnswers {
                answersToSave [possibleAnswer.index] = [Constants.Profile.TitleKey : possibleAnswer.title, Constants.Profile.SelectedKey : possibleAnswer.selected, Constants.Profile.PointsKey : possibleAnswer.points]
            }
            basicInfoContent [question.index] = [question.questionTitle : answersToSave]
        }
        return basicInfoContent
    }

    func sorterForQuestions (q1 : Question, q2 : Question) - > Bool {
        return q1.index<
        q2.index
    }

    func sorterForAnswers (a1 : Answer, a2 : Answer) - > Bool {
        return a1.index<
        a2.index
    }

    func sorterForValueAndUnitsQuestions (q1 : ValueAndUnitsQuestion, q2 : ValueAndUnitsQuestion) - > Bool {
        return q1.index<
        q2.index
    }

    func sorterForSingleValueQuestions (q1 : SingleValueQuestion, q2 : SingleValueQuestion) - > Bool {
        return q1.index<
        q2.index
    }

    func saveBasicInfoData (_ basicInfoData : BasicInfoData) {
        let paths = NSSearchPathForDirectoriesInDomains ( .documentDirectory, .userDomainMask, true) as NSArray
        guard let documentDirectory : String = paths [0] as? String else {
            return
        }
        let path = documentDirectory.appending (Constants.Profile.BasicInfoQuestionnaireFilePath)
        let basicInfoDict : [Int : Dictionary <String, Dictionary <Int, Dictionary <String, Any>>>] = self.constructPersistenceLayerBasicInfoData (basicInfoData : basicInfoData)
        NSKeyedArchiver.archiveRootObject (basicInfoDict, toFile : path)
        UserDefaults.standard.userAge = getAge (basicInfo : basicInfoData)
        UserDefaults.standard.userWeight = getWeightInPounds (basicInfo : basicInfoData)
        UserDefaults.standard.userGender = getGender (basicInfo : basicInfoData)
        if let countryName = getCountryName (), let provinceName = getProvinceName () {
            UserDefaults.standard.userCurrentLocation = "\(provinceName), \(countryName)"
        } else {
            UserDefaults.standard.userCurrentLocation = ""
        }
    }

    func loadBasicInfoData () - > BasicInfoData? {
        let paths = NSSearchPathForDirectoriesInDomains ( .documentDirectory, .userDomainMask, true) as NSArray
        guard let documentDirectory : String = paths [0] as? String else {
            return self.constructBasicInfoContent (content : self.basicInfoContent)
        }
        let path = documentDirectory.appending (Constants.Profile.BasicInfoQuestionnaireFilePath)
        let fileManager = FileManager.default
        if (! (fileManager.fileExists (atPath : path))) {
            return self.constructBasicInfoContent (content : self.basicInfoContent)
        } else {
            guard let unarchivedBasicInfoData : [Int : Dictionary <String, Dictionary <Int, Dictionary <String, Any>>>] = NSKeyedUnarchiver.unarchiveObject (withFile : path) as? [Int : Dictionary <String, Dictionary <Int, Dictionary <String, Any>>>] else {
                return self.constructBasicInfoContent (content : self.basicInfoContent)
            }
            return self.constructBasicInfoContent (content : unarchivedBasicInfoData)
        }
    }

    func saveQuestionnaireData (_ questionnaireData : QuestionnaireData, lifestyleQuizType : LifestyleQuizType) {
        let paths = NSSearchPathForDirectoriesInDomains ( .documentDirectory, .userDomainMask, true) as NSArray
        guard let documentDirectory : String = paths [0] as? String else {
            return
        }
        var filePath : String = ""
        switch lifestyleQuizType {
            case.Nutrition :
                filePath = Constants.Profile.NutritionQuestionnaireFilePath
            case.LifeStyle :
                filePath = Constants.Profile.LifestyleQuestionnaireFilePath
            case.Exercise :
                filePath = Constants.Profile.ExerciseQuestionnaireFilePath
            default :
                return
        }
        let path = documentDirectory.appending (filePath)
        let questionnaireDict : [Int : Dictionary <String, Dictionary <Int, Dictionary <String, Any>>>] = self.constructPersistenceLayerData (questionnaireData : questionnaireData)
        NSKeyedArchiver.archiveRootObject (questionnaireDict, toFile : path)
    }

    func loadQuestionnaireData (lifestyleQuizType : LifestyleQuizType) - > QuestionnaireData? {
        var filePath : String = ""
        var content : [Int : Dictionary <String, Dictionary <Int, Dictionary <String, Any>>>] = [:]
        var questionnaireTitle : String = ""
        switch lifestyleQuizType {
            case.Nutrition :
                filePath = Constants.Profile.NutritionQuestionnaireFilePath
                content = self.nutritionContent
                questionnaireTitle = Constants.Profile.NutritionQuestionnaireTitle
            case.LifeStyle :
                filePath = Constants.Profile.LifestyleQuestionnaireFilePath
                content = self.lifestyleContent
                questionnaireTitle = Constants.Profile.LifestyleQuestionnaireTitle
            case.Exercise :
                filePath = Constants.Profile.ExerciseQuestionnaireFilePath
                content = self.exerciseContent
                questionnaireTitle = Constants.Profile.ExerciseQuestionnaireTitle
            default :
                return self.constructQuestionnaireData (content : content, questionnaireTitle : questionnaireTitle)
        }
        let paths = NSSearchPathForDirectoriesInDomains ( .documentDirectory, .userDomainMask, true) as NSArray
        guard let documentDirectory : String = paths [0] as? String else {
            return self.constructQuestionnaireData (content : content, questionnaireTitle : questionnaireTitle)
        }
        let path = documentDirectory.appending (filePath)
        let fileManager = FileManager.default
        if (! (fileManager.fileExists (atPath : path))) {
            return self.constructQuestionnaireData (content : content, questionnaireTitle : questionnaireTitle)
        } else {
            guard let unarchivedQuestionnaireData : [Int : Dictionary <String, Dictionary <Int, Dictionary <String, Any>>>] = NSKeyedUnarchiver.unarchiveObject (withFile : path) as? [Int : Dictionary <String, Dictionary <Int, Dictionary <String, Any>>>]
              else {
                return self.constructQuestionnaireData (content : content, questionnaireTitle : questionnaireTitle)
            }
            return self.constructQuestionnaireData (content : unarchivedQuestionnaireData, questionnaireTitle : questionnaireTitle)
        }
    }

    class func wipeAllQuestionnaireDataFromPersistenceLayer (completion : ((_ success : Bool, _ error : String?) - > ())?) {
        let filePaths : [String] = [Constants.Profile.BasicInfoQuestionnaireFilePath, Constants.Profile.NutritionQuestionnaireFilePath, Constants.Profile.LifestyleQuestionnaireFilePath, Constants.Profile.ExerciseQuestionnaireFilePath]
        let paths = NSSearchPathForDirectoriesInDomains ( .documentDirectory, .userDomainMask, true) as NSArray
        guard let documentDirectory : String = paths [0] as? String else {
            completion? (false, "Failed to find documents")
            return
        }
        let fileManager = FileManager.default
        for filePath in filePaths {
            let path = documentDirectory.appending (filePath)
            if (fileManager.fileExists (atPath : path)) {
                do {
                    try fileManager.removeItem (atPath : path)
                } catch let error as NSError {
                    completion? (false, error.debugDescription)
                    return
                }
            }
        }
        completion? (true, nil)
    }

    func getAge (basicInfo : BasicInfoData) - > Int? {
        for question in basicInfo.singleValueQuestions {
            if question.index == Constants.Profile.BasicInfoAgeQuestionIndex {
                guard let age = question.valueAnswer.value else {
                    return nil
                }
                return Int (age)
            }
        }
        return nil
    }

    func getWeightInPounds (basicInfo : BasicInfoData) - > Int? {
        for question in basicInfo.valueAndUnitsQuestions {
            if question.index == Constants.Profile.BasicInfoWeightQuestionIndex {
                guard let weight : String = question.valueAnswer.value else {
                    return nil
                }
                for unit in question.units {
                    if unit.index == 2 {
                        if unit.selected {
                            guard let weightInKG : Double = Double (weight) else {
                                return nil
                            }
                            let weightInPounds : Double = weightInKG*
                            Constants.Profile.PoundsPerKilogram
                            let rounded : Double = round (weightInPounds)
                            return Int (rounded)
                        }
                    }
                }
                return Int (weight)
            }
        }
        return nil
    }

    func getGender (basicInfo : BasicInfoData) - > String? {
        for question in basicInfo.normalQuestions {
            if question.index == Constants.Profile.BasicInfoGenderQuestionIndex {
                for answer in question.possibleAnswers {
                    if answer.selected {
                        return answer.title
                    }
                }
            }
        }
        return nil
    }

    func checkUnitsComplete (basicInfoQuestionnaire : BasicInfoData) - > (weightComplete : Bool, heightComplete : Bool) {
        var weight = true
        var height = true
        for ValueAndUnitsQuestion in basicInfoQuestionnaire.valueAndUnitsQuestions {
            if ValueAndUnitsQuestion.index == Constants.Profile.BasicInfoWeightQuestionIndex {
                if ValueAndUnitsQuestion.valueAnswer.value! = ""&& ! ValueAndUnitsQuestion.unitSelected () {
                    weight = false
                }
            }
            if ValueAndUnitsQuestion.index == Constants.Profile.BasicInfoHeightQuestionIndex {
                if ValueAndUnitsQuestion.valueAnswer.value! = ""&& ! ValueAndUnitsQuestion.unitSelected () {
                    height = false
                }
            }
        }
        return (weight, height)
    }

    func sumAllPoints () - > Int? {
        guard let nutritionPoints = totalPointsForLifestyleQuizType ( .Nutrition) else {
            return nil
        }
        guard let lifestylePoints = totalPointsForLifestyleQuizType ( .LifeStyle) else {
            return nil
        }
        guard let exercisePoints = totalPointsForLifestyleQuizType ( .Exercise) else {
            return nil
        }
        let total : Int = nutritionPoints+
        lifestylePoints+
        exercisePoints
        if basicInfoQuizComplete () {
            return total
        } else {
            return nil
        }
    }

    func totalPointsForLifestyleQuizType (_ lifestyleQuizType : LifestyleQuizType) - > Int? {
        guard let questionnaire : QuestionnaireData = self.loadQuestionnaireData (lifestyleQuizType : lifestyleQuizType) else {
            return nil
        }
        var totalForQuestionnaire : Int = 0
        for question in questionnaire.questions {
            var questionAnswered : Bool = false
            for answer in question.possibleAnswers {
                if answer.selected {
                    totalForQuestionnaire = totalForQuestionnaire+
                    answer.points
                    questionAnswered = true
                }
            }
            if ! questionAnswered {
                return nil
            }
        }
        return totalForQuestionnaire
    }

    func basicInfoQuizComplete () - > Bool {
        guard let basicInfoQuestionnaire : BasicInfoData = self.loadBasicInfoData () else {
            return false
        }
        for valueAndUnitsQuestion in basicInfoQuestionnaire.valueAndUnitsQuestions {
            if valueAndUnitsQuestion.valueAnswer.value == nil || valueAndUnitsQuestion.valueAnswer.value == "" {
                return false
            }
            var atLeastOneSelected : Bool = false
            for unit in valueAndUnitsQuestion.units {
                if unit.selected {
                    atLeastOneSelected = true
                }
            }
            if ! atLeastOneSelected {
                return false
            }
        }
        for singleValueQuestion in basicInfoQuestionnaire.singleValueQuestions {
            if singleValueQuestion.valueAnswer.value == nil || singleValueQuestion.valueAnswer.value == "" {
                return false
            }
        }
        for question in basicInfoQuestionnaire.normalQuestions {
            var questionAnswered : Bool = false
            for answer in question.possibleAnswers {
                if answer.selected {
                    questionAnswered = true
                }
            }
            if ! questionAnswered {
                return false
            }
        }
        return true
    }

    func getCountryName () - > String? {
        guard let basicInfo : BasicInfoData = self.loadBasicInfoData () else {
            return nil
        }
        for question in basicInfo.singleValueQuestions {
            if question.index == Constants.Profile.BasicInfoCountryQuestionIndex {
                let locations = LocationsDataProvider.loadLoactionsFromFile ()
                if let countries = locations?.countries {
                    for country in countries {
                        if country.id == question.valueAnswer.value {
                            return country.name
                        }
                    }
                }
            }
        }
        return nil
    }

    func getProvinceName () - > String? {
        guard let basicInfo : BasicInfoData = self.loadBasicInfoData () else {
            return nil
        }
        for question in basicInfo.singleValueQuestions {
            if question.index == Constants.Profile.BasicInfoProvinceQuestionIndex {
                let locations = LocationsDataProvider.loadLoactionsFromFile ()
                if let countries = locations?.countries {
                    for country in countries {
                        for province in country.provinces {
                            if province.id == question.valueAnswer.value {
                                return province.name
                            }
                        }
                    }
                }
            }
        }
        return nil
    }

    func getCountryID () - > String? {
        guard let basicInfo : BasicInfoData = self.loadBasicInfoData () else {
            return nil
        }
        for question in basicInfo.singleValueQuestions {
            if question.index == Constants.Profile.BasicInfoCountryQuestionIndex {
                return question.valueAnswer.value
            }
        }
        return nil
    }

    func getProvinceID () - > String? {
        guard let basicInfo : BasicInfoData = self.loadBasicInfoData () else {
            return nil
        }
        for question in basicInfo.singleValueQuestions {
            if question.index == Constants.Profile.BasicInfoProvinceQuestionIndex {
                return question.valueAnswer.value
            }
        }
        return nil
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/OnboardingDataProvider.swift" startline="1" endline="108">
import Moya
struct LoginData {
    let token : String
    let userID : String
    let lastName : String
    let firstName : String
    init (token : String, userID : String, lastName : String, firstName : String) {
        self.token = token
        self.userID = userID
        self.lastName = lastName
        self.firstName = firstName
    }
}

class OnboardingDataProvider {
    let provider = MoyaProvider <OnboardingService> ()

    func login (email : String, password : String, completion :@escaping (LoginData?, String?) - > ()) {
        provider.request ( .login (email : email, password : password)) {
            result in do {
                let response = try result.dematerialize ()
                let loginData = try response.mapToken ()
                completion (loginData, nil)
            } catch {
                completion (nil, error.localizedDescription)
            }
        }
    }

    func signInWithFacebook (userID : String, token : String, completion :@escaping (LoginData?, String?) - > ()) {
        provider.request ( .signupWithFacebook (facebookID : userID, facebookToken : token)) {
            result in do {
                let response = try result.dematerialize ()
                let loginData = try response.mapToken ()
                completion (loginData, nil)
            } catch {
                completion (nil, error.localizedDescription)
            }
        }
    }

    func createAccount (first : String, last : String, email : String, password : String, completion :@escaping (Bool, String?) - > ()) {
        provider.request ( .createAccount (first : first, last : last, email : email, password : password)) {
            result in do {
                let response = try result.dematerialize ()
                let success = try response.mapSuccess ()
                completion (success, nil)
            } catch {
                completion (false, error.localizedDescription)
            }
        }
    }

    func forgotPassword (email : String, completion :@escaping (Bool, String?) - > ()) {
        provider.request ( .forgotPassword (email : email)) {
            result in do {
                let response = try result.dematerialize ()
                let success = try response.mapSuccess ()
                completion (success, nil)
            } catch {
                let printableError = error as CustomStringConvertible
                let errorMessage = printableError.description
                completion (false, errorMessage)
            }
        }
    }
}

extension Moya.Response {

    func mapToken () throws - > LoginData {
        let responseObject = try self.map (to : REPerformanceResponse.self)
        guard responseObject.success else {
            throw REPerformanceError.requestFailed (responseObject.message)
        }
        guard let token = responseObject.data ["token"]?.stringValue else {
            throw MoyaError.jsonMapping (self)
        }
        guard let userID = responseObject.data ["user_id"]?.stringValue else {
            throw MoyaError.jsonMapping (self)
        }
        guard let lastName = responseObject.data ["last_name"]?.stringValue else {
            throw MoyaError.jsonMapping (self)
        }
        guard let firstName = responseObject.data ["first_name"]?.stringValue else {
            throw MoyaError.jsonMapping (self)
        }
        return LoginData (token : token, userID : userID, lastName : lastName, firstName : firstName)
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/ExercisesReportMileViewController.swift" startline="1" endline="98">
import UIKit

class ExercisesReportMileRunViewController : ExercisesReportFortyYardDashViewController {
    private let minTextFieldUpperBounds : Int = 1000
    @IBOutlet private var leftDivider : UIView?
    @IBOutlet private var minLabel : UILabel?
    @IBOutlet private var minTextField : REPCustomTextField?
    @IBOutlet var averageHeartrateTextField : REPCustomTextField?

    override func setUpView () {
        super.setUpView ()
        minLabel?.textColor = UIColor.white
        minTextField?.keyboardType = .numberPad
        averageHeartrateTextField?.keyboardType = .numberPad
        minTextField?.addTarget (self, action : #selector (textFieldDidChange (textField :)), for : .editingChanged)
        averageHeartrateTextField?.addTarget (self, action : #selector (textFieldDidChange (textField :)), for : .editingChanged)
        minTextField?.textColor = UIColor.white
        averageHeartrateTextField?.roundCornersAndApplyBorder ()
        leftDivider?.backgroundColor = UIColor.init (named : .rePerformanceOrange)
    }

    override func wipeView () {
        super.wipeView ()
        minTextField?.text = ""
        averageHeartrateTextField?.text = ""
    }

    override func textFieldDidChange (textField : REPCustomTextField) {
        let upperBounds : Int = {
            if textField == self.minTextField {
                return self.minTextFieldUpperBounds
            } else if textField == self.secTextField {
                return self.secTextFieldUpperBounds
            } else if textField == self.msTextField {
                return self.msTextFieldUpperBounds
            } else if textField == self.averageHeartrateTextField {
                return self.averageHeartRateTextFieldUpperBounds
            } else {
                return 0
            }
        } ()
        let sanitizedResult = textField.sanitizeIntegerInput (upperBounds : upperBounds)
        if textField == self.minTextField {
            exerciseScore.minutes = sanitizedResult
        } else if textField == self.secTextField {
            exerciseScore.seconds = sanitizedResult
        } else if textField == self.msTextField {
            exerciseScore.milliseconds = sanitizedResult
        } else if textField == self.averageHeartrateTextField {
            exerciseScore.heartrate = sanitizedResult
        }
        if let sanitizedResult = sanitizedResult {
            textField.text = String (sanitizedResult)
        } else {
            textField.text = ""
        }
        if (exerciseScore.minutes! = nil)|| (exerciseScore.seconds! = nil)|| (exerciseScore.milliseconds! = nil) {
            submitScoreButton?.setEnabled (enabled : true)
        } else {
            submitScoreButton?.setEnabled (enabled : false)
        }
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/Challenge.swift" startline="1" endline="125">
import Foundation
enum ChallengeRule : String, Decodable {
    case leader = "by_leader"
    case date = "by_date"
}
enum ChallengeType : String, Decodable {
    case personal = "personal"
    case gym = "gym"
}
struct Challenge : Decodable {
    private enum CodingKeys : String, CodingKey {
        case uniqueIdentifier = "id"
        case name = "name"
        case description = "description"
        case hasJoined = "has_joined"
        case subtitle = "subtitle"
        case reps = "reps"
        case rule = "rule"
        case imageURL = "image_url"
        case gymOne = "gym_one"
        case gymTwo = "gym_two"
        case gyms = "gyms"
        case complete = "complete"
        case joinedTotal = "joined_no"
        case type = "type"
        case exercise = "exercise"
        case format = "format"
        case startDate = "start_date"
        case endDate = "end_date"
    }
    let uniqueIdentifier : Int
    let name : String
    let description : String
    var hasJoined : Bool
    let subtitle : String?
    let reps : Int?
    let rule : ChallengeRule
    let imageURL : URL?
    private let gymOne : Gym?
    private let gymTwo : Gym?
    let gyms : [Gym]?
    let complete : Bool
    let joinedTotal : Int
    let type : ChallengeType
    let exercise : ExerciseCategory?
    let format : String
    private let startDateString : String?
    private let endDateString : String?
    var startDate : Date? {
        get {
            guard let startDateString = self.startDateString else {
                return nil
            }
            let dateFormatter = DateFormatter.serverDateFormatter ()
            return dateFormatter.date (from : startDateString)
        }
    }
    var endDate : Date? {
        get {
            guard let endDateString = self.endDateString else {
                return nil
            }
            let dateFormatter = DateFormatter.serverDateFormatter ()
            return dateFormatter.date (from : endDateString)
        }
    }
    var hasExpired : Bool? {
        get {
            guard let endDate = self.endDate else {
                return nil
            }
            return (endDate.compare (Date ())==.orderedAscending)
        }
    }
    init (from decoder : Decoder) throws {
        let container = try decoder.container (keyedBy : CodingKeys.self)
        self.uniqueIdentifier = try container.decode (Int.self, forKey : .uniqueIdentifier)
        self.name = try container.decode (String.self, forKey : .name)
        self.description = try container.decode (String.self, forKey : .description)
        self.hasJoined = try container.decode (Bool.self, forKey : .hasJoined)
        self.subtitle = try? container.decode (String.self, forKey : .subtitle)
        self.reps = try? container.decode (Int.self, forKey : .reps)
        self.rule = try container.decode (ChallengeRule.self, forKey : .rule)
        self.imageURL = try? container.decode (URL.self, forKey : .imageURL)
        self.gymOne = try? container.decode (Gym.self, forKey : .gymOne)
        self.gymTwo = try? container.decode (Gym.self, forKey : .gymTwo)
        self.complete = try container.decode (Bool.self, forKey : .complete)
        self.gyms = try? container.decode ([Gym].self, forKey : .gyms)
        self.joinedTotal = try container.decode (Int.self, forKey : .joinedTotal)
        self.startDateString = try? container.decode (String.self, forKey : .startDate)
        self.endDateString = try? container.decode (String.self, forKey : .endDate)
        self.type = try container.decode (ChallengeType.self, forKey : .type)
        self.exercise = try container.decode (ExerciseCategory.self, forKey : .exercise)
        self.format = try container.decode (String.self, forKey : .format)
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/BlockBarButtonItem.swift" startline="1" endline="37">
import UIKit

class BlockBarButtonItem : UIBarButtonItem {
    private var actionHandler : (() - > ())?
    convenience init (title : String?, style : UIBarButtonItem.Style, actionHandler : (() - > ())?) {
        self.init (title : title, style : style, target : nil, action : nil)
        self.target = self
        self.action = #selector (self.barButtonItemPressed (sender :))
        self.actionHandler = actionHandler
    }
    convenience init (barButtonSystemItem systemItem : UIBarButtonItem.SystemItem, actionHandler : (() - > ())?) {
        self.init (barButtonSystemItem : systemItem, target : nil, action : nil)
        self.target = self
        self.action = #selector (self.barButtonItemPressed (sender :))
        self.actionHandler = actionHandler
    }

    @objc private func barButtonItemPressed (sender : UIBarButtonItem) {
        if let actionHandler = self.actionHandler {
            actionHandler ()
        }
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/EndorsementsViewController.swift" startline="1" endline="74">
import UIKit
import youtube_ios_player_helper
struct EndorsementsViewData {
    let player1Name : String
    let player1Description : String
    let player2Name : String
    let player2Description : String
    let player3Name : String
    let player3Description : String
    init (player1Name : String, player1Description : String, player2Name : String, player2Description : String, player3Name : String, player3Description : String) {
        self.player1Name = player1Name
        self.player1Description = player1Description
        self.player2Name = player2Name
        self.player2Description = player2Description
        self.player3Name = player3Name
        self.player3Description = player3Description
    }
}

class EndorsementsViewController : UIViewController {
    @IBOutlet private var endorsementVideoView : YTPlayerView? {
        didSet {
            self.endorsementVideoView?.load (withVideoId : Constants.OurValue.EndorsementsVideoYouTubeID)
        }
    }
    @IBOutlet private var player1NameLabel : UILabel?
    @IBOutlet private var player1DescriptionLabel : UILabel?
    @IBOutlet private var player2NameLabel : UILabel?
    @IBOutlet private var player2DescriptionLabel : UILabel?
    @IBOutlet private var player3NameLabel : UILabel?
    @IBOutlet private var player3DescriptionLabel : UILabel?
    var viewData : EndorsementsViewData?

    override func viewWillAppear (_ animated : Bool) {
        super.viewWillAppear (animated)
        setUpLabels ()
    }

    override func viewDidAppear (_ animated : Bool) {
        super.viewDidAppear (animated)
        REPAnalytics.trackScreenWithName (screenName : ScreenName.OurValueEndorsements, className : String (describing : self))
    }

    func setUpLabels () {
        player1NameLabel?.textColor = UIColor.white
        player1DescriptionLabel?.textColor = UIColor.white
        player2NameLabel?.textColor = UIColor.white
        player2DescriptionLabel?.textColor = UIColor.white
        player3NameLabel?.textColor = UIColor.white
        player3DescriptionLabel?.textColor = UIColor.white
        player1NameLabel?.text = viewData?.player1Name
        player1DescriptionLabel?.text = viewData?.player1Description
        player2NameLabel?.text = viewData?.player2Name
        player2DescriptionLabel?.text = viewData?.player2Description
        player3NameLabel?.text = viewData?.player3Name
        player3DescriptionLabel?.text = viewData?.player3Description
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/CacheSubmissionManager.swift" startline="1" endline="182">
import UIKit

class CacheSubmission : NSObject, NSCoding {
    let submissionID : Int
    let videoURL : URL
    let videoIdentifier : String
    init (videoURL : URL, submissionID : Int, videoIdentifier : String) {
        self.videoURL = videoURL
        self.submissionID = submissionID
        self.videoIdentifier = videoIdentifier
    }
    required init? (coder aDecoder : NSCoder) {
        guard let videoURL = aDecoder.decodeObject (forKey : "videoURL") as? URL else {
            return nil
        }
        guard let videoIdentifier = aDecoder.decodeObject (forKey : "videoIdentifier") as? String else {
            return nil
        }
        self.submissionID = aDecoder.decodeInteger (forKey : "submissionID")
        self.videoURL = videoURL
        self.videoIdentifier = videoIdentifier
        super.init ()
    }

    func encode (with aCoder : NSCoder) {
        aCoder.encode (self.submissionID, forKey : "submissionID")
        aCoder.encode (self.videoURL, forKey : "videoURL")
        aCoder.encode (self.videoIdentifier, forKey : "videoIdentifier")
    }
}

class CacheSubmissionManager : NSObject {
    var cacheSubmissions : [CacheSubmission] = {
        let directory = CacheSubmissionManager.cacheFile ()
        let submissions = NSKeyedUnarchiver.unarchiveObject (withFile : directory.path) as? [CacheSubmission]
        return submissions?? [CacheSubmission] ()
    } ()

    func videoURLInCurrentSandbox (url : URL) - > URL {
        return CacheSubmissionManager.applicationSupportDirectory ().appendingPathComponent (url.lastPathComponent)
    }

    class func saveVideo (videoURL : URL?) - > URL? {
        guard let videoURL = videoURL else {
            return nil
        }
        do {
            let fm = FileManager.default
            let videoData = try NSData (contentsOf : videoURL, options : [ .uncached])
            let applicationURL = CacheSubmissionManager.applicationSupportDirectory ()
            let filename = DateFormatter.storedDateFormatter ().string (from : Date ())
            let videoDataURL = applicationURL.appendingPathComponent ("\(filename).mov")
            print (videoDataURL)
            if (fm.fileExists (atPath : videoDataURL.path)) {
                try fm.removeItem (at : videoDataURL)
            }
            try videoData.write (to : videoDataURL, options : .atomic)
            return videoDataURL
        } catch let error {
            print ("Error saving video: \(error)")
            return nil
        }
    }

    class func deleteVideo (videoURL : URL?) {
        guard let videoURL = videoURL else {
            return
        }
        let fileManager = FileManager.default
        if (fileManager.fileExists (atPath : videoURL.path)) {
            do {
                try fileManager.removeItem (atPath : videoURL.path)
            } catch let error as NSError {
                print (error.debugDescription)
                return
            }
        }
    }

    fileprivate class func applicationSupportDirectory () - > URL {
        do {
            let bundleID = Bundle.main.bundleIdentifier??
            "push_interactions"
            let fm = FileManager.default
            let applicationSupportUrl = try fm.url (for : .applicationSupportDirectory, in : .userDomainMask, appropriateFor : nil, create : true)
            let bundleURL = applicationSupportUrl.appendingPathComponent (bundleID)
            if ! (fm.fileExists (atPath : bundleURL.path)) {
                try fm.createDirectory (at : bundleURL, withIntermediateDirectories : false, attributes : nil)
            }
            return bundleURL
        } catch let error as NSError {
            fatalError ("Error creating directory: \(error.localizedDescription)")
        }
    }

    fileprivate class func cacheFile () - > URL {
        let directory = CacheSubmissionManager.applicationSupportDirectory ()
        return directory.appendingPathComponent ("cacheSubmissions.data")
    }

    func saveSubmissions (saveSubmission : CacheSubmission) {
        var cacheSubmissions = self.cacheSubmissions
        for submission in cacheSubmissions {
            if submission.submissionID == saveSubmission.submissionID {
                return
            }
        }
        cacheSubmissions.append (saveSubmission)
        let directory = CacheSubmissionManager.cacheFile ()
        let saved = NSKeyedArchiver.archiveRootObject (cacheSubmissions, toFile : directory.path)
        print (saved)
    }

    func removeSubmission (submission : CacheSubmission) {
        var cacheSubmissions = self.cacheSubmissions
        if let index = cacheSubmissions.index (of : submission) {
            let videoURL = videoURLInCurrentSandbox (url : submission.videoURL)
            CacheSubmissionManager.deleteVideo (videoURL : videoURL)
            cacheSubmissions.remove (at : index)
            let directory = CacheSubmissionManager.cacheFile ()
            NSKeyedArchiver.archiveRootObject (cacheSubmissions, toFile : directory.path)
        }
    }

    func clearExpiredMovieFiles () {
        let fm = FileManager.default
        let applicationURL = CacheSubmissionManager.applicationSupportDirectory ()
        do {
            let directoryContents = try fm.contentsOfDirectory (at : applicationURL, includingPropertiesForKeys : nil, options : [])
            print (directoryContents)
            let movFiles = directoryContents.filter {
                $0.pathExtension==
                "mov"
            }
            for movieFileURL in movFiles {
                if let _ = cacheSubmissions.first (where : {
                    movieFileURL.lastPathComponent==
                    $0.videoURL.lastPathComponent
                }) {
                    break
                }
                let movieFilename = movieFileURL.deletingPathExtension ().lastPathComponent
                let filenameDate = DateFormatter.storedDateFormatter ().date (from : movieFilename)
                if let filenameDate = filenameDate, filenameDate.timeIntervalSinceNow<- (Constants.Vimeo.VideoExpiration) {
                    try fm.removeItem (at : movieFileURL)
                }
            }
        } catch {
            print (error.localizedDescription)
        }
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/AchievementsDataProvider.swift" startline="1" endline="173">
import Moya
import SwiftyJSON
struct Achievements {
    let mileRun : Achievement
    let fourtyYardDash : Achievement
    let benchPress : Achievement
    let deadlift : Achievement
    let squat : Achievement
    let militaryPress : Achievement
    let challenge : Achievement_Challenge
    let loyalty : Achievement_Loyalty
}
struct Achievement {
    let personalBestCount : Int
    let personalBestCreditWorth : Int
    let videoCount : Int
    let videoCreditWorth : Int
    let submissionCount : Int
    let submissionCreditWorth : Int
}
struct Achievement_Challenge {
    let joinChallengeCount : Int
    let joinChallengeCreditWorth : Int
    let challengeStreakCount : Int
    let challgeneStreakCreditWorth : Int
}
struct Achievement_Loyalty {
    let dailyVisitCount : Int
    let dailyVisitCreditWorth : Int
}

class AchievementsDataProvider {
    let provider = MoyaProvider <AchievementsService> ()

    func retrieveAchievements (completion :@escaping (Achievements?, String?) - > ()) {
        guard let token = UserDefaults.standard.userToken else {
            completion (nil, L10n.userTokenMissingMessage)
            return
        }
        provider.request ( .getAchievements (token : token)) {
            result in do {
                let response = try result.dematerialize ()
                let achievements = try response.mapAchievements ()
                completion (achievements, nil)
            } catch {
                completion (nil, error.localizedDescription)
            }
        }
    }
}

extension Moya.Response {

    func mapAchievements () throws - > Achievements {
        let responseObject = try self.map (to : REPerformanceResponse.self)
        guard responseObject.success else {
            throw REPerformanceError.requestFailed (responseObject.message)
        }
        let jsonData = responseObject.data
        guard let squatData = jsonData ["squat"]?.dictionary, let squatPersonalBest = squatData ["personal_best"], let squatPersonalBestCount = squatPersonalBest ["amount"].int, let squatPersonalBestCreditWorth = squatPersonalBest ["value"].int, let
          squatVideo = squatData ["video"], let squatVideoCount = squatVideo ["amount"].int, let squatVideoCreditWorth = squatVideo ["value"].int, let squatSubmission = squatData ["submission"], let squatSubmissionCount = squatSubmission ["amount"].int,
          let squatSubmissionCreditWorth = squatSubmission ["value"].int, let benchPressData = jsonData ["bench_press"]?.dictionary, let benchPressPersonalBest = benchPressData ["personal_best"], let benchPressPersonalBestCount = benchPressPersonalBest [
          "amount"].int, let benchPressPersonalBestCreditWorth = benchPressPersonalBest ["value"].int, let benchPressVideo = benchPressData ["video"], let benchPressVideoCount = benchPressVideo ["amount"].int, let benchPressVideoCreditWorth =
          benchPressVideo ["value"].int, let benchPressSubmission = benchPressData ["submission"], let benchPressSubmissionCount = benchPressSubmission ["amount"].int, let benchPressSubmissionCreditWorth = benchPressSubmission ["value"].int, let
          militaryPressData = jsonData ["military_press"]?.dictionary, let militaryPressPersonalBest = militaryPressData ["personal_best"], let militaryPressPersonalBestCount = militaryPressPersonalBest ["amount"].int, let
          militaryPressPersonalBestCreditWorth = militaryPressPersonalBest ["value"].int, let militaryPressVideo = militaryPressData ["video"], let militaryPressVideoCount = militaryPressVideo ["amount"].int, let militaryPressVideoCreditWorth =
          militaryPressVideo ["value"].int, let militaryPressSubmission = militaryPressData ["submission"], let militaryPressSubmissionCount = militaryPressSubmission ["amount"].int, let militaryPressSubmissionCreditWorth = militaryPressSubmission [
          "value"].int, let fortyYardDashData = jsonData ["forty_yard_dash"]?.dictionary, let fortyYardDashPersonalBest = fortyYardDashData ["personal_best"], let fortyYardDashPersonalBestCount = fortyYardDashPersonalBest ["amount"].int, let
          fortyYardDashPersonalBestCreditWorth = fortyYardDashPersonalBest ["value"].int, let fortyYardDashVideo = fortyYardDashData ["video"], let fortyYardDashVideoCount = fortyYardDashVideo ["amount"].int, let fortyYardDashVideoCreditWorth =
          fortyYardDashVideo ["value"].int, let fortyYardDashSubmission = fortyYardDashData ["submission"], let fortyYardDashSubmissionCount = fortyYardDashSubmission ["amount"].int, let fortyYardDashSubmissionCreditWorth = fortyYardDashSubmission [
          "value"].int, let deadliftData = jsonData ["deadlift"]?.dictionary, let deadliftPersonalBest = deadliftData ["personal_best"], let deadliftPersonalBestCount = deadliftPersonalBest ["amount"].int, let deadliftPersonalBestCreditWorth =
          deadliftPersonalBest ["value"].int, let deadliftVideo = deadliftData ["video"], let deadliftVideoCount = deadliftVideo ["amount"].int, let deadliftVideoCreditWorth = deadliftVideo ["value"].int, let deadliftSubmission = deadliftData [
          "submission"], let deadliftSubmissionCount = deadliftSubmission ["amount"].int, let deadliftSubmissionCreditWorth = deadliftSubmission ["value"].int, let mileRunData = jsonData ["mile_run"]?.dictionary, let milePersonalBest = mileRunData [
          "personal_best"], let milePersonalBestCount = milePersonalBest ["amount"].int, let milePersonalBestCreditWorth = milePersonalBest ["value"].int, let mileVideo = mileRunData ["video"], let mileVideoCount = mileVideo ["amount"].int, let
          mileVideoCreditWorth = mileVideo ["value"].int, let mileSubmission = mileRunData ["submission"], let mileSubmissionCount = mileSubmission ["amount"].int, let mileSubmissionCreditWorth = mileSubmission ["value"].int, let challengeData = jsonData [
          "challenge"]?.dictionary, let challengeJoin = challengeData ["join_challenge"], let challengeJoinCount = challengeJoin ["amount"].int, let challengeJoinCreditWorth = challengeJoin ["value"].int, let challengeStreak = challengeData [
          "join_challenge_streak"], let challengeStreakCount = challengeStreak ["amount"].int, let challengeStreakCreditWorth = challengeStreak ["value"].int, let loyaltyData = jsonData ["loyalty"]?.dictionary, let loyaltyDailyVisit = loyaltyData [
          "daily_visit"], let loyaltyDailyVisitCount = loyaltyDailyVisit ["amount"].int, let loyaltyDailyVisitCreditWorth = loyaltyDailyVisit ["value"].int else {
            throw MoyaError.jsonMapping (self)
        }
        let squatAchievement = Achievement (personalBestCount : squatPersonalBestCount, personalBestCreditWorth : squatPersonalBestCreditWorth, videoCount : squatVideoCount, videoCreditWorth : squatVideoCreditWorth, submissionCount : squatSubmissionCount,
          submissionCreditWorth : squatSubmissionCreditWorth)
        let benchPressAchievement = Achievement (personalBestCount : benchPressPersonalBestCount, personalBestCreditWorth : benchPressPersonalBestCreditWorth, videoCount : benchPressVideoCount, videoCreditWorth : benchPressVideoCreditWorth, submissionCount
          : benchPressSubmissionCount, submissionCreditWorth : benchPressSubmissionCreditWorth)
        let militaryPressAchievement = Achievement (personalBestCount : militaryPressPersonalBestCount, personalBestCreditWorth : militaryPressPersonalBestCreditWorth, videoCount : militaryPressVideoCount, videoCreditWorth : militaryPressVideoCreditWorth,
          submissionCount : militaryPressSubmissionCount, submissionCreditWorth : militaryPressSubmissionCreditWorth)
        let fortyYardDashAchievement = Achievement (personalBestCount : fortyYardDashPersonalBestCount, personalBestCreditWorth : fortyYardDashPersonalBestCreditWorth, videoCount : fortyYardDashVideoCount, videoCreditWorth : fortyYardDashVideoCreditWorth,
          submissionCount : fortyYardDashSubmissionCount, submissionCreditWorth : fortyYardDashSubmissionCreditWorth)
        let deadliftAchievement = Achievement (personalBestCount : deadliftPersonalBestCount, personalBestCreditWorth : deadliftPersonalBestCreditWorth, videoCount : deadliftVideoCount, videoCreditWorth : deadliftVideoCreditWorth, submissionCount :
          deadliftSubmissionCount, submissionCreditWorth : deadliftSubmissionCreditWorth)
        let mileRunAchievement = Achievement (personalBestCount : milePersonalBestCount, personalBestCreditWorth : milePersonalBestCreditWorth, videoCount : mileVideoCount, videoCreditWorth : mileVideoCreditWorth, submissionCount : mileSubmissionCount,
          submissionCreditWorth : mileSubmissionCreditWorth)
        let challengeAchievement = Achievement_Challenge (joinChallengeCount : challengeJoinCount, joinChallengeCreditWorth : challengeJoinCreditWorth, challengeStreakCount : challengeStreakCount, challgeneStreakCreditWorth : challengeStreakCreditWorth)
        let loyaltyAchievement = Achievement_Loyalty (dailyVisitCount : loyaltyDailyVisitCount, dailyVisitCreditWorth : loyaltyDailyVisitCreditWorth)
        return Achievements (mileRun : mileRunAchievement, fourtyYardDash : fortyYardDashAchievement, benchPress : benchPressAchievement, deadlift : deadliftAchievement, squat : squatAchievement, militaryPress : militaryPressAchievement, challenge :
          challengeAchievement, loyalty : loyaltyAchievement)
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/LeaderboardDividerTableViewCell.swift" startline="1" endline="35">
import UIKit

class LeaderboardDividerTableViewCell : UITableViewCell {
    @IBOutlet private var leftDot : UIView?
    @IBOutlet private var centerDot : UIView?
    @IBOutlet private var rightDot : UIView?

    override func awakeFromNib () {
        super.awakeFromNib ()
        selectionStyle = .none
        setUpDotWithView (leftDot)
        setUpDotWithView (centerDot)
        setUpDotWithView (rightDot)
    }

    private func setUpDotWithView (_ view : UIView?) {
        if let width : CGFloat = view?.bounds.width {
            view?.layer.cornerRadius = width/
            2
            view?.layer.masksToBounds = true
        }
        view?.backgroundColor = UIColor (named : .rePerformanceOrange)
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/WelcomeViewController.swift" startline="1" endline="248">
import UIKit
import FBSDKLoginKit
enum OnboardingState {
    case Welcome
    case Login
    case ForgotPassword
}

class WelcomeViewController : UIViewController {
    @IBOutlet fileprivate var createAccountButton : UIButton?
    @IBOutlet fileprivate var actionButton : UIButton?
    @IBOutlet fileprivate var exitButton : UIButton?
    @IBOutlet fileprivate var loginStackView : UIStackView?
    @IBOutlet fileprivate var facebookContainerView : UIView!
    @IBOutlet fileprivate var welcomeContraint : NSLayoutConstraint?
    @IBOutlet fileprivate var loginContraint : NSLayoutConstraint?
    @IBOutlet fileprivate var forgotPasswordContraint : NSLayoutConstraint?
    @IBOutlet fileprivate var createAccountCenterContraint : NSLayoutConstraint?
    @IBOutlet fileprivate var loginStackViewCenterContraint : NSLayoutConstraint?
    @IBOutlet fileprivate var showFBContraint : NSLayoutConstraint?
    @IBOutlet fileprivate var logoToForgotPasswordContraint : NSLayoutConstraint?
    @IBOutlet fileprivate var emailTextfield : UITextField?
    @IBOutlet fileprivate var passwordTextfield : UITextField?
    @IBOutlet fileprivate var forgotPasswordLabel : UILabel?
    fileprivate var onboardingState = OnboardingState.Welcome
    let animationOptions : UIView.AnimationOptions = .curveEaseIn
    var createAccount : (() - > ())?
    var login : ((String, String) - > ())?
    var submitForgotPassword : ((String) - > ())?
    var facebookLogin : ((String, String) - > ())?

    override func viewWillAppear (_ animated : Bool) {
        super.viewWillAppear (animated)
        self.navigationController?.setNavigationBarHidden (true, animated : true)
    }

    override func viewDidLoad () {
        super.viewDidLoad ()
        NotificationCenter.default.addObserver (forName : Notification.Name.AccessTokenDidChange, object : nil, queue : nil) {
            (_) in if let currentAccessToken = AccessToken.current {
                self.facebookLogin? (currentAccessToken.userID, currentAccessToken.tokenString)
            }
        }
        let facebookLoginButton = FBLoginButton ()
        facebookLoginButton.permissions = [FacebookPermissions.email.rawValue, FacebookPermissions.publicProfile.rawValue, FacebookPermissions.userFriends.rawValue]
        facebookContainerView?.addSubview (facebookLoginButton)
        facebookLoginButton.snp.makeConstraints {
            (make) in make.edges.equalToSuperview ()
        }
        self.createAccountButton?.backgroundColor = UIColor (named : .rePerformanceBlue)
        self.actionButton?.backgroundColor = UIColor (named : .rePerformanceYellow)
        self.onboardingState = .Welcome
        self.exitButton?.alpha = 0
        self.forgotPasswordLabel?.alpha = 0
        self.facebookContainerView.isHidden = true
        self.showFBContraint?.isActive = false
        self.loginStackViewCenterContraint?.constant+=
        self.view.bounds.width
        self.view.layoutIfNeeded ()
    }
    override var preferredStatusBarStyle : UIStatusBarStyle {
        return .lightContent
    }

    @IBAction fileprivate func viewCreateAccount (_ sender : UIButton) {
        createAccount? ()
    }

    @IBAction fileprivate func showLogin (_ sender : UIButton) {
        switch self.onboardingState {
            case.Welcome :
                presentLoginLayoutFromWelcome ()
            case.Login :
                loginTapped ()
            case.ForgotPassword :
                submitTapped ()
        }
    }

    @IBAction fileprivate func backToWelcome (_ sender : UIButton) {
        switch self.onboardingState {
            case.Welcome :
                break
            case.Login :
                presentWelcomeLayout ()
            case.ForgotPassword :
                presentLoginLayoutFromForgotPassword ()
        }
    }

    @IBAction fileprivate func forgotPassword () {
        showForgottenPassword ()
    }

    func clearUsernameAndPassword () {
        emailTextfield?.text = ""
        passwordTextfield?.text = ""
    }

    fileprivate func loginTapped () {
        guard let email = emailTextfield?.text, ! email.isEmpty else {
            UIAlertController.showAlert (L10n.missingInfo, message : L10n.emailMissing, inViewController : self)
            return
        }
        guard isValidEmail (email : email) else {
            UIAlertController.showAlert (L10n.validation, message : L10n.emailInvalid, inViewController : self)
            return
        }
        guard let password = passwordTextfield?.text, ! password.isEmpty else {
            UIAlertController.showAlert (L10n.missingInfo, message : L10n.passwordMissing, inViewController : self)
            return
        }
        login? (email, password)
    }

    fileprivate func submitTapped () {
        guard let email = emailTextfield?.text, ! email.isEmpty else {
            UIAlertController.showAlert (L10n.missingInfo, message : L10n.emailMissing, inViewController : self)
            return
        }
        guard isValidEmail (email : email) else {
            UIAlertController.showAlert (L10n.validation, message : L10n.emailInvalid, inViewController : self)
            return
        }
        submitForgotPassword? (email)
    }

    func presentWelcomeLayout () {
        self.onboardingState = .Welcome
        self.actionButton?.setTitle ("Login", for : .normal)
        UIView.animate (withDuration : 0.4, delay : 0, options : animationOptions, animations : {
            self.loginStackViewCenterContraint?.constant+=
            self.view.bounds.width
            self.view.layoutIfNeeded ()
        }) {
            (success) in UIView.animate (withDuration : 0.2, delay : 0, options : self.animationOptions, animations : {
                self.createAccountCenterContraint?.constant = 0
                self.loginContraint?.isActive = false
                self.welcomeContraint?.isActive = true
                self.forgotPasswordContraint?.isActive = false
                self.showFBContraint?.isActive = false
                self.exitButton?.alpha = 0
                self.forgotPasswordLabel?.alpha = 0
                self.facebookContainerView.isHidden = true
                self.view.layoutIfNeeded ()
            })
        }
    }

    fileprivate func presentLoginLayoutFromWelcome () {
        REPAnalytics.trackScreenWithName (screenName : ScreenName.Login, className : String (describing : self))
        self.onboardingState = .Login
        self.passwordTextfield?.alpha = 1
        UIView.animate (withDuration : 0.2, delay : 0, options : animationOptions, animations : {
            self.welcomeContraint?.isActive = false
            self.loginContraint?.isActive = true
            self.forgotPasswordContraint?.isActive = false
            self.showFBContraint?.isActive = true
            self.createAccountCenterContraint?.constant-=
            self.view.bounds.width
            self.view.layoutIfNeeded ()
        }) {
            (success) in UIView.animate (withDuration : 0.4, delay : 0, options : self.animationOptions, animations : {
                self.loginStackViewCenterContraint?.constant = 0
                self.view.layoutIfNeeded ()
                self.exitButton?.alpha = 1
                self.forgotPasswordLabel?.alpha = 1
                self.facebookContainerView.isHidden = false
            })
        }
    }

    fileprivate func showForgottenPassword () {
        self.onboardingState = .ForgotPassword
        self.actionButton?.setTitle ("Submit", for : .normal)
        self.view.bringSubviewToFront (self.actionButton!)
        UIView.animate (withDuration : 0.4, delay : 0, options : animationOptions, animations : {
            self.welcomeContraint?.isActive = false
            self.loginContraint?.isActive = false
            self.forgotPasswordContraint?.isActive = true
            self.showFBContraint?.isActive = false
            self.view.layoutIfNeeded ()
            self.passwordTextfield?.alpha = 0
            self.forgotPasswordLabel?.alpha = 0
            self.facebookContainerView.isHidden = true
            self.logoToForgotPasswordContraint?.constant = 100
        })
    }

    fileprivate func presentLoginLayoutFromForgotPassword () {
        REPAnalytics.trackScreenWithName (screenName : ScreenName.Login, className : String (describing : self))
        self.onboardingState = .Login
        self.actionButton?.setTitle ("Login", for : .normal)
        UIView.animate (withDuration : 0.4, delay : 0, options : animationOptions, animations : {
            self.welcomeContraint?.isActive = false
            self.loginContraint?.isActive = true
            self.forgotPasswordContraint?.isActive = false
            self.showFBContraint?.isActive = true
            self.logoToForgotPasswordContraint?.constant = 20
            self.view.layoutIfNeeded ()
            self.passwordTextfield?.alpha = 1
            self.forgotPasswordLabel?.alpha = 1
            self.facebookContainerView.isHidden = false
        })
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/ValueTableViewCell.swift" startline="1" endline="58">
import UIKit

class ValueTableViewCell : UITableViewCell {
    @IBOutlet private var valueTextField : REPCustomTextField?
    let textFieldUpperBounds = 600
    var valueFieldChanged : ((String) - > ())?

    override func awakeFromNib () {
        super.awakeFromNib ()
        valueTextField?.keyboardType = .numberPad
        valueTextField?.addTarget (self, action : #selector (textFieldDidChange (textField :)), for : .editingChanged)
        valueTextField?.applyProfileWhiteUnderline ()
    }

    func setUp (valueText : String) {
        setValueTextFieldText (text : valueText)
        valueTextField?.keyboardType = .numberPad
    }

    func setValueTextFieldText (text : String) {
        self.valueTextField?.text = text
    }

    func getValueTextFieldText () - > String {
        guard let text = self.valueTextField?.text else {
            return ""
        }
        return text
    }

    @objc func textFieldDidChange (textField : UITextField) {
        if textField == valueTextField {
            if let sanitized : Int = valueTextField?.sanitizeIntegerInput (upperBounds : textFieldUpperBounds) {
                valueTextField?.text = String (sanitized)
                valueFieldChanged? (String (sanitized))
            } else {
                valueTextField?.text = ""
                valueFieldChanged? (String (0))
            }
        }
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/ExercisesInformationViewController.swift" startline="1" endline="87">
import UIKit
struct ExerciseInformation {
    let title : String
    let description : String
    let funFacts : String
    let backgroundImage : UIImage
    let activityLineImage : UIImage
}

class ExercisesInformationViewController : UIViewController {
    @IBOutlet private var backgroundImageView : UIImageView?
    @IBOutlet private var titleLabel : UILabel?
    @IBOutlet private var descriptionLabel : UILabel?
    @IBOutlet private var activityLineImageView : UIImageView?
    @IBOutlet private var funFactsTitleLabel : UILabel?
    @IBOutlet private var funFactsDescriptionLabel : UILabel?
    @IBOutlet private var getStartedButton : UIButton?
    var exerciseInformation : ExerciseInformation?
    var exerciseCategory : ExerciseCategory?
    var getStarted : (() - > ())?
    override var prefersStatusBarHidden : Bool {
        return true
    }

    override func viewWillAppear (_ animated : Bool) {
        super.viewWillAppear (animated)
        loadExerciseInformation (exerciseInformation : exerciseInformation)
        self.titleLabel?.textColor = UIColor.white
        self.descriptionLabel?.textColor = UIColor.white
        self.funFactsTitleLabel?.textColor = UIColor.white
        self.funFactsDescriptionLabel?.textColor = UIColor.white
    }

    override func viewDidAppear (_ animated : Bool) {
        super.viewDidAppear (animated)
        guard let exerciseCategory = exerciseCategory else {
            return
        }
        switch exerciseCategory {
            case.MileRun :
                REPAnalytics.trackScreenWithName (screenName : ScreenName.TestsMileRun.Description, className : String (describing : self))
            case.FortyYardDash :
                REPAnalytics.trackScreenWithName (screenName : ScreenName.TestsFortyYardDash.Description, className : String (describing : self))
            case.BenchPress :
                REPAnalytics.trackScreenWithName (screenName : ScreenName.TestsBenchPress.Description, className : String (describing : self))
            case.DeadLift :
                REPAnalytics.trackScreenWithName (screenName : ScreenName.TestsDeadlift.Description, className : String (describing : self))
            case.Squat :
                REPAnalytics.trackScreenWithName (screenName : ScreenName.TestsSquat.Description, className : String (describing : self))
            case.MilitaryPress :
                REPAnalytics.trackScreenWithName (screenName : ScreenName.TestsMilitaryPress.Description, className : String (describing : self))
        }
    }

    fileprivate func loadExerciseInformation (exerciseInformation : ExerciseInformation?) {
        if let exerciseInformation = exerciseInformation {
            self.titleLabel?.text = exerciseInformation.title
            self.descriptionLabel?.text = exerciseInformation.description
            self.backgroundImageView?.image = exerciseInformation.backgroundImage
            self.activityLineImageView?.image = exerciseInformation.activityLineImage
            self.funFactsDescriptionLabel?.text = exerciseInformation.funFacts
        }
    }

    @IBAction func getStartedTapped (_ sender : UIButton) {
        getStarted? ()
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/ReportCardDataProvider.swift" startline="1" endline="142">
import Moya

class ReportCardDataProvider {
    let retrieveServiceProvider = MoyaProvider <RetrieveService> ()
    let reportCardServiceProvider = MoyaProvider <ReportCardService> ()

    func retrievePersonalReportCard (completion :@escaping ((ReportCard?, String?) - > ())) {
        guard let token = UserDefaults.standard.userToken else {
            completion (nil, L10n.userTokenMissingMessage)
            return
        }
        self.retrieveServiceProvider.request ( .getPersonalReportCard (token : token)) {
            result in do {
                let response = try result.dematerialize ()
                let reportCard = try response.map (ReportCard.self, atKeyPath : "data")
                completion (reportCard, nil)
            } catch {
                completion (nil, error.localizedDescription)
            }
        }
    }

    func retrieveAthleteReportCard (identifier : String, completion :@escaping ((ReportCard?, String?) - > ())) {
        guard let token = UserDefaults.standard.userToken else {
            completion (nil, L10n.userTokenMissingMessage)
            return
        }
        self.retrieveServiceProvider.request ( .getAthleteReportCard (token : token, athlete : identifier)) {
            result in do {
                let response = try result.dematerialize ()
                let reportCard = try response.map (ReportCard.self, atKeyPath : "data")
                completion (reportCard, nil)
            } catch {
                completion (nil, error.localizedDescription)
            }
        }
    }

    func retrieveScores (completion :@escaping (ReportCardExerciseScores?, String?) - > ()) {
        guard let token = UserDefaults.standard.userToken else {
            completion (nil, L10n.userTokenMissingMessage)
            return
        }
        self.retrieveServiceProvider.request ( .getScores (token : token)) {
            result in do {
                let response = try result.dematerialize ()
                let myScores = try response.map (ReportCardExerciseScores.self, atKeyPath : "data")
                completion (myScores, nil)
            } catch {
                completion (nil, error.localizedDescription)
            }
        }
    }

    func retrieveAthleteScores (identifier : String, completion :@escaping (ReportCardExerciseScores?, String?) - > ()) {
        guard let token = UserDefaults.standard.userToken else {
            completion (nil, L10n.userTokenMissingMessage)
            return
        }
        self.retrieveServiceProvider.request ( .getAthleteScores (token : token, athlete : identifier)) {
            result in do {
                let response = try result.dematerialize ()
                let myScores = try response.map (ReportCardExerciseScores.self, atKeyPath : "data")
                completion (myScores, nil)
            } catch {
                completion (nil, error.localizedDescription)
            }
        }
    }

    func updateProfileVisibility (isPrivate : Bool, completion :@escaping (String?) - > ()) {
        guard let token = UserDefaults.standard.userToken else {
            completion (L10n.userTokenMissingMessage)
            return
        }
        self.reportCardServiceProvider.request ( .setProfilePrivacy (token : token, isPublic : ! isPrivate)) {
            result in do {
                let response = try result.dematerialize ()
                let _ = try response.map (REPerformanceBaseResponse <Bool>.self)
                completion (nil)
            } catch {
                completion (error.localizedDescription)
            }
        }
    }

    func updateProfileImage (completion :@escaping (String?) - > ()) {
        guard let token = UserDefaults.standard.userToken else {
            completion (L10n.userTokenMissingMessage)
            return
        }
        guard let profileImage = UIImage.getSavedProfileImage () else {
            completion ("Missing profile image")
            return
        }
        self.reportCardServiceProvider.request ( .setProfileImage (token : token, profileImage : profileImage)) {
            result in do {
                let response = try result.dematerialize ()
                let _ = try response.map (REPerformanceBaseResponse <ProfileImage>.self)
                completion (nil)
            } catch {
                print (error.localizedDescription)
                completion (error.localizedDescription)
            }
        }
    }

    func getProfileImage (athleteID : Int, completion :@escaping (URL?) - > ()) {
        guard let token = UserDefaults.standard.userToken else {
            completion (nil)
            return
        }
        self.reportCardServiceProvider.request ( .profileImage (token : token, athleteId : "\(athleteID)")) {
            result in do {
                let response = try result.dematerialize ()
                let repResponse = try response.map (REPerformanceBaseResponse <ProfileImage>.self)
                completion (repResponse.data.image)
            } catch {
                print (error)
                completion (nil)
            }
        }
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/ChallengeDataProvider.swift" startline="1" endline="73">
import Foundation
import Result
import Moya

class ChallengeDataProvider {
    let retrieveProvider = MoyaProvider <RetrieveService> ()
    let submitProvider = MoyaProvider <SubmitService> ()
    let leaderboardProvider = MoyaProvider <SubmitService> ()

    func retreiveChallenges (completion :@escaping (Result <[Challenge], REPerformanceError>) - > ()) {
        guard let token = UserDefaults.standard.userToken else {
            completion ( .failure ( .userTokenMissing))
            return
        }
        self.retrieveProvider.request ( .getChallenges (token : token)) {
            result in do {
                let response = try result.dematerialize ()
                let challenges = try response.map ([Challenge].self, atKeyPath : "data")
                completion ( .success (challenges))
            } catch {
                completion ( .failure ( .requestFailed (error.localizedDescription)))
            }
        }
    }

    func submitChallengeAction (challenge : Challenge, completion :@escaping (Result <Bool, REPerformanceError>) - > ()) {
        guard let token = UserDefaults.standard.userToken else {
            completion ( .failure ( .userTokenMissing))
            return
        }
        let challengeCompletion : Completion = {
            result in do {
                let response = try result.dematerialize ()
                let isSuccess = try response.mapSuccess ()
                completion ( .success (isSuccess))
            } catch {
                completion ( .failure ( .requestFailed (error.localizedDescription)))
            }
        }
        if challenge.hasJoined {
            self.submitProvider.request ( .submitChallengeLeave (token : token, challenge : challenge), completion : challengeCompletion)
        } else {
            self.submitProvider.request ( .submitChallengeJoin (token : token, challenge : challenge), completion : challengeCompletion)
        }
    }

    func retreiveLeaderboard (challenge : Challenge, gym : Gym? = nil, completion :@escaping (Result <[Athlete], REPerformanceError>) - > ()) {
        self.retrieveProvider.request ( .getChallengeLeaderboard (challenge : challenge, gym : gym)) {
            result in do {
                let response = try result.dematerialize ()
                let athletes = try response.map ([Athlete].self, atKeyPath : "data")
                completion ( .success (athletes))
            } catch {
                completion ( .failure ( .requestFailed (error.localizedDescription)))
            }
        }
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/ViewSnapshot.swift" startline="1" endline="25">
import UIKit

extension UIView {

    func snapshot (backgroundColor : UIColor = UIColor.clear) - > UIImage? {
        let renderer = UIGraphicsImageRenderer (bounds : self.bounds)
        let image = renderer.image {
            rendererContext in backgroundColor.setFill ()
            rendererContext.fill (rendererContext.format.bounds)
            self.layer.render (in : rendererContext.cgContext)
        }
        return image
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/GoogleDataProvider.swift" startline="1" endline="82">
import Moya
import SwiftyJSON
import MapKit
struct REPPlace {
    let location : CLLocationCoordinate2D
    let name : String
    let placeID : String
    let vicinity : String
}

class GoogleDataProvider {
    let provider = MoyaProvider <PlaceSearchService> ()

    func searchNearbyPlaces (location : CLLocationCoordinate2D, queryString : String, completion :@escaping ([REPPlace]?, String?, String?) - > ()) {
        provider.request ( .nearbySearch (location : location, queryString : queryString)) {
            (result) in do {
                let response = try result.dematerialize ()
                let placesResponse = try response.mapPlacesResponse ()
                completion (placesResponse.places, placesResponse.pageToken, nil)
            } catch {
                completion (nil, nil, error.localizedDescription)
            }
        }
    }

    func findNearbyGyms (location : CLLocationCoordinate2D, pageToken : String?, completion :@escaping ([REPPlace]?, String?, [String]?, String?) - > ()) {
        provider.request ( .emptySearch (location : location, pageToken : pageToken)) {
            (result) in do {
                let response = try result.dematerialize ()
                let placesResponse = try response.mapPlacesResponse ()
                completion (placesResponse.places, placesResponse.pageToken, placesResponse.htmlAttributions, nil)
            } catch {
                completion (nil, nil, nil, error.localizedDescription)
            }
        }
    }
}

extension Moya.Response {

    func mapPlacesResponse () throws - > (places : [REPPlace], pageToken : String, htmlAttributions : [String]) {
        let responseObject = try self.map (to : GoogleResponse.self)
        guard responseObject.success else {
            throw GoogleError.requestFailed (responseObject.status)
        }
        let jsonData = responseObject.results
        var places : [REPPlace] = []
        for (placeJson) : (JSON) in jsonData {
            guard let geometryJson = placeJson ["geometry"].dictionary, let locationJson = geometryJson ["location"]?.dictionary, let lat = locationJson ["lat"]?.doubleValue, let lng = locationJson ["lng"]?.doubleValue else {
                throw MoyaError.jsonMapping (self)
            }
            let currentName = placeJson ["name"].stringValue
            let currentPlaceID = placeJson ["place_id"].stringValue
            let vicinity = placeJson ["vicinity"].stringValue
            let currentCoordinate = CLLocationCoordinate2D (latitude : lat, longitude : lng)
            let currentPlace = REPPlace (location : currentCoordinate, name : currentName, placeID : currentPlaceID, vicinity : vicinity)
            places.append (currentPlace)
        }
        let attributionJSON = responseObject.attributions
        return (places, responseObject.nextPageToken, attributionJSON)
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/LeaderboardViewController.swift" startline="1" endline="354">
import UIKit
import NVActivityIndicatorView
struct LeaderboardViewModel {
    let leaderboard : Leaderboard
    let globalLeaderboard : Bool
    let exerciseCategory : ExerciseCategory?
    let exerciseTestFormat : ExerciseTestFormat?
    let filteredByAge : Bool
    var leaderboardLocation : String {
        get {
            return (UserDefaults.standard.userCurrentLocation? ? "")
        }
    }
    var title : String {
        get {
            if let exerciseCategory = self.exerciseCategory {
                return LeaderboardSelectionHeaderData.titleForExerciseCategory (exerciseCategory : exerciseCategory)+
                " Leaderboard"
            }
            return "Leaderboard"
        }
    }
    var subtitle : String {
        get {
            if let exerciseTestFormat = self.exerciseTestFormat {
                return LeaderboardSelectionCellData.textForExerciseFormat (exerciseTestFormat)
            }
            return ""
        }
    }
}
enum ErrorableLeaderboardViewModel {
    case leaderboard (viewModel : LeaderboardViewModel)
    case error (message : String)
}

class LeaderboardViewController : UIViewController {
    @IBOutlet private var tableView : UITableView?
    @IBOutlet private var segmentedControl : UISegmentedControl?
    @IBOutlet private var outOfLabel : UILabel?
    @IBOutlet private var medalImageView : UIImageView?
    @IBOutlet private var accountVerifiedLabel : UILabel?
    @IBOutlet private var compareLabel : UILabel?
    @IBOutlet private var byTestButton : UIButton?
    @IBOutlet private var byAgeGroupButton : UIButton?
    @IBOutlet private var subtitleLabel : UILabel?
    @IBOutlet private var locationLabel : UILabel?
    let friendsIndex : Int = 0
    let everyoneIndex : Int = 1
    let nearbyIndex : Int = 2
    var errorableLeaderboardViewModel : ErrorableLeaderboardViewModel?
    var currentSegment : LeaderboardGroup = .Everyone
    var dismiss : (() - > ())?
    var byTest : (() - > ())?
    var byAge : (() - > ())?
    var segmentChanged : ((LeaderboardGroup) - > ())?
    var willAppear : (() - > ())?
    var selectedAthlete : ((Athlete) - > ())?

    override func viewDidLoad () {
        super.viewDidLoad ()
        self.tableView?.estimatedRowHeight = 55
        self.tableView?.rowHeight = UITableView.automaticDimension
        self.navigationItem.leftBarButtonItem = UIBarButtonItem (barButtonSystemItem : .done, target : self, action : #selector (dismissTapped (_ :)))
        self.setUpSegmentedControl ()
        self.setUpViewComponents ()
    }

    override func viewWillAppear (_ animated : Bool) {
        super.viewWillAppear (animated)
        self.willAppear? ()
    }

    override func viewDidAppear (_ animated : Bool) {
        super.viewDidAppear (animated)
        guard let errorableLeaderboardViewModel = self.errorableLeaderboardViewModel, case let.leaderboard (leaderboardViewModel) = errorableLeaderboardViewModel else {
            return
        }
        if leaderboardViewModel.globalLeaderboard {
            REPAnalytics.trackScreenWithName (screenName : ScreenName.LeaderBoard.Global, className : String (describing : self))
        }
        guard let exerciseCategory = leaderboardViewModel.exerciseCategory else {
            return
        }
        switch exerciseCategory {
            case.MileRun :
                REPAnalytics.trackScreenWithName (screenName : ScreenName.LeaderBoard.MileRun, className : String (describing : self))
            case.FortyYardDash :
                REPAnalytics.trackScreenWithName (screenName : ScreenName.LeaderBoard.FortyYardDash, className : String (describing : self))
            case.BenchPress :
                REPAnalytics.trackScreenWithName (screenName : ScreenName.LeaderBoard.BenchPress, className : String (describing : self))
            case.DeadLift :
                REPAnalytics.trackScreenWithName (screenName : ScreenName.LeaderBoard.Deadlift, className : String (describing : self))
            case.Squat :
                REPAnalytics.trackScreenWithName (screenName : ScreenName.LeaderBoard.Squat, className : String (describing : self))
            case.MilitaryPress :
                REPAnalytics.trackScreenWithName (screenName : ScreenName.LeaderBoard.MilitaryPress, className : String (describing : self))
        }
    }

    func setUpSegmentedControl () {
        self.segmentedControl?.tintColor = UIColor (named : .rePerformanceOrange)
        self.segmentedControl?.setTitleTextAttributes ([NSAttributedString.Key.foregroundColor : UIColor.white], for : .normal)
        self.segmentedControl?.setTitleTextAttributes ([NSAttributedString.Key.foregroundColor : UIColor.white], for : .selected)
        self.segmentedControl?.backgroundColor = UIColor.clear
        self.segmentedControl?.selectedSegmentIndex = everyoneIndex
    }

    func setUpViewComponents () {
        self.subtitleLabel?.textColor = UIColor.white
        self.locationLabel?.textColor = UIColor.white
        self.outOfLabel?.textColor = UIColor.white
        self.accountVerifiedLabel?.textColor = UIColor (named : .rePerformanceOrange)
        self.compareLabel?.textColor = UIColor.white
        self.byTestButton?.setUpWhiteREPerformanceButton ()
        self.byAgeGroupButton?.setUpWhiteREPerformanceButton ()
    }

    func setUpView () {
        if let errorableLeaderboardViewModel = self.errorableLeaderboardViewModel, case let.leaderboard (leaderboardViewModel) = errorableLeaderboardViewModel {
            if leaderboardViewModel.leaderboard.isRankingEmpty {
                self.outOfLabel?.text = ""
            } else {
                self.outOfLabel?.text = "out of \(leaderboardViewModel.leaderboard.total)"
            }
            if leaderboardViewModel.leaderboard.isRankingEmpty {
                self.setAccountVerifiedVisible (false)
            } else {
                self.setAccountVerifiedVisible (true)
            }
            if leaderboardViewModel.filteredByAge {
                self.byAgeGroupButton?.setTitle (L10n.leaderboardAllAgeGroupButtonTitle, for : .normal)
            } else {
                self.byAgeGroupButton?.setTitle (L10n.leaderboardYourAgeGroupButtonTitle, for : .normal)
            }
            self.title = leaderboardViewModel.title
            self.subtitleLabel?.text = leaderboardViewModel.subtitle
            if self.currentSegment==.Nearby {
                self.locationLabel?.text = leaderboardViewModel.leaderboardLocation
            } else {
                self.locationLabel?.text = nil
            }
        } else {
            self.outOfLabel?.text = ""
            self.setAccountVerifiedVisible (false)
            self.byAgeGroupButton?.setTitle (L10n.leaderboardYourAgeGroupButtonTitle, for : .normal)
            self.title = "Leaderboard"
            self.subtitleLabel?.text = nil
            self.locationLabel?.text = nil
        }
        self.tableView?.setContentOffset (CGPoint.zero, animated : true)
    }

    func setAccountVerifiedVisible (_ visible : Bool) {
        self.medalImageView?.isHidden = ! visible
        self.accountVerifiedLabel?.isHidden = ! visible
    }

    @IBAction func dismissTapped (_ sender : UIButton) {
        self.dismiss? ()
    }

    @IBAction func byTestTapped (_ sender : UIButton) {
        self.byTest? ()
    }

    @IBAction func byAgeGroupTapped (_ sender : UIButton) {
        self.byAge? ()
    }

    @IBAction func segmentChanged (_ sender : UISegmentedControl) {
        switch sender.selectedSegmentIndex {
            case 0 :
                self.currentSegment = .Friends
                self.segmentChanged? ( .Friends)
            case 1 :
                self.currentSegment = .Everyone
                self.segmentChanged? ( .Everyone)
            case 2 :
                self.currentSegment = .Nearby
                self.segmentChanged? ( .Nearby)
            default :
                self.currentSegment = .Everyone
                self.segmentChanged? ( .Everyone)
        }
    }

    func reloadView () {
        self.setUpView ()
        self.tableView?.reloadData ()
    }

    func showLoadingIndicator (_ show : Bool) {
        if show {
            NVActivityIndicatorPresenter.sharedInstance.startAnimating (Constants.activityData)
        } else {
            NVActivityIndicatorPresenter.sharedInstance.stopAnimating ()
        }
    }

    func reloadRow (row : Int, section : Int) {
        let indexPathToReload = IndexPath (row : row, section : section)
        self.tableView?.reloadRows (at : [indexPathToReload], with : .automatic)
    }
}

extension LeaderboardViewController : UITableViewDataSource, UITableViewDelegate {

    func numberOfSections (in tableView : UITableView) - > Int {
        guard let errorableLeaderboardViewModel = self.errorableLeaderboardViewModel, case let.leaderboard (leaderboardViewModel) = errorableLeaderboardViewModel else {
            return 0
        }
        if leaderboardViewModel.leaderboard.isRankingEmpty {
            return 1
        } else {
            return ((leaderboardViewModel.leaderboard.groupedRankings.count * 2) - 1)
        }
    }

    func tableView (_ tableView : UITableView, numberOfRowsInSection section : Int) - > Int {
        guard let errorableLeaderboardViewModel = self.errorableLeaderboardViewModel, case let.leaderboard (leaderboardViewModel) = errorableLeaderboardViewModel else {
            return 0
        }
        if leaderboardViewModel.leaderboard.isRankingEmpty {
            return 1
        } else {
            if (section % 2 == 0) {
                let groupedRankingSection = Int (floor (Double (section) / 2))
                return leaderboardViewModel.leaderboard.groupedRankings [groupedRankingSection].count
            } else {
                return 1
            }
        }
    }

    func tableView (_ tableView : UITableView, cellForRowAt indexPath : IndexPath) - > UITableViewCell {
        guard let errorableLeaderboardViewModel = self.errorableLeaderboardViewModel else {
            fatalError ()
        }
        switch errorableLeaderboardViewModel {
            case.leaderboard (let leaderboardViewModel) :
                if (indexPath.section % 2 == 0) {
                    let leaderboardPositionTableViewCell = tableView.dequeueReusableCell (withIdentifier : Constants.ReportCard.LeaderboardPositionCellIdentifier, for : indexPath) as! LeaderboardPositionTableViewCell
                    let groupedRankingSection = Int (floor (Double (indexPath.section) / 2))
                    let athlete = leaderboardViewModel.leaderboard.groupedRankings [groupedRankingSection] [indexPath.row]
                    let score : String?
                    if leaderboardViewModel.globalLeaderboard == true {
                        score = athlete.lifestyleCategory
                    } else if let athleteScore = athlete.score {
                        if leaderboardViewModel.exerciseCategory==.MileRun, let localScore = FormatMillisecondsForDisplay.convertScoreForDisplayMileRun (score : "\(athleteScore)") {
                            score = localScore
                        } else if leaderboardViewModel.exerciseCategory==.FortyYardDash, let localScore = FormatMillisecondsForDisplay.convertScoreForDisplayFortyYardDash (score : "\(athleteScore)") {
                            score = localScore
                        } else {
                            score = "\(athleteScore)"
                        }
                    } else {
                        score = nil
                    }
                    var athleteRank = ""
                    if let rank = athlete.rank {
                        athleteRank = "\(rank)"
                    }
                    leaderboardPositionTableViewCell.configureCell (rankText : athleteRank, nameText : athlete.name, isPublic : (athlete.isPublic? ? false), rightSideText : score? ? "", medalVisible : athlete.isVerified? ? false, personFacebookID : athlete
                      .facebookIdentifier, profileURL : athlete.imageURL)
                    return leaderboardPositionTableViewCell
                } else {
                    return tableView.dequeueReusableCell (withIdentifier : Constants.ReportCard.LeaderboardDividerCellIdentifier, for : indexPath) as! LeaderboardDividerTableViewCell
                }
            case.error (let message) :
                let leaderboardErrorTableViewCell = tableView.dequeueReusableCell (withIdentifier : Constants.ReportCard.LeaderboardErrorCellIdentifier, for : indexPath) as! LeaderboardErrorTableViewCell
                leaderboardErrorTableViewCell.configureCell (errorMessage : message)
                return leaderboardErrorTableViewCell
        }
    }

    func tableView (_ tableView : UITableView, didSelectRowAt indexPath : IndexPath) {
        tableView.deselectRow (at : indexPath, animated : true)
        guard let errorableLeaderboardViewModel = self.errorableLeaderboardViewModel, case let.leaderboard (leaderboardViewModel) = errorableLeaderboardViewModel else {
            return
        }
        guard indexPath.section % 2 == 0 else {
            return
        }
        let groupedRankingSection = Int (floor (Double (indexPath.section) / 2))
        let athlete = leaderboardViewModel.leaderboard.groupedRankings [groupedRankingSection] [indexPath.row]
        self.selectedAthlete? (athlete)
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/MyScoresViewController.swift" startline="1" endline="120">
import UIKit
struct ExerciseInfo {
    let image : Image
    let title : String
    let isWeightLifting : Bool
}
protocol MyScoresProviding {
    var isPersonal : Bool {get}

    func numberOfSections () - > Int

    func numberOfRows (for section : Int) - > Int

    func exercise (for : Int) - > ExerciseInfo

    func score (for : IndexPath) - > ExerciseScorePersonalCellViewModel
}

class MyScoresViewController : UIViewController {
    @IBOutlet var scoresTableView : UITableView?
    @IBOutlet var videoStatusLegendView : UIView?
    override var preferredStatusBarStyle : UIStatusBarStyle {
        return .lightContent
    }
    var viewData : MyScoresProviding?
    var showVideoStatusLegend : Bool = false

    override func viewWillAppear (_ animated : Bool) {
        super.viewWillAppear (animated)
        self.videoStatusLegendView?.isHidden = self.showVideoStatusLegend==
        false
    }

    override func viewDidAppear (_ animated : Bool) {
        super.viewDidAppear (animated)
        REPAnalytics.trackScreenWithName (screenName : ScreenName.MyScores, className : String (describing : self))
    }
}

extension MyScoresViewController : UITableViewDataSource, UITableViewDelegate {

    func numberOfSections (in tableView : UITableView) - > Int {
        guard let viewModel = self.viewData else {
            return 0
        }
        return viewModel.numberOfSections ()+
        1
    }

    func tableView (_ tableView : UITableView, numberOfRowsInSection section : Int) - > Int {
        guard let viewModel = self.viewData else {
            return 0
        }
        if section == 0 {
            return (self.showVideoStatusLegend == true? 1 : 0)
        } else {
            let adjustedSection = section-
            1
            return viewModel.numberOfRows (for : adjustedSection)
        }
    }

    func tableView (_ tableView : UITableView, cellForRowAt indexPath : IndexPath) - > UITableViewCell {
        if indexPath.section == 0 {
            return tableView.dequeueReusableCell (withIdentifier : "Video Status Legend Cell Identifier", for : indexPath)
        }
        var adjustedIndexPath = indexPath
        adjustedIndexPath.section-=
        1
        let viewData = self.viewData!
        let score = viewData.score (for : adjustedIndexPath)
        let cell = tableView.dequeueReusableCell (withIdentifier : "Score Cell Identifier", for : indexPath) as! ExerciseScorePersonalTableViewCell
        cell.configure (with : score)
        return cell
    }

    func tableView (_ tableView : UITableView, viewForHeaderInSection section : Int) - > UIView? {
        if section == 0 {
            return nil
        }
        let adjustedSection = section-
        1
        let viewData = self.viewData!
        let exercise = viewData.exercise (for : adjustedSection)
        let header = tableView.dequeueReusableCell (withIdentifier : "Score Section Header") as! MyScoreSectionHeaderTableViewCell
        header.configure (with : exercise)
        return header
    }

    func tableView (_ tableView : UITableView, heightForHeaderInSection section : Int) - > CGFloat {
        if section == 0 {
            return 0
        }
        return 111
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/ExercisesStartViewController.swift" startline="1" endline="216">
import UIKit
struct ExercisesStartViewControllerContent {
    let title : String
    let instructionsLabel1Text : String
    let instructionsLabel2Text : String?
    let button1Text : String?
    let button2Text : String?
    let button3Text : String?
    let button4Text : String?
    let exerciseTestFormatButton1 : ExerciseTestFormat
    let exerciseTestFormatButton2 : ExerciseTestFormat
    let exerciseTestFormatButton3 : ExerciseTestFormat?
    let exerciseTestFormatButton4 : ExerciseTestFormat?
}
enum VideoState {
    case unDetermined
    case upload
    case notUpload
}

class ExercisesStartViewController : UIViewController {
    override var preferredStatusBarStyle : UIStatusBarStyle {
        return .lightContent
    }
    @IBOutlet private var instructionsLabelOne : UILabel!
    @IBOutlet private var instructionsLabelTwo : UILabel!
    @IBOutlet private var button1 : UIButton!
    @IBOutlet private var button2 : UIButton!
    @IBOutlet private var button3 : UIButton!
    @IBOutlet private var button4 : UIButton!
    @IBOutlet private var videoLabel : UILabel!
    @IBOutlet private var uploadButton : UIButton!
    @IBOutlet private var notUploadButton : UIButton!
    @IBOutlet private var nextButton : UIButton!
    var buttons : Array <UIButton> = []
    var videoButtons : Array <UIButton> = []
    var uploadState : VideoState = .unDetermined
    var exercisesStartViewControllerContent : ExercisesStartViewControllerContent? {
        didSet {
            populateFields ()
        }
    }
    var exerciseCategory : ExerciseCategory?
    var exerciseTestFormat : ExerciseTestFormat?
    var nextButtonClosure : ((ExerciseTestFormat, VideoState) - > ())?
    var retrieveExerciseContent : ((ExerciseCategory) - > ())?

    override func viewDidLoad () {
        super.viewDidLoad ()
        buttons = [button1, button2, button3, button4]
        videoButtons = [uploadButton, notUploadButton]
        setUpView ()
    }

    override func viewWillAppear (_ animated : Bool) {
        super.viewWillAppear (animated)
        guard let exercise = exerciseCategory else {
            return
        }
        retrieveExerciseContent? (exercise)
    }

    override func viewDidAppear (_ animated : Bool) {
        super.viewDidAppear (animated)
        guard let exerciseCategory = exerciseCategory else {
            return
        }
        switch exerciseCategory {
            case.MileRun :
                REPAnalytics.trackScreenWithName (screenName : ScreenName.TestsMileRun.Setup, className : String (describing : self))
            case.FortyYardDash :
                REPAnalytics.trackScreenWithName (screenName : ScreenName.TestsFortyYardDash.Setup, className : String (describing : self))
            case.BenchPress :
                REPAnalytics.trackScreenWithName (screenName : ScreenName.TestsBenchPress.Setup, className : String (describing : self))
            case.DeadLift :
                REPAnalytics.trackScreenWithName (screenName : ScreenName.TestsDeadlift.Setup, className : String (describing : self))
            case.Squat :
                REPAnalytics.trackScreenWithName (screenName : ScreenName.TestsSquat.Setup, className : String (describing : self))
            case.MilitaryPress :
                REPAnalytics.trackScreenWithName (screenName : ScreenName.TestsMilitaryPress.Setup, className : String (describing : self))
        }
    }

    private func setUpView () {
        self.instructionsLabelOne.textColor = .white
        self.instructionsLabelTwo.textColor = .white
        self.videoLabel.textColor = .white
        self.nextButton.setUpOrangeREPerformanceButton ()
        self.nextButton.setEnabled (enabled : false)
        uploadButton.imageView?.contentMode = .scaleAspectFit
        notUploadButton.imageView?.contentMode = .scaleAspectFit
        applyLayout (buttons : buttons)
        applyLayout (buttons : videoButtons)
    }

    private func applyLayout (buttons : Array <UIButton>) {
        for currentButton in buttons {
            currentButton.roundCornersAndApplyBorder ()
            currentButton.textColor = UIColor.white
            currentButton.titleLabel?.lineBreakMode = NSLineBreakMode.byWordWrapping
            currentButton.titleLabel?.numberOfLines = 2
            currentButton.titleLabel?.textAlignment = NSTextAlignment.center
        }
    }

    private func populateFields () {
        guard let exercisesStartViewControllerContent = self.exercisesStartViewControllerContent else {
            UIAlertController.showAlert (L10n.exerciseInfoErrorTitle, message : L10n.exerciseInfoErrorMessage, inViewController : self)
            return
        }
        self.title = exercisesStartViewControllerContent.title
        self.instructionsLabelOne?.text = exercisesStartViewControllerContent.instructionsLabel1Text
        if let instructionsLabel2Text = self.exercisesStartViewControllerContent?.instructionsLabel2Text {
            self.instructionsLabelTwo?.text = instructionsLabel2Text
        } else {
            self.instructionsLabelTwo?.removeFromSuperview ()
        }
        self.button1?.setTitle (exercisesStartViewControllerContent.button1Text, for : .normal)
        self.button2?.setTitle (exercisesStartViewControllerContent.button2Text, for : .normal)
        if let button3Text = self.exercisesStartViewControllerContent?.button3Text {
            self.button3?.setTitle (button3Text, for : .normal)
        } else {
            button3.superview?.removeFromSuperview ()
        }
        if let button4Text = self.exercisesStartViewControllerContent?.button4Text {
            self.button4?.setTitle (button4Text, for : .normal)
        } else {
            button4.superview?.removeFromSuperview ()
        }
    }

    private func setToggleButtonSelected (button : UIButton?, buttons : Array <UIButton>) {
        for currentButton in buttons {
            if currentButton == button {
                currentButton.backgroundColor = UIColor.init (named : .rePerformanceOrange)
            } else {
                currentButton.backgroundColor = UIColor.clear
            }
        }
        checkNextButtonState ()
    }

    private func checkNextButtonState () {
        let shouldEnable = self.exerciseTestFormat!=
        nil&&
        uploadState!=.unDetermined
        self.nextButton.setEnabled (enabled : shouldEnable)
    }

    @IBAction func button1Tapped (_ sender : UIButton) {
        exerciseTestFormat = exercisesStartViewControllerContent?.exerciseTestFormatButton1
        setToggleButtonSelected (button : button1, buttons : buttons)
    }

    @IBAction func button2Tapped (_ sender : UIButton) {
        exerciseTestFormat = exercisesStartViewControllerContent?.exerciseTestFormatButton2
        setToggleButtonSelected (button : button2, buttons : buttons)
    }

    @IBAction func button3Tapped (_ sender : UIButton) {
        exerciseTestFormat = exercisesStartViewControllerContent?.exerciseTestFormatButton3
        setToggleButtonSelected (button : button3, buttons : buttons)
    }

    @IBAction func button4Tapped (_ sender : UIButton) {
        exerciseTestFormat = exercisesStartViewControllerContent?.exerciseTestFormatButton4
        setToggleButtonSelected (button : button4, buttons : buttons)
    }

    @IBAction func uploadTapped (_ sender : UIButton) {
        uploadState = .upload
        setToggleButtonSelected (button : uploadButton, buttons : videoButtons)
    }

    @IBAction func notUploadTapped (_ sender : UIButton) {
        uploadState = .notUpload
        setToggleButtonSelected (button : notUploadButton, buttons : videoButtons)
    }

    @IBAction func nextTapped (_ sender : UIButton) {
        guard let exerciseTestFormat = self.exerciseTestFormat, uploadState!=.unDetermined else {
            return
        }
        nextButtonClosure? (exerciseTestFormat, uploadState)
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/ChatUserTableViewCell.swift" startline="1" endline="76">
import UIKit
import AlamofireImage

class ChatUserTableViewCell : UITableViewCell {
    @IBOutlet fileprivate var userProfileImageView : UIImageView?
    @IBOutlet fileprivate var athleteNameLabel : UILabel?
    @IBOutlet fileprivate var lastMessageTimeIntervalLabel : UILabel?
    @IBOutlet fileprivate var unreadMessagesIndicatorView : UIView?
    @IBOutlet fileprivate var unreadMessagesCountLabel : UILabel?
    var userProfileImage : UIImage? = nil {
        didSet {
            self.userProfileImageView?.image = self.userProfileImage
        }
    }
    var userProfileURL : String? = nil {
        didSet {
            if let userProfileURL = userProfileURL {
                UIImage.userProfileImage (url : URL (string : userProfileURL), completion : {
                    (image) in self.userProfileImage = image
                })
            }
        }
    }
    var athleteName : String? = nil {
        didSet {
            self.athleteNameLabel?.text = self.athleteName
        }
    }
    var lastMessageTimeInterval : String? = nil {
        didSet {
            self.lastMessageTimeIntervalLabel?.text = self.lastMessageTimeInterval
        }
    }
    var unreadMessagesCount : Int = 0 {
        didSet {
            self.unreadMessagesCountLabel?.text = "\(self.unreadMessagesCount)"
            self.unreadMessagesIndicatorView?.isHidden = (self.unreadMessagesCount< = 0)
        }
    }

    override func prepareForReuse () {
        self.userProfileImage = Asset.Assets.nonFacebook.image
        self.athleteName = nil
        self.lastMessageTimeInterval = nil
        self.unreadMessagesCount = 0
        super.prepareForReuse ()
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/ExercisesReportRepsViewController.swift" startline="1" endline="63">
import UIKit

class ExercisesReportRepsViewController : ExercisesReportViewController {
    private let repsTextFieldUpperBounds : Int = 1000
    @IBOutlet private var repsPerformedTextField : REPCustomTextField?

    override func setUpView () {
        super.setUpView ()
        instructionsLabel?.text = L10n.exerciseWeightLiftingInputInstructions
        repsPerformedTextField?.roundCornersAndApplyBorder ()
        repsPerformedTextField?.keyboardType = .numberPad
        repsPerformedTextField?.addTarget (self, action : #selector (textFieldDidChange (textField :)), for : .editingChanged)
        repsPerformedTextField?.textColor = UIColor.white
    }

    override func wipeView () {
        super.wipeView ()
        repsPerformedTextField?.text = ""
    }

    @objc func textFieldDidChange (textField : REPCustomTextField) {
        if textField == repsPerformedTextField {
            let sanitizedResult = textField.sanitizeIntegerInput (upperBounds : repsTextFieldUpperBounds)
            exerciseScore.reps = sanitizedResult
            if let sanitizedResult = sanitizedResult {
                textField.text = String (sanitizedResult)
            } else {
                textField.text = ""
            }
        }
        if exerciseScore.reps! = nil {
            submitScoreButton?.setEnabled (enabled : true)
        } else {
            submitScoreButton?.setEnabled (enabled : false)
        }
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/REPerformanceResponse.swift" startline="1" endline="53">
import Foundation
import Moya_SwiftyJSONMapper
import SwiftyJSON

class REPerformanceBaseResponse <T : Decodable> : Decodable {
    private enum CodingKeys : String, CodingKey {
        case success = "success"
        case message = "message"
        case data = "data"
    }
    let success : Int
    let message : String
    let data : T
    required init (from decoder : Decoder) throws {
        let container = try decoder.container (keyedBy : CodingKeys.self)
        self.success = try container.decode (Int.self, forKey : .success)
        self.message = try container.decode (String.self, forKey : .message)
        self.data = try container.decode (T.self, forKey : .data)
    }
}

final class REPerformanceResponse : ALSwiftyJSONAble {
    let data : [String : JSON]
    let success : Bool
    let message : String
    let arrayData : [JSON]
    required init? (jsonData : JSON) {
        self.data = jsonData ["data"].dictionaryValue
        self.success = jsonData ["success"].boolValue
        self.message = jsonData ["message"].stringValue
        self.arrayData = jsonData ["data"].arrayValue
    }
}

</source>
<source file="systems/swift/reperformance_swift/REPerformance/ChooseAGymViewController.swift" startline="1" endline="267">
import UIKit
import GoogleMaps
protocol MapSearchDelegate {

    func didSelectLocation (repPlace : REPPlace)
}

class ChooseAGymViewController : UIViewController {
    @IBOutlet private var searchBarView : UIView?
    @IBOutlet fileprivate var mapView : GMSMapView?
    @IBOutlet private var bottomViewConstraint : NSLayoutConstraint?
    @IBOutlet private var bottomView : UIView?
    @IBOutlet private var bottomTitleLabel : UILabel?
    @IBOutlet private var bottomAddressLabel : UILabel?
    let locationManager = CLLocationManager ()
    var searchController : UISearchController? = nil
    var nearbyGyms : [(repPlace : REPPlace, marker : GMSMarker?)] = []
    var alreadyCalled : Bool = false
    var selectedGym : REPPlace? = nil
    var attributions : [String]? = nil
    var didLoad : (() - > ())?
    var findNearbyGyms : ((_ currentLocation : CLLocationCoordinate2D, _ pageToken : String?) - > ())?
    var selectGym : ((REPPlace) - > ())?

    override func viewDidLoad () {
        super.viewDidLoad ()
        navigationItem.leftBarButtonItem = UIBarButtonItem (image : Asset.Assets.xIcon.image, style : .plain, target : self, action : #selector (closeButtonTapped (_ :)))
        setUpBottomView ()
        setUpMap ()
        setUpLoactionManager ()
        setUpSearchController ()
        didLoad? ()
    }

    @IBAction func closeButtonTapped (_ sender : UIButton?) {
        self.dismiss (animated : true, completion : nil)
    }

    @IBAction func attributionsButtonTapped (_ sender : UIButton?) {
        let attributionsVC = StoryboardScene.Leaderboard.attributionsVC.instantiate ()
        attributionsVC.willAppear = {
            if let attributions = self.attributions, attributions.count > 0 {
                attributionsVC.loadHTMLAttributions (attributions : attributions)
            }
        }
        navigationController?.pushViewController (attributionsVC, animated : true)
    }

    override func viewWillDisappear (_ animated : Bool) {
        super.viewWillDisappear (animated)
        if let searchController = searchController, searchController.isActive {
            searchController.dismiss (animated : false, completion : nil)
        }
    }

    func loadAttributions () {
        if let attributions = attributions, attributions.count > 0 {
            navigationItem.rightBarButtonItem = UIBarButtonItem (title : "Attributions", style : .plain, target : self, action : #selector (attributionsButtonTapped (_ :)))
        } else {
            navigationItem.rightBarButtonItem = nil
        }
    }

    func setUpBottomView () {
        if let selectedGym = selectedGym {
            bottomTitleLabel?.text = selectedGym.name
            bottomAddressLabel?.text = selectedGym.vicinity
            animateBottomView (up : true)
        } else {
            bottomTitleLabel?.text = ""
            bottomAddressLabel?.text = ""
            animateBottomView (up : false)
        }
    }

    func animateBottomView (up : Bool) {
        var constant : CGFloat = 0
        if ! up {
            if let height = bottomView?.bounds.height {
                constant = - height
            } else {
                constant = - 70.0
            }
        }
        UIView.animate (withDuration : 0.5) {
            self.bottomViewConstraint?.constant = constant
            self.view.layoutIfNeeded ()
        }
    }

    func setUpMap () {
        mapView?.delegate = self
    }

    func searchForNearbyGyms (pageToken : String?) {
        if let userLocation = locationManager.location?.coordinate {
            findNearbyGyms? (userLocation, pageToken)
        }
    }

    func showGyms () {
        mapView?.clear ()
        var bounds = GMSCoordinateBounds ()
        for i in nearbyGyms.indices {
            if let marker = nearbyGyms [i].marker {
                marker.map = mapView
            } else {
                let marker = GMSMarker (position : nearbyGyms [i].repPlace.location)
                marker.title = nearbyGyms [i].repPlace.name
                marker.snippet = nearbyGyms [i].repPlace.vicinity
                marker.icon = GMSMarker.markerImage (with : UIColor (named : .rePerformanceOrange))
                marker.map = mapView
                nearbyGyms [i].marker = marker
            }
            if let position = nearbyGyms [i].marker?.position {
                bounds = bounds.includingCoordinate (position)
            }
            if let userLocation = mapView?.myLocation?.coordinate {
                bounds = bounds.includingCoordinate (userLocation)
            }
        }
        mapView?.animate (with : GMSCameraUpdate.fit (bounds, withPadding : 30.0))
    }

    func showPin (repPlace : REPPlace) {
        mapView?.clear ()
        var bounds = GMSCoordinateBounds ()
        let marker = GMSMarker (position : repPlace.location)
        marker.title = repPlace.name
        marker.snippet = repPlace.vicinity
        marker.icon = GMSMarker.markerImage (with : UIColor (named : .rePerformanceOrange))
        marker.map = mapView
        bounds = bounds.includingCoordinate (marker.position)
        if let userLocation = mapView?.myLocation?.coordinate {
            bounds = bounds.includingCoordinate (userLocation)
        }
        mapView?.animate (with : GMSCameraUpdate.fit (bounds, withPadding : 30.0))
    }

    func setUpLoactionManager () {
        locationManager.delegate = self
        locationManager.desiredAccuracy = kCLLocationAccuracyBest
        locationManager.requestWhenInUseAuthorization ()
    }

    func setUpSearchController () {
        let mapSearchResultsTableViewController = StoryboardScene.Leaderboard.mapSearchResultsTVC.instantiate ()
        mapSearchResultsTableViewController.mapSearchDelegate = self
        let enclosingNav = UINavigationController (rootViewController : mapSearchResultsTableViewController)
        if let currentGymPlaceID = UserDefaults.standard.currentGymPlaceID, currentGymPlaceID! = "" {
            mapSearchResultsTableViewController.title = L10n.chooseAGymTitleChange
        } else {
            mapSearchResultsTableViewController.title = L10n.chooseAGymTitleFind
        }
        enclosingNav.navigationBar.setHalfLeaderboardGradientBackground ()
        mapSearchResultsTableViewController.mapView = mapView
        searchController = UISearchController (searchResultsController : enclosingNav)
        searchController?.searchBar.delegate = mapSearchResultsTableViewController
        if let searchBar = searchController?.searchBar {
            searchBarView?.addSubview (searchBar)
            let gradientLayer = CAGradientLayer (frame : searchBar.frame, colors : [UIColor (named : .rePerformanceNavGradientMiddle), UIColor (named : .rePerformanceNavGradientEnd)])
            searchBar.setBackgroundImage (gradientLayer.createGradientImage (), for : .any, barMetrics : .default)
            searchBar.tintColor = UIColor.white
            if let searchTextField : UITextField = searchBar.value (forKey : "searchField") as? UITextField {
                searchTextField.backgroundColor = UIColor.white.withAlphaComponent (Constants.UIConstants.SearchBar.BackgroundAlpha)
                searchTextField.layer.cornerRadius = Constants.UIConstants.SearchBar.CornerRadius
                searchTextField.layer.borderColor = UIColor.white.cgColor
                searchTextField.layer.borderWidth = Constants.UIConstants.SearchBar.BorderWidth
                searchTextField.textColor = UIColor.white
                searchTextField.attributedPlaceholder = NSAttributedString (string : L10n.chooseAGymSearchPlaceholder, attributes : [NSAttributedString.Key.foregroundColor : UIColor.white.withAlphaComponent (Constants.UIConstants.SearchBar.
                  PlaceholderAlpha)])
                if let magnifyingGlassIcon : UIImageView = searchTextField.leftView as? UIImageView {
                    magnifyingGlassIcon.image = magnifyingGlassIcon.image?.withRenderingMode ( .alwaysTemplate)
                    magnifyingGlassIcon.tintColor = UIColor.white
                }
                if let clearButton : UIButton = searchTextField.value (forKey : "clearButton") as? UIButton {
                    clearButton.setImage (clearButton.imageView?.image?.withRenderingMode ( .alwaysTemplate), for : .normal)
                    clearButton.tintColor = UIColor.white
                }
            }
        }
        searchController?.hidesNavigationBarDuringPresentation = false
        searchController?.dimsBackgroundDuringPresentation = false
        searchController?.definesPresentationContext = true
    }

    @IBAction private func selectButtonTapped (_ sender : UIButton?) {
        if let selectedGym = selectedGym {
            selectGym? (selectedGym)
        }
    }
}

extension ChooseAGymViewController : GMSMapViewDelegate {

    func mapView (_ mapView : GMSMapView, didTap marker : GMSMarker) - > Bool {
        for gym in nearbyGyms {
            if gym.marker == marker {
                selectedGym = gym.repPlace
                setUpBottomView ()
            }
        }
        return false
    }
}

extension ChooseAGymViewController : CLLocationManagerDelegate {

    func locationManager (_ manager : CLLocationManager, didChangeAuthorization status : CLAuthorizationStatus) {
        if status==.authorizedWhenInUse {
            locationManager.requestLocation ()
            mapView?.isMyLocationEnabled = true
        } else if status==.denied {
            UIAlertController.showAlert (nil, message : L10n.unableDetermineLocationMessage, inViewController : self)
        }
    }

    func locationManager (_ manager : CLLocationManager, didUpdateLocations locations : [CLLocation]) {
        if let mostRecentLocation = locations.last {
            let zoomLevel : Float = 15.0
            let camera = GMSCameraPosition.camera (withLatitude : mostRecentLocation.coordinate.latitude, longitude : mostRecentLocation.coordinate.longitude, zoom : zoomLevel)
            mapView?.camera = camera
            if ! alreadyCalled {
                if manager.location! = nil {
                    locationManager.stopUpdatingLocation ()
                    alreadyCalled = true
                    searchForNearbyGyms (pageToken : nil)
                }
            }
        }
    }

    func locationManager (_ manager : CLLocationManager, didFailWithError error : Error) {
        UIAlertController.showAlert (nil, message : L10n.unableDetermineLocationMessage, inViewController : self)
    }
}

extension ChooseAGymViewController : MapSearchDelegate {

    func didSelectLocation (repPlace : REPPlace) {
        selectedGym = repPlace
        setUpBottomView ()
        showPin (repPlace : repPlace)
    }
}

</source>
