<source file="systems/ruby/discourse-master/app/models/topic_posters_summary.rb" startline="62" endline="64">
def last_poster_is_topic_creator?
    topic.user_id == topic.last_post_user_id
end
</source>
<source file="systems/ruby/discourse-master/app/models/topic_posters_summary.rb" startline="66" endline="68">
def sorted_top_posters
    shuffle_last_poster_to_back_in top_posters
end
</source>
<source file="systems/ruby/discourse-master/app/models/topic_posters_summary.rb" startline="70" endline="72">
def top_posters
    user_ids.map {|id| avatar_lookup [id]
    }.compact.uniq.take (5)
end
</source>
<source file="systems/ruby/discourse-master/app/models/topic_posters_summary.rb" startline="74" endline="76">
def user_ids
    [topic.user_id, topic.last_post_user_id, * topic.featured_user_ids]
end
</source>
<source file="systems/ruby/discourse-master/app/models/topic_posters_summary.rb" startline="78" endline="80">
def avatar_lookup
    @avatar_lookup ||= options [:avatar_lookup] || AvatarLookup.new (user_ids)
end
</source>
<source file="systems/ruby/discourse-master/app/models/topic_posters_summary.rb" startline="82" endline="84">
def primary_group_lookup
    @primary_group_lookup ||= options [:primary_group_lookup] || PrimaryGroupLookup.new (user_ids)
end
</source>
<source file="systems/ruby/discourse-master/app/models/directory_item.rb" startline="5" endline="13">
def self.headings
    @headings ||= [:likes_received,
        :likes_given,
        :topics_entered,
        :topic_count,
        :post_count,
        :posts_read,
        :days_visited]
end
</source>
<source file="systems/ruby/discourse-master/app/models/directory_item.rb" startline="15" endline="22">
def self.period_types
    @types ||= Enum.new (all : 1,
            yearly : 2,
            monthly : 3,
            weekly : 4,
            daily : 5,
            quarterly : 6)
end
</source>
<source file="systems/ruby/discourse-master/app/models/directory_item.rb" startline="24" endline="26">
def self.refresh!
    period_types.each_key {|p| refresh_period! (p)
    }
end
</source>
<source file="systems/ruby/discourse-master/app/models/directory_item.rb" startline="28" endline="143">
def self.refresh_period! (period_type, force : false)
    return unless SiteSetting.enable_user_directory? || force
    since =
    case period_type
        when :daily then 1.day.ago
        when :weekly then 1.week.ago
        when :monthly then 1.month.ago
        when :quarterly then 3.months.ago
        when :yearly then 1.year.ago
        else 1000.years.ago
    end
    ActiveRecord :: Base.transaction do
        exec_sql "DELETE FROM directory_items
                USING directory_items di
                LEFT JOIN users u ON (u.id = user_id AND u.active AND u.silenced_till IS NULL AND u.id > 0)
                WHERE di.id = directory_items.id AND
                      u.id IS NULL AND
                      di.period_type = :period_type", period_type : period_types [period_type]
        exec_sql "INSERT INTO directory_items(period_type, user_id, likes_received, likes_given, topics_entered, days_visited, posts_read, topic_count, post_count)
                SELECT
                    :period_type,
                    u.id,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                FROM users u
                LEFT JOIN directory_items di ON di.user_id = u.id AND di.period_type = :period_type
                WHERE di.id IS NULL AND u.id > 0 AND u.silenced_till IS NULL and u.active
      ", period_type : period_types [period_type]
        exec_sql"WITH x AS (SELECT
                    u.id user_id,
                    SUM(CASE WHEN p.id IS NOT NULL AND t.id IS NOT NULL AND ua.action_type = :was_liked_type THEN 1 ELSE 0 END) likes_received,
                    SUM(CASE WHEN p.id IS NOT NULL AND t.id IS NOT NULL AND ua.action_type = :like_type THEN 1 ELSE 0 END) likes_given,
                    COALESCE((SELECT COUNT(topic_id) FROM topic_views AS v WHERE v.user_id = u.id AND v.viewed_at >= :since), 0) topics_entered,
                    COALESCE((SELECT COUNT(id) FROM user_visits AS uv WHERE uv.user_id = u.id AND uv.visited_at >= :since), 0) days_visited,
                    COALESCE((SELECT SUM(posts_read) FROM user_visits AS uv2 WHERE uv2.user_id = u.id AND uv2.visited_at >= :since), 0) posts_read,
                    SUM(CASE WHEN t2.id IS NOT NULL AND ua.action_type = :new_topic_type THEN 1 ELSE 0 END) topic_count,
                    SUM(CASE WHEN p.id IS NOT NULL AND t.id IS NOT NULL AND ua.action_type = :reply_type THEN 1 ELSE 0 END) post_count
                  FROM users AS u
                  LEFT OUTER JOIN user_actions AS ua ON ua.user_id = u.id AND COALESCE(ua.created_at, :since) >= :since
                  LEFT OUTER JOIN posts AS p ON ua.target_post_id = p.id AND p.deleted_at IS NULL AND p.post_type = :regular_post_type AND NOT p.hidden
                  LEFT OUTER JOIN topics AS t ON p.topic_id = t.id AND t.archetype = 'regular' AND t.deleted_at IS NULL AND t.visible
                  LEFT OUTER JOIN topics AS t2 ON t2.id = ua.target_topic_id AND t2.archetype = 'regular' AND t2.deleted_at IS NULL AND t2.visible
                  LEFT OUTER JOIN categories AS c ON t.category_id = c.id
                  WHERE u.active
                    AND u.silenced_till IS NULL
                    AND u.id > 0
                  GROUP BY u.id)
      UPDATE directory_items di SET
               likes_received = x.likes_received,
               likes_given = x.likes_given,
               topics_entered = x.topics_entered,
               days_visited = x.days_visited,
               posts_read = x.posts_read,
               topic_count = x.topic_count,
               post_count = x.post_count
      FROM x
      WHERE
        x.user_id = di.user_id AND
        di.period_type = :period_type AND (
        di.likes_received <> x.likes_received OR
        di.likes_given <> x.likes_given OR
        di.topics_entered <> x.topics_entered OR
        di.days_visited <> x.days_visited OR
        di.posts_read <> x.posts_read OR
        di.topic_count <> x.topic_count OR
        di.post_count <> x.post_count )

      "
            ,
            period_type : period_types [period_type],
            since : since,
            like_type : UserAction :: LIKE,
            was_liked_type : UserAction :: WAS_LIKED,
            new_topic_type : UserAction :: NEW_TOPIC,
            reply_type : UserAction :: REPLY,
            regular_post_type : Post.types [:regular]
        if period_type == :all
            exec_sql <<SQL
                    UPDATE user_stats s
                    SET likes_given = d.likes_given,
                    likes_received = d.likes_received,
                    topic_count = d.topic_count,
                    post_count = d.post_count

                    FROM directory_items d
                    WHERE s.user_id = d.user_id AND
                    d.period_type = 1 AND
                    (s.likes_given < > d.likes_given OR
                    s.likes_received < > d.likes_received OR
                    s.topic_count < > d.topic_count OR
                    s.post_count < > d.post_count
                    )

                SQL
        end
    end
end
</source>
<source file="systems/ruby/discourse-master/app/models/topic_featured_users.rb" startline="4" endline="6">
def initialize (topic)
    @topic = topic
end
</source>
<source file="systems/ruby/discourse-master/app/models/topic_featured_users.rb" startline="8" endline="10">
def self.count
    4
end
</source>
<source file="systems/ruby/discourse-master/app/models/topic_featured_users.rb" startline="13" endline="16">
def choose (args = {
})
    self.class.ensure_consistency! (topic.id.to_i)
    update_participant_count
end
</source>
<source file="systems/ruby/discourse-master/app/models/topic_featured_users.rb" startline="18" endline="23">
def user_ids
    [topic.featured_user1_id,
        topic.featured_user2_id,
        topic.featured_user3_id,
        topic.featured_user4_id].uniq.compact
end
</source>
<source file="systems/ruby/discourse-master/app/models/topic_featured_users.rb" startline="25" endline="83">
def self.ensure_consistency! (topic_id = nil)
    filter = "#{"AND t.id = #{topic_id.to_i}" if topic_id}"
    filter2 = "#{"AND tt.id = #{topic_id.to_i}" if topic_id}"
    sql = <<SQL

        WITH cte as (
        SELECT
        t.id,
        p.user_id,
        MAX (p.created_at) last_post_date,
        ROW_NUMBER () OVER (PARTITION BY t.id ORDER BY COUNT (*) DESC, MAX (p.created_at) DESC) as rank
        FROM topics t
        JOIN posts p ON p.topic_id = t.id
        WHERE p.deleted_at IS NULL AND
        NOT p.hidden AND
        p.post_type in (#{Topic.visible_post_types.join(",")}) AND
        p.user_id < > t.user_id AND
        p.user_id < > t.last_post_user_id
        #{filter}
        GROUP BY t.id, p.user_id
        ),

        cte2 as (
        SELECT id, user_id, ROW_NUMBER () OVER (PARTITION BY id ORDER BY last_post_date ASC) as rank
        FROM cte
        WHERE rank <= #{count}
        )

        UPDATE topics tt
        SET
        featured_user1_id = x.featured_user1,
        featured_user2_id = x.featured_user2,
        featured_user3_id = x.featured_user3,
        featured_user4_id = x.featured_user4
        FROM topics AS tt2
        LEFT OUTER JOIN (
        SELECT
        c.id,
        MAX (case when c.rank = 1 then c.user_id end) featured_user1,
        MAX (case when c.rank = 2 then c.user_id end) featured_user2,
        MAX (case when c.rank = 3 then c.user_id end) featured_user3,
        MAX (case when c.rank = 4 then c.user_id end) featured_user4
        FROM cte2 as c
        GROUP BY c.id
        ) x ON x.id = tt2.id
        WHERE tt.id = tt2.id AND
        (
        COALESCE (tt.featured_user1_id, - 99) < > COALESCE (x.featured_user1, - 99) OR
        COALESCE (tt.featured_user2_id, - 99) < > COALESCE (x.featured_user2, - 99) OR
        COALESCE (tt.featured_user3_id, - 99) < > COALESCE (x.featured_user3, - 99) OR
        COALESCE (tt.featured_user4_id, - 99) < > COALESCE (x.featured_user4, - 99)
        )
        #{filter2}
    SQL
    Topic.exec_sql (sql)
end
</source>
<source file="systems/ruby/discourse-master/app/models/topic_featured_users.rb" startline="87" endline="90">
def update_participant_count
    count = topic.posts.where ('NOT hidden AND post_type in (?)', Topic.visible_post_types).count ('distinct user_id')
    topic.update_columns (participant_count : count)
end
</source>
<source file="systems/ruby/discourse-master/app/models/group_history.rb" startline="10" endline="18">
def self.actions
    @actions ||= Enum.new (
            change_group_setting : 1,
            add_user_to_group : 2,
            remove_user_from_group : 3,
            make_user_group_owner : 4,
            remove_user_as_group_owner : 5
        )
end
</source>
<source file="systems/ruby/discourse-master/app/models/group_history.rb" startline="20" endline="27">
def self.filters
    [
        :acting_user,
        :target_user,
        :action,
        :subject
        ]
end
</source>
<source file="systems/ruby/discourse-master/app/models/group_history.rb" startline="29" endline="48">
def self.with_filters (group, params = {
})
    records = self.includes (:acting_user, :target_user)
    .where (group_id : group.id)
    .order ('group_histories.created_at DESC')
    if ! params.blank?
        params = params.slice (* filters)
        records = records.where (action : self.actions [params [:action].to_sym]) unless params [:action].blank?
        records = records.where (subject : params [:subject]) unless params [:subject].blank?
        [:acting_user, :target_user].each do |filter|
            unless params [filter].blank?
                id = User.where (username_lower : params [filter]).pluck (:id)
                records = records.where ("#{filter}_id" => id)
            end
        end
    end
    records
end
</source>
<source file="systems/ruby/discourse-master/app/models/locale_site_setting.rb" startline="5" endline="7">
def self.valid_value? (val)
    supported_locales.include? (val)
end
</source>
<source file="systems/ruby/discourse-master/app/models/locale_site_setting.rb" startline="9" endline="17">
def self.values
    @values ||= supported_locales.map do |locale|
        lang = language_names [locale] || language_names [locale.split ("_") [0]]
        {
        name : lang ? lang ['nativeName'] : locale,
        value : locale

        }
    end
end
</source>
<source file="systems/ruby/discourse-master/app/models/locale_site_setting.rb" startline="21" endline="37">
def self.language_names
    return @language_names if @language_names
    @lock.synchronize do
        @language_names ||= begin
            names = YAML.load (File.read (File.join (Rails.root, 'config', 'locales', 'names.yml')))
            DiscoursePluginRegistry.locales.each do |locale,options|
                if ! names.key? (locale) && options [:name] && options [:nativeName]
                    names [locale] = {"name" => options [:name], "nativeName" => options [:nativeName]

                    }
                end
            end
            names
        end
    end
end
</source>
<source file="systems/ruby/discourse-master/app/models/locale_site_setting.rb" startline="39" endline="50">
def self.supported_locales
    @lock.synchronize do
        @supported_locales ||= begin
            locales = Dir.glob (
                    File.join (Rails.root, 'config', 'locales', 'client.*.yml')
                ).map {|x| x.split ('.') [-2]
            }
            locales += DiscoursePluginRegistry.locales.keys
            locales.uniq.sort
        end
    end
end
</source>
<source file="systems/ruby/discourse-master/app/models/locale_site_setting.rb" startline="52" endline="56">
def self.reset!
    @lock.synchronize do
        @values = @language_names = @supported_locales = nil
    end
end
</source>
<source file="systems/ruby/discourse-master/app/models/locale_site_setting.rb" startline="58" endline="61">
def self.fallback_locale (locale)
    plugin_locale = DiscoursePluginRegistry.locales [locale.to_s]
    plugin_locale ? plugin_locale [:fallbackLocale] &.to_sym : nil
end
</source>
<source file="systems/ruby/discourse-master/app/models/scheduler_stat.rb" startline="2" endline="4">
def self.purge_old
    where ('started_at < ?', 1.months.ago).delete_all
end
</source>
<source file="systems/ruby/discourse-master/app/models/user_profile.rb" startline="23" endline="27">
def bio_excerpt (length = 350, opts = {
})
    excerpt = PrettyText.excerpt (bio_cooked, length, opts).sub (/<br>$/, '')
    return excerpt if excerpt.blank? || (user.has_trust_level? (TrustLevel [1]) && ! user.suspended?)
    PrettyText.strip_links (excerpt)
end
</source>
<source file="systems/ruby/discourse-master/app/models/user_profile.rb" startline="29" endline="32">
def bio_processed
    return bio_cooked if bio_cooked.blank? || (user.has_trust_level? (TrustLevel [1]) && ! user.suspended?)
    PrettyText.strip_links (bio_cooked)
end
</source>
<source file="systems/ruby/discourse-master/app/models/user_profile.rb" startline="34" endline="37">
def bio_summary
    return nil unless bio_cooked.present?
    bio_excerpt (500, strip_links : true, text_entities : true)
end
</source>
<source file="systems/ruby/discourse-master/app/models/user_profile.rb" startline="39" endline="42">
def recook_bio
    self.bio_raw_will_change!
    cook
end
</source>
<source file="systems/ruby/discourse-master/app/models/user_profile.rb" startline="44" endline="47">
def upload_card_background (upload)
    self.card_background = upload.url
    self.save!
end
</source>
<source file="systems/ruby/discourse-master/app/models/user_profile.rb" startline="49" endline="52">
def clear_card_background
    self.card_background = ""
    self.save!
end
</source>
<source file="systems/ruby/discourse-master/app/models/user_profile.rb" startline="54" endline="57">
def upload_profile_background (upload)
    self.profile_background = upload.url
    self.save!
end
</source>
<source file="systems/ruby/discourse-master/app/models/user_profile.rb" startline="59" endline="62">
def clear_profile_background
    self.profile_background = ""
    self.save!
end
</source>
<source file="systems/ruby/discourse-master/app/models/user_profile.rb" startline="64" endline="75">
def self.rebake_old (limit)
    problems = []
    UserProfile.where ('bio_cooked_version IS NULL OR bio_cooked_version < ?', BAKED_VERSION)
    .limit (limit).each do |p|
        begin
            p.rebake!
        rescue => e
            problems << {profile : p, ex : e

            }
        end
    end
    problems
end
</source>
<source file="systems/ruby/discourse-master/app/models/user_profile.rb" startline="77" endline="79">
def rebake!
    update_columns (bio_cooked : cooked, bio_cooked_version : BAKED_VERSION)
end
</source>
<source file="systems/ruby/discourse-master/app/models/user_profile.rb" startline="83" endline="85">
def trigger_badges
    BadgeGranter.queue_badge_grant (Badge :: Trigger :: UserChange, user : self)
end
</source>
<source file="systems/ruby/discourse-master/app/models/user_profile.rb" startline="89" endline="95">
def cooked
    if self.bio_raw.present?
        PrettyText.cook (self.bio_raw, omit_nofollow : user.has_trust_level? (TrustLevel [3]) && ! SiteSetting.tl3_links_no_follow)
    else
        nil
    end
end
</source>
<source file="systems/ruby/discourse-master/app/models/user_profile.rb" startline="97" endline="106">
def cook
    if self.bio_raw.present?
        if bio_raw_changed?
            self.bio_cooked = cooked
            self.bio_cooked_version = BAKED_VERSION
        end
    else
        self.bio_cooked = nil
    end
end
</source>
<source file="systems/ruby/discourse-master/app/models/user_profile.rb" startline="108" endline="114">
def website_domain_validator
    allowed_domains = SiteSetting.user_website_domains_whitelist
    return if (allowed_domains.blank? || self.website.blank?)
    domain = URI.parse (self.website).host
    self.errors.add :base, (I18n.t ('user.website.domain_not_allowed', domains : allowed_domains.split ('|').join (", "))) unless allowed_domains.split ('|').include? (domain)
end
</source>
<source file="systems/ruby/discourse-master/app/models/topic_view_item.rb" startline="9" endline="50">
def self.add (topic_id, ip, user_id = nil, at = nil, skip_redis = false)
    at ||= Date.today
    redis_key = "view:#{topic_id}:#{at}"
    if user_id
        redis_key << ":user-#{user_id}"
    else
        redis_key << ":ip-#{ip}"
    end
    if skip_redis || $redis.setnx (redis_key, "1")
        skip_redis || $redis.expire (redis_key, SiteSetting.topic_view_duration_hours.hours)
        TopicViewItem.transaction do
            sql = "INSERT INTO topic_views (topic_id, ip_address, viewed_at, user_id)
               SELECT :topic_id, :ip_address, :viewed_at, :user_id
               WHERE NOT EXISTS (
                 SELECT 1 FROM topic_views
                 /*where*/
               )"
            builder = SqlBuilder.new (sql)
            if ! user_id
                builder.where ("ip_address = :ip_address AND topic_id = :topic_id AND user_id IS NULL")
            else
                builder.where ("user_id = :user_id AND topic_id = :topic_id")
            end
            result = builder.exec (topic_id : topic_id, ip_address : ip, viewed_at : at, user_id : user_id)
            Topic.where (id : topic_id).update_all 'views = views + 1'
            if result.cmd_tuples > 0
                UserStat.where (user_id : user_id).update_all 'topics_entered = topics_entered + 1' if user_id
            end
        end
    end
end
</source>
<source file="systems/ruby/discourse-master/app/models/user_profile_view.rb" startline="6" endline="42">
def self.add (user_profile_id, ip, user_id = nil, at = nil, skip_redis = false)
    at ||= Time.zone.now
    redis_key = "user-profile-view:#{user_profile_id}:#{at.to_date}"
    if user_id
        return if user_id < 1
        redis_key << ":user-#{user_id}"
    else
        redis_key << ":ip-#{ip}"
    end
    if skip_redis || $redis.setnx (redis_key, '1')
        skip_redis || $redis.expire (redis_key, SiteSetting.user_profile_view_duration_hours.hours)
        self.transaction do
            sql = "INSERT INTO user_profile_views (user_profile_id, ip_address, viewed_at, user_id)
               SELECT :user_profile_id, :ip_address, :viewed_at, :user_id
               WHERE NOT EXISTS (
                  SELECT 1 FROM user_profile_views
                  /*where*/
               )"
            builder = SqlBuilder.new (sql)
            if ! user_id
                builder.where ("viewed_at = :viewed_at AND ip_address = :ip_address AND user_profile_id = :user_profile_id AND user_id IS NULL")
            else
                builder.where ("viewed_at = :viewed_at AND user_id = :user_id AND user_profile_id = :user_profile_id")
            end
            result = builder.exec (user_profile_id : user_profile_id, ip_address : ip, viewed_at : at, user_id : user_id)
            if result.cmd_tuples > 0
                UserProfile.find (user_profile_id).increment! (:views)
            end
        end
    end
end
</source>
<source file="systems/ruby/discourse-master/app/models/user_profile_view.rb" startline="44" endline="52">
def self.profile_views_by_day (start_date, end_date, group_id = nil)
    profile_views = self.where ("viewed_at >= ? AND viewed_at < ?", start_date, end_date + 1.day)
    if group_id
        profile_views = profile_views.joins ("INNER JOIN users ON users.id = user_profile_views.user_id")
        profile_views = profile_views.joins ("INNER JOIN group_users ON group_users.user_id = users.id")
        profile_views = profile_views.where ("group_users.group_id = ?", group_id)
    end
    profile_views.group ("date(viewed_at)").order ("date(viewed_at)").count
end
</source>
<source file="systems/ruby/discourse-master/app/models/plugin_store.rb" startline="5" endline="7">
def initialize (plugin_name)
    @plugin_name = plugin_name
end
</source>
<source file="systems/ruby/discourse-master/app/models/plugin_store.rb" startline="9" endline="11">
def get (key)
    self.class.get (plugin_name, key)
end
</source>
<source file="systems/ruby/discourse-master/app/models/plugin_store.rb" startline="13" endline="15">
def set (key, value)
    self.class.set (plugin_name, key, value)
end
</source>
<source file="systems/ruby/discourse-master/app/models/plugin_store.rb" startline="17" endline="19">
def remove (key)
    self.class.remove (plugin_name, key)
end
</source>
<source file="systems/ruby/discourse-master/app/models/plugin_store.rb" startline="21" endline="25">
def self.get (plugin_name, key)
    if row = PluginStoreRow.find_by (plugin_name : plugin_name, key : key)
        cast_value (row.type_name, row.value)
    end
end
</source>
<source file="systems/ruby/discourse-master/app/models/plugin_store.rb" startline="27" endline="41">
def self.set (plugin_name, key, value)
    hash = {plugin_name : plugin_name, key : key

    }
    row = PluginStoreRow.find_by (hash) || PluginStoreRow.new (hash)
    row.type_name = determine_type (value)
    row.value =
    if row.type_name == "JSON"
        value.to_json
    elsif value
        value.to_s
    end
    row.save
end
</source>
<source file="systems/ruby/discourse-master/app/models/plugin_store.rb" startline="43" endline="45">
def self.remove (plugin_name, key)
    PluginStoreRow.where (plugin_name : plugin_name, key : key).destroy_all
end
</source>
<source file="systems/ruby/discourse-master/app/models/plugin_store.rb" startline="47" endline="49">
def self.determine_type (value)
    value.is_a? (Hash) || value.is_a? (Array) ? "JSON" : value.class.to_s
end
</source>
<source file="systems/ruby/discourse-master/app/models/plugin_store.rb" startline="51" endline="59">
def self.map_json (item)
    if item.is_a? Hash
        ActiveSupport :: HashWithIndifferentAccess.new item
    elsif item.is_a? Array
        item.map {|subitem| map_json subitem
        }
    else
        item
    end
end
</source>
<source file="systems/ruby/discourse-master/app/models/plugin_store.rb" startline="61" endline="68">
def self.cast_value (type, value)
    case type
        when "Integer", "Fixnum" then value.to_i
        when "TrueClass", "FalseClass" then value == "true"
        when "JSON" then map_json (:: JSON.parse (value))
        else value
    end
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="100" endline="102">
def self.topic_ids
    @topic_id_cache ['ids'] || reset_topic_ids_cache
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="104" endline="106">
def self.reset_topic_ids_cache
    @topic_id_cache ['ids'] = Set.new (Category.pluck (:topic_id).compact)
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="108" endline="110">
def reset_topic_ids_cache
    Category.reset_topic_ids_cache
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="112" endline="136">
def self.scoped_to_permissions (guardian, permission_types)
    if guardian.try (:is_admin?)
        all
    elsif ! guardian || guardian.anonymous?
        if permission_types.include? (:readonly)
            where ("NOT categories.read_restricted")
        else
            where ("1 = 0")
        end
    else
        permissions = permission_types.map {|p| CategoryGroup.permission_types [p]
        }
        where ("(:staged AND LENGTH(COALESCE(email_in, '')) > 0 AND email_in_allow_strangers)
          OR categories.id NOT IN (SELECT category_id FROM category_groups)
          OR categories.id IN (
                SELECT category_id
                  FROM category_groups
                 WHERE permission_type IN (:permissions)
                   AND (group_id = :everyone OR group_id IN (SELECT group_id FROM group_users WHERE user_id = :user_id))
             )",
                staged : guardian.is_staged?,
                permissions : permissions,
                user_id : guardian.user.id,
                everyone : Group [:everyone].id)
    end
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="138" endline="180">
def self.update_stats
    topics_with_post_count = Topic
    .select ("topics.category_id, COUNT(*) topic_count, SUM(topics.posts_count) post_count")
    .where ("topics.id NOT IN (select cc.topic_id from categories cc WHERE topic_id IS NOT NULL)")
    .group ("topics.category_id")
    .visible.to_sql
    Category.exec_sql <<-SQL
            UPDATE categories c
            SET topic_count = x.topic_count,
            post_count = x.post_count
            FROM (#{topics_with_post_count}) x
            WHERE x.category_id = c.id
            AND (c.topic_count < > x.topic_count OR c.post_count < > x.post_count)
        SQL
    Category.all.each do |c|
        topics = c.topics.visible
        topics = topics.where (['topics.id <> ?', c.topic_id]) if c.topic_id
        c.topics_year = topics.created_since (1.year.ago).count
        c.topics_month = topics.created_since (1.month.ago).count
        c.topics_week = topics.created_since (1.week.ago).count
        c.topics_day = topics.created_since (1.day.ago).count
        posts = c.visible_posts
        c.posts_year = posts.created_since (1.year.ago).count
        c.posts_month = posts.created_since (1.month.ago).count
        c.posts_week = posts.created_since (1.week.ago).count
        c.posts_day = posts.created_since (1.day.ago).count
        c.save if c.changed?
    end
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="182" endline="189">
def visible_posts
    query = Post.joins (:topic)
    .where (['topics.category_id = ?', self.id])
    .where ('topics.visible = true')
    .where ('posts.deleted_at IS NULL')
    .where ('posts.user_deleted = false')
    self.topic_id ? query.where (['topics.id <> ?', self.topic_id]) : query
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="192" endline="194">
def self.post_template
    I18n.t ("category.post_template", replace_paragraph : I18n.t ("category.replace_paragraph"))
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="196" endline="204">
def create_category_definition
    t = Topic.new (title : I18n.t ("category.topic_prefix", category : name), user : user, pinned_at : Time.now, category_id : id)
    t.skip_callbacks = true
    t.ignore_category_auto_close = true
    t.delete_topic_timer (TopicTimer.types [:close])
    t.save! (validate : false)
    update_column (:topic_id, t.id)
    t.posts.create (raw : description || post_template, user : user)
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="206" endline="212">
def topic_url
    if has_attribute? ("topic_slug")
        Topic.relative_url (topic_id, read_attribute (:topic_slug))
    else
        topic_only_relative_url.try (:relative_url)
    end
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="214" endline="221">
def description_text
    return nil unless self.description
    @@cache ||= LruRedux :: ThreadSafeCache.new (1000)
    @@cache.getset (self.description) do
        Nokogiri :: HTML.fragment (self.description).text.strip
    end
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="223" endline="225">
def duplicate_slug?
    Category.where (slug : self.slug, parent_category_id : parent_category_id).where.not (id : id).any?
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="227" endline="246">
def ensure_slug
    return unless name.present?
    self.name.strip!
    if slug.present?
        self.slug = Slug.sanitize (slug)
        errors.add (:slug, 'is already in use') if duplicate_slug?
    else
        self.slug = Slug.for (name, '')
        self.slug = '' if duplicate_slug?
    end
    unless new_record?
        match_id = /^(\d+)-category/.match (self.slug)
        errors.add (:slug, :invalid) if match_id && match_id [1] && match_id [1] != self.id.to_s
    end
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="248" endline="250">
def slug_for_url
    slug.present? ? self.slug : "#{self.id}-category"
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="252" endline="255">
def publish_category
    group_ids = self.groups.pluck (:id) if self.read_restricted
    MessageBus.publish ('/categories', {categories : ActiveModel :: ArraySerializer.new ([self]).as_json

            }, group_ids : group_ids)
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="257" endline="264">
def remove_site_settings
    SiteSetting.all_settings.each do |s|
        if s [:type] == 'category' && s [:value].to_i == self.id
            SiteSetting.send ("#{s[:setting]}=", '')
        end
    end
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="266" endline="268">
def publish_category_deletion
    MessageBus.publish ('/categories', deleted_categories : [self.id])
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="270" endline="278">
def parent_category_validator
    if parent_category_id
        errors.add (:base, I18n.t ("category.errors.self_parent")) if parent_category_id == id
        errors.add (:base, I18n.t ("category.errors.uncategorized_parent")) if uncategorized?
        grandfather_id = Category.where (id : parent_category_id).pluck (:parent_category_id).first
        errors.add (:base, I18n.t ("category.errors.depth")) if grandfather_id
    end
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="280" endline="287">
def group_names= (names)
    category_groups.destroy_all unless new_record?
    ids = Group.where (name : names.split (",")).pluck (:id)
    ids.each do |id|
        category_groups.build (group_id : id)
    end
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="298" endline="303">
def set_permissions (permissions)
    self.read_restricted, @permissions = Category.resolve_permissions (permissions)
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="305" endline="307">
def permissions= (permissions)
    set_permissions (permissions)
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="309" endline="315">
def permissions_params
    hash = {
    }
    category_groups.includes (:group).each do |category_group|
        hash [category_group.group_name] = category_group.permission_type
    end
    hash
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="317" endline="325">
def apply_permissions
    if @permissions
        category_groups.destroy_all
        @permissions.each do |group_id,permission_type|
            category_groups.build (group_id : group_id, permission_type : permission_type)
        end
        @permissions = nil
    end
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="327" endline="349">
def self.resolve_permissions (permissions)
    read_restricted = true
    everyone = Group :: AUTO_GROUPS [:everyone]
    full = CategoryGroup.permission_types [:full]
    mapped = permissions.map do |group,permission|
        group_id = Group.group_id_from_param (group)
        permission = CategoryGroup.permission_types [permission] unless permission.is_a? (Integer)
        [group_id, permission]
    end
    mapped.each do |group,permission|
        if group == everyone && permission == full
            return [false, []]
        end
        read_restricted = false if group == everyone
    end
    [read_restricted, mapped]
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="351" endline="353">
def allowed_tags= (tag_names_arg)
    DiscourseTagging.add_or_create_tags_by_name (self, tag_names_arg, unlimited : true)
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="355" endline="357">
def allowed_tag_groups= (group_names)
    self.tag_groups = TagGroup.where (name : group_names).all.to_a
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="359" endline="361">
def downcase_email
    self.email_in = (email_in || "").strip.downcase.presence
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="363" endline="376">
def email_in_validator
    return if self.email_in.blank?
    email_in.split ("|").each do |email|
        escaped = Rack :: Utils.escape_html (email)
        if ! Email.is_valid? (email)
            self.errors.add (:base, I18n.t ('category.errors.invalid_email_in', email : escaped))
        elsif group = Group.find_by_email (email)
            self.errors.add (:base, I18n.t ('category.errors.email_already_used_in_group', email : escaped, group_name : Rack :: Utils.escape_html (group.name)))
        elsif category = Category.where.not (id : self.id).find_by_email (email)
            self.errors.add (:base, I18n.t ('category.errors.email_already_used_in_category', email : escaped, category_name : Rack :: Utils.escape_html (category.name)))
        end
    end
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="378" endline="380">
def downcase_name
    self.name_lower = name.downcase if self.name
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="382" endline="386">
def secure_group_ids
    if self.read_restricted?
        groups.pluck ("groups.id")
    end
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="388" endline="407">
def update_latest
    latest_post_id = Post
    .order ("posts.created_at desc")
    .where ("NOT hidden")
    .joins ("join topics on topics.id = topic_id")
    .where ("topics.category_id = :id", id : self.id)
    .limit (1)
    .pluck ("posts.id")
    .first
    latest_topic_id = Topic
    .order ("topics.created_at desc")
    .where ("visible")
    .where ("topics.category_id = :id", id : self.id)
    .limit (1)
    .pluck ("topics.id")
    .first
    self.update_attributes (latest_topic_id : latest_topic_id, latest_post_id : latest_post_id)
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="409" endline="412">
def self.query_parent_category (parent_slug)
    self.where (slug : parent_slug, parent_category_id : nil).pluck (:id).first ||
    self.where (id : parent_slug.to_i).pluck (:id).first
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="414" endline="417">
def self.query_category (slug_or_id, parent_category_id)
    self.where (slug : slug_or_id, parent_category_id : parent_category_id).first ||
    self.where (id : slug_or_id.to_i, parent_category_id : parent_category_id).first
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="419" endline="421">
def self.find_by_email (email)
    self.where ("string_to_array(email_in, '|') @> ARRAY[?]", Email.downcase (email)).first
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="423" endline="426">
def has_children?
    @has_children ||= (id && Category.where (parent_category_id : id).exists?) ? :true : :false
    @has_children == :true
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="428" endline="430">
def uncategorized?
    id == SiteSetting.uncategorized_category_id
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="434" endline="436">
def clear_url_cache
    @@url_cache.clear
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="438" endline="440">
def full_slug (separator = "-")
    url [3..-1].gsub ("/", separator)
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="442" endline="454">
def url
    url = @@url_cache [self.id]
    unless url
        url = "#{Discourse.base_uri}/c"
        url << "/#{parent_category.slug}" if parent_category_id
        url << "/#{slug}"
        url.freeze
        @@url_cache [self.id] = url
    end
    url
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="456" endline="458">
def url_with_id
    self.parent_category ? "#{url}/#{self.id}" : "#{Discourse.base_uri}/c/#{self.id}-#{self.slug}"
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="462" endline="468">
def rename_category_definition
    old_name = saved_changes.transform_values (& :first) ["name"]
    return unless topic.present?
    if topic.title == I18n.t ("category.topic_prefix", category : old_name)
        topic.update_attribute (:title, I18n.t ("category.topic_prefix", category : name))
    end
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="470" endline="483">
def create_category_permalink
    old_slug = saved_changes.transform_values (& :first) ["slug"]
    if self.parent_category
        url = "c/#{self.parent_category.slug}/#{old_slug}"
    else
        url = "c/#{old_slug}"
    end
    if Permalink.where (url : url).exists?
        Permalink.where (url : url).update_all (category_id : id)
    else
        Permalink.create (url : url, category_id : id)
    end
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="485" endline="492">
def delete_category_permalink
    if self.parent_category
        permalink = Permalink.find_by_url ("c/#{self.parent_category.slug}/#{slug}")
    else
        permalink = Permalink.find_by_url ("c/#{slug}")
    end
    permalink.destroy if permalink
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="494" endline="496">
def publish_discourse_stylesheet
    Stylesheet :: Manager.cache.clear
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="498" endline="500">
def index_search
    SearchIndexer.index (self)
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="502" endline="509">
def self.find_by_slug (category_slug, parent_category_slug = nil)
    if parent_category_slug
        parent_category_id = self.where (slug : parent_category_slug, parent_category_id : nil).pluck (:id).first
        self.where (slug : category_slug, parent_category_id : parent_category_id).first
    else
        self.where (slug : category_slug, parent_category_id : nil).first
    end
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="511" endline="513">
def subcategory_list_includes_topics?
    subcategory_list_style.end_with? ("with_featured_topics")
end
</source>
<source file="systems/ruby/discourse-master/app/models/category.rb" startline="515" endline="518">
def trigger_category_created_event
    DiscourseEvent.trigger (:category_created, self)
    true
end
</source>
