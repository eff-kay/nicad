<source file="systems/cs/RssBandit1.5.0.17sources/NewsComponents/Collections/Tst/TstDictionaryEntry.cs.ifdefed" startline="1" endline="311">
using System;
using System.Collections;
using System.Text;
using System.IO;

namespace Tst
{
    public class TstDictionaryEntry : ICloneable
    {
        private char splitChar;
        private bool isKey;
        private string key;
        private Object value;
        private TstDictionaryEntry parent;
        private TstDictionaryEntry lowChild;
        private TstDictionaryEntry eqChild;
        private TstDictionaryEntry highChild;
        public TstDictionaryEntry (TstDictionaryEntry parent, char splitChar)
        {
            this.isKey = false;
            this.key = null;
            this.value = null;
            this.parent = parent;
            this.splitChar = splitChar;
            this.lowChild = null;
            this.eqChild = null;
            this.highChild = null;
        }

        public TstDictionaryEntry Parent
        {
            get {
                return parent;
            }
        }

        public char SplitChar
        {
            get {
                return splitChar;
            }
        }

        public bool IsKey
        {
            get {
                return isKey;
            }
            set {
                isKey = value;
            }
        }

        public String Key
        {
            get {
                if (! IsKey)
                    throw new InvalidOperationException ("node is not a key");

                return key;
            }
            set {
                key = value;
            }
        }

        public Object Value
        {
            get {
                if (! IsKey)
                    throw new InvalidOperationException ("node is not a key");

                return value;
            }
            set {
                this.value = value;
            }
        }

        public TstDictionaryEntry LowChild
        {
            get {
                return lowChild;
            }
            set {
                lowChild = value;
            }
        }

        public TstDictionaryEntry EqChild
        {
            get {
                return eqChild;
            }
            set {
                eqChild = value;
            }
        }

        public TstDictionaryEntry HighChild
        {
            get {
                return highChild;
            }
            set {
                highChild = value;
            }
        }

        public bool HasChildren
        {
            get {
                return LowChild != null || EqChild != null || HighChild != null;
            }
        }

        public bool IsLowChild
        {
            get {
                return Parent != null && Parent.LowChild == this;
            }
        }

        public bool IsHighChild
        {
            get {
                return Parent != null && Parent.HighChild == this;
            }
        }

        public bool IsEqChild
        {
            get {
                return Parent != null && Parent.EqChild == this;
            }
        }

        public Object Clone ()
        {
            TstDictionaryEntry entry = new TstDictionaryEntry (Parent, SplitChar);
            if (LowChild != null)
                entry.LowChild = LowChild.Clone () as TstDictionaryEntry;

            if (EqChild != null)
                entry.EqChild = EqChild.Clone () as TstDictionaryEntry;

            if (HighChild != null)
                entry.HighChild = HighChild.Clone () as TstDictionaryEntry;

            return entry;
        }

        public override string ToString ()
        {
            char c;
            if (this.IsEqChild)
                c = 'E';
            else if (this.IsLowChild)
                c = 'L';
            else if (this.IsHighChild)
                c = 'H';
            else
                c = 'R';

            if (this.IsKey)
                return String.Format ("{0} {1} {2}", c, this.SplitChar, this.Key);
            else
                return String.Format ("{0} {1}", c, this.SplitChar);

        }

    }

}

</source>
<source file="systems/cs/RssBandit1.5.0.17sources/NewsComponents/Collections/Tst/TstDictionaryEnumerator.cs.ifdefed" startline="1" endline="227">
using System;
using System.Collections;

namespace Tst
{
    public sealed class TstDictionaryEnumerator : IDictionaryEnumerator
    {
        private long version;
        private Stack stack;
        private TstDictionaryEntry currentNode;
        private TstDictionary dictionary;
        public TstDictionaryEnumerator (TstDictionary tst)
        {
            if (tst == null)
                throw new ArgumentNullException ("tst");

            this.version = tst.Version;
            this.dictionary = tst;
            this.currentNode = null;
            this.stack = null;
        }

        public void Reset ()
        {
            this.ThrowIfChanged ();
            this.stack.Clear ();
            stack = null;
        }

        public DictionaryEntry Current
        {
            get {
                this.ThrowIfChanged ();
                return this.Entry;
            }
        }

        Object IEnumerator.Current
        {
            get {
                return this.Current;
            }
        }

        public DictionaryEntry Entry
        {
            get {
                this.ThrowIfChanged ();
                if (currentNode == null)
                    throw new InvalidOperationException ();

                return new DictionaryEntry (currentNode.Key, currentNode.Value);
            }
        }

        public String Key
        {
            get {
                this.ThrowIfChanged ();
                if (currentNode == null)
                    throw new InvalidOperationException ();

                return currentNode.Key;
            }
        }

        Object IDictionaryEnumerator.Key
        {
            get {
                return this.Key;
            }
        }

        public Object Value
        {
            get {
                this.ThrowIfChanged ();
                if (currentNode == null)
                    throw new InvalidOperationException ();

                return currentNode.Value;
            }
        }

        public bool MoveNext ()
        {
            this.ThrowIfChanged ();
            if (stack == null) {
                stack = new Stack ();
                currentNode = null;
                if (dictionary.Root != null)
                    stack.Push (dictionary.Root);

            } else if (currentNode == null)
                throw new InvalidOperationException ("out of range");

            if (stack.Count == 0)
                currentNode = null;

            while (stack.Count > 0) {
                currentNode = (TstDictionaryEntry) stack.Pop ();
                if (currentNode.HighChild != null)
                    stack.Push (currentNode.HighChild);

                if (currentNode.EqChild != null)
                    stack.Push (currentNode.EqChild);

                if (currentNode.LowChild != null)
                    stack.Push (currentNode.LowChild);

                if (currentNode.IsKey)
                    break;

            }
            return currentNode != null;
        }

        internal void ThrowIfChanged ()
        {
            if (version != dictionary.Version)
                throw new InvalidOperationException ("Collection changed");

        }

    }

}

</source>
<source file="systems/cs/RssBandit1.5.0.17sources/NewsComponents/Collections/Tst/TstTraverser.cs.ifdefed" startline="1" endline="148">
using System;
using System.Collections;

namespace Tst
{
    public class TstTraverser
    {
        public TstTraverser ()
        {
        }

        public void Traverse (TstDictionary dic)
        {
            if (dic == null)
                throw new ArgumentNullException ("dic");

            Traverse (dic.Root);
        }

        public event TstDictionaryEntryEventHandler TreeEntry;
        protected virtual void OnTreeEntry (TstDictionaryEntry p)
        {
            if (TreeEntry != null)
                TreeEntry (this, new TstDictionaryEntryEventArgs (p));

        }

        public event TstDictionaryEntryEventHandler LowChild;
        protected virtual void OnLowChild (TstDictionaryEntry p)
        {
            if (LowChild != null)
                LowChild (this, new TstDictionaryEntryEventArgs (p));

        }

        public event TstDictionaryEntryEventHandler EqChild;
        protected virtual void OnEqChild (TstDictionaryEntry p)
        {
            if (EqChild != null)
                EqChild (this, new TstDictionaryEntryEventArgs (p));

        }

        public event TstDictionaryEntryEventHandler HighChild;
        protected virtual void OnHighChild (TstDictionaryEntry p)
        {
            if (HighChild != null)
                HighChild (this, new TstDictionaryEntryEventArgs (p));

        }

        protected void Traverse (TstDictionaryEntry p)
        {
            if (p == null)
                return;

            OnTreeEntry (p);
            OnLowChild (p.LowChild);
            Traverse (p.LowChild);
            OnEqChild (p.EqChild);
            Traverse (p.EqChild);
            OnHighChild (p.HighChild);
            Traverse (p.HighChild);
        }

    }

}

</source>
<source file="systems/cs/RssBandit1.5.0.17sources/NewsComponents/Collections/Tst/TstSynchronizedDictionary.cs.ifdefed" startline="1" endline="257">
using System;
using System.Collections;

namespace Tst
{
    public class TstSynchronizedDictionary : TstDictionary
    {
        private TstDictionary wrapped;
        public TstSynchronizedDictionary (TstDictionary dic) : base ()
        {
            this.wrapped = dic;
        }

        private TstDictionary Wrapped
        {
            get {
                return Wrapped;
            }
        }

        public override void Add (String key, Object value)
        {
            lock (Wrapped.SyncRoot)
            {
                Wrapped.Add (key, value);
            }}

        public override void Clear ()
        {
            lock (Wrapped.SyncRoot)
            {
                Wrapped.Clear ();
            }}

        public override void Remove (String key)
        {
            lock (Wrapped.SyncRoot)
            {
                Wrapped.Remove (key);
            }}

        public override Object Clone ()
        {
            return Wrapped.Clone ();
        }

        public override bool ContainsKey (String key)
        {
            return Wrapped.ContainsKey (key);
        }

        public override void CopyTo (Array array, int arrayIndex)
        {
            Wrapped.CopyTo (array, arrayIndex);
        }

        public override int Count
        {
            get {
                return Wrapped.Count;
            }
        }

        public override TstDictionaryEntry Find (String key)
        {
            return Wrapped.Find (key);
        }

        public override TstDictionaryEnumerator GetEnumerator ()
        {
            return Wrapped.GetEnumerator ();
        }

        public override bool IsFixedSize
        {
            get {
                return Wrapped.IsFixedSize;
            }
        }

        public override bool IsSynchronized
        {
            get {
                return true;
            }
        }

        public override bool IsReadOnly
        {
            get {
                return Wrapped.IsReadOnly;
            }
        }

        public override ICollection Keys
        {
            get {
                return Wrapped.Keys;
            }
        }

        public override ICollection Values
        {
            get {
                return Wrapped.Values;
            }
        }

        public override Object this [String key] {
            get {
                return Wrapped [key];
            }
            set {
                lock (Wrapped.SyncRoot)
                {
                    Wrapped [key] = value;
                }}
        }

        public override Object SyncRoot
        {
            get {
                return Wrapped.SyncRoot;
            }
        }

        public override ICollection PartialMatch (string key)
        {
            return Wrapped.PartialMatch (key);
        }

        public override ICollection PartialMatch (string key, char wildChar)
        {
            return Wrapped.PartialMatch (key, wildChar);
        }

        public override ICollection NearNeighbors (string key, int distance)
        {
            return Wrapped.NearNeighbors (key, distance);
        }

    }

}

</source>
<source file="systems/cs/RssBandit1.5.0.17sources/NewsComponents/Collections/Tst/TstDictionaries.cs.ifdefed" startline="1" endline="255">
using System;
using System.Collections;

namespace Tst
{
    public class TstDictionaries : IDictionary, ICollection, IEnumerable, ICloneable
    {
        protected Hashtable innerHash;
        public TstDictionaries ()
        {
            innerHash = new Hashtable ();
        }

        public TstDictionaries (TstDictionaries original)
        {
            innerHash = new Hashtable (original.innerHash);
        }

        public TstDictionaries (IDictionary dictionary)
        {
            innerHash = new Hashtable (dictionary);
        }

        public TstDictionaries (int capacity)
        {
            innerHash = new Hashtable (capacity);
        }

        public TstDictionaries (IDictionary dictionary, float loadFactor)
        {
            innerHash = new Hashtable (dictionary, loadFactor);
        }

        public TstDictionaries (IHashCodeProvider codeProvider, IComparer comparer)
        {
            innerHash = new Hashtable (codeProvider, comparer);
        }

        public TstDictionaries (int capacity, int loadFactor)
        {
            innerHash = new Hashtable (capacity, loadFactor);
        }

        public TstDictionaries (IDictionary dictionary, IHashCodeProvider codeProvider, IComparer comparer)
        {
            innerHash = new Hashtable (dictionary, codeProvider, comparer);
        }

        public TstDictionaries (int capacity, IHashCodeProvider codeProvider, IComparer comparer)
        {
            innerHash = new Hashtable (capacity, codeProvider, comparer);
        }

        public TstDictionaries (IDictionary dictionary, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer)
        {
            innerHash = new Hashtable (dictionary, loadFactor, codeProvider, comparer);
        }

        public TstDictionaries (int capacity, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer)
        {
            innerHash = new Hashtable (capacity, loadFactor, codeProvider, comparer);
        }

        public TstDictionariesEnumerator GetEnumerator ()
        {
            return new TstDictionariesEnumerator (this);
        }

        System.Collections.IDictionaryEnumerator IDictionary.GetEnumerator ()
        {
            return new TstDictionariesEnumerator (this);
        }

        IEnumerator IEnumerable.GetEnumerator ()
        {
            return GetEnumerator ();
        }

        public void Remove (string key)
        {
            innerHash.Remove (key);
        }

        void IDictionary.Remove (object key)
        {
            Remove ((string) key);
        }

        public bool Contains (string key)
        {
            return innerHash.Contains (key);
        }

        bool IDictionary.Contains (object key)
        {
            return Contains ((string) key);
        }

        public void Clear ()
        {
            innerHash.Clear ();
        }

        public void Add (string key, TstDictionary value)
        {
            innerHash.Add (key, value);
        }

        void IDictionary.Add (object key, object value)
        {
            Add ((string) key, (TstDictionary) value);
        }

        public bool IsReadOnly
        {
            get {
                return innerHash.IsReadOnly;
            }
        }

        public TstDictionary this [string key] {
            get {
                return (TstDictionary) innerHash [key];
            }
            set {
                innerHash [key] = value;
            }
        }
        object IDictionary.this [object key] {
            get {
                return this [(string) key];
            }
            set {
                this [(string) key] = (TstDictionary) value;
            }
        }

        public System.Collections.ICollection Values
        {
            get {
                return innerHash.Values;
            }
        }

        public System.Collections.ICollection Keys
        {
            get {
                return innerHash.Keys;
            }
        }

        public bool IsFixedSize
        {
            get {
                return innerHash.IsFixedSize;
            }
        }

        public void CopyTo (System.Array array, int index)
        {
            innerHash.CopyTo (array, index);
        }

        public bool IsSynchronized
        {
            get {
                return innerHash.IsSynchronized;
            }
        }

        public int Count
        {
            get {
                return innerHash.Count;
            }
        }

        public object SyncRoot
        {
            get {
                return innerHash.SyncRoot;
            }
        }

        public TstDictionaries Clone ()
        {
            TstDictionaries clone = new TstDictionaries ();
            clone.innerHash = (Hashtable) innerHash.Clone ();
            return clone;
        }

        object ICloneable.Clone ()
        {
            return Clone ();
        }

        public bool ContainsKey (string key)
        {
            return innerHash.ContainsKey (key);
        }

        public bool ContainsValue (TstDictionary value)
        {
            return innerHash.ContainsValue (value);
        }

        public static TstDictionaries Synchronized (TstDictionaries nonSync)
        {
            TstDictionaries sync = new TstDictionaries ();
            sync.innerHash = Hashtable.Synchronized (nonSync.innerHash);
            return sync;
        }

        internal Hashtable InnerHash
        {
            get {
                return innerHash;
            }
        }

    }

    public class TstDictionariesEnumerator : IDictionaryEnumerator
    {
        private IDictionaryEnumerator innerEnumerator;
        internal TstDictionariesEnumerator (TstDictionaries enumerable)
        {
            innerEnumerator = enumerable.InnerHash.GetEnumerator ();
        }

        public string Key
        {
            get {
                return (string) innerEnumerator.Key;
            }
        }

        object IDictionaryEnumerator.Key
        {
            get {
                return Key;
            }
        }

        public TstDictionary Value
        {
            get {
                return (TstDictionary) innerEnumerator.Value;
            }
        }

        object IDictionaryEnumerator.Value
        {
            get {
                return Value;
            }
        }

        public System.Collections.DictionaryEntry Entry
        {
            get {
                return innerEnumerator.Entry;
            }
        }

        public void Reset ()
        {
            innerEnumerator.Reset ();
        }

        public bool MoveNext ()
        {
            return innerEnumerator.MoveNext ();
        }

        public object Current
        {
            get {
                return innerEnumerator.Current;
            }
        }

    }

}

</source>
<source file="systems/cs/RssBandit1.5.0.17sources/NewsComponents/Collections/Tst/TstDictionaryEntryEventArgs.cs.ifdefed" startline="1" endline="69">
using System;

namespace Tst
{
    public class TstDictionaryEntryEventArgs : EventArgs
    {
        private TstDictionaryEntry entry;
        public TstDictionaryEntryEventArgs (TstDictionaryEntry entry)
        {
            this.entry = entry;
        }

        public TstDictionaryEntry Entry
        {
            get {
                return entry;
            }
        }

    }

    public delegate void TstDictionaryEntryEventHandler (Object sender, TstDictionaryEntryEventArgs e);

}

</source>
<source file="systems/cs/RssBandit1.5.0.17sources/NewsComponents/Collections/Tst/TstDictionary.cs.ifdefed" startline="1" endline="769">
using System;
using System.Collections;
using System.Collections.Specialized;

namespace Tst
{
    public class TstDictionary : IEnumerable, ICollection, ICloneable
    {
        private TstDictionaryEntry root;
        private long version;
        public TstDictionary ()
        {
            root = null;
            version = 0;
        }

        protected TstDictionary (TstDictionaryEntry root)
        {
            if (root == null)
                throw new ArgumentNullException ("root is null");

            this.root = root;
            this.version = 0;
        }

        public TstDictionaryEntry Root
        {
            get {
                return root;
            }
        }

        public long Version
        {
            get {
                return version;
            }
        }

        public virtual int Count
        {
            get {
                IEnumerator en = this.GetEnumerator ();
                int n = 0;
                while (en.MoveNext ())
                    ++ n;

                return n;
            }
        }

        public virtual bool IsSynchronized
        {
            get {
                return false;
            }
        }

        public virtual Object SyncRoot
        {
            get {
                return this;
            }
        }

        public virtual bool IsFixedSize
        {
            get {
                return false;
            }
        }

        public virtual bool IsReadOnly
        {
            get {
                return false;
            }
        }

        public virtual ICollection Keys
        {
            get {
                StringCollection keys = new StringCollection ();
                TstDictionaryEnumerator en = GetEnumerator ();
                while (en.MoveNext ())
                    keys.Add (en.Key);

                return keys;
            }
        }

        public virtual ICollection Values
        {
            get {
                ArrayList values = new ArrayList ();
                foreach (DictionaryEntry de in this)
                    values.Add (de.Value);

                return values;
            }
        }

        public virtual Object Clone ()
        {
            return new TstDictionary (Root.Clone () as TstDictionaryEntry);
        }

        public static TstDictionary Synchronized (TstDictionary table)
        {
            if (table == null)
                throw new ArgumentNullException ("table");

            return new TstSynchronizedDictionary (table);
        }

        public virtual void CopyTo (Array array, int arrayIndex)
        {
            if (array == null)
                throw new ArgumentNullException ("array");

            if (arrayIndex < 0)
                throw new ArgumentOutOfRangeException ("index is negative");

            if (array.Rank > 1)
                throw new ArgumentException ("array is multi-dimensional");

            if (arrayIndex >= array.Length)
                throw new ArgumentException ("index >= array.Length");

            int i = arrayIndex;
            foreach (Object de in this) {
                if (i > array.Length)
                    throw new ArgumentException ("The number of elements in the source ICollection is greater than the available space from index to the end of the destination array.");

                array.SetValue (de, i ++);
            }
        }

        public virtual Object this [String key] {
            get {
                if (key == null)
                    throw new ArgumentNullException ("key");

                TstDictionaryEntry de = Find (key);
                if (de == null)
                    return null;
                else
                    return de.Value;

            }
            set {
                if (key == null)
                    throw new ArgumentNullException ("key");

                if (key.Length == 0)
                    throw new ArgumentException ("key is an empty string");

                if (IsReadOnly)
                    throw new NotSupportedException ("read-only dictionary");

                ++ version;
                TstDictionaryEntry de = Find (key);
                if (de == null)
                    Add (key, value);
                else {
                    if (IsFixedSize)
                        throw new NotSupportedException ("fixed-size dictionary");

                    de.Value = value;
                }
            }
        }
        public virtual void Add (String key, Object value)
        {
            if (key == null)
                throw new ArgumentNullException ("key is null");

            if (key.Length == 0)
                throw new ArgumentException ("trying to add empty key");

            if (IsReadOnly)
                throw new NotSupportedException ("dictionary is read-only");

            if (IsFixedSize)
                throw new NotSupportedException ("dictionary has fixed size");

            ++ version;
            if (Root == null)
                root = new TstDictionaryEntry (null, key [0]);

            TstDictionaryEntry p = Root;
            int i = 0;
            char c;
            while (i < key.Length) {
                c = key [i];
                if (c < p.SplitChar) {
                    if (p.LowChild == null)
                        p.LowChild = new TstDictionaryEntry (p, c);

                    p = p.LowChild;
                    continue;
                }
                if (c > p.SplitChar) {
                    if (p.HighChild == null)
                        p.HighChild = new TstDictionaryEntry (p, c);

                    p = p.HighChild;
                    continue;
                } else {
                    ++ i;
                    if (i == key.Length) {
                        if (p.IsKey)
                            throw new ArgumentException ("key already in dictionary");

                        break;
                    }
                    if (p.EqChild == null)
                        p.EqChild = new TstDictionaryEntry (p, key [i]);

                    p = p.EqChild;
                }
            }
            p.IsKey = true;
            p.Key = key;
            p.Value = value;
        }

        public virtual void Remove (String key)
        {
            if (key == null)
                throw new ArgumentNullException ("key is null");

            if (key.Length == 0)
                throw new ArgumentException ("key length cannot be 0");

            if (IsReadOnly)
                throw new NotSupportedException ("dictionary is read-only");

            if (IsFixedSize)
                throw new NotSupportedException ("dictionary has fixed size");

            ++ version;
            TstDictionaryEntry p = Find (key);
            if (p == null)
                return;

            p.IsKey = false;
            p.Key = null;
            while (! p.IsKey && ! p.HasChildren && p.Parent != null) {
                if (p.IsLowChild)
                    p.Parent.LowChild = null;
                else if (p.IsHighChild)
                    p.Parent.HighChild = null;
                else
                    p.Parent.EqChild = null;

                p = p.Parent;
            }
            if (! p.IsKey && ! p.HasChildren && p == root)
                root = null;

        }

        public virtual void Clear ()
        {
            if (IsReadOnly)
                throw new NotSupportedException ("dictionary is read-only");

            ++ version;
            root = null;
        }

        public bool Contains (String key)
        {
            return ContainsKey (key);
        }

        public virtual bool ContainsKey (String key)
        {
            if (key == null)
                throw new ArgumentNullException ("key");

            TstDictionaryEntry de = Find (key);
            return de != null && de.IsKey;
        }

        public bool ContainsValue (Object value)
        {
            foreach (DictionaryEntry de in this)
                if (de.Value == value)
                    return true;

            return false;
        }

        public virtual TstDictionaryEnumerator GetEnumerator ()
        {
            return new TstDictionaryEnumerator (this);
        }

        IEnumerator IEnumerable.GetEnumerator ()
        {
            return this.GetEnumerator ();
        }

        public virtual TstDictionaryEntry Find (String key)
        {
            if (key == null)
                throw new ArgumentNullException ("key");

            int n = key.Length;
            if (n == 0)
                return null;

            TstDictionaryEntry p = Root;
            int index = 0;
            char c;
            while (index < n && p != null) {
                c = key [index];
                if (c < p.SplitChar)
                    p = p.LowChild;
                else if (c > p.SplitChar)
                    p = p.HighChild;
                else {
                    if (index == n - 1)
                        return p;
                    else {
                        ++ index;
                        p = p.EqChild;
                    }
                }
            }
            return p;
        }

        public virtual ICollection PartialMatch (string key)
        {
            return PartialMatch (key, '*');
        }

        public virtual ICollection PartialMatch (string key, char wildChar)
        {
            if (key == null)
                throw new ArgumentNullException ("key");

            if (key.Length == 0)
                throw new ArgumentException ("key is empty");

            ArrayList matches = new ArrayList ();
            PartialMatchSearch (Root, key, 0, wildChar, matches);
            return matches;
        }

        internal void PartialMatchSearch (TstDictionaryEntry p, string key, int index, char wildChar, IList matches)
        {
            if (p == null)
                return;

            char c = key [index];
            if (c == wildChar || c < p.SplitChar)
                PartialMatchSearch (p.LowChild, key, index, wildChar, matches);

            if (c == wildChar || c == p.SplitChar) {
                if (index < key.Length - 1)
                    PartialMatchSearch (p.EqChild, key, index + 1, wildChar, matches);
                else if (p.IsKey)
                    matches.Add (new DictionaryEntry (p.Key, p.Value));

            }
            if (c == wildChar || c > p.SplitChar)
                PartialMatchSearch (p.HighChild, key, index, wildChar, matches);

        }

        public virtual ICollection NearNeighbors (string key, int distance)
        {
            if (key == null)
                throw new ArgumentNullException ("key");

            if (distance < 0)
                throw new ArgumentException ("dist is negative");

            ArrayList matches = new ArrayList ();
            NearNeighborsSearch (Root, key, 0, distance, matches);
            return matches;
        }

        internal void NearNeighborsSearch (TstDictionaryEntry p, string key, int index, int dist, IList matches)
        {
            if (p == null || dist < 0)
                return;

            char c = key [index];
            if (dist > 0 || c < p.SplitChar)
                NearNeighborsSearch (p.LowChild, key, index, dist, matches);

            if ((p.IsKey) && ((key.Length - index) <= dist)) {
                matches.Add (new DictionaryEntry (p.Key, p.Value));
            } else {
                int localIndex = index;
                if (localIndex != key.Length - 1)
                    ++ localIndex;

                int localDist = dist;
                if (c != p.SplitChar)
                    -- localDist;

                NearNeighborsSearch (p.EqChild, key, localIndex, localDist, matches);
            }
            if (dist > 0 || c > p.SplitChar)
                NearNeighborsSearch (p.HighChild, key, index, dist, matches);

        }

    }

}

</source>
<source file="systems/cs/RssBandit1.5.0.17sources/NewsComponents/VersionInfo.cs.ifdefed" startline="1" endline="31">
using System.Reflection;

[assembly : AssemblyVersion ("1.5.0.17")] [assembly : AssemblyFileVersion ("1.5.0.17")] [assembly : AssemblyInformationalVersion ("1.5.17")]
</source>
