<source file="systems/java/jEdit/trunk/org/gjt/sp/jedit/help/HelpTOCPanel.java" startline="1" endline="487">
package org.gjt.sp.jedit.help;

import javax.swing.*;

import javax.swing.border.*;

import javax.swing.tree.*;

import java.awt.*;

import java.awt.event.*;

import java.io.*;

import java.net.*;

import java.util.*;

import org.xml.sax.Attributes;

import org.xml.sax.helpers.DefaultHandler;

import org.gjt.sp.jedit.browser.FileCellRenderer;

import org.gjt.sp.jedit.io.VFSManager;

import org.gjt.sp.jedit.*;

import org.gjt.sp.util.Log;

import org.gjt.sp.util.StandardUtilities;

import org.gjt.sp.util.XMLUtilities;

import static javax.swing.tree.TreeSelectionModel.SINGLE_TREE_SELECTION;

public class HelpTOCPanel extends JPanel {

    public HelpTOCPanel (HelpViewerInterface helpViewer) {
        super (new BorderLayout ());
        this.helpViewer = helpViewer;
        nodes = new Hashtable ();
        toc = new TOCTree ();
        if (! OperatingSystem.isMacOSLF ()) toc.putClientProperty ("JTree.lineStyle", "Angled");

        toc.setCellRenderer (new TOCCellRenderer ());
        toc.setEditable (false);
        toc.setShowsRootHandles (true);
        add (BorderLayout.CENTER, new JScrollPane (toc));
        load ();
    }

    public void selectNode (String shortURL) {
        if (tocModel == null) return;

        DefaultMutableTreeNode node = (DefaultMutableTreeNode) nodes.get (shortURL);
        if (node == null) return;

        TreePath path = new TreePath (tocModel.getPathToRoot (node));
        toc.expandPath (path);
        toc.setSelectionPath (path);
        toc.scrollPathToVisible (path);
    }

    public void load () {
        DefaultTreeModel empty = new DefaultTreeModel (new DefaultMutableTreeNode (jEdit.getProperty ("helpviewer.toc.loading")));
        toc.setModel (empty);
        toc.setRootVisible (true);
        VFSManager.runInWorkThread (new Runnable () {

            public void run () {
                createTOC ();
                tocModel.reload (tocRoot);
                toc.setModel (tocModel);
                toc.setRootVisible (false);
                for (int i = 0;
                i < tocRoot.getChildCount (); i ++) {
                    DefaultMutableTreeNode node = (DefaultMutableTreeNode) tocRoot.getChildAt (i);
                    toc.expandPath (new TreePath (node.getPath ()));
                }
                if (helpViewer.getShortURL () != null) selectNode (helpViewer.getShortURL ());

            }

        }

        );
    }

    private HelpViewerInterface helpViewer;
    private DefaultTreeModel tocModel;
    private DefaultMutableTreeNode tocRoot;
    private JTree toc;
    private Hashtable nodes;

    private DefaultMutableTreeNode createNode (String href, String title) {
        DefaultMutableTreeNode node = new DefaultMutableTreeNode (new HelpNode (href, title), true);
        nodes.put (href, node);
        return node;
    }

    private void createTOC () {
        EditPlugin [] plugins = jEdit.getPlugins ();
        Arrays.sort (plugins, new PluginCompare ());
        tocRoot = new DefaultMutableTreeNode ();
        tocRoot.add (createNode ("welcome.html", jEdit.getProperty ("helpviewer.toc.welcome")));
        tocRoot.add (createNode ("README.txt", jEdit.getProperty ("helpviewer.toc.readme")));
        tocRoot.add (createNode ("CHANGES.txt", jEdit.getProperty ("helpviewer.toc.changes")));
        tocRoot.add (createNode ("TODO.txt", jEdit.getProperty ("helpviewer.toc.todo")));
        tocRoot.add (createNode ("COPYING.txt", jEdit.getProperty ("helpviewer.toc.copying")));
        tocRoot.add (createNode ("COPYING.DOC.txt", jEdit.getProperty ("helpviewer.toc.copying-doc")));
        tocRoot.add (createNode ("Apache.LICENSE.txt", jEdit.getProperty ("helpviewer.toc.copying-apache")));
        tocRoot.add (createNode ("COPYING.PLUGINS.txt", jEdit.getProperty ("helpviewer.toc.copying-plugins")));
        loadTOC (tocRoot, "news44/toc.xml");
        loadTOC (tocRoot, "users-guide/toc.xml");
        loadTOC (tocRoot, "FAQ/toc.xml");
        DefaultMutableTreeNode pluginTree = new DefaultMutableTreeNode (jEdit.getProperty ("helpviewer.toc.plugins"), true);
        for (int i = 0;
        i < plugins.length; i ++) {
            EditPlugin plugin = plugins [i];
            String name = plugin.getClassName ();
            String docs = jEdit.getProperty ("plugin." + name + ".docs");
            String label = jEdit.getProperty ("plugin." + name + ".name");
            if (docs != null) {
                if (label != null && docs != null) {
                    String path = plugin.getPluginJAR ().getClassLoader ().getResourceAsPath (docs);
                    pluginTree.add (createNode (path, label));
                }
            }
        }
        if (pluginTree.getChildCount () != 0) tocRoot.add (pluginTree);
        else {
            pluginTree = null;
        }
        loadTOC (tocRoot, "api/toc.xml");
        tocModel = new DefaultTreeModel (tocRoot);
    }

    private void loadTOC (DefaultMutableTreeNode root, String path) {
        TOCHandler h = new TOCHandler (root, MiscUtilities.getParentOfPath (path));
        try {
            XMLUtilities.parseXML (new URL (helpViewer.getBaseURL () + '/' + path).openStream (), h);
        } catch (FileNotFoundException e) {
            if ("api/toc.xml".equals (path)) {
                Log.log (Log.NOTICE, this, "The API docs for jEdit will not be available (reinstall jEdit if you want them)");
                root.add (createNode ("http://www.jedit.org/api/overview-summary.html", jEdit.getProperty ("helpviewer.toc.online-apidocs")));
            } else {
                Log.log (Log.ERROR, this, e);
            }
        } catch (IOException e) {
            Log.log (Log.ERROR, this, e);
        }
    }

    static class HelpNode {
        String href, title;

        HelpNode (String href, String title) {
            this.href = href;
            this.title = title;
        }

        public String toString () {
            return title;
        }

    }

    class TOCHandler extends DefaultHandler {
        String dir;

        TOCHandler (DefaultMutableTreeNode root, String dir) {
            nodes = new Stack ();
            node = root;
            this.dir = dir;
        }

        public void characters (char [] c, int off, int len) {
            if (tag.equals ("TITLE")) {
                boolean firstNonWhitespace = false;
                for (int i = 0;
                i < len; i ++) {
                    char ch = c [off + i];
                    if (! firstNonWhitespace && Character.isWhitespace (ch)) continue;

                    firstNonWhitespace = true;
                    title.append (ch);
                }
            }
        }

        public void startElement (String uri, String localName, String name, Attributes attrs) {
            tag = name;
            if (name.equals ("ENTRY")) href = attrs.getValue ("HREF");

        }

        public void endElement (String uri, String localName, String name) {
            if (name == null) return;

            if (name.equals ("TITLE")) {
                DefaultMutableTreeNode newNode = createNode (dir + href, title.toString ());
                node.add (newNode);
                nodes.push (node);
                node = newNode;
                title.setLength (0);
            } else if (name.equals ("ENTRY")) {
                node = (DefaultMutableTreeNode) nodes.pop ();
                href = null;
            }

        }

        private String tag;
        private StringBuilder title = new StringBuilder ();
        private String href;
        private DefaultMutableTreeNode node;
        private Stack nodes;
    }

    class TOCTree extends JTree {

        TOCTree () {
            ToolTipManager.sharedInstance ().registerComponent (this);
            selectionModel.setSelectionMode (SINGLE_TREE_SELECTION);
        }

        public final String getToolTipText (MouseEvent evt) {
            TreePath path = getPathForLocation (evt.getX (), evt.getY ());
            if (path != null) {
                Rectangle cellRect = getPathBounds (path);
                if (cellRect != null && ! cellRectIsVisible (cellRect)) return path.getLastPathComponent ().toString ();

            }
            return null;
        }

        public void processKeyEvent (KeyEvent evt) {
            if ((KeyEvent.KEY_PRESSED == evt.getID ()) && (KeyEvent.VK_ENTER == evt.getKeyCode ())) {
                TreePath path = getSelectionPath ();
                if (path != null) {
                    Object obj = ((DefaultMutableTreeNode) path.getLastPathComponent ()).getUserObject ();
                    if (! (obj instanceof HelpNode)) {
                        this.expandPath (path);
                        return;
                    }
                    HelpNode node = (HelpNode) obj;
                    helpViewer.gotoURL (node.href, true, 0);
                }
                evt.consume ();
            } else {
                super.processKeyEvent (evt);
            }
        }

        protected void processMouseEvent (MouseEvent evt) {
            switch (evt.getID ()) {
                case MouseEvent.MOUSE_CLICKED :
                    TreePath path = getPathForLocation (evt.getX (), evt.getY ());
                    if (path != null) {
                        if (! isPathSelected (path)) setSelectionPath (path);

                        Object obj = ((DefaultMutableTreeNode) path.getLastPathComponent ()).getUserObject ();
                        if (! (obj instanceof HelpNode)) {
                            this.expandPath (path);
                            return;
                        }
                        HelpNode node = (HelpNode) obj;
                        helpViewer.gotoURL (node.href, true, 0);
                    }
                    super.processMouseEvent (evt);
                    break;
                default :
                    super.processMouseEvent (evt);
                    break;
            }
        }

        private boolean cellRectIsVisible (Rectangle cellRect) {
            Rectangle vr = TOCTree.this.getVisibleRect ();
            return vr.contains (cellRect.x, cellRect.y) && vr.contains (cellRect.x + cellRect.width, cellRect.y + cellRect.height);
        }

    }

    static class TOCCellRenderer extends DefaultTreeCellRenderer {
        EmptyBorder border = new EmptyBorder (1, 0, 1, 1);

        public Component getTreeCellRendererComponent (JTree tree, Object value, boolean sel, boolean expanded, boolean leaf, int row, boolean focus) {
            super.getTreeCellRendererComponent (tree, value, sel, expanded, leaf, row, focus);
            setIcon (leaf ? FileCellRenderer.fileIcon : (expanded ? FileCellRenderer.openDirIcon : FileCellRenderer.dirIcon));
            setBorder (border);
            return this;
        }

    }

    static class PluginCompare implements Comparator {

        public int compare (Object o1, Object o2) {
            EditPlugin p1 = (EditPlugin) o1;
            EditPlugin p2 = (EditPlugin) o2;
            return StandardUtilities.compareStrings (jEdit.getProperty ("plugin." + p1.getClassName () + ".name"), jEdit.getProperty ("plugin." + p2.getClassName () + ".name"), true);
        }

    }

}

</source>
<source file="systems/java/jEdit/trunk/org/gjt/sp/jedit/help/HelpHistoryModelListener.java" startline="1" endline="34">
package org.gjt.sp.jedit.help;

public interface HelpHistoryModelListener {

    public void historyUpdated ();

}

</source>
<source file="systems/java/jEdit/trunk/org/gjt/sp/jedit/help/HelpIndex.java" startline="1" endline="396">
package org.gjt.sp.jedit.help;

import java.io.*;

import java.net.*;

import java.util.zip.*;

import java.util.*;

import org.gjt.sp.jedit.io.*;

import org.gjt.sp.jedit.*;

import org.gjt.sp.util.Log;

class HelpIndex {

    public HelpIndex () {
        words = new HashMap < String, Object > ();
        files = new ArrayList < HelpFile > ();
        ignoreWord ("a");
        ignoreWord ("an");
        ignoreWord ("and");
        ignoreWord ("are");
        ignoreWord ("as");
        ignoreWord ("be");
        ignoreWord ("by");
        ignoreWord ("can");
        ignoreWord ("do");
        ignoreWord ("for");
        ignoreWord ("from");
        ignoreWord ("how");
        ignoreWord ("i");
        ignoreWord ("if");
        ignoreWord ("in");
        ignoreWord ("is");
        ignoreWord ("it");
        ignoreWord ("not");
        ignoreWord ("of");
        ignoreWord ("on");
        ignoreWord ("or");
        ignoreWord ("s");
        ignoreWord ("that");
        ignoreWord ("the");
        ignoreWord ("this");
        ignoreWord ("to");
        ignoreWord ("will");
        ignoreWord ("with");
        ignoreWord ("you");
    }

    public void indexEditorHelp () {
        try {
            String jEditHome = jEdit.getJEditHome ();
            if (jEditHome != null) {
                indexDirectory (MiscUtilities.constructPath (jEditHome, "doc", "users-guide"));
                indexDirectory (MiscUtilities.constructPath (jEditHome, "doc", "FAQ"));
                indexDirectory (MiscUtilities.constructPath (jEditHome, "doc", "news44"));
            }
        } catch (Throwable e) {
            Log.log (Log.ERROR, this, "Error indexing editor help");
            Log.log (Log.ERROR, this, e);
        }
        PluginJAR [] jars = jEdit.getPluginJARs ();
        for (int i = 0;
        i < jars.length; i ++) {
            try {
                indexJAR (jars [i].getZipFile ());
            } catch (Throwable e) {
                Log.log (Log.ERROR, this, "Error indexing JAR: " + jars [i].getPath ());
                Log.log (Log.ERROR, this, e);
            }
        }
        Log.log (Log.DEBUG, this, "Indexed " + words.size () + " words");
    }

    public void indexDirectory (String dir) throws Exception {
        String [] files = VFSManager.getFileVFS ()._listDirectory (null, dir, "*.{html,txt}", true, null);
        for (int i = 0;
        i < files.length; i ++) {
            indexURL (files [i]);
        }
    }

    public void indexJAR (ZipFile jar) throws Exception {
        Enumeration e = jar.entries ();
        while (e.hasMoreElements ()) {
            ZipEntry entry = (ZipEntry) e.nextElement ();
            String name = entry.getName ();
            String lname = name.toLowerCase ();
            if (lname.endsWith (".html")) {
                String url = "jeditresource:/" + MiscUtilities.getFileName (jar.getName ()) + "!/" + name;
                Log.log (Log.DEBUG, this, url);
                indexStream (jar.getInputStream (entry), url);
            }
        }
    }

    public void indexURL (String url) throws Exception {
        InputStream _in;
        if (MiscUtilities.isURL (url)) _in = new URL (url).openStream ();
        else {
            _in = new FileInputStream (url);
            url = "file:" + url;
        }
        indexStream (_in, url);
    }

    public Word lookupWord (String word) {
        Object o = words.get (word);
        if (o == IGNORE) return null;
        else return (Word) o;

    }

    public HelpFile getFile (int index) {
        return files.get (index);
    }

    private static Object IGNORE = new Object ();
    private Map < String, Object > words;
    private List < HelpFile > files;

    private void ignoreWord (String word) {
        words.put (word, IGNORE);
    }

    private void indexStream (InputStream _in, String fileName) throws Exception {
        HelpFile file = new HelpFile (fileName);
        files.add (file);
        int index = files.size () - 1;
        StringBuilder titleText = new StringBuilder ();
        BufferedReader in = new BufferedReader (new InputStreamReader (_in));
        try {
            StringBuilder word = new StringBuilder ();
            boolean insideTag = false;
            boolean insideEntity = false;
            boolean title = false;
            int c;
            while ((c = in.read ()) != - 1) {
                char ch = (char) c;
                if (insideTag) {
                    if (ch == '>') {
                        if (word.toString ().equals ("title")) title = true;

                        insideTag = false;
                        word.setLength (0);
                    } else word.append (ch);

                } else if (insideEntity) {
                    if (ch == ';') insideEntity = false;

                } else if (ch == '<') {
                    if (title) title = false;

                    if (word.length () != 0) {
                        addWord (word.toString (), index, title);
                        word.setLength (0);
                    }
                    insideTag = true;
                } else if (ch == '&') insideEntity = true;
                else if (title) titleText.append (ch);
                else if (! Character.isLetterOrDigit (ch)) {
                    if (word.length () != 0) {
                        addWord (word.toString (), index, title);
                        word.setLength (0);
                    }
                } else word.append (ch);

            }
        } finally {
            in.close ();
        }
        if (titleText.length () == 0) file.title = fileName;
        else file.title = titleText.toString ();

    }

    private void addWord (String word, int file, boolean title) {
        word = word.toLowerCase ();
        Object o = words.get (word);
        if (o == IGNORE) return;

        if (o == null) words.put (word, new Word (word, file, title));
        else ((Word) o).addOccurrence (file, title);

    }

    static class Word {
        static final int TITLE_OCCUR = 10;
        String word;
        int occurCount = 0;
        Occurrence [] occurrences;

        Word (String word, int file, boolean title) {
            this.word = word;
            occurrences = new Occurrence [5];
            addOccurrence (file, title);
        }

        void addOccurrence (int file, boolean title) {
            for (int i = 0;
            i < occurCount; i ++) {
                if (occurrences [i].file == file) {
                    occurrences [i].count += (title ? TITLE_OCCUR : 1);
                    return;
                }
            }
            if (occurCount >= occurrences.length) {
                Occurrence [] newOccur = new Occurrence [occurrences.length * 2];
                System.arraycopy (occurrences, 0, newOccur, 0, occurCount);
                occurrences = newOccur;
            }
            occurrences [occurCount ++] = new Occurrence (file, title);
        }

        static class Occurrence {
            int file;
            int count;

            Occurrence (int file, boolean title) {
                this.file = file;
                this.count = (title ? TITLE_OCCUR : 1);
            }

        }

    }

    static class HelpFile {
        String file;
        String title;

        HelpFile (String file) {
            this.file = file;
        }

        public String toString () {
            return title;
        }

        public boolean equals (Object o) {
            if (o instanceof HelpFile) return ((HelpFile) o).file.equals (file);
            else return false;

        }

    }

}

</source>
<source file="systems/java/jEdit/trunk/org/gjt/sp/jedit/help/HelpHistoryModel.java" startline="1" endline="248">
package org.gjt.sp.jedit.help;

import java.net.URL;

import java.util.List;

import java.util.ArrayList;

public class HelpHistoryModel {

    public HelpHistoryModel (int size) {
        history = new HistoryEntry [size];
        listeners = new ArrayList < HelpHistoryModelListener > ();
    }

    HistoryEntry forward (HelpViewer helpViewer) {
        if (history.length - historyPos <= 1) {
            return null;
        }
        if (history [historyPos] == null) {
            return null;
        }
        setCurrentScrollPosition (helpViewer.getCurrentPage (), helpViewer.getCurrentScrollPosition ());
        HistoryEntry result = new HistoryEntry (history [historyPos]);
        historyPos ++;
        fireUpdate ();
        return result;
    }

    public boolean hasNext () {
        return ! ((history.length - historyPos <= 1) || (history [historyPos] == null));
    }

    HistoryEntry back (HelpViewer helpViewer) {
        if (historyPos <= 1) {
            return null;
        }
        setCurrentScrollPosition (helpViewer.getCurrentPage (), helpViewer.getCurrentScrollPosition ());
        HistoryEntry result = new HistoryEntry (history [-- historyPos - 1]);
        fireUpdate ();
        return result;
    }

    public boolean hasPrevious () {
        return (historyPos > 1);
    }

    public void addToHistory (String url) {
        history [historyPos] = new HistoryEntry (url, url, 0);
        if (historyPos + 1 == history.length) {
            System.arraycopy (history, 1, history, 0, history.length - 1);
            history [historyPos] = null;
        } else {
            historyPos ++;
            for (int i = historyPos;
            i < history.length; i ++) {
                history [i] = null;
            }
        }
        fireUpdate ();
    }

    public void setCurrentScrollPosition (URL currentPage, int scrollPosition) {
        if ((null != currentPage) && (historyPos >= 1) && (currentPage.toString ().equals (history [historyPos - 1].url))) {
            history [historyPos - 1].scrollPosition = scrollPosition;
        }
    }

    public void setCurrentEntry (HistoryEntry entry) {
        for (int i = 0;
        i < history.length; i ++) {
            if ((history [i] != null) && (history [i].equals (entry))) {
                historyPos = i + 1;
                fireUpdate ();
                break;
            }
        }
    }

    public void updateTitle (String url, String title) {
        for (int i = 0;
        i < history.length; i ++) {
            if ((history [i] != null) && history [i].url.equals (url)) {
                history [i].title = title;
            }
        }
        fireUpdate ();
    }

    HistoryEntry [] getPreviousURLs () {
        if (historyPos <= 1) {
            return new HelpHistoryModel.HistoryEntry [0];
        }
        HistoryEntry [] previous = new HistoryEntry [historyPos - 1];
        System.arraycopy (history, 0, previous, 0, historyPos - 1);
        return previous;
    }

    HistoryEntry [] getNextURLs () {
        if (history.length - historyPos <= 1) {
            return new HelpHistoryModel.HistoryEntry [0];
        }
        if (history [historyPos] == null) {
            return new HelpHistoryModel.HistoryEntry [0];
        }
        HistoryEntry [] next = new HistoryEntry [history.length - historyPos];
        System.arraycopy (history, historyPos, next, 0, history.length - historyPos);
        return next;
    }

    public void addHelpHistoryModelListener (HelpHistoryModelListener hhml) {
        listeners.add (hhml);
    }

    public void removeHelpHistoryModelListener (HelpHistoryModelListener hhml) {
        listeners.remove (hhml);
    }

    public void fireUpdate () {
        for (int i = 0;
        i < listeners.size (); i ++) {
            listeners.get (i).historyUpdated ();
        }
    }

    private int historyPos;
    private HistoryEntry [] history;
    private List < HelpHistoryModelListener > listeners;
    static class HistoryEntry {
        String url;
        String title;
        int scrollPosition;

        HistoryEntry (String url, String title) {
            this (url, title, 0);
        }

        HistoryEntry (HistoryEntry original) {
            this (original.url, original.title, original.scrollPosition);
        }

        HistoryEntry (String url, String title, int scrollPosition) {
            this.url = url;
            this.title = title;
            this.scrollPosition = scrollPosition;
        }

        public boolean equals (HistoryEntry he) {
            return he.url.equals (this.url) && he.title.equals (this.title) && (he.scrollPosition == scrollPosition);
        }

        public String toString () {
            return getClass ().getName () + "[url=" + url + ",title=" + title + ",scrollPosition=" + scrollPosition + ']';
        }

    }

}

</source>
<source file="systems/java/jEdit/trunk/org/gjt/sp/jedit/help/HelpViewerInterface.java" startline="1" endline="41">
package org.gjt.sp.jedit.help;

import java.awt.Component;

import java.beans.PropertyChangeListener;

public interface HelpViewerInterface {

    public void gotoURL (String url, boolean addToHistory, int scrollPos);

    public String getBaseURL ();

    public void addPropertyChangeListener (PropertyChangeListener l);

    public void dispose ();

    public Component getComponent ();

    public String getShortURL ();

    public void queueTOCReload ();

    public void setTitle (String newTitle);

}

</source>
<source file="systems/java/jEdit/trunk/org/gjt/sp/jedit/EditAction.java" startline="1" endline="226">
package org.gjt.sp.jedit;

import org.gjt.sp.util.Log;

import java.awt.Component;

import java.awt.event.ActionEvent;

import java.awt.event.ActionListener;

public abstract class EditAction extends JEditAbstractEditAction < View > {

    public EditAction (String name) {
        super (name);
    }

    public EditAction (String name, Object [] newArgs) {
        super (name, newArgs);
    }

    public String getLabel () {
        if (args != null) {
            return jEdit.getProperty (name + ".label", args);
        }
        return jEdit.getProperty (name + ".label");
    }

    public final String getMouseOverText () {
        return jEdit.getProperty (name + ".mouse-over");
    }

    abstract public void invoke (View view);

    @Deprecated
    public static View getView (Component comp) {
        return GUIUtilities.getView (comp);
    }

    public final boolean isToggle () {
        return jEdit.getBooleanProperty (name + ".toggle");
    }

    public boolean isSelected (Component comp) {
        return false;
    }

    public boolean noRepeat () {
        return false;
    }

    public boolean noRecord () {
        return false;
    }

    public boolean noRememberLast () {
        return false;
    }

    public String getCode () {
        return "jEdit.getAction(" + name + ").invoke(view); ";
    }

    public static class Wrapper implements ActionListener {
        private final ActionContext context;
        private final String actionName;

        public Wrapper (ActionContext context, String actionName) {
            this.context = context;
            this.actionName = actionName;
        }

        public void actionPerformed (ActionEvent evt) {
            EditAction action = context.getAction (actionName);
            if (action == null) {
                Log.log (Log.WARNING, this, "Unknown action: " + actionName);
            } else context.invokeAction (evt, action);

        }

    }

}

</source>
<source file="systems/java/jEdit/trunk/org/gjt/sp/jedit/BufferHistory.java" startline="1" endline="464">
package org.gjt.sp.jedit;

import java.io.IOException;

import java.util.*;

import java.util.concurrent.locks.ReentrantReadWriteLock;

import org.xml.sax.InputSource;

import org.xml.sax.helpers.DefaultHandler;

import org.gjt.sp.jedit.msg.DynamicMenuChanged;

import org.gjt.sp.jedit.textarea.*;

import org.gjt.sp.util.Log;

import org.gjt.sp.util.XMLUtilities;

import org.gjt.sp.util.IOUtilities;

public class BufferHistory {
    public static class Entry {
        public String path;
        public int caret;
        public String selection;
        public String encoding;
        public String mode;

        public Selection [] getSelection () {
            return stringToSelection (selection);
        }

        public Entry (String path, int caret, String selection, String encoding, String mode) {
            this.path = path;
            this.caret = caret;
            this.selection = selection;
            this.encoding = encoding;
            this.mode = mode;
        }

        public String toString () {
            return path + ": " + caret;
        }

    }

    public static Entry getEntry (String path) {
        historyLock.readLock ().lock ();
        try {
            for (Entry entry : history) {
                if (MiscUtilities.pathsEqual (entry.path, path)) return entry;

            }
        } finally {
            historyLock.readLock ().unlock ();
        }
        return null;
    }

    public static void setEntry (String path, int caret, Selection [] selection, String encoding, String mode) {
        Entry entry = new Entry (path, caret, selectionToString (selection), encoding, mode);
        historyLock.writeLock ().lock ();
        try {
            removeEntry (path);
            addEntry (entry);
        } finally {
            historyLock.writeLock ().unlock ();
        }
        notifyChange ();
    }

    public static void clear () {
        historyLock.writeLock ().lock ();
        try {
            history.clear ();
        } finally {
            historyLock.writeLock ().unlock ();
        }
        notifyChange ();
    }

    public static List < Entry > getHistory () {
        historyLock.readLock ().lock ();
        try {
            return (List < Entry >) history.clone ();
        } finally {
            historyLock.readLock ().unlock ();
        }
    }

    public static void load () {
        if (recentXML == null) return;

        if (! recentXML.fileExists ()) return;

        Log.log (Log.MESSAGE, BufferHistory.class, "Loading " + recentXML);
        RecentHandler handler = new RecentHandler ();
        try {
            recentXML.load (handler);
        } catch (IOException e) {
            Log.log (Log.ERROR, BufferHistory.class, e);
        }
        trimToLimit (handler.result);
        history = handler.result;
    }

    public static void save () {
        if (recentXML == null) return;

        if (recentXML.hasChangedOnDisk ()) {
            Log.log (Log.WARNING, BufferHistory.class, recentXML + " changed on disk; will not save recent" + " files");
            return;
        }
        Log.log (Log.MESSAGE, BufferHistory.class, "Saving " + recentXML);
        String lineSep = System.getProperty ("line.separator");
        SettingsXML.Saver out = null;
        try {
            out = recentXML.openSaver ();
            out.writeXMLDeclaration ();
            out.write ("<!DOCTYPE RECENT SYSTEM \"recent.dtd\">");
            out.write (lineSep);
            out.write ("<RECENT>");
            out.write (lineSep);
            List < Entry > snapshot = getHistory ();
            for (Entry entry : snapshot) {
                out.write ("<ENTRY>");
                out.write (lineSep);
                out.write ("<PATH>");
                out.write (XMLUtilities.charsToEntities (entry.path, false));
                out.write ("</PATH>");
                out.write (lineSep);
                out.write ("<CARET>");
                out.write (String.valueOf (entry.caret));
                out.write ("</CARET>");
                out.write (lineSep);
                if (entry.selection != null && entry.selection.length () > 0) {
                    out.write ("<SELECTION>");
                    out.write (entry.selection);
                    out.write ("</SELECTION>");
                    out.write (lineSep);
                }
                if (entry.encoding != null) {
                    out.write ("<ENCODING>");
                    out.write (entry.encoding);
                    out.write ("</ENCODING>");
                    out.write (lineSep);
                }
                if (entry.mode != null) {
                    out.write ("<MODE>");
                    out.write (entry.mode);
                    out.write ("</MODE>");
                    out.write (lineSep);
                }
                out.write ("</ENTRY>");
                out.write (lineSep);
            }
            out.write ("</RECENT>");
            out.write (lineSep);
            out.finish ();
        } catch (Exception e) {
            Log.log (Log.ERROR, BufferHistory.class, e);
        } finally {
            IOUtilities.closeQuietly (out);
        }
    }

    private static LinkedList < Entry > history;
    private static ReentrantReadWriteLock historyLock;
    private static SettingsXML recentXML;

    static {
        history = new LinkedList < Entry > ();
        historyLock = new ReentrantReadWriteLock ();
        String settingsDirectory = jEdit.getSettingsDirectory ();
        if (settingsDirectory != null) {
            recentXML = new SettingsXML (settingsDirectory, "recent");
        }
    }

    private static void addEntry (Entry entry) {
        historyLock.writeLock ().lock ();
        try {
            history.addFirst (entry);
            trimToLimit (history);
        } finally {
            historyLock.writeLock ().unlock ();
        }
    }

    private static void removeEntry (String path) {
        historyLock.writeLock ().lock ();
        try {
            Iterator < Entry > iter = history.iterator ();
            while (iter.hasNext ()) {
                Entry entry = iter.next ();
                if (MiscUtilities.pathsEqual (path, entry.path)) {
                    iter.remove ();
                    return;
                }
            }
        } finally {
            historyLock.writeLock ().unlock ();
        }
    }

    private static String selectionToString (Selection [] s) {
        if (s == null) return null;

        StringBuilder buf = new StringBuilder ();
        for (int i = 0;
        i < s.length; i ++) {
            if (i != 0) buf.append (' ');

            Selection sel = s [i];
            if (sel instanceof Selection.Range) buf.append ("range ");
            else buf.append ("rect ");

            buf.append (sel.getStart ());
            buf.append (' ');
            buf.append (sel.getEnd ());
        }
        return buf.toString ();
    }

    private static Selection [] stringToSelection (String s) {
        if (s == null) return null;

        List < Selection > selection = new ArrayList < Selection > ();
        StringTokenizer st = new StringTokenizer (s);
        while (st.hasMoreTokens ()) {
            String type = st.nextToken ();
            int start = Integer.parseInt (st.nextToken ());
            int end = Integer.parseInt (st.nextToken ());
            if (end < start) {
                continue;
            }
            Selection sel;
            if (type.equals ("range")) sel = new Selection.Range (start, end);
            else sel = new Selection.Rect (start, end);

            selection.add (sel);
        }
        Selection [] returnValue = new Selection [selection.size ()];
        returnValue = selection.toArray (returnValue);
        return returnValue;
    }

    private static void trimToLimit (LinkedList < Entry > list) {
        int max = jEdit.getIntegerProperty ("recentFiles", 50);
        while (list.size () > max) list.removeLast ();

    }

    private static void notifyChange () {
        EditBus.send (new DynamicMenuChanged ("recent-files"));
    }

    private static class RecentHandler extends DefaultHandler {
        public LinkedList < Entry > result = new LinkedList < Entry > ();

        public InputSource resolveEntity (String publicId, String systemId) {
            return XMLUtilities.findEntity (systemId, "recent.dtd", getClass ());
        }

        public void endElement (String uri, String localName, String name) {
            if (name.equals ("ENTRY")) {
                result.addLast (new Entry (path, caret, selection, encoding, mode));
                path = null;
                caret = 0;
                selection = null;
                encoding = null;
                mode = null;
            } else if (name.equals ("PATH")) path = charData.toString ();
            else if (name.equals ("CARET")) caret = Integer.parseInt (charData.toString ());
            else if (name.equals ("SELECTION")) selection = charData.toString ();
            else if (name.equals ("ENCODING")) encoding = charData.toString ();
            else if (name.equals ("MODE")) mode = charData.toString ();

            charData.setLength (0);
        }

        public void characters (char [] ch, int start, int length) {
            charData.append (ch, start, length);
        }

        private String path;
        private int caret;
        private String selection;
        private String encoding;
        private String mode;
        private StringBuilder charData = new StringBuilder ();
    }

}

</source>
<source file="systems/java/jEdit/trunk/org/gjt/sp/jedit/EditServer.java" startline="1" endline="366">
package org.gjt.sp.jedit;

import org.gjt.sp.jedit.bsh.NameSpace;

import javax.swing.SwingUtilities;

import java.io.*;

import java.net.*;

import java.util.Random;

import org.gjt.sp.jedit.io.FileVFS;

import org.gjt.sp.util.Log;

public class EditServer extends Thread {

    EditServer (String portFile) {
        super ("jEdit server daemon [" + portFile + "]");
        setDaemon (true);
        this.portFile = portFile;
        try {
            if (OperatingSystem.isUnix ()) {
                new File (portFile).createNewFile ();
                FileVFS.setPermissions (portFile, 0600);
            }
            socket = new ServerSocket (0, 2, InetAddress.getByName ("127.0.0.1"));
            authKey = new Random ().nextInt (Integer.MAX_VALUE);
            int port = socket.getLocalPort ();
            FileWriter out = new FileWriter (portFile);
            try {
                out.write ("b\n");
                out.write (String.valueOf (port));
                out.write ("\n");
                out.write (String.valueOf (authKey));
                out.write ("\n");
            } finally {
                out.close ();
            }
            ok = true;
            Log.log (Log.DEBUG, this, "jEdit server started on port " + socket.getLocalPort ());
            Log.log (Log.DEBUG, this, "Authorization key is " + authKey);
        } catch (IOException io) {
            Log.log (Log.NOTICE, this, io);
        }
    }

    public void run () {
        for (;;) {
            if (abort) return;

            Socket client = null;
            try {
                client = socket.accept ();
                client.setSoTimeout (1000);
                Log.log (Log.MESSAGE, this, client + ": connected");
                DataInputStream in = new DataInputStream (client.getInputStream ());
                if (! handleClient (client, in)) abort = true;

            } catch (Exception e) {
                if (! abort) Log.log (Log.ERROR, this, e);

                abort = true;
            } finally {
            }
        }
    }

    public static void handleClient (boolean restore, String parent, String [] args) {
        handleClient (restore, false, false, parent, args);
    }

    public static Buffer handleClient (boolean restore, boolean newView, boolean newPlainView, String parent, String [] args) {
        if (jEdit.getFirstView () == null) {
            Buffer buffer = jEdit.openFiles (null, parent, args);
            boolean restoreFiles = restore && jEdit.getBooleanProperty ("restore") && (buffer == null || jEdit.getBooleanProperty ("restore.cli"));
            View view = PerspectiveManager.loadPerspective (restoreFiles);
            if (view == null) {
                if (buffer == null) buffer = jEdit.getFirstBuffer ();

                jEdit.newView (null, buffer);
            } else if (buffer != null) view.setBuffer (buffer, false);

            return buffer;
        } else if (newPlainView) {
            Buffer buffer = jEdit.openFiles (null, parent, args);
            if (buffer == null) buffer = jEdit.getFirstBuffer ();

            jEdit.newView (null, buffer, true);
            return buffer;
        } else if (newView) {
            Buffer buffer = jEdit.openFiles (null, parent, args);
            if (buffer == null) buffer = jEdit.getFirstBuffer ();

            jEdit.newView (jEdit.getActiveView (), buffer, false);
            return buffer;
        } else {
            View view = jEdit.getActiveView ();
            Buffer buffer = jEdit.openFiles (view, parent, args);
            if (jEdit.getBooleanProperty ("server.brokenToFront")) view.setState (java.awt.Frame.ICONIFIED);

            view.setState (java.awt.Frame.NORMAL);
            view.requestFocus ();
            view.toFront ();
            return buffer;
        }

    }

    boolean isOK () {
        return ok;
    }

    public int getPort () {
        return socket.getLocalPort ();
    }

    void stopServer () {
        abort = true;
        try {
            socket.close ();
        } catch (IOException io) {
        }
        new File (portFile).delete ();
    }

    private String portFile;
    private ServerSocket socket;
    private int authKey;
    private boolean ok;
    private boolean abort;

    private boolean handleClient (final Socket client, DataInputStream in) throws Exception {
        int key = in.readInt ();
        if (key != authKey) {
            Log.log (Log.ERROR, this, client + ": wrong" + " authorization key (got " + key + ", expected " + authKey + ")");
            in.close ();
            client.close ();
            return false;
        } else {
            client.setSoTimeout (0);
            Log.log (Log.DEBUG, this, client + ": authenticated" + " successfully");
            final String script = in.readUTF ();
            Log.log (Log.DEBUG, this, script);
            SwingUtilities.invokeLater (new Runnable () {

                public void run () {
                    try {
                        NameSpace ns = new NameSpace (BeanShell.getNameSpace (), "EditServer namespace");
                        ns.setVariable ("socket", client);
                        BeanShell.eval (null, ns, script);
                    } catch (org.gjt.sp.jedit.bsh.UtilEvalError e) {
                        Log.log (Log.ERROR, this, e);
                    } finally {
                        try {
                            BeanShell.getNameSpace ().setVariable ("socket", null);
                        } catch (org.gjt.sp.jedit.bsh.UtilEvalError e) {
                            Log.log (Log.ERROR, this, e);
                        }
                    }
                }

            }

            );
            return true;
        }
    }

}

</source>
<source file="systems/java/jEdit/trunk/org/gjt/sp/jedit/BeanShellAction.java" startline="1" endline="205">
package org.gjt.sp.jedit;

import org.gjt.sp.jedit.bsh.*;

import java.lang.ref.SoftReference;

import java.awt.Component;

import org.gjt.sp.jedit.gui.BeanShellErrorDialog;

import org.gjt.sp.util.Log;

public class BeanShellAction extends EditAction {

    public BeanShellAction (String name, String code, String isSelected, boolean noRepeat, boolean noRecord, boolean noRememberLast) {
        super (name);
        String sanitizedName = name.replace ('.', '_').replace ('-', '_');
        this.code = new CachedBshMethod ("action_" + sanitizedName, code);
        if (isSelected != null) {
            this.isSelected = new CachedBshMethod ("selected_" + sanitizedName, isSelected);
        }
        this.noRepeat = noRepeat;
        this.noRecord = noRecord;
        this.noRememberLast = noRememberLast;
        jEdit.setTemporaryProperty (name + ".toggle", isSelected != null ? "true" : "false");
    }

    public void invoke (View view) {
        try {
            BeanShell.runCachedBlock (code.get (), view, new NameSpace (BeanShell.getNameSpace (), "BeanShellAction.invoke()"));
        } catch (Throwable e) {
            Log.log (Log.ERROR, this, e);
            new BeanShellErrorDialog (view, e);
        }
    }

    public boolean isSelected (Component comp) {
        if (isSelected == null) return false;

        NameSpace global = BeanShell.getNameSpace ();
        try {
            View view = GUIUtilities.getView (comp);
            global.setVariable ("_comp", comp);
            return Boolean.TRUE.equals (BeanShell.runCachedBlock (isSelected.get (), view, new NameSpace (BeanShell.getNameSpace (), "BeanShellAction.isSelected()")));
        } catch (Throwable e) {
            Log.log (Log.ERROR, this, e);
            isSelected = null;
            return false;
        } finally {
            try {
                global.setVariable ("_comp", null);
            } catch (UtilEvalError err) {
                Log.log (Log.ERROR, this, err);
            }
        }
    }

    public boolean noRepeat () {
        return noRepeat;
    }

    public boolean noRecord () {
        return noRecord;
    }

    public boolean noRememberLast () {
        return noRememberLast;
    }

    public String getCode () {
        return code.getSource ().trim ();
    }

    private boolean noRepeat;
    private boolean noRecord;
    private boolean noRememberLast;
    private CachedBshMethod code;
    private CachedBshMethod isSelected;
    private static class CachedBshMethod {
        private final String name;
        private final String source;
        private SoftReference < BshMethod > cache;

        public CachedBshMethod (String name, String source) {
            this.name = name;
            this.source = source;
            this.cache = null;
        }

        public BshMethod get () throws java.lang.Exception {
            if (cache != null) {
                BshMethod cached = cache.get ();
                if (cached != null) {
                    return cached;
                }
            }
            BshMethod newOne = BeanShell.cacheBlock (name, source, true);
            cache = new SoftReference < BshMethod > (newOne);
            return newOne;
        }

        public String getSource () {
            return source;
        }

    }

}

</source>
<source file="systems/java/jEdit/trunk/org/gjt/sp/jedit/buffer/KillRing.java" startline="1" endline="301">
package org.gjt.sp.jedit.buffer;

import javax.swing.event.ListDataListener;

import java.util.List;

import org.gjt.sp.jedit.gui.MutableListModel;

public class KillRing implements MutableListModel {

    public static KillRing getInstance () {
        return killRing;
    }

    public static void setInstance (KillRing killRing) {
        KillRing.killRing = killRing;
    }

    public void propertiesChanged (int historySize) {
        int newSize = Math.max (1, historySize);
        if (ring == null) ring = new UndoManager.RemovedContent [newSize];
        else if (newSize != ring.length) {
            UndoManager.RemovedContent [] newRing = new UndoManager.RemovedContent [newSize];
            int newCount = Math.min (getSize (), newSize);
            for (int i = 0;
            i < newCount; i ++) {
                newRing [i] = (UndoManager.RemovedContent) getElementAt (i);
            }
            ring = newRing;
            count = newCount;
            wrap = false;
        }

        if (count == ring.length) {
            count = 0;
            wrap = true;
        }
    }

    public void load () {
    }

    public void save () {
    }

    protected void reset (List source) {
        UndoManager.RemovedContent [] newRing = new UndoManager.RemovedContent [source.size ()];
        int i = 0;
        for (Object x : source) {
            UndoManager.RemovedContent element;
            if (x instanceof String) {
                element = new UndoManager.RemovedContent ((String) x);
            } else {
                element = (UndoManager.RemovedContent) x;
            }
            newRing [i ++] = element;
        }
        ring = newRing;
        count = 0;
        wrap = true;
    }

    public void addListDataListener (ListDataListener listener) {
    }

    public void removeListDataListener (ListDataListener listener) {
    }

    public Object getElementAt (int index) {
        return ring [virtualToPhysicalIndex (index)];
    }

    public int getSize () {
        if (wrap) return ring.length;
        else return count;

    }

    public boolean removeElement (Object value) {
        for (int i = 0;
        i < getSize (); i ++) {
            if (ring [i].equals (value)) {
                remove (i);
                return true;
            }
        }
        return false;
    }

    public void insertElementAt (Object value, int index) {
        remove (index);
        add ((UndoManager.RemovedContent) value);
    }

    void changed (UndoManager.RemovedContent rem) {
        if (rem.inKillRing) {
            int length = (wrap ? ring.length : count);
            int kill = - 1;
            for (int i = 0;
            i < length; i ++) {
                if (ring [i] != rem && ring [i].hashcode == rem.hashcode && ring [i].str.equals (rem.str)) {
                    kill = i;
                    break;
                }
            }
            if (kill != - 1) remove (kill);

        } else add (rem);

    }

    void add (UndoManager.RemovedContent rem) {
        int length = (wrap ? ring.length : count);
        for (int i = 0;
        i < length; i ++) {
            if (ring [i].hashcode == rem.hashcode) {
                if (ring [i].str.equals (rem.str)) {
                    return;
                }
            }
        }
        boolean allWhitespace = true;
        for (int i = 0;
        i < rem.str.length (); i ++) {
            if (! Character.isWhitespace (rem.str.charAt (i))) {
                allWhitespace = false;
                break;
            }
        }
        if (allWhitespace) return;

        rem.inKillRing = true;
        if (ring [count] != null) ring [count].inKillRing = false;

        ring [count] = rem;
        if (++ count >= ring.length) {
            wrap = true;
            count = 0;
        }
    }

    void remove (int i) {
        if (wrap) {
            UndoManager.RemovedContent [] newRing = new UndoManager.RemovedContent [ring.length];
            int newCount = 0;
            for (int j = 0;
            j < ring.length; j ++) {
                int index = virtualToPhysicalIndex (j);
                if (i == index) {
                    ring [index].inKillRing = false;
                    continue;
                }
                newRing [newCount ++] = ring [index];
            }
            ring = newRing;
            count = newCount;
            wrap = false;
        } else {
            System.arraycopy (ring, i + 1, ring, i, count - i - 1);
            count --;
        }
    }

    private UndoManager.RemovedContent [] ring;
    private int count;
    private boolean wrap;
    private static KillRing killRing = new KillRing ();

    private int virtualToPhysicalIndex (int index) {
        if (wrap) {
            if (index < count) return count - index - 1;
            else return count + ring.length - index - 1;

        } else return count - index - 1;

    }

}

</source>
<source file="systems/java/jEdit/trunk/org/gjt/sp/jedit/buffer/BufferChangeAdapter.java" startline="1" endline="127">
package org.gjt.sp.jedit.buffer;

import org.gjt.sp.jedit.Buffer;

public abstract class BufferChangeAdapter implements BufferChangeListener {

    public void foldLevelChanged (Buffer buffer, int start, int end) {
    }

    public void contentInserted (Buffer buffer, int startLine, int offset, int numLines, int length) {
    }

    public void preContentRemoved (Buffer buffer, int startLine, int offset, int numLines, int length) {
    }

    public void contentRemoved (Buffer buffer, int startLine, int offset, int numLines, int length) {
    }

    public void transactionComplete (Buffer buffer) {
    }

    public void foldHandlerChanged (Buffer buffer) {
    }

    public void bufferLoaded (Buffer buffer) {
    }

}

</source>
<source file="systems/java/jEdit/trunk/org/gjt/sp/jedit/buffer/BufferSegment.java" startline="1" endline="115">
package org.gjt.sp.jedit.buffer;

class BufferSegment implements CharSequence {

    public BufferSegment (char [] data, int offset, int len) {
        this (data, offset, len, null);
    }

    public BufferSegment (char [] data, int offset, int len, BufferSegment next) {
        this.data = data;
        this.offset = offset;
        this.len = len;
        this.next = next;
    }

    public char charAt (int index) {
        if (index < len) return data [offset + index];
        else if (next != null) return next.charAt (index - len);
        else throw new ArrayIndexOutOfBoundsException (index);

    }

    public int length () {
        return len + ((next != null) ? next.length () : 0);
    }

    public CharSequence subSequence (int start, int end) {
        return subSegment (start, end);
    }

    public String toString () {
        StringBuilder sb = new StringBuilder ();
        toString (sb);
        return sb.toString ();
    }

    private void toString (StringBuilder sb) {
        sb.append (data, offset, len);
        if (next != null) next.toString (sb);

    }

    private BufferSegment subSegment (int start, int end) {
        if (0 <= start && start <= end) if (end <= len) return new BufferSegment (data, offset + start, end - start);
        else if (next != null) if (start < len) return new BufferSegment (data, offset + start, len - start, next.subSegment (0, end - len));
        else return next.subSegment (start - len, end - len);

        else throw new ArrayIndexOutOfBoundsException ();

        else throw new ArrayIndexOutOfBoundsException ();

    }

    private final char [] data;
    private final int offset;
    private final int len;
    private final BufferSegment next;
}

</source>
<source file="systems/java/jEdit/trunk/org/gjt/sp/jedit/buffer/BufferChangeListener.java" startline="1" endline="269">
package org.gjt.sp.jedit.buffer;

import org.gjt.sp.jedit.Buffer;

public interface BufferChangeListener {

    void foldLevelChanged (Buffer buffer, int startLine, int endLine);

    void contentInserted (Buffer buffer, int startLine, int offset, int numLines, int length);

    void contentRemoved (Buffer buffer, int startLine, int offset, int numLines, int length);

    public void preContentRemoved (Buffer buffer, int startLine, int offset, int numLines, int length);

    void transactionComplete (Buffer buffer);

    void foldHandlerChanged (Buffer buffer);

    void bufferLoaded (Buffer buffer);

    public class Adapter implements BufferListener {
        private BufferChangeListener delegate;

        public Adapter (BufferChangeListener delegate) {
            this.delegate = delegate;
        }

        public BufferChangeListener getDelegate () {
            return delegate;
        }

        public void foldLevelChanged (JEditBuffer buffer, int startLine, int endLine) {
            delegate.foldLevelChanged ((Buffer) buffer, startLine, endLine);
        }

        public void contentInserted (JEditBuffer buffer, int startLine, int offset, int numLines, int length) {
            delegate.contentInserted ((Buffer) buffer, startLine, offset, numLines, length);
        }

        public void contentRemoved (JEditBuffer buffer, int startLine, int offset, int numLines, int length) {
            delegate.contentRemoved ((Buffer) buffer, startLine, offset, numLines, length);
        }

        public void preContentInserted (JEditBuffer buffer, int startLine, int offset, int numLines, int length) {
        }

        public void preContentRemoved (JEditBuffer buffer, int startLine, int offset, int numLines, int length) {
            delegate.preContentRemoved ((Buffer) buffer, startLine, offset, numLines, length);
        }

        public void transactionComplete (JEditBuffer buffer) {
            delegate.transactionComplete ((Buffer) buffer);
        }

        public void foldHandlerChanged (JEditBuffer buffer) {
            delegate.foldHandlerChanged ((Buffer) buffer);
        }

        public void bufferLoaded (JEditBuffer buffer) {
            delegate.bufferLoaded ((Buffer) buffer);
        }

    }

}

</source>
<source file="systems/java/jEdit/trunk/org/gjt/sp/jedit/buffer/LineManager.java" startline="1" endline="363">
package org.gjt.sp.jedit.buffer;

import org.gjt.sp.jedit.syntax.*;

import org.gjt.sp.jedit.Debug;

import org.gjt.sp.util.IntegerArray;

import org.gjt.sp.util.Log;

public class LineManager {

    public LineManager () {
        endOffsets = new int [1];
        endOffsets [0] = 1;
        foldLevels = new short [1];
        lineContext = new TokenMarker.LineContext [1];
        lineCount = 1;
    }

    public final int getLineCount () {
        return lineCount;
    }

    public int getLineOfOffset (int offset) {
        int start = 0;
        int end = lineCount - 1;
        for (;;) {
            switch (end - start) {
                case 0 :
                    if (getLineEndOffset (start) <= offset) return start + 1;
                    else return start;

                case 1 :
                    if (getLineEndOffset (start) <= offset) {
                        if (getLineEndOffset (end) <= offset) return end + 1;
                        else return end;

                    } else return start;

                default :
                    int pivot = (end + start) / 2;
                    int value = getLineEndOffset (pivot);
                    if (value == offset) return pivot + 1;
                    else if (value < offset) start = pivot + 1;
                    else end = pivot - 1;

                    break;
            }
        }
    }

    public final int getLineEndOffset (int line) {
        if (gapLine != - 1 && line >= gapLine) return endOffsets [line] + gapWidth;
        else return endOffsets [line];

    }

    public final int getFoldLevel (int line) {
        return foldLevels [line];
    }

    public final void setFoldLevel (int line, int level) {
        if (level > 0xffff) {
            level = 0xffff;
        }
        foldLevels [line] = (short) level;
    }

    public void setFirstInvalidFoldLevel (int firstInvalidFoldLevel) {
        this.firstInvalidFoldLevel = firstInvalidFoldLevel;
    }

    public int getFirstInvalidFoldLevel () {
        return firstInvalidFoldLevel;
    }

    public final TokenMarker.LineContext getLineContext (int line) {
        return lineContext [line];
    }

    public final void setLineContext (int line, TokenMarker.LineContext context) {
        lineContext [line] = context;
    }

    public void setFirstInvalidLineContext (int firstInvalidLineContext) {
        this.firstInvalidLineContext = firstInvalidLineContext;
    }

    public int getFirstInvalidLineContext () {
        return firstInvalidLineContext;
    }

    public void _contentInserted (IntegerArray endOffsets) {
        gapLine = - 1;
        gapWidth = 0;
        firstInvalidLineContext = firstInvalidFoldLevel = 0;
        lineCount = endOffsets.getSize ();
        this.endOffsets = endOffsets.getArray ();
        foldLevels = new short [lineCount];
        lineContext = new TokenMarker.LineContext [lineCount];
    }

    public void contentInserted (int startLine, int offset, int numLines, int length, IntegerArray endOffsets) {
        int endLine = startLine + numLines;
        if (numLines > 0) {
            lineCount += numLines;
            if (this.endOffsets.length <= lineCount) {
                int [] endOffsetsN = new int [(lineCount + 1) * 2];
                System.arraycopy (this.endOffsets, 0, endOffsetsN, 0, this.endOffsets.length);
                this.endOffsets = endOffsetsN;
            }
            if (foldLevels.length <= lineCount) {
                short [] foldLevelsN = new short [(lineCount + 1) * 2];
                System.arraycopy (foldLevels, 0, foldLevelsN, 0, foldLevels.length);
                foldLevels = foldLevelsN;
            }
            if (lineContext.length <= lineCount) {
                TokenMarker.LineContext [] lineContextN = new TokenMarker.LineContext [(lineCount + 1) * 2];
                System.arraycopy (lineContext, 0, lineContextN, 0, lineContext.length);
                lineContext = lineContextN;
            }
            System.arraycopy (this.endOffsets, startLine, this.endOffsets, endLine, lineCount - endLine);
            System.arraycopy (foldLevels, startLine, foldLevels, endLine, lineCount - endLine);
            System.arraycopy (lineContext, startLine, lineContext, endLine, lineCount - endLine);
            if (startLine <= gapLine) gapLine += numLines;
            else if (gapLine != - 1) offset -= gapWidth;

            if (startLine < firstInvalidLineContext) firstInvalidLineContext += numLines;

            for (int i = 0;
            i < numLines; i ++) {
                this.endOffsets [startLine + i] = (offset + endOffsets.get (i));
                foldLevels [startLine + i] = 0;
            }
        }
        if (firstInvalidFoldLevel == - 1 || firstInvalidFoldLevel > startLine) firstInvalidFoldLevel = startLine;

        moveGap (endLine, length, "contentInserted");
    }

    public void contentRemoved (int startLine, int offset, int numLines, int length) {
        int endLine = startLine + numLines;
        if (numLines > 0) {
            if (startLine + numLines < gapLine) gapLine -= numLines;
            else if (startLine < gapLine) gapLine = startLine;

            if (startLine + numLines < firstInvalidLineContext) firstInvalidLineContext -= numLines;
            else if (startLine < firstInvalidLineContext) firstInvalidLineContext = startLine - 1;

            lineCount -= numLines;
            System.arraycopy (endOffsets, endLine, endOffsets, startLine, lineCount - startLine);
            System.arraycopy (foldLevels, endLine, foldLevels, startLine, lineCount - startLine);
            System.arraycopy (lineContext, endLine, lineContext, startLine, lineCount - startLine);
        }
        if (firstInvalidFoldLevel == - 1 || firstInvalidFoldLevel > startLine) firstInvalidFoldLevel = startLine;

        moveGap (startLine, - length, "contentRemoved");
    }

    private int [] endOffsets;
    private short [] foldLevels;
    private TokenMarker.LineContext [] lineContext;
    private int lineCount;
    private int gapLine;
    private int gapWidth;
    private int firstInvalidLineContext;
    private int firstInvalidFoldLevel;

    private final void setLineEndOffset (int line, int end) {
        endOffsets [line] = end;
    }

    private final void moveGap (int newGapLine, int newGapWidth, String method) {
        if (gapLine == - 1) gapWidth = newGapWidth;
        else if (newGapLine == - 1) {
            if (gapWidth != 0) {
                if (Debug.OFFSET_DEBUG && gapLine != lineCount) Log.log (Log.DEBUG, this, method + ": update from " + gapLine + " to " + lineCount + " width " + gapWidth);

                for (int i = gapLine;
                i < lineCount; i ++) setLineEndOffset (i, getLineEndOffset (i));

            }
            gapWidth = newGapWidth;
        } else if (newGapLine < gapLine) {
            if (gapWidth != 0) {
                if (Debug.OFFSET_DEBUG && newGapLine != gapLine) Log.log (Log.DEBUG, this, method + ": update from " + newGapLine + " to " + gapLine + " width " + gapWidth);

                for (int i = newGapLine;
                i < gapLine; i ++) setLineEndOffset (i, getLineEndOffset (i) - gapWidth);

            }
            gapWidth += newGapWidth;
        } else {
            if (gapWidth != 0) {
                if (Debug.OFFSET_DEBUG && gapLine != newGapLine) Log.log (Log.DEBUG, this, method + ": update from " + gapLine + " to " + newGapLine + " width " + gapWidth);

                for (int i = gapLine;
                i < newGapLine; i ++) setLineEndOffset (i, getLineEndOffset (i));

            }
            gapWidth += newGapWidth;
        }

        if (newGapLine == lineCount) gapLine = - 1;
        else gapLine = newGapLine;

    }

}

</source>
<source file="systems/java/jEdit/trunk/org/gjt/sp/jedit/buffer/BufferListener.java" startline="1" endline="151">
package org.gjt.sp.jedit.buffer;

public interface BufferListener {

    void foldLevelChanged (JEditBuffer buffer, int startLine, int endLine);

    void contentInserted (JEditBuffer buffer, int startLine, int offset, int numLines, int length);

    void contentRemoved (JEditBuffer buffer, int startLine, int offset, int numLines, int length);

    void preContentInserted (JEditBuffer buffer, int startLine, int offset, int numLines, int length);

    void preContentRemoved (JEditBuffer buffer, int startLine, int offset, int numLines, int length);

    void transactionComplete (JEditBuffer buffer);

    void foldHandlerChanged (JEditBuffer buffer);

    void bufferLoaded (JEditBuffer buffer);

}

</source>
<source file="systems/java/jEdit/trunk/org/gjt/sp/jedit/buffer/PositionManager.java" startline="1" endline="210">
package org.gjt.sp.jedit.buffer;

import javax.swing.text.Position;

import java.util.*;

import org.gjt.sp.util.Log;

public class PositionManager {

    public PositionManager (JEditBuffer buffer) {
        this.buffer = buffer;
    }

    public synchronized Position createPosition (int offset) {
        PosBottomHalf bh = new PosBottomHalf (offset);
        PosBottomHalf existing = positions.get (bh);
        if (existing == null) {
            positions.put (bh, bh);
            existing = bh;
        }
        return new PosTopHalf (existing);
    }

    public synchronized void contentInserted (int offset, int length) {
        if (positions.isEmpty ()) return;

        Iterator < PosBottomHalf > iter = positions.tailMap (new PosBottomHalf (offset)).keySet ().iterator ();
        iteration = true;
        while (iter.hasNext ()) {
            iter.next ().contentInserted (offset, length);
        }
        iteration = false;
    }

    public synchronized void contentRemoved (int offset, int length) {
        if (positions.isEmpty ()) return;

        Iterator < PosBottomHalf > iter = positions.tailMap (new PosBottomHalf (offset)).keySet ().iterator ();
        iteration = true;
        while (iter.hasNext ()) {
            iter.next ().contentRemoved (offset, length);
        }
        iteration = false;
    }

    boolean iteration;
    private JEditBuffer buffer;
    private SortedMap < PosBottomHalf, PosBottomHalf > positions = new TreeMap < PosBottomHalf, PosBottomHalf > ();
    class PosTopHalf implements Position {
        final PosBottomHalf bh;

        PosTopHalf (PosBottomHalf bh) {
            this.bh = bh;
            bh.ref ();
        }

        public int getOffset () {
            return bh.offset;
        }

        @Override
        protected void finalize () {
            synchronized (PositionManager.this) {
                bh.unref ();
            }
        }

    }

    class PosBottomHalf implements Comparable < PosBottomHalf > {
        int offset;
        int ref;

        PosBottomHalf (int offset) {
            this.offset = offset;
        }

        void ref () {
            ref ++;
        }

        void unref () {
            if (-- ref == 0) positions.remove (this);

        }

        void contentInserted (int offset, int length) {
            if (offset > this.offset) throw new ArrayIndexOutOfBoundsException ();

            this.offset += length;
            checkInvariants ();
        }

        void contentRemoved (int offset, int length) {
            if (offset > this.offset) throw new ArrayIndexOutOfBoundsException ();

            if (this.offset <= offset + length) this.offset = offset;
            else this.offset -= length;

            checkInvariants ();
        }

        @Override
        public boolean equals (Object o) {
            if (! (o instanceof PosBottomHalf)) return false;

            return ((PosBottomHalf) o).offset == offset;
        }

        public int compareTo (PosBottomHalf posBottomHalf) {
            if (iteration) Log.log (Log.ERROR, this, "Consistency failure");

            return offset - posBottomHalf.offset;
        }

        private void checkInvariants () {
            if (offset < 0 || offset > buffer.getLength ()) throw new ArrayIndexOutOfBoundsException ();

        }

    }

}

</source>
<source file="systems/java/jEdit/trunk/org/gjt/sp/jedit/buffer/DummyFoldHandler.java" startline="1" endline="57">
package org.gjt.sp.jedit.buffer;

import javax.swing.text.Segment;

public class DummyFoldHandler extends FoldHandler {

    public DummyFoldHandler () {
        super ("none");
    }

    public int getFoldLevel (JEditBuffer buffer, int lineIndex, Segment seg) {
        return 0;
    }

}

</source>
<source file="systems/java/jEdit/trunk/org/gjt/sp/jedit/buffer/FoldHandler.java" startline="1" endline="163">
package org.gjt.sp.jedit.buffer;

import java.util.List;

import javax.swing.text.Segment;

public abstract class FoldHandler {
    @Deprecated
    public static final String SERVICE = "org.gjt.sp.jedit.buffer.FoldHandler";
    public static FoldHandlerProvider foldHandlerProvider;

    public String getName () {
        return name;
    }

    public abstract int getFoldLevel (JEditBuffer buffer, int lineIndex, Segment seg);

    public List < Integer > getPrecedingFoldLevels (JEditBuffer buffer, int lineIndex, Segment seg, int lineFoldLevel) {
        return null;
    }

    public boolean equals (Object o) {
        if (o == null) return false;
        else return getClass () == o.getClass ();

    }

    public int hashCode () {
        return getClass ().hashCode ();
    }

    public static FoldHandler getFoldHandler (String name) {
        return foldHandlerProvider.getFoldHandler (name);
    }

    public static String [] getFoldModes () {
        return foldHandlerProvider.getFoldModes ();
    }

    protected FoldHandler (String name) {
        this.name = name;
    }

    public String toString () {
        return name;
    }

    private String name;
}

</source>
<source file="systems/java/jEdit/trunk/org/gjt/sp/jedit/buffer/FoldHandlerProvider.java" startline="1" endline="49">
package org.gjt.sp.jedit.buffer;

public interface FoldHandlerProvider {

    FoldHandler getFoldHandler (String name);

    String [] getFoldModes ();

}

</source>
<source file="systems/java/jEdit/trunk/org/gjt/sp/jedit/buffer/DefaultFoldHandlerProvider.java" startline="1" endline="70">
package org.gjt.sp.jedit.buffer;

import java.util.Map;

import java.util.HashMap;

public class DefaultFoldHandlerProvider implements FoldHandlerProvider {
    private final Map < String, FoldHandler > folds = new HashMap < String, FoldHandler > ();

    public FoldHandler getFoldHandler (String name) {
        return folds.get (name);
    }

    public String [] getFoldModes () {
        return folds.keySet ().toArray (new String [folds.size ()]);
    }

    public void addFoldHandler (FoldHandler foldHandler) {
        folds.put (foldHandler.getName (), foldHandler);
    }

}

</source>
<source file="systems/java/jEdit/trunk/org/gjt/sp/jedit/buffer/IndentFoldHandler.java" startline="1" endline="137">
package org.gjt.sp.jedit.buffer;

import java.util.ArrayList;

import java.util.List;

import javax.swing.text.Segment;

public class IndentFoldHandler extends FoldHandler {

    public IndentFoldHandler () {
        super ("indent");
    }

    private int getLeadingWhitespaceWidth (Segment seg, int tabSize) {
        int offset = seg.offset;
        int count = seg.count;
        int whitespace = 0;
        for (int i = 0;
        i < count; i ++) {
            switch (seg.array [offset + i]) {
                case ' ' :
                    whitespace ++;
                    break;
                case '\t' :
                    whitespace += (tabSize - whitespace % tabSize);
                    break;
                default :
                    return whitespace;
            }
        }
        return (- 1);
    }

    public int getFoldLevel (JEditBuffer buffer, int lineIndex, Segment seg) {
        int tabSize = buffer.getTabSize ();
        int prevLevel = 0;
        for (int index = lineIndex;
        index < buffer.getLineCount (); index ++) {
            buffer.getLineText (index, seg);
            int whitespace = getLeadingWhitespaceWidth (seg, tabSize);
            if (whitespace >= 0) return (whitespace > prevLevel) ? whitespace : prevLevel;

            if (index == 0) return 0;

            if (index == lineIndex) prevLevel = buffer.getFoldLevel (lineIndex - 1);

        }
        return prevLevel;
    }

    public List < Integer > getPrecedingFoldLevels (JEditBuffer buffer, int lineIndex, Segment seg, int lineFoldLevel) {
        List < Integer > precedingFoldLevels = new ArrayList < Integer > ();
        int tabSize = buffer.getTabSize ();
        int whitespace = 0;
        int index;
        for (index = lineIndex - 1; index > 0; index --) {
            buffer.getLineText (index, seg);
            whitespace = getLeadingWhitespaceWidth (seg, tabSize);
            if (whitespace >= 0) break;

        }
        int max = (lineFoldLevel > whitespace) ? lineFoldLevel : whitespace;
        for (index ++; index < lineIndex; index ++) precedingFoldLevels.add (Integer.valueOf (max));

        return precedingFoldLevels;
    }

}

</source>
<source file="systems/java/jEdit/trunk/org/gjt/sp/jedit/buffer/ContentManager.java" startline="1" endline="241">
package org.gjt.sp.jedit.buffer;

import javax.swing.text.Segment;

public class ContentManager {

    public final int getLength () {
        return length;
    }

    public String getText (int start, int len) {
        if (start >= gapStart) return new String (text, start + gapEnd - gapStart, len);
        else if (start + len <= gapStart) return new String (text, start, len);
        else {
            return new String (text, start, gapStart - start).concat (new String (text, gapEnd, start + len - gapStart));
        }

    }

    public void getText (int start, int len, Segment seg) {
        if (start >= gapStart) {
            seg.array = text;
            seg.offset = start + gapEnd - gapStart;
            seg.count = len;
        } else if (start + len <= gapStart) {
            seg.array = text;
            seg.offset = start;
            seg.count = len;
        } else {
            seg.array = new char [len];
            System.arraycopy (text, start, seg.array, 0, gapStart - start);
            System.arraycopy (text, gapEnd, seg.array, gapStart - start, len + start - gapStart);
            seg.offset = 0;
            seg.count = len;
        }

    }

    public CharSequence getSegment (int start, int len) {
        if (start >= gapStart) return new BufferSegment (text, start + gapEnd - gapStart, len);
        else if (start + len <= gapStart) return new BufferSegment (text, start, len);
        else {
            return new BufferSegment (text, start, gapStart - start, new BufferSegment (text, gapEnd, start + len - gapStart));
        }

    }

    public void insert (int start, String str) {
        int len = str.length ();
        moveGapStart (start);
        if (gapEnd - gapStart < len) {
            ensureCapacity (length + len + 1024);
            moveGapEnd (start + len + 1024);
        }
        str.getChars (0, len, text, start);
        gapStart += len;
        length += len;
    }

    public void insert (int start, CharSequence str) {
        int len = str.length ();
        moveGapStart (start);
        if (gapEnd - gapStart < len) {
            ensureCapacity (length + len + 1024);
            moveGapEnd (start + len + 1024);
        }
        for (int i = 0;
        i < len; i ++) {
            text [start + i] = str.charAt (i);
        }
        gapStart += len;
        length += len;
    }

    public void insert (int start, Segment seg) {
        moveGapStart (start);
        if (gapEnd - gapStart < seg.count) {
            ensureCapacity (length + seg.count + 1024);
            moveGapEnd (start + seg.count + 1024);
        }
        System.arraycopy (seg.array, seg.offset, text, start, seg.count);
        gapStart += seg.count;
        length += seg.count;
    }

    public void _setContent (char [] text, int length) {
        this.text = text;
        this.gapStart = this.gapEnd = 0;
        this.length = length;
    }

    public void remove (int start, int len) {
        moveGapStart (start);
        gapEnd += len;
        length -= len;
    }

    private char [] text;
    private int gapStart;
    private int gapEnd;
    private int length;

    private void moveGapStart (int newStart) {
        int newEnd = gapEnd + (newStart - gapStart);
        if (newStart == gapStart) {
        } else if (newStart > gapStart) {
            System.arraycopy (text, gapEnd, text, gapStart, newStart - gapStart);
        } else if (newStart < gapStart) {
            System.arraycopy (text, newStart, text, newEnd, gapStart - newStart);
        }

        gapStart = newStart;
        gapEnd = newEnd;
    }

    private void moveGapEnd (int newEnd) {
        System.arraycopy (text, gapEnd, text, newEnd, length - gapStart);
        gapEnd = newEnd;
    }

    private void ensureCapacity (int capacity) {
        if (capacity >= text.length) {
            char [] textN = new char [capacity * 2];
            System.arraycopy (text, 0, textN, 0, length + (gapEnd - gapStart));
            text = textN;
        }
    }

}

</source>
<source file="systems/java/jEdit/trunk/org/gjt/sp/jedit/buffer/ExplicitFoldHandler.java" startline="1" endline="100">
package org.gjt.sp.jedit.buffer;

import javax.swing.text.Segment;

public class ExplicitFoldHandler extends FoldHandler {

    public ExplicitFoldHandler () {
        super ("explicit");
    }

    public int getFoldLevel (JEditBuffer buffer, int lineIndex, Segment seg) {
        if (lineIndex == 0) return 0;
        else {
            int foldLevel = buffer.getFoldLevel (lineIndex - 1);
            buffer.getLineText (lineIndex - 1, seg);
            int offset = seg.offset;
            int count = seg.count;
            int openingBrackets = 0, closingBrackets = 0;
            for (int i = 0;
            i < count; i ++) {
                switch (seg.array [offset + i]) {
                    case '{' :
                        closingBrackets = 0;
                        openingBrackets ++;
                        if (openingBrackets == 3) {
                            foldLevel ++;
                            openingBrackets = 0;
                        }
                        break;
                    case '}' :
                        openingBrackets = 0;
                        closingBrackets ++;
                        if (closingBrackets == 3) {
                            if (foldLevel > 0) foldLevel --;

                            closingBrackets = 0;
                        }
                        break;
                    default :
                        closingBrackets = openingBrackets = 0;
                        break;
                }
            }
            return foldLevel;
        }
    }

}

</source>
<source file="systems/java/jEdit/trunk/org/gjt/sp/jedit/buffer/BufferAdapter.java" startline="1" endline="139">
package org.gjt.sp.jedit.buffer;

public abstract class BufferAdapter implements BufferListener {

    public void foldLevelChanged (JEditBuffer buffer, int start, int end) {
    }

    public void contentInserted (JEditBuffer buffer, int startLine, int offset, int numLines, int length) {
    }

    public void preContentInserted (JEditBuffer buffer, int startLine, int offset, int numLines, int length) {
    }

    public void preContentRemoved (JEditBuffer buffer, int startLine, int offset, int numLines, int length) {
    }

    public void contentRemoved (JEditBuffer buffer, int startLine, int offset, int numLines, int length) {
    }

    public void transactionComplete (JEditBuffer buffer) {
    }

    public void foldHandlerChanged (JEditBuffer buffer) {
    }

    public void bufferLoaded (JEditBuffer buffer) {
    }

}

</source>
<source file="systems/java/jEdit/trunk/org/gjt/sp/jedit/buffer/BufferUndoListener.java" startline="1" endline="73">
package org.gjt.sp.jedit.buffer;

public interface BufferUndoListener {

    void beginUndo (JEditBuffer buffer);

    void endUndo (JEditBuffer buffer);

    void beginRedo (JEditBuffer buffer);

    void endRedo (JEditBuffer buffer);

}

</source>
<source file="systems/java/jEdit/trunk/org/gjt/sp/jedit/buffer/JEditBuffer.java" startline="1" endline="2790">
package org.gjt.sp.jedit.buffer;

import org.gjt.sp.jedit.Debug;

import org.gjt.sp.jedit.Mode;

import org.gjt.sp.jedit.TextUtilities;

import org.gjt.sp.jedit.indent.IndentAction;

import org.gjt.sp.jedit.indent.IndentRule;

import org.gjt.sp.jedit.syntax.*;

import org.gjt.sp.jedit.textarea.TextArea;

import org.gjt.sp.util.IntegerArray;

import org.gjt.sp.util.Log;

import org.gjt.sp.util.StandardUtilities;

import javax.swing.text.Position;

import javax.swing.text.Segment;

import java.awt.*;

import java.util.*;

import java.util.List;

import java.util.concurrent.locks.ReentrantReadWriteLock;

import java.util.regex.Pattern;

public class JEditBuffer {
    public static final String LINESEP = "lineSeparator";
    public static final String ENCODING = "encoding";

    public JEditBuffer (Map props) {
        bufferListeners = new Vector < Listener > ();
        lock = new ReentrantReadWriteLock ();
        contentMgr = new ContentManager ();
        lineMgr = new LineManager ();
        positionMgr = new PositionManager (this);
        undoMgr = new UndoManager (this);
        integerArray = new IntegerArray ();
        propertyLock = new Object ();
        properties = new HashMap < Object, PropValue > ();
        Set < Map.Entry > set = props.entrySet ();
        for (Map.Entry entry : set) {
            properties.put (entry.getKey (), new PropValue (entry.getValue (), false));
        }
        if (getProperty (ENCODING) == null) properties.put (ENCODING, new PropValue (System.getProperty ("file.encoding"), false));

        if (getProperty (LINESEP) == null) properties.put (LINESEP, new PropValue (System.getProperty ("line.separator"), false));

    }

    public JEditBuffer () {
        bufferListeners = new Vector < Listener > ();
        lock = new ReentrantReadWriteLock ();
        contentMgr = new ContentManager ();
        lineMgr = new LineManager ();
        positionMgr = new PositionManager (this);
        undoMgr = new UndoManager (this);
        integerArray = new IntegerArray ();
        propertyLock = new Object ();
        properties = new HashMap < Object, PropValue > ();
        properties.put ("wrap", new PropValue ("none", false));
        properties.put ("folding", new PropValue ("none", false));
        tokenMarker = new TokenMarker ();
        tokenMarker.addRuleSet (new ParserRuleSet ("text", "MAIN"));
        setTokenMarker (tokenMarker);
        loadText (null, null);
        if (getProperty (ENCODING) == null) properties.put (ENCODING, new PropValue (System.getProperty ("file.encoding"), false));

        if (getProperty (LINESEP) == null) properties.put (LINESEP, new PropValue (System.getProperty ("line.separator"), false));

        setFoldHandler (new DummyFoldHandler ());
    }

    public boolean isDirty () {
        return dirty;
    }

    public boolean isLoading () {
        return loading;
    }

    public void setLoading (boolean loading) {
        this.loading = loading;
    }

    public boolean isPerformingIO () {
        return isLoading () || io;
    }

    public void setPerformingIO (boolean io) {
        this.io = io;
    }

    public boolean isEditable () {
        return ! (isReadOnly () || isPerformingIO ());
    }

    public boolean isReadOnly () {
        return readOnly || readOnlyOverride;
    }

    public void setReadOnly (boolean readOnly) {
        readOnlyOverride = readOnly;
    }

    public void setDirty (boolean d) {
        boolean editable = isEditable ();
        if (d) {
            if (editable) dirty = true;

        } else {
            dirty = false;
            if (! isUndoInProgress ()) {
                undoMgr.resetClearDirty ();
            }
        }
    }

    public void readLock () {
        lock.readLock ().lock ();
    }

    public void readUnlock () {
        lock.readLock ().unlock ();
    }

    public void writeLock () {
        lock.writeLock ().lock ();
    }

    public void writeUnlock () {
        lock.writeLock ().unlock ();
    }

    public int getLength () {
        return contentMgr.getLength ();
    }

    public int getLineCount () {
        return lineMgr.getLineCount ();
    }

    public int getLineOfOffset (int offset) {
        try {
            readLock ();
            if (offset < 0 || offset > getLength ()) throw new ArrayIndexOutOfBoundsException (offset);

            return lineMgr.getLineOfOffset (offset);
        } finally {
            readUnlock ();
        }
    }

    public int getLineStartOffset (int line) {
        try {
            readLock ();
            if (line < 0 || line >= lineMgr.getLineCount ()) throw new ArrayIndexOutOfBoundsException (line);
            else if (line == 0) return 0;

            return lineMgr.getLineEndOffset (line - 1);
        } finally {
            readUnlock ();
        }
    }

    public int getLineEndOffset (int line) {
        try {
            readLock ();
            if (line < 0 || line >= lineMgr.getLineCount ()) throw new ArrayIndexOutOfBoundsException (line);

            return lineMgr.getLineEndOffset (line);
        } finally {
            readUnlock ();
        }
    }

    public int getLineLength (int line) {
        try {
            readLock ();
            return getLineEndOffset (line) - getLineStartOffset (line) - 1;
        } finally {
            readUnlock ();
        }
    }

    public int getPriorNonEmptyLine (int lineIndex) {
        int returnValue = - 1;
        if (! mode.getIgnoreWhitespace ()) {
            return lineIndex - 1;
        }
        for (int i = lineIndex - 1;
        i >= 0; i --) {
            Segment seg = new Segment ();
            getLineText (i, seg);
            if (seg.count != 0) returnValue = i;

            for (int j = 0;
            j < seg.count; j ++) {
                char ch = seg.array [seg.offset + j];
                if (! Character.isWhitespace (ch)) return i;

            }
        }
        return returnValue;
    }

    public String getLineText (int line) {
        if (line < 0 || line >= lineMgr.getLineCount ()) throw new ArrayIndexOutOfBoundsException (line);

        try {
            readLock ();
            int start = line == 0 ? 0 : lineMgr.getLineEndOffset (line - 1);
            int end = lineMgr.getLineEndOffset (line);
            return getText (start, end - start - 1);
        } finally {
            readUnlock ();
        }
    }

    public void getLineText (int line, Segment segment) {
        if (line < 0 || line >= lineMgr.getLineCount ()) throw new ArrayIndexOutOfBoundsException (line);

        try {
            readLock ();
            int start = line == 0 ? 0 : lineMgr.getLineEndOffset (line - 1);
            int end = lineMgr.getLineEndOffset (line);
            getText (start, end - start - 1, segment);
        } finally {
            readUnlock ();
        }
    }

    public CharSequence getLineSegment (int line) {
        if (line < 0 || line >= lineMgr.getLineCount ()) throw new ArrayIndexOutOfBoundsException (line);

        try {
            readLock ();
            int start = line == 0 ? 0 : lineMgr.getLineEndOffset (line - 1);
            int end = lineMgr.getLineEndOffset (line);
            return getSegment (start, end - start - 1);
        } finally {
            readUnlock ();
        }
    }

    public String getText (int start, int length) {
        try {
            readLock ();
            if (start < 0 || length < 0 || start + length > contentMgr.getLength ()) throw new ArrayIndexOutOfBoundsException (start + ":" + length);

            return contentMgr.getText (start, length);
        } finally {
            readUnlock ();
        }
    }

    public void getText (int start, int length, Segment seg) {
        try {
            readLock ();
            if (start < 0 || length < 0 || start + length > contentMgr.getLength ()) throw new ArrayIndexOutOfBoundsException (start + ":" + length);

            contentMgr.getText (start, length, seg);
        } finally {
            readUnlock ();
        }
    }

    public CharSequence getSegment (int start, int length) {
        try {
            readLock ();
            if (start < 0 || length < 0 || start + length > contentMgr.getLength ()) throw new ArrayIndexOutOfBoundsException (start + ":" + length);

            return contentMgr.getSegment (start, length);
        } finally {
            readUnlock ();
        }
    }

    public void insert (int offset, String str) {
        if (str == null) return;

        int len = str.length ();
        if (len == 0) return;

        if (isReadOnly ()) throw new RuntimeException ("buffer read-only");

        try {
            writeLock ();
            if (offset < 0 || offset > contentMgr.getLength ()) throw new ArrayIndexOutOfBoundsException (offset);

            contentMgr.insert (offset, str);
            integerArray.clear ();
            for (int i = 0;
            i < len; i ++) {
                if (str.charAt (i) == '\n') integerArray.add (i + 1);

            }
            if (! undoInProgress) {
                undoMgr.contentInserted (offset, len, str, ! dirty);
            }
            contentInserted (offset, len, integerArray);
        } finally {
            writeUnlock ();
        }
    }

    public void insert (int offset, Segment seg) {
        if (seg.count == 0) return;

        if (isReadOnly ()) throw new RuntimeException ("buffer read-only");

        try {
            writeLock ();
            if (offset < 0 || offset > contentMgr.getLength ()) throw new ArrayIndexOutOfBoundsException (offset);

            contentMgr.insert (offset, seg);
            integerArray.clear ();
            for (int i = 0;
            i < seg.count; i ++) {
                if (seg.array [seg.offset + i] == '\n') integerArray.add (i + 1);

            }
            if (! undoInProgress) {
                undoMgr.contentInserted (offset, seg.count, seg.toString (), ! dirty);
            }
            contentInserted (offset, seg.count, integerArray);
        } finally {
            writeUnlock ();
        }
    }

    public void remove (int offset, int length) {
        if (length == 0) return;

        if (isReadOnly ()) throw new RuntimeException ("buffer read-only");

        try {
            transaction = true;
            writeLock ();
            if (offset < 0 || length < 0 || offset + length > contentMgr.getLength ()) throw new ArrayIndexOutOfBoundsException (offset + ":" + length);

            int startLine = lineMgr.getLineOfOffset (offset);
            int endLine = lineMgr.getLineOfOffset (offset + length);
            int numLines = endLine - startLine;
            if (! undoInProgress && ! loading) {
                undoMgr.contentRemoved (offset, length, getText (offset, length), ! dirty);
            }
            firePreContentRemoved (startLine, offset, numLines, length);
            contentMgr.remove (offset, length);
            lineMgr.contentRemoved (startLine, offset, numLines, length);
            positionMgr.contentRemoved (offset, length);
            setDirty (true);
            fireContentRemoved (startLine, offset, numLines, length);
            if (! undoInProgress && ! insideCompoundEdit ()) fireTransactionComplete ();

        } finally {
            transaction = false;
            writeUnlock ();
        }
    }

    public void removeTrailingWhiteSpace (int [] lines) {
        try {
            beginCompoundEdit ();
            for (int i = 0;
            i < lines.length; i ++) {
                int pos, lineStart, lineEnd, tail;
                Segment seg = new Segment ();
                getLineText (lines [i], seg);
                if (seg.count == 0) continue;

                lineStart = seg.offset;
                lineEnd = seg.offset + seg.count - 1;
                for (pos = lineEnd; pos >= lineStart; pos --) {
                    if (! Character.isWhitespace (seg.array [pos])) break;

                }
                tail = lineEnd - pos;
                if (tail == 0) continue;

                remove (getLineEndOffset (lines [i]) - 1 - tail, tail);
            }
        } finally {
            endCompoundEdit ();
        }
    }

    public void shiftIndentLeft (int [] lines) {
        int tabSize = getTabSize ();
        int indentSize = getIndentSize ();
        boolean noTabs = getBooleanProperty ("noTabs");
        try {
            beginCompoundEdit ();
            for (int i = 0;
            i < lines.length; i ++) {
                int lineStart = getLineStartOffset (lines [i]);
                CharSequence line = getLineSegment (lines [i]);
                int whiteSpace = StandardUtilities.getLeadingWhiteSpace (line);
                if (whiteSpace == 0) continue;

                int whiteSpaceWidth = Math.max (0, StandardUtilities.getLeadingWhiteSpaceWidth (line, tabSize) - indentSize);
                insert (lineStart + whiteSpace, StandardUtilities.createWhiteSpace (whiteSpaceWidth, noTabs ? 0 : tabSize));
                remove (lineStart, whiteSpace);
            }
        } finally {
            endCompoundEdit ();
        }
    }

    public void shiftIndentRight (int [] lines) {
        try {
            beginCompoundEdit ();
            int tabSize = getTabSize ();
            int indentSize = getIndentSize ();
            boolean noTabs = getBooleanProperty ("noTabs");
            for (int i = 0;
            i < lines.length; i ++) {
                int lineStart = getLineStartOffset (lines [i]);
                CharSequence line = getLineSegment (lines [i]);
                int whiteSpace = StandardUtilities.getLeadingWhiteSpace (line);
                int whiteSpaceWidth = StandardUtilities.getLeadingWhiteSpaceWidth (line, tabSize) + indentSize;
                insert (lineStart + whiteSpace, StandardUtilities.createWhiteSpace (whiteSpaceWidth, noTabs ? 0 : tabSize));
                remove (lineStart, whiteSpace);
            }
        } finally {
            endCompoundEdit ();
        }
    }

    public void indentLines (int start, int end) {
        try {
            beginCompoundEdit ();
            for (int i = start;
            i <= end; i ++) indentLine (i, true);

        } finally {
            endCompoundEdit ();
        }
    }

    public void indentLines (int [] lines) {
        try {
            beginCompoundEdit ();
            for (int i = 0;
            i < lines.length; i ++) indentLine (lines [i], true);

        } finally {
            endCompoundEdit ();
        }
    }

    @Deprecated
    public boolean indentLine (int lineIndex, boolean canIncreaseIndent, boolean canDecreaseIndent) {
        return indentLine (lineIndex, canDecreaseIndent);
    }

    public boolean indentLine (int lineIndex, boolean canDecreaseIndent) {
        int [] whitespaceChars = new int [1];
        int currentIndent = getCurrentIndentForLine (lineIndex, whitespaceChars);
        int prevLineIndex = getPriorNonEmptyLine (lineIndex);
        int prevLineIndent = (prevLineIndex == - 1) ? 0 : StandardUtilities.getLeadingWhiteSpaceWidth (getLineSegment (prevLineIndex), getTabSize ());
        int idealIndent = getIdealIndentForLine (lineIndex, prevLineIndex, prevLineIndent);
        if (idealIndent == - 1 || idealIndent == currentIndent || (! canDecreaseIndent && idealIndent < currentIndent)) return false;

        try {
            beginCompoundEdit ();
            int start = getLineStartOffset (lineIndex);
            remove (start, whitespaceChars [0]);
            String prevIndentString = (prevLineIndex >= 0) ? StandardUtilities.getIndentString (getLineText (prevLineIndex)) : null;
            String indentString;
            if (prevIndentString == null) {
                indentString = StandardUtilities.createWhiteSpace (idealIndent, getBooleanProperty ("noTabs") ? 0 : getTabSize ());
            } else if (idealIndent == prevLineIndent) indentString = prevIndentString;
            else if (idealIndent < prevLineIndent) indentString = StandardUtilities.truncateWhiteSpace (idealIndent, getTabSize (), prevIndentString);
            else indentString = prevIndentString + StandardUtilities.createWhiteSpace (idealIndent - prevLineIndent, getBooleanProperty ("noTabs") ? 0 : getTabSize (), prevLineIndent);

            insert (start, indentString);
        } finally {
            endCompoundEdit ();
        }
        return true;
    }

    public int getCurrentIndentForLine (int lineIndex, int [] whitespaceChars) {
        Segment seg = new Segment ();
        getLineText (lineIndex, seg);
        int tabSize = getTabSize ();
        int currentIndent = 0;
        loop : for (int i = 0;
        i < seg.count; i ++) {
            char c = seg.array [seg.offset + i];
            switch (c) {
                case ' ' :
                    currentIndent ++;
                    if (whitespaceChars != null) whitespaceChars [0] ++;

                    break;
                case '\t' :
                    currentIndent += tabSize - (currentIndent % tabSize);
                    if (whitespaceChars != null) whitespaceChars [0] ++;

                    break;
                default :
                    break loop;
            }
        }
        return currentIndent;
    }

    public int getIdealIndentForLine (int lineIndex) {
        int prevLineIndex = getPriorNonEmptyLine (lineIndex);
        int oldIndent = prevLineIndex == - 1 ? 0 : StandardUtilities.getLeadingWhiteSpaceWidth (getLineSegment (prevLineIndex), getTabSize ());
        return getIdealIndentForLine (lineIndex, prevLineIndex, oldIndent);
    }

    private int getIdealIndentForLine (int lineIndex, int prevLineIndex, int oldIndent) {
        int prevPrevLineIndex = prevLineIndex < 0 ? - 1 : getPriorNonEmptyLine (prevLineIndex);
        int newIndent = oldIndent;
        List < IndentRule > indentRules = getIndentRules (lineIndex);
        List < IndentAction > actions = new LinkedList < IndentAction > ();
        for (int i = 0;
        i < indentRules.size (); i ++) {
            IndentRule rule = indentRules.get (i);
            rule.apply (this, lineIndex, prevLineIndex, prevPrevLineIndex, actions);
        }
        for (IndentAction action : actions) {
            newIndent = action.calculateIndent (this, lineIndex, oldIndent, newIndent);
            if (! action.keepChecking ()) break;

        }
        if (newIndent < 0) newIndent = 0;

        return newIndent;
    }

    public int getVirtualWidth (int line, int column) {
        try {
            readLock ();
            int start = getLineStartOffset (line);
            Segment seg = new Segment ();
            getText (start, column, seg);
            return StandardUtilities.getVirtualWidth (seg, getTabSize ());
        } finally {
            readUnlock ();
        }
    }

    public int getOffsetOfVirtualColumn (int line, int column, int [] totalVirtualWidth) {
        try {
            readLock ();
            Segment seg = new Segment ();
            getLineText (line, seg);
            return StandardUtilities.getOffsetOfVirtualColumn (seg, getTabSize (), column, totalVirtualWidth);
        } finally {
            readUnlock ();
        }
    }

    public void insertAtColumn (int line, int col, String str) {
        try {
            writeLock ();
            int [] total = new int [1];
            int offset = getOffsetOfVirtualColumn (line, col, total);
            if (offset == - 1) {
                offset = getLineEndOffset (line) - 1;
                str = StandardUtilities.createWhiteSpace (col - total [0], 0) + str;
            } else offset += getLineStartOffset (line);

            insert (offset, str);
        } finally {
            writeUnlock ();
        }
    }

    public int insertIndented (int offset, String text) {
        try {
            beginCompoundEdit ();
            int firstLine = getLineOfOffset (offset);
            CharSequence lineText = getLineSegment (firstLine);
            int leadingIndent = StandardUtilities.getLeadingWhiteSpaceWidth (lineText, getTabSize ());
            String whiteSpace = StandardUtilities.createWhiteSpace (leadingIndent, getBooleanProperty ("noTabs") ? 0 : getTabSize ());
            insert (offset, text);
            int lastLine = getLineOfOffset (offset + text.length ());
            for (int i = firstLine + 1;
            i <= lastLine; i ++) {
                insert (getLineStartOffset (i), whiteSpace);
            }
            return whiteSpace.length ();
        } finally {
            endCompoundEdit ();
        }
    }

    @Deprecated
    public boolean isElectricKey (char ch) {
        return mode.isElectricKey (ch);
    }

    public boolean isElectricKey (char ch, int line) {
        TokenMarker.LineContext ctx = lineMgr.getLineContext (line);
        Mode mode = ModeProvider.instance.getMode (ctx.rules.getModeName ());
        if (mode == null) return false;

        return mode.isElectricKey (ch);
    }

    public void markTokens (int lineIndex, TokenHandler tokenHandler) {
        Segment seg = new Segment ();
        if (lineIndex < 0 || lineIndex >= lineMgr.getLineCount ()) throw new ArrayIndexOutOfBoundsException (lineIndex);

        int firstInvalidLineContext = lineMgr.getFirstInvalidLineContext ();
        int start;
        if (textMode || firstInvalidLineContext == - 1) {
            start = lineIndex;
        } else {
            start = Math.min (firstInvalidLineContext, lineIndex);
        }
        if (Debug.TOKEN_MARKER_DEBUG) Log.log (Log.DEBUG, this, "tokenize from " + start + " to " + lineIndex);

        TokenMarker.LineContext oldContext = null;
        TokenMarker.LineContext context = null;
        for (int i = start;
        i <= lineIndex; i ++) {
            getLineText (i, seg);
            oldContext = lineMgr.getLineContext (i);
            TokenMarker.LineContext prevContext = ((i == 0 || textMode) ? null : lineMgr.getLineContext (i - 1));
            context = tokenMarker.markTokens (prevContext, (i == lineIndex ? tokenHandler : DummyTokenHandler.INSTANCE), seg);
            lineMgr.setLineContext (i, context);
        }
        int lineCount = lineMgr.getLineCount ();
        if (lineCount - 1 == lineIndex) lineMgr.setFirstInvalidLineContext (- 1);
        else if (oldContext != context) lineMgr.setFirstInvalidLineContext (lineIndex + 1);
        else if (firstInvalidLineContext == - 1);
        else {
            lineMgr.setFirstInvalidLineContext (Math.max (firstInvalidLineContext, lineIndex + 1));
        }

    }

    public TokenMarker getTokenMarker () {
        return tokenMarker;
    }

    public void setTokenMarker (TokenMarker tokenMarker) {
        TokenMarker oldTokenMarker = this.tokenMarker;
        this.tokenMarker = tokenMarker;
        if (oldTokenMarker != null && tokenMarker != oldTokenMarker) {
            lineMgr.setFirstInvalidLineContext (0);
        }
    }

    public Position createPosition (int offset) {
        try {
            readLock ();
            if (offset < 0 || offset > contentMgr.getLength ()) throw new ArrayIndexOutOfBoundsException (offset);

            return positionMgr.createPosition (offset);
        } finally {
            readUnlock ();
        }
    }

    public void propertiesChanged () {
        String folding = getStringProperty ("folding");
        FoldHandler handler = FoldHandler.getFoldHandler (folding);
        if (handler != null) {
            setFoldHandler (handler);
        } else {
            if (folding != null) Log.log (Log.WARNING, this, "invalid 'folding' property: " + folding);

            setFoldHandler (new DummyFoldHandler ());
        }
    }

    public int getTabSize () {
        int tabSize = getIntegerProperty ("tabSize", 8);
        if (tabSize <= 0) return 8;
        else return tabSize;

    }

    public int getIndentSize () {
        int indentSize = getIntegerProperty ("indentSize", 8);
        if (indentSize <= 0) return 8;
        else return indentSize;

    }

    public Object getProperty (Object name) {
        synchronized (propertyLock) {
            PropValue o = properties.get (name);
            if (o != null) return o.value;

            if (! (name instanceof String)) return null;

            Object retVal = getDefaultProperty ((String) name);
            if (retVal == null) return null;
            else {
                properties.put (name, new PropValue (retVal, true));
                return retVal;
            }
        }
    }

    public Object getDefaultProperty (String key) {
        return null;
    }

    public void setProperty (String name, Object value) {
        if (value == null) properties.remove (name);
        else {
            PropValue test = properties.get (name);
            if (test == null) properties.put (name, new PropValue (value, false));
            else if (test.value.equals (value)) {
            } else {
                test.value = value;
                test.defaultValue = false;
            }

        }
    }

    public void setDefaultProperty (String name, Object value) {
        properties.put (name, new PropValue (value, true));
    }

    public void unsetProperty (String name) {
        properties.remove (name);
    }

    public void resetCachedProperties () {
        Iterator < PropValue > iter = properties.values ().iterator ();
        while (iter.hasNext ()) {
            PropValue value = iter.next ();
            if (value.defaultValue) iter.remove ();

        }
    }

    public String getStringProperty (String name) {
        Object obj = getProperty (name);
        if (obj != null) return obj.toString ();
        else return null;

    }

    public void setStringProperty (String name, String value) {
        setProperty (name, value);
    }

    public boolean getBooleanProperty (String name) {
        return getBooleanProperty (name, false);
    }

    public boolean getBooleanProperty (String name, boolean def) {
        Object obj = getProperty (name);
        return StandardUtilities.getBoolean (obj, def);
    }

    public void setBooleanProperty (String name, boolean value) {
        setProperty (name, value ? Boolean.TRUE : Boolean.FALSE);
    }

    public int getIntegerProperty (String name, int defaultValue) {
        boolean defaultValueFlag;
        Object obj;
        PropValue value = properties.get (name);
        if (value != null) {
            obj = value.value;
            defaultValueFlag = value.defaultValue;
        } else {
            obj = getProperty (name);
            defaultValueFlag = true;
        }
        if (obj == null) return defaultValue;
        else if (obj instanceof Number) return ((Number) obj).intValue ();
        else {
            try {
                int returnValue = Integer.parseInt (obj.toString ().trim ());
                properties.put (name, new PropValue (returnValue, defaultValueFlag));
                return returnValue;
            } catch (Exception e) {
                return defaultValue;
            }
        }

    }

    public void setIntegerProperty (String name, int value) {
        setProperty (name, value);
    }

    public Pattern getPatternProperty (String name, int flags) {
        synchronized (propertyLock) {
            boolean defaultValueFlag;
            Object obj;
            PropValue value = properties.get (name);
            if (value != null) {
                obj = value.value;
                defaultValueFlag = value.defaultValue;
            } else {
                obj = getProperty (name);
                defaultValueFlag = true;
            }
            if (obj == null) return null;
            else if (obj instanceof Pattern) return (Pattern) obj;
            else {
                Pattern re = Pattern.compile (obj.toString (), flags);
                properties.put (name, new PropValue (re, defaultValueFlag));
                return re;
            }

        }
    }

    public ParserRuleSet getRuleSetAtOffset (int offset) {
        int line = getLineOfOffset (offset);
        offset -= getLineStartOffset (line);
        if (offset != 0) offset --;

        DefaultTokenHandler tokens = new DefaultTokenHandler ();
        markTokens (line, tokens);
        Token token = TextUtilities.getTokenAtOffset (tokens.getTokens (), offset);
        return token.rules;
    }

    public KeywordMap getKeywordMapAtOffset (int offset) {
        return getRuleSetAtOffset (offset).getKeywords ();
    }

    public String getContextSensitiveProperty (int offset, String name) {
        ParserRuleSet rules = getRuleSetAtOffset (offset);
        Object value = null;
        Map < String, String > rulesetProps = rules.getProperties ();
        if (rulesetProps != null) value = rulesetProps.get (name);

        if (value == null) return null;
        else return String.valueOf (value);

    }

    public Mode getMode () {
        return mode;
    }

    public void setMode (String mode) {
        setMode (ModeProvider.instance.getMode (mode));
    }

    public void setMode (Mode mode) {
        if (mode == null) throw new NullPointerException ("Mode must be non-null");

        this.mode = mode;
        textMode = "text".equals (mode.getName ());
        setTokenMarker (mode.getTokenMarker ());
        resetCachedProperties ();
        propertiesChanged ();
    }

    public boolean isFoldStart (int line) {
        return line != getLineCount () - 1 && getFoldLevel (line) < getFoldLevel (line + 1);
    }

    public boolean isFoldEnd (int line) {
        return line != getLineCount () - 1 && getFoldLevel (line) > getFoldLevel (line + 1);
    }

    public void invalidateCachedFoldLevels () {
        lineMgr.setFirstInvalidFoldLevel (0);
        fireFoldLevelChanged (0, getLineCount ());
    }

    public int getFoldLevel (int line) {
        if (line < 0 || line >= lineMgr.getLineCount ()) throw new ArrayIndexOutOfBoundsException (line);

        if (foldHandler instanceof DummyFoldHandler) return 0;

        int firstInvalidFoldLevel = lineMgr.getFirstInvalidFoldLevel ();
        if (firstInvalidFoldLevel == - 1 || line < firstInvalidFoldLevel) {
            return lineMgr.getFoldLevel (line);
        } else {
            if (Debug.FOLD_DEBUG) Log.log (Log.DEBUG, this, "Invalid fold levels from " + firstInvalidFoldLevel + " to " + line);

            int newFoldLevel = 0;
            boolean changed = false;
            int firstUpdatedFoldLevel = firstInvalidFoldLevel;
            for (int i = firstInvalidFoldLevel;
            i <= line; i ++) {
                Segment seg = new Segment ();
                newFoldLevel = foldHandler.getFoldLevel (this, i, seg);
                if (newFoldLevel != lineMgr.getFoldLevel (i)) {
                    if (Debug.FOLD_DEBUG) Log.log (Log.DEBUG, this, i + " fold level changed");

                    changed = true;
                    if (i == firstInvalidFoldLevel) {
                        List < Integer > precedingFoldLevels = foldHandler.getPrecedingFoldLevels (this, i, seg, newFoldLevel);
                        if (precedingFoldLevels != null) {
                            int j = i;
                            for (Integer foldLevel : precedingFoldLevels) {
                                j --;
                                lineMgr.setFoldLevel (j, foldLevel.intValue ());
                            }
                            if (j < firstUpdatedFoldLevel) firstUpdatedFoldLevel = j;

                        }
                    }
                }
                lineMgr.setFoldLevel (i, newFoldLevel);
            }
            if (line == lineMgr.getLineCount () - 1) lineMgr.setFirstInvalidFoldLevel (- 1);
            else lineMgr.setFirstInvalidFoldLevel (line + 1);

            if (changed) {
                if (Debug.FOLD_DEBUG) Log.log (Log.DEBUG, this, "fold level changed: " + firstUpdatedFoldLevel + ',' + line);

                fireFoldLevelChanged (firstUpdatedFoldLevel, line);
            }
            return newFoldLevel;
        }
    }

    public int [] getFoldAtLine (int line) {
        int start, end;
        if (isFoldStart (line)) {
            start = line;
            int foldLevel = getFoldLevel (line);
            line ++;
            while (getFoldLevel (line) > foldLevel) {
                line ++;
                if (line == getLineCount ()) break;

            }
            end = line - 1;
        } else {
            start = line;
            int foldLevel = getFoldLevel (line);
            while (getFoldLevel (start) >= foldLevel) {
                if (start == 0) break;
                else start --;

            }
            end = line;
            while (getFoldLevel (end) >= foldLevel) {
                end ++;
                if (end == getLineCount ()) break;

            }
            end --;
        }
        while (getLineLength (end) == 0 && end > start) end --;

        return new int [] {start, end};
    }

    public FoldHandler getFoldHandler () {
        return foldHandler;
    }

    public void setFoldHandler (FoldHandler foldHandler) {
        FoldHandler oldFoldHandler = this.foldHandler;
        if (foldHandler.equals (oldFoldHandler)) return;

        this.foldHandler = foldHandler;
        lineMgr.setFirstInvalidFoldLevel (0);
        fireFoldHandlerChanged ();
    }

    public void undo (TextArea textArea) {
        if (undoMgr == null) return;

        if (! isEditable ()) {
            textArea.getToolkit ().beep ();
            return;
        }
        try {
            writeLock ();
            undoInProgress = true;
            fireBeginUndo ();
            int caret = undoMgr.undo ();
            if (caret == - 1) textArea.getToolkit ().beep ();
            else textArea.setCaretPosition (caret);

            fireEndUndo ();
            fireTransactionComplete ();
        } finally {
            undoInProgress = false;
            writeUnlock ();
        }
    }

    public void redo (TextArea textArea) {
        if (undoMgr == null) return;

        if (! isEditable ()) {
            Toolkit.getDefaultToolkit ().beep ();
            return;
        }
        try {
            writeLock ();
            undoInProgress = true;
            fireBeginRedo ();
            int caret = undoMgr.redo ();
            if (caret == - 1) textArea.getToolkit ().beep ();
            else textArea.setCaretPosition (caret);

            fireEndRedo ();
            fireTransactionComplete ();
        } finally {
            undoInProgress = false;
            writeUnlock ();
        }
    }

    public boolean isTransactionInProgress () {
        return transaction || undoInProgress || insideCompoundEdit ();
    }

    public void beginCompoundEdit () {
        try {
            writeLock ();
            undoMgr.beginCompoundEdit ();
        } finally {
            writeUnlock ();
        }
    }

    public void endCompoundEdit () {
        try {
            writeLock ();
            undoMgr.endCompoundEdit ();
            if (! insideCompoundEdit ()) fireTransactionComplete ();

        } finally {
            writeUnlock ();
        }
    }

    public boolean insideCompoundEdit () {
        return undoMgr.insideCompoundEdit ();
    }

    public boolean isUndoInProgress () {
        return undoInProgress;
    }

    public Object getUndoId () {
        return undoMgr.getUndoId ();
    }

    public static final int NORMAL_PRIORITY = 0;
    public static final int HIGH_PRIORITY = 1;
    static class Listener {
        BufferListener listener;
        int priority;

        Listener (BufferListener listener, int priority) {
            this.listener = listener;
            this.priority = priority;
        }

    }

    public void addBufferListener (BufferListener listener, int priority) {
        Listener l = new Listener (listener, priority);
        for (int i = 0;
        i < bufferListeners.size (); i ++) {
            Listener _l = bufferListeners.get (i);
            if (_l.priority < priority) {
                bufferListeners.add (i, l);
                return;
            }
        }
        bufferListeners.add (l);
    }

    public void addBufferListener (BufferListener listener) {
        addBufferListener (listener, NORMAL_PRIORITY);
    }

    public void removeBufferListener (BufferListener listener) {
        for (int i = 0;
        i < bufferListeners.size (); i ++) {
            if (bufferListeners.get (i).listener == listener) {
                bufferListeners.remove (i);
                return;
            }
        }
    }

    public BufferListener [] getBufferListeners () {
        BufferListener [] returnValue = new BufferListener [bufferListeners.size ()];
        for (int i = 0;
        i < returnValue.length; i ++) {
            returnValue [i] = bufferListeners.get (i).listener;
        }
        return returnValue;
    }

    public void setUndoLimit (int limit) {
        if (undoMgr != null) undoMgr.setLimit (limit);

    }

    public boolean canUndo () {
        if (undoMgr == null) return false;

        return undoMgr.canUndo ();
    }

    public boolean canRedo () {
        if (undoMgr == null) return false;

        return undoMgr.canRedo ();
    }

    protected Mode mode;
    protected boolean textMode;
    protected UndoManager undoMgr;

    protected void fireFoldLevelChanged (int start, int end) {
        for (int i = 0;
        i < bufferListeners.size (); i ++) {
            BufferListener listener = getListener (i);
            try {
                listener.foldLevelChanged (this, start, end);
            } catch (Throwable t) {
                Log.log (Log.ERROR, this, "Exception while sending buffer event to " + listener + " :");
                Log.log (Log.ERROR, this, t);
            }
        }
    }

    protected void fireContentInserted (int startLine, int offset, int numLines, int length) {
        for (int i = 0;
        i < bufferListeners.size (); i ++) {
            BufferListener listener = getListener (i);
            try {
                listener.contentInserted (this, startLine, offset, numLines, length);
            } catch (Throwable t) {
                Log.log (Log.ERROR, this, "Exception while sending buffer event to " + listener + " :");
                Log.log (Log.ERROR, this, t);
            }
        }
    }

    protected void fireContentRemoved (int startLine, int offset, int numLines, int length) {
        for (int i = 0;
        i < bufferListeners.size (); i ++) {
            BufferListener listener = getListener (i);
            try {
                listener.contentRemoved (this, startLine, offset, numLines, length);
            } catch (Throwable t) {
                Log.log (Log.ERROR, this, "Exception while sending buffer event to " + listener + " :");
                Log.log (Log.ERROR, this, t);
            }
        }
    }

    protected void firePreContentInserted (int startLine, int offset, int numLines, int length) {
        for (int i = 0;
        i < bufferListeners.size (); i ++) {
            BufferListener listener = getListener (i);
            try {
                listener.preContentInserted (this, startLine, offset, numLines, length);
            } catch (Throwable t) {
                Log.log (Log.ERROR, this, "Exception while sending buffer event to " + listener + " :");
                Log.log (Log.ERROR, this, t);
            }
        }
    }

    protected void firePreContentRemoved (int startLine, int offset, int numLines, int length) {
        for (int i = 0;
        i < bufferListeners.size (); i ++) {
            BufferListener listener = getListener (i);
            try {
                listener.preContentRemoved (this, startLine, offset, numLines, length);
            } catch (Throwable t) {
                Log.log (Log.ERROR, this, "Exception while sending buffer event to " + listener + " :");
                Log.log (Log.ERROR, this, t);
            }
        }
    }

    protected void fireBeginUndo () {
    }

    protected void fireEndUndo () {
    }

    protected void fireBeginRedo () {
    }

    protected void fireEndRedo () {
    }

    protected void fireTransactionComplete () {
        for (int i = 0;
        i < bufferListeners.size (); i ++) {
            BufferListener listener = getListener (i);
            try {
                listener.transactionComplete (this);
            } catch (Throwable t) {
                Log.log (Log.ERROR, this, "Exception while sending buffer event to " + listener + " :");
                Log.log (Log.ERROR, this, t);
            }
        }
    }

    protected void fireFoldHandlerChanged () {
        for (int i = 0;
        i < bufferListeners.size (); i ++) {
            BufferListener listener = getListener (i);
            try {
                listener.foldHandlerChanged (this);
            } catch (Throwable t) {
                Log.log (Log.ERROR, this, "Exception while sending buffer event to " + listener + " :");
                Log.log (Log.ERROR, this, t);
            }
        }
    }

    protected void fireBufferLoaded () {
        for (int i = 0;
        i < bufferListeners.size (); i ++) {
            BufferListener listener = getListener (i);
            try {
                listener.bufferLoaded (this);
            } catch (Throwable t) {
                Log.log (Log.ERROR, this, "Exception while sending buffer event to " + listener + " :");
                Log.log (Log.ERROR, this, t);
            }
        }
    }

    protected boolean isFileReadOnly () {
        return readOnly;
    }

    protected void setFileReadOnly (boolean readOnly) {
        this.readOnly = readOnly;
    }

    protected void loadText (Segment seg, IntegerArray endOffsets) {
        if (seg == null) seg = new Segment (new char [1024], 0, 0);

        if (endOffsets == null) {
            endOffsets = new IntegerArray ();
            endOffsets.add (1);
        }
        try {
            writeLock ();
            int length = getLength ();
            firePreContentRemoved (0, 0, getLineCount () - 1, length);
            contentMgr.remove (0, length);
            lineMgr.contentRemoved (0, 0, getLineCount () - 1, length);
            positionMgr.contentRemoved (0, length);
            fireContentRemoved (0, 0, getLineCount () - 1, length);
            firePreContentInserted (0, 0, endOffsets.getSize () - 1, seg.count - 1);
            contentMgr._setContent (seg.array, seg.count);
            lineMgr._contentInserted (endOffsets);
            positionMgr.contentInserted (0, seg.count);
            fireContentInserted (0, 0, endOffsets.getSize () - 1, seg.count - 1);
        } finally {
            writeUnlock ();
        }
    }

    protected void invalidateFoldLevels () {
        lineMgr.setFirstInvalidFoldLevel (0);
    }

    protected void parseBufferLocalProperties () {
        int maxRead = 10000;
        int lineCount = getLineCount ();
        int lastLine = Math.min (9, lineCount - 1);
        int max = Math.min (maxRead, getLineEndOffset (lastLine) - 1);
        parseBufferLocalProperties (getSegment (0, max));
        int firstLine = Math.max (lastLine + 1, lineCount - 10);
        if (firstLine < lineCount) {
            int firstLineStartOffset = getLineStartOffset (firstLine);
            int length = getLineEndOffset (lineCount - 1) - (firstLineStartOffset + 1);
            if (length > maxRead) {
                firstLineStartOffset += length - maxRead;
                length = maxRead;
            }
            parseBufferLocalProperties (getSegment (firstLineStartOffset, length));
        }
    }

    protected static class PropValue {

        PropValue (Object value, boolean defaultValue) {
            if (value == null) throw new NullPointerException ();

            this.value = value;
            this.defaultValue = defaultValue;
        }

        Object value;
        boolean defaultValue;

        public String toString () {
            return value.toString ();
        }

    }

    private List < Listener > bufferListeners;
    private final ReentrantReadWriteLock lock;
    private ContentManager contentMgr;
    private LineManager lineMgr;
    private PositionManager positionMgr;
    private FoldHandler foldHandler;
    private IntegerArray integerArray;
    private TokenMarker tokenMarker;
    private boolean undoInProgress;
    private boolean dirty;
    private boolean readOnly;
    private boolean readOnlyOverride;
    private boolean transaction;
    private boolean loading;
    private boolean io;
    private final Map < Object, PropValue > properties;
    private final Object propertyLock;

    private BufferListener getListener (int index) {
        return bufferListeners.get (index).listener;
    }

    private void contentInserted (int offset, int length, IntegerArray endOffsets) {
        try {
            transaction = true;
            int startLine = lineMgr.getLineOfOffset (offset);
            int numLines = endOffsets.getSize ();
            if (! loading) {
                firePreContentInserted (startLine, offset, numLines, length);
            }
            lineMgr.contentInserted (startLine, offset, numLines, length, endOffsets);
            positionMgr.contentInserted (offset, length);
            setDirty (true);
            if (! loading) {
                fireContentInserted (startLine, offset, numLines, length);
                if (! undoInProgress && ! insideCompoundEdit ()) fireTransactionComplete ();

            }
        } finally {
            transaction = false;
        }
    }

    private void parseBufferLocalProperties (CharSequence prop) {
        StringBuilder buf = new StringBuilder ();
        String name = null;
        boolean escape = false;
        int length = prop.length ();
        for (int i = 0;
        i < length; i ++) {
            char c = prop.charAt (i);
            switch (c) {
                case ':' :
                    if (escape) {
                        escape = false;
                        buf.append (':');
                        break;
                    }
                    if (name != null) {
                        properties.put (name, new PropValue (buf.toString (), false));
                        name = null;
                    }
                    buf.setLength (0);
                    break;
                case '=' :
                    if (escape) {
                        escape = false;
                        buf.append ('=');
                        break;
                    }
                    name = buf.toString ();
                    buf.setLength (0);
                    break;
                case '\\' :
                    if (escape) buf.append ('\\');

                    escape = ! escape;
                    break;
                case 'n' :
                    if (escape) {
                        buf.append ('\n');
                        escape = false;
                        break;
                    }
                case 'r' :
                    if (escape) {
                        buf.append ('\r');
                        escape = false;
                        break;
                    }
                case 't' :
                    if (escape) {
                        buf.append ('\t');
                        escape = false;
                        break;
                    }
                default :
                    buf.append (c);
                    break;
            }
        }
    }

    private List < IndentRule > getIndentRules (int line) {
        String modeName = null;
        TokenMarker.LineContext ctx = lineMgr.getLineContext (line);
        if (ctx != null && ctx.rules != null) modeName = ctx.rules.getModeName ();

        if (modeName == null) modeName = tokenMarker.getMainRuleSet ().getModeName ();

        return ModeProvider.instance.getMode (modeName).getIndentRules ();
    }

}

</source>
<source file="systems/java/jEdit/trunk/org/gjt/sp/jedit/buffer/UndoManager.java" startline="1" endline="503">
package org.gjt.sp.jedit.buffer;

import org.gjt.sp.util.Log;

public class UndoManager {

    public UndoManager (JEditBuffer buffer) {
        this.buffer = buffer;
    }

    public void setLimit (int limit) {
        this.limit = limit;
    }

    public void clear () {
        undosFirst = undosLast = redosFirst = null;
        undoCount = 0;
    }

    public boolean canUndo () {
        return (undosLast != null);
    }

    public int undo () {
        if (insideCompoundEdit ()) throw new InternalError ("Unbalanced begin/endCompoundEdit()");

        if (undosLast == null) return - 1;
        else {
            reviseUndoId ();
            undoCount --;
            int caret = undosLast.undo ();
            redosFirst = undosLast;
            undosLast = undosLast.prev;
            if (undosLast == null) undosFirst = null;

            return caret;
        }
    }

    public boolean canRedo () {
        return (redosFirst != null);
    }

    public int redo () {
        if (insideCompoundEdit ()) throw new InternalError ("Unbalanced begin/endCompoundEdit()");

        if (redosFirst == null) return - 1;
        else {
            reviseUndoId ();
            undoCount ++;
            int caret = redosFirst.redo ();
            undosLast = redosFirst;
            if (undosFirst == null) undosFirst = undosLast;

            redosFirst = redosFirst.next;
            return caret;
        }
    }

    public void beginCompoundEdit () {
        if (compoundEditCount == 0) {
            compoundEdit = new CompoundEdit ();
            reviseUndoId ();
        }
        compoundEditCount ++;
    }

    public void endCompoundEdit () {
        if (compoundEditCount == 0) {
            Log.log (Log.WARNING, this, new Exception ("Unbalanced begin/endCompoundEdit()"));
            return;
        } else if (compoundEditCount == 1) {
            if (compoundEdit.first == null);
            else if (compoundEdit.first == compoundEdit.last) addEdit (compoundEdit.first);
            else addEdit (compoundEdit);

            compoundEdit = null;
        }

        compoundEditCount --;
    }

    public boolean insideCompoundEdit () {
        return compoundEditCount != 0;
    }

    public Object getUndoId () {
        return undoId;
    }

    public void contentInserted (int offset, int length, String text, boolean clearDirty) {
        Edit last = getLastEdit ();
        Edit toMerge = getMergeEdit ();
        if (! clearDirty && toMerge instanceof Insert && redosFirst == null) {
            Insert ins = (Insert) toMerge;
            if (ins.offset == offset) {
                ins.str = text.concat (ins.str);
                ins.length += length;
                return;
            } else if (ins.offset + ins.length == offset) {
                ins.str = ins.str.concat (text);
                ins.length += length;
                return;
            }

        }
        Insert ins = new Insert (this, offset, length, text);
        if (clearDirty) {
            redoClearDirty = last;
            undoClearDirty = ins;
        }
        if (compoundEdit != null) compoundEdit.add (ins);
        else {
            reviseUndoId ();
            addEdit (ins);
        }
    }

    public void contentRemoved (int offset, int length, String text, boolean clearDirty) {
        Edit last = getLastEdit ();
        Edit toMerge = getMergeEdit ();
        if (! clearDirty && toMerge instanceof Remove && redosFirst == null) {
            Remove rem = (Remove) toMerge;
            if (rem.offset == offset) {
                rem.content.str = rem.content.str.concat (text);
                rem.content.hashcode = rem.content.str.hashCode ();
                rem.length += length;
                KillRing.getInstance ().changed (rem.content);
                return;
            } else if (offset + length == rem.offset) {
                rem.content.str = text.concat (rem.content.str);
                rem.content.hashcode = rem.content.str.hashCode ();
                rem.length += length;
                rem.offset = offset;
                KillRing.getInstance ().changed (rem.content);
                return;
            }

        }
        Remove rem = new Remove (this, offset, length, text);
        if (clearDirty) {
            redoClearDirty = last;
            undoClearDirty = rem;
        }
        if (compoundEdit != null) compoundEdit.add (rem);
        else {
            reviseUndoId ();
            addEdit (rem);
        }
        KillRing.getInstance ().add (rem.content);
    }

    public void resetClearDirty () {
        redoClearDirty = getLastEdit ();
        if (redosFirst instanceof CompoundEdit) undoClearDirty = ((CompoundEdit) redosFirst).first;
        else undoClearDirty = redosFirst;

    }

    private JEditBuffer buffer;
    private Edit undosFirst;
    private Edit undosLast;
    private Edit redosFirst;
    private int limit;
    private int undoCount;
    private int compoundEditCount;
    private CompoundEdit compoundEdit;
    private Edit undoClearDirty, redoClearDirty;
    private Object undoId;

    private void addEdit (Edit edit) {
        if (undosFirst == null) undosFirst = undosLast = edit;
        else {
            undosLast.next = edit;
            edit.prev = undosLast;
            undosLast = edit;
        }
        redosFirst = null;
        undoCount ++;
        while (undoCount > limit) {
            undoCount --;
            if (undosFirst == undosLast) undosFirst = undosLast = null;
            else {
                undosFirst.next.prev = null;
                undosFirst = undosFirst.next;
            }
        }
    }

    private Edit getMergeEdit () {
        Edit last = getLastEdit ();
        return (compoundEdit != null ? compoundEdit.last : last);
    }

    private Edit getLastEdit () {
        if (undosLast instanceof CompoundEdit) return ((CompoundEdit) undosLast).last;
        else return undosLast;

    }

    private void reviseUndoId () {
        undoId = new Object ();
    }

    abstract static class Edit {
        Edit prev, next;

        abstract int undo ();

        abstract int redo ();

    }

    static class Insert extends Edit {

        Insert (UndoManager mgr, int offset, int length, String str) {
            this.mgr = mgr;
            this.offset = offset;
            this.length = length;
            this.str = str;
        }

        int undo () {
            mgr.buffer.remove (offset, length);
            if (mgr.undoClearDirty == this) mgr.buffer.setDirty (false);

            return offset;
        }

        int redo () {
            mgr.buffer.insert (offset, str);
            if (mgr.redoClearDirty == this) mgr.buffer.setDirty (false);

            return offset + length;
        }

        UndoManager mgr;
        int offset;
        int length;
        String str;
    }

    public static class RemovedContent {
        String str;
        int hashcode;
        boolean inKillRing;

        public RemovedContent (String str) {
            this.str = str;
            this.hashcode = str.hashCode ();
        }

        public String toString () {
            return str;
        }

    }

    static class Remove extends Edit {

        Remove (UndoManager mgr, int offset, int length, String str) {
            this.mgr = mgr;
            this.offset = offset;
            this.length = length;
            this.content = new RemovedContent (str);
        }

        int undo () {
            mgr.buffer.insert (offset, content.str);
            if (mgr.undoClearDirty == this) mgr.buffer.setDirty (false);

            return offset + length;
        }

        int redo () {
            mgr.buffer.remove (offset, length);
            if (mgr.redoClearDirty == this) mgr.buffer.setDirty (false);

            return offset;
        }

        UndoManager mgr;
        int offset;
        int length;
        final RemovedContent content;
    }

    static class CompoundEdit extends Edit {

        public int undo () {
            int retVal = - 1;
            Edit edit = last;
            while (edit != null) {
                retVal = edit.undo ();
                edit = edit.prev;
            }
            return retVal;
        }

        public int redo () {
            int retVal = - 1;
            Edit edit = first;
            while (edit != null) {
                retVal = edit.redo ();
                edit = edit.next;
            }
            return retVal;
        }

        public void add (Edit edit) {
            if (first == null) first = last = edit;
            else {
                edit.prev = last;
                last.next = edit;
                last = edit;
            }
        }

        Edit first, last;
    }

}

</source>
<source file="systems/java/jEdit/trunk/doclet/GenerateTocXML.java" startline="1" endline="117">
package doclet;

import com.sun.javadoc.*;

import com.sun.tools.doclets.standard.Standard;

import java.io.*;

import java.util.Arrays;

public class GenerateTocXML {
    public static final String OUT = "toc.xml";
    public static final String HEADER = "<?xml version='1.0'?>\n<TOC>\n" + "<ENTRY HREF='overview-summary.html'><TITLE>jEdit API Reference</TITLE>";
    public static final String FOOTER = "</ENTRY></TOC>\n";

    public static boolean start (RootDoc root) {
        if (! Standard.start (root)) {
            return false;
        }
        try {
            FileWriter out = new FileWriter (Standard.htmlDoclet.configuration ().destDirName + OUT);
            out.write (HEADER);
            PackageDoc [] packages = root.specifiedPackages ();
            for (int i = 0;
            i < packages.length; ++ i) {
                processPackage (out, packages [i]);
            }
            out.write (FOOTER);
            out.close ();
            return true;
        } catch (IOException e) {
            e.printStackTrace ();
            return false;
        }
    }

    public static int optionLength (String option) {
        return Standard.optionLength (option);
    }

    public static boolean validOptions (String [] [] options, DocErrorReporter reporter) {
        return Standard.validOptions (options, reporter);
    }

    public static LanguageVersion languageVersion () {
        return Standard.languageVersion ();
    }

    private static void processPackage (Writer out, PackageDoc pkg) throws IOException {
        out.write ("<ENTRY HREF='");
        String pkgPath = pkg.name ().replace ('.', '/') + "/";
        out.write (pkgPath);
        out.write ("package-summary.html'><TITLE>");
        out.write (pkg.name ());
        out.write ("</TITLE>\n");
        ClassDoc [] classes = pkg.allClasses ();
        String [] classNames = new String [classes.length];
        for (int i = 0;
        i < classes.length; i ++) {
            classNames [i] = classes [i].name ();
        }
        Arrays.sort (classNames);
        for (int i = 0;
        i < classes.length; i ++) {
            processClass (out, pkgPath, classNames [i]);
        }
        out.write ("</ENTRY>");
    }

    private static void processClass (Writer out, String pkgPath, String clazz) throws IOException {
        out.write ("<ENTRY HREF='");
        out.write (pkgPath);
        out.write (clazz);
        out.write (".html'><TITLE>");
        out.write (clazz);
        out.write ("</TITLE>\n");
        out.write ("</ENTRY>");
    }

}

</source>
<source file="systems/java/jEdit/trunk/de/masters_of_disaster/ant/tasks/calculatesize/CalculateSize.java" startline="1" endline="95">
package de.masters_of_disaster.ant.tasks.calculatesize;

import java.io.File;

import java.util.Enumeration;

import java.util.Vector;

import org.apache.tools.ant.BuildException;

import org.apache.tools.ant.taskdefs.MatchingTask;

import org.apache.tools.ant.types.FileSet;

public class CalculateSize extends MatchingTask {
    String realSizeProperty = null;
    String diskSizeProperty = null;
    Vector fileSets = new Vector ();
    File baseDir;

    public FileSet createFileSet () {
        FileSet fileSet = new FileSet ();
        fileSets.addElement (fileSet);
        return fileSet;
    }

    public void setBaseDir (File baseDir) {
        this.baseDir = baseDir;
        fileset.setDir (baseDir);
    }

    public void setRealSizeProperty (String realSizeProperty) {
        this.realSizeProperty = realSizeProperty;
    }

    public void setDiskSizeProperty (String diskSizeProperty) {
        this.diskSizeProperty = diskSizeProperty;
    }

    public void execute () throws BuildException {
        if ((null == realSizeProperty) && (null == diskSizeProperty)) {
            throw new BuildException ("realSizeProperty or diskSizeProperty must be set for <CalculateSize>");
        }
        if (null != baseDir) {
            fileSets.addElement (fileset);
        }
        long realSize = 0;
        long diskSize = 0;
        for (Enumeration e = fileSets.elements ();
        e.hasMoreElements ();) {
            FileSet fileSet = (FileSet) e.nextElement ();
            String [] files = fileSet.getDirectoryScanner (getProject ()).getIncludedFiles ();
            File fileSetDir = fileSet.getDir (getProject ());
            for (int i = 0, c = files.length;
            i < c; i ++) {
                long fileLength = new File (fileSetDir, files [i]).length ();
                realSize += fileLength / 1024;
                diskSize += (fileLength / 4096 + 1) * 4;
            }
        }
        if (null != realSizeProperty) {
            getProject ().setNewProperty (realSizeProperty, Long.toString (realSize));
        }
        if (null != diskSizeProperty) {
            getProject ().setNewProperty (diskSizeProperty, Long.toString (diskSize));
        }
    }

}

</source>
<source file="systems/java/jEdit/trunk/de/masters_of_disaster/ant/tasks/deb/Deb.java" startline="1" endline="352">
package de.masters_of_disaster.ant.tasks.deb;

import de.masters_of_disaster.ant.tasks.ar.Ar;

import de.masters_of_disaster.ant.tasks.ar.Ar.ArFileSet;

import java.io.File;

import java.util.Enumeration;

import java.util.Vector;

import org.apache.tools.ant.BuildException;

import org.apache.tools.ant.Project;

import org.apache.tools.ant.Task;

import org.apache.tools.ant.taskdefs.Checksum;

import org.apache.tools.ant.taskdefs.Echo;

import org.apache.tools.ant.taskdefs.Echo.EchoLevel;

import org.apache.tools.ant.taskdefs.Mkdir;

import org.apache.tools.ant.taskdefs.MatchingTask;

import org.apache.tools.ant.taskdefs.Tar;

import org.apache.tools.ant.taskdefs.Tar.TarCompressionMethod;

import org.apache.tools.ant.taskdefs.Tar.TarFileSet;

import org.apache.tools.ant.util.FileUtils;

import org.apache.tools.ant.util.MergingMapper;

import org.apache.tools.ant.util.SourceFileScanner;

public class Deb extends MatchingTask {
    Vector controlFileSets = new Vector ();
    Vector dataFileSets = new Vector ();
    File baseDir;
    File destFile;
    File tempDir;
    boolean deleteTempFiles = true;
    boolean includeMd5sums = false;
    Tar controlTarGz = new Tar ();
    Tar dataTarGz = new Tar ();
    Ar debPackage = new Ar ();

    {
        fileset = dataTarGz.createTarFileSet ();
    }

    public TarFileSet createControlFileSet () {
        TarFileSet fileSet = controlTarGz.createTarFileSet ();
        controlFileSets.addElement (fileSet);
        return fileSet;
    }

    public TarFileSet createDataFileSet () {
        TarFileSet fileSet = dataTarGz.createTarFileSet ();
        dataFileSets.addElement (fileSet);
        return fileSet;
    }

    public void setDestFile (File destFile) {
        this.destFile = destFile;
        debPackage.setDestFile (destFile);
    }

    public void setBaseDir (File baseDir) {
        this.baseDir = baseDir;
        fileset.setDir (baseDir);
    }

    public void setTempDir (File tempDir) {
        this.tempDir = tempDir;
    }

    public void setDeleteTempFiles (boolean deleteTempFiles) {
        this.deleteTempFiles = deleteTempFiles;
    }

    public void setIncludeMd5sums (boolean includeMd5sums) {
        this.includeMd5sums = includeMd5sums;
    }

    public void execute () throws BuildException {
        prepareTask (controlTarGz);
        prepareTask (dataTarGz);
        prepareTask (debPackage);
        TarFileSet tarFileSet = controlTarGz.createTarFileSet ();
        tarFileSet.setFile (new File (System.getProperty ("user.dir")));
        tarFileSet.setUserName ("root");
        tarFileSet.setGroup ("root");
        tarFileSet.setFullpath ("./");
        tarFileSet = dataTarGz.createTarFileSet ();
        tarFileSet.setFile (new File (System.getProperty ("user.dir")));
        tarFileSet.setUserName ("root");
        tarFileSet.setGroup ("root");
        tarFileSet.setFullpath ("./");
        if (null == tempDir) {
            tempDir = getProject ().getBaseDir ();
        }
        if (null != baseDir) {
            dataFileSets.addElement (fileset);
        } else {
            fileset.setDir (new File (System.getProperty ("user.dir")));
            fileset.setExcludes ("**");
        }
        boolean controlFound = false;
        for (Enumeration e = controlFileSets.elements ();
        e.hasMoreElements ();) {
            TarFileSet fileSet = (TarFileSet) e.nextElement ();
            String [] files = fileSet.getFiles (getProject ());
            int i = 0;
            int c;
            for (c = files.length; i < c && ! controlFound; i ++) {
                if (files [i].endsWith ("control") && (new File (fileSet.getDir (getProject ()), files [i])).isFile ()) {
                    controlFound = true;
                }
            }
        }
        if (! controlFound) {
            throw new BuildException ("The control fileset must contain a file \"control\"", getLocation ());
        }
        boolean upToDate = true;
        for (Enumeration e = controlFileSets.elements ();
        e.hasMoreElements ();) {
            TarFileSet fileSet = (TarFileSet) e.nextElement ();
            String [] files = fileSet.getFiles (getProject ());
            if (! packageIsUpToDate (files, fileSet.getDir (getProject ()))) {
                upToDate = false;
            }
        }
        for (Enumeration e = dataFileSets.elements ();
        e.hasMoreElements ();) {
            TarFileSet fileSet = (TarFileSet) e.nextElement ();
            String [] files = fileSet.getFiles (getProject ());
            if (! packageIsUpToDate (files, fileSet.getDir (getProject ()))) {
                upToDate = false;
            }
        }
        if (upToDate) {
            log ("Nothing to do: " + destFile.getAbsolutePath () + " is up to date.", Project.MSG_INFO);
            return;
        }
        log ("Building deb: " + destFile.getAbsolutePath (), Project.MSG_INFO);
        Mkdir mkdir = new Mkdir ();
        prepareTask (mkdir);
        mkdir.setDir (tempDir);
        mkdir.perform ();
        Echo echo = new Echo ();
        prepareTask (echo);
        EchoLevel echoLevel = new EchoLevel ();
        echoLevel.setValue ("error");
        File debianBinaryFile = new File (tempDir, "debian-binary");
        echo.setFile (debianBinaryFile);
        echo.setLevel (echoLevel);
        echo.setMessage ("2.0\n");
        echo.perform ();
        for (Enumeration e = controlFileSets.elements ();
        e.hasMoreElements ();) {
            TarFileSet fileSet = (TarFileSet) e.nextElement ();
            String prefix = fileSet.getPrefix ();
            String fullpath = fileSet.getFullpath ();
            if ("".equals (fullpath) && ! prefix.startsWith ("./")) {
                if (prefix.startsWith ("/")) {
                    fileSet.setPrefix ("." + prefix);
                } else {
                    fileSet.setPrefix ("./" + prefix);
                }
            }
            if ((fullpath.length () > 0) && ! fullpath.startsWith ("./")) {
                fileSet.setPrefix ("");
                if (fullpath.startsWith ("/")) {
                    fileSet.setFullpath ("." + fullpath);
                } else {
                    fileSet.setFullpath ("./" + fullpath);
                }
            }
            if ((0 == fileSet.getUid ()) && ("" == fileSet.getUserName ())) {
                fileSet.setUserName ("root");
            }
            if ((0 == fileSet.getGid ()) && ("" == fileSet.getGroup ())) {
                fileSet.setGroup ("root");
            }
        }
        for (Enumeration e = dataFileSets.elements ();
        e.hasMoreElements ();) {
            TarFileSet fileSet = (TarFileSet) e.nextElement ();
            String prefix = fileSet.getPrefix ();
            String fullpath = fileSet.getFullpath ();
            if ("".equals (fullpath) && ! prefix.startsWith ("./")) {
                if (prefix.startsWith ("/")) {
                    fileSet.setPrefix ("." + prefix);
                } else {
                    fileSet.setPrefix ("./" + prefix);
                }
            }
            if ((fullpath.length () > 0) && ! fullpath.startsWith ("./")) {
                fileSet.setPrefix ("");
                if (fullpath.startsWith ("/")) {
                    fileSet.setFullpath ("." + fullpath);
                } else {
                    fileSet.setFullpath ("./" + fullpath);
                }
            }
            if ((0 == fileSet.getUid ()) && ("" == fileSet.getUserName ())) {
                fileSet.setUserName ("root");
            }
            if ((0 == fileSet.getGid ()) && ("" == fileSet.getGroup ())) {
                fileSet.setGroup ("root");
            }
        }
        File md5sumsFile = new File (tempDir, "md5sums");
        if (includeMd5sums) {
            Checksum md5 = new Checksum ();
            prepareTask (md5);
            int md5Count = 0;
            StringBuffer md5sums = new StringBuffer ();
            for (Enumeration e = dataFileSets.elements ();
            e.hasMoreElements ();) {
                TarFileSet fileSet = (TarFileSet) e.nextElement ();
                String [] files = fileSet.getDirectoryScanner (getProject ()).getIncludedFiles ();
                File fileSetDir = fileSet.getDir (getProject ());
                for (int i = 0, c = files.length;
                i < c; i ++) {
                    md5.setFile (new File (fileSetDir, files [i]));
                    md5.setProperty ("md5_" + md5Count);
                    md5.perform ();
                    md5sums.append (getProject ().getProperty ("md5_" + md5Count)).append ("  ");
                    String fullpath = fileSet.getFullpath ();
                    if (fullpath.length () > 0) {
                        md5sums.append (fullpath.substring (2));
                    } else {
                        md5sums.append (fileSet.getPrefix ().substring (2)).append (files [i].replace ('\\', '/'));
                    }
                    md5sums.append ("\n");
                    md5Count ++;
                }
            }
            echo.setFile (md5sumsFile);
            echo.setMessage (md5sums.toString ());
            echo.perform ();
            tarFileSet = controlTarGz.createTarFileSet ();
            tarFileSet.setFile (md5sumsFile);
            tarFileSet.setUserName ("root");
            tarFileSet.setGroup ("root");
            tarFileSet.setPrefix ("./");
        }
        TarCompressionMethod tarCompressionMethod = new TarCompressionMethod ();
        tarCompressionMethod.setValue ("gzip");
        controlTarGz.setCompression (tarCompressionMethod);
        File controlTarGzFile = new File (tempDir, "control.tar.gz");
        controlTarGz.setDestFile (controlTarGzFile);
        controlTarGz.perform ();
        dataTarGz.setCompression (tarCompressionMethod);
        File dataTarGzFile = new File (tempDir, "data.tar.gz");
        dataTarGz.setDestFile (dataTarGzFile);
        dataTarGz.perform ();
        FileUtils.delete (destFile);
        ArFileSet fileSet = debPackage.createArFileSet ();
        fileSet.setFile (debianBinaryFile);
        fileSet = debPackage.createArFileSet ();
        fileSet.setFile (controlTarGzFile);
        fileSet = debPackage.createArFileSet ();
        fileSet.setFile (dataTarGzFile);
        debPackage.perform ();
        if (deleteTempFiles) {
            FileUtils.delete (debianBinaryFile);
            FileUtils.delete (controlTarGzFile);
            FileUtils.delete (dataTarGzFile);
            FileUtils.delete (md5sumsFile);
        }
    }

    protected boolean packageIsUpToDate (String [] files, File dir) {
        SourceFileScanner sfs = new SourceFileScanner (this);
        MergingMapper mm = new MergingMapper ();
        mm.setTo (destFile.getAbsolutePath ());
        return sfs.restrict (files, dir, null, mm).length == 0;
    }

    protected void prepareTask (Task task) {
        task.setProject (getProject ());
        task.setOwningTarget (getOwningTarget ());
        task.setTaskName (getTaskName ());
        task.setTaskType (getTaskType ());
    }

}

</source>
<source file="systems/java/jEdit/trunk/de/masters_of_disaster/ant/tasks/ar/Ar.java" startline="1" endline="469">
package de.masters_of_disaster.ant.tasks.ar;

import java.io.BufferedOutputStream;

import java.io.File;

import java.io.FileInputStream;

import java.io.FileOutputStream;

import java.io.IOException;

import java.util.Enumeration;

import java.util.Vector;

import org.apache.tools.ant.BuildException;

import org.apache.tools.ant.DirectoryScanner;

import org.apache.tools.ant.Project;

import org.apache.tools.ant.taskdefs.MatchingTask;

import org.apache.tools.ant.types.EnumeratedAttribute;

import org.apache.tools.ant.types.FileSet;

import org.apache.tools.ant.util.FileUtils;

import org.apache.tools.ant.util.MergingMapper;

import org.apache.tools.ant.util.SourceFileScanner;

import org.apache.tools.zip.UnixStat;

public class Ar extends MatchingTask {
    File destFile;
    File baseDir;
    private ArLongFileMode longFileMode = new ArLongFileMode ();
    Vector filesets = new Vector ();
    private boolean longWarningGiven = false;

    public ArFileSet createArFileSet () {
        ArFileSet fileset = new ArFileSet ();
        filesets.addElement (fileset);
        return fileset;
    }

    public void setDestFile (File destFile) {
        this.destFile = destFile;
    }

    public void setBasedir (File baseDir) {
        this.baseDir = baseDir;
    }

    public void setLongfile (ArLongFileMode mode) {
        this.longFileMode = mode;
    }

    public void execute () throws BuildException {
        if (destFile == null) {
            throw new BuildException ("destFile attribute must be set!", getLocation ());
        }
        if (destFile.exists () && destFile.isDirectory ()) {
            throw new BuildException ("destFile is a directory!", getLocation ());
        }
        if (destFile.exists () && ! destFile.canWrite ()) {
            throw new BuildException ("Can not write to the specified destFile!", getLocation ());
        }
        Vector savedFileSets = (Vector) filesets.clone ();
        try {
            if (baseDir != null) {
                if (! baseDir.exists ()) {
                    throw new BuildException ("basedir does not exist!", getLocation ());
                }
                ArFileSet mainFileSet = new ArFileSet (fileset);
                mainFileSet.setDir (baseDir);
                filesets.addElement (mainFileSet);
            }
            if (filesets.size () == 0) {
                throw new BuildException ("You must supply either a basedir " + "attribute or some nested filesets.", getLocation ());
            }
            boolean upToDate = true;
            for (Enumeration e = filesets.elements ();
            e.hasMoreElements ();) {
                ArFileSet fs = (ArFileSet) e.nextElement ();
                String [] files = fs.getFiles (getProject ());
                if (! archiveIsUpToDate (files, fs.getDir (getProject ()))) {
                    upToDate = false;
                }
                for (int i = 0;
                i < files.length; ++ i) {
                    if (destFile.equals (new File (fs.getDir (getProject ()), files [i]))) {
                        throw new BuildException ("An ar file cannot include " + "itself", getLocation ());
                    }
                }
            }
            if (upToDate) {
                log ("Nothing to do: " + destFile.getAbsolutePath () + " is up to date.", Project.MSG_INFO);
                return;
            }
            log ("Building ar: " + destFile.getAbsolutePath (), Project.MSG_INFO);
            ArOutputStream aOut = null;
            try {
                aOut = new ArOutputStream (new BufferedOutputStream (new FileOutputStream (destFile)));
                if (longFileMode.isTruncateMode () || longFileMode.isWarnMode ()) {
                    aOut.setLongFileMode (ArOutputStream.LONGFILE_TRUNCATE);
                } else if (longFileMode.isFailMode () || longFileMode.isOmitMode ()) {
                    aOut.setLongFileMode (ArOutputStream.LONGFILE_ERROR);
                } else if (longFileMode.isBsdMode ()) {
                    aOut.setLongFileMode (ArOutputStream.LONGFILE_BSD);
                } else {
                    aOut.setLongFileMode (ArOutputStream.LONGFILE_GNU);
                }

                longWarningGiven = false;
                for (Enumeration e = filesets.elements ();
                e.hasMoreElements ();) {
                    ArFileSet fs = (ArFileSet) e.nextElement ();
                    String [] files = fs.getFiles (getProject ());
                    if (files.length > 1 && fs.getFullpath ().length () > 0) {
                        throw new BuildException ("fullpath attribute may only " + "be specified for " + "filesets that specify a " + "single file.");
                    }
                    for (int i = 0;
                    i < files.length; i ++) {
                        File f = new File (fs.getDir (getProject ()), files [i]);
                        arFile (f, aOut, fs);
                    }
                }
            } catch (IOException ioe) {
                String msg = "Problem creating AR: " + ioe.getMessage ();
                throw new BuildException (msg, ioe, getLocation ());
            } finally {
                FileUtils.close (aOut);
            }
        } finally {
            filesets = savedFileSets;
        }
    }

    protected void arFile (File file, ArOutputStream aOut, ArFileSet arFileSet) throws IOException {
        FileInputStream fIn = null;
        if (file.isDirectory ()) {
            return;
        }
        String fileName = file.getName ();
        String fullpath = arFileSet.getFullpath ();
        if (fullpath.length () > 0) {
            fileName = fullpath.substring (fullpath.lastIndexOf ('/'));
        }
        if (fileName.length () <= 0) {
            return;
        }
        try {
            if ((fileName.length () >= ArConstants.NAMELEN) || (- 1 != fileName.indexOf (' '))) {
                if (longFileMode.isOmitMode ()) {
                    log ("Omitting: " + fileName, Project.MSG_INFO);
                    return;
                } else if (longFileMode.isWarnMode ()) {
                    if (! longWarningGiven) {
                        log ("Resulting ar file contains truncated or space converted filenames", Project.MSG_WARN);
                        longWarningGiven = true;
                    }
                    log ("Entry: \"" + fileName + "\" longer than " + ArConstants.NAMELEN + " characters or containing spaces.", Project.MSG_WARN);
                } else if (longFileMode.isFailMode ()) {
                    throw new BuildException ("Entry: \"" + fileName + "\" longer than " + ArConstants.NAMELEN + "characters or containting spaces.", getLocation ());
                }

            }
            ArEntry ae = new ArEntry (fileName);
            ae.setFileDate (file.lastModified ());
            ae.setUserId (arFileSet.getUid ());
            ae.setGroupId (arFileSet.getGid ());
            ae.setMode (arFileSet.getMode ());
            ae.setSize (file.length ());
            aOut.putNextEntry (ae);
            fIn = new FileInputStream (file);
            byte [] buffer = new byte [8 * 1024];
            int count = 0;
            do {
                aOut.write (buffer, 0, count);
                count = fIn.read (buffer, 0, buffer.length);
            } while (count != - 1);
            aOut.closeEntry ();
        } finally {
            if (fIn != null) {
                fIn.close ();
            }
        }
    }

    protected boolean archiveIsUpToDate (String [] files, File dir) {
        SourceFileScanner sfs = new SourceFileScanner (this);
        MergingMapper mm = new MergingMapper ();
        mm.setTo (destFile.getAbsolutePath ());
        return sfs.restrict (files, dir, null, mm).length == 0;
    }

    public static class ArFileSet extends FileSet {
        private String [] files = null;
        private int fileMode = UnixStat.FILE_FLAG | UnixStat.DEFAULT_FILE_PERM;
        private int uid;
        private int gid;
        private String fullpath = "";

        public ArFileSet (FileSet fileset) {
            super (fileset);
        }

        public ArFileSet () {
            super ();
        }

        public String [] getFiles (Project p) {
            if (files == null) {
                DirectoryScanner ds = getDirectoryScanner (p);
                files = ds.getIncludedFiles ();
            }
            return files;
        }

        public void setMode (String octalString) {
            this.fileMode = UnixStat.FILE_FLAG | Integer.parseInt (octalString, 8);
        }

        public int getMode () {
            return fileMode;
        }

        public void setUid (int uid) {
            this.uid = uid;
        }

        public int getUid () {
            return uid;
        }

        public void setGid (int gid) {
            this.gid = gid;
        }

        public int getGid () {
            return gid;
        }

        public void setFullpath (String fullpath) {
            this.fullpath = fullpath;
        }

        public String getFullpath () {
            return fullpath;
        }

    }

    public static class ArLongFileMode extends EnumeratedAttribute {
        public static final String WARN = "warn", FAIL = "fail", TRUNCATE = "truncate", GNU = "gnu", BSD = "bsd", OMIT = "omit";
        private final String [] validModes = {WARN, FAIL, TRUNCATE, GNU, BSD, OMIT};

        public ArLongFileMode () {
            super ();
            setValue (WARN);
        }

        public String [] getValues () {
            return validModes;
        }

        public boolean isTruncateMode () {
            return TRUNCATE.equalsIgnoreCase (getValue ());
        }

        public boolean isWarnMode () {
            return WARN.equalsIgnoreCase (getValue ());
        }

        public boolean isGnuMode () {
            return GNU.equalsIgnoreCase (getValue ());
        }

        public boolean isBsdMode () {
            return BSD.equalsIgnoreCase (getValue ());
        }

        public boolean isFailMode () {
            return FAIL.equalsIgnoreCase (getValue ());
        }

        public boolean isOmitMode () {
            return OMIT.equalsIgnoreCase (getValue ());
        }

    }

}

</source>
<source file="systems/java/jEdit/trunk/de/masters_of_disaster/ant/tasks/ar/ArConstants.java" startline="1" endline="63">
package de.masters_of_disaster.ant.tasks.ar;

public interface ArConstants {
    int NAMELEN = 16;
    int FILEDATELEN = 12;
    int UIDLEN = 6;
    int GIDLEN = 6;
    int MODELEN = 8;
    int SIZELEN = 10;
    int MAGICLEN = 2;
    String HEADERMAGIC = "`\n";
    int HEADERLENGTH = NAMELEN + FILEDATELEN + UIDLEN + GIDLEN + MODELEN + SIZELEN + MAGICLEN;
    byte [] PADDING = {'\n'};
    byte [] ARMAGIC = {'!', '<', 'a', 'r', 'c', 'h', '>', '\n'};
}

</source>
<source file="systems/java/jEdit/trunk/de/masters_of_disaster/ant/tasks/ar/ArEntry.java" startline="1" endline="356">
package de.masters_of_disaster.ant.tasks.ar;

import java.io.File;

import java.util.Date;

public class ArEntry implements ArConstants {
    private StringBuffer filename;
    private long fileDate;
    private int userId;
    private int groupId;
    private int mode;
    private long size;
    private StringBuffer magic;
    private File file;
    public static final int DEFAULT_FILE_MODE = 0100644;
    public static final int MILLIS_PER_SECOND = 1000;

    private ArEntry () {
        this.magic = new StringBuffer (HEADERMAGIC);
        this.filename = new StringBuffer ();
        this.userId = 0;
        this.groupId = 0;
        this.file = null;
    }

    public ArEntry (String name) {
        this ();
        if (name.endsWith ("/")) {
            throw new IllegalArgumentException ("ar archives can only contain files");
        }
        this.filename = new StringBuffer (name);
        this.mode = DEFAULT_FILE_MODE;
        this.userId = 0;
        this.groupId = 0;
        this.size = 0;
        this.fileDate = (new Date ()).getTime () / MILLIS_PER_SECOND;
    }

    public ArEntry (File file) {
        this ();
        if (file.isDirectory ()) {
            throw new IllegalArgumentException ("ar archives can only contain files");
        }
        this.file = file;
        this.filename = new StringBuffer (file.getName ());
        this.fileDate = file.lastModified () / MILLIS_PER_SECOND;
        this.mode = DEFAULT_FILE_MODE;
        this.size = file.length ();
    }

    public ArEntry (byte [] headerBuf) {
        this ();
        this.parseArHeader (headerBuf);
    }

    public boolean equals (ArEntry it) {
        return this.getFilename ().equals (it.getFilename ());
    }

    public boolean equals (Object it) {
        if (it == null || getClass () != it.getClass ()) {
            return false;
        }
        return equals ((ArEntry) it);
    }

    public int hashCode () {
        return getFilename ().hashCode ();
    }

    public String getFilename () {
        return this.filename.toString ();
    }

    public void setFilename (String filename) {
        this.filename = new StringBuffer (filename);
    }

    public void setMode (int mode) {
        this.mode = mode;
    }

    public int getUserId () {
        return this.userId;
    }

    public void setUserId (int userId) {
        this.userId = userId;
    }

    public int getGroupId () {
        return this.groupId;
    }

    public void setGroupId (int groupId) {
        this.groupId = groupId;
    }

    public void setIds (int userId, int groupId) {
        this.setUserId (userId);
        this.setGroupId (groupId);
    }

    public void setFileDate (long time) {
        this.fileDate = time / MILLIS_PER_SECOND;
    }

    public void setFileDate (Date time) {
        this.fileDate = time.getTime () / MILLIS_PER_SECOND;
    }

    public Date getFileDate () {
        return new Date (this.fileDate * MILLIS_PER_SECOND);
    }

    public File getFile () {
        return this.file;
    }

    public int getMode () {
        return this.mode;
    }

    public long getSize () {
        return this.size;
    }

    public void setSize (long size) {
        this.size = size;
    }

    public void writeEntryHeader (byte [] outbuf) {
        int offset = 0;
        offset = ArUtils.getNameBytes (this.filename, outbuf, offset, NAMELEN);
        offset = ArUtils.getLongBytes (this.fileDate, outbuf, offset, FILEDATELEN);
        offset = ArUtils.getIntegerBytes (this.userId, outbuf, offset, UIDLEN);
        offset = ArUtils.getIntegerBytes (this.groupId, outbuf, offset, GIDLEN);
        offset = ArUtils.getOctalBytes (this.mode, outbuf, offset, MODELEN);
        offset = ArUtils.getLongBytes (this.size, outbuf, offset, SIZELEN);
        offset = ArUtils.getNameBytes (this.magic, outbuf, offset, MAGICLEN);
        while (offset < outbuf.length) {
            outbuf [offset ++] = 0;
        }
    }

    public void parseArHeader (byte [] header) {
        throw new UnsupportedOperationException ("parseArHeader(byte[]) not yet implmented");
    }

}

</source>
<source file="systems/java/jEdit/trunk/de/masters_of_disaster/ant/tasks/ar/ArUtils.java" startline="1" endline="156">
package de.masters_of_disaster.ant.tasks.ar;

public class ArUtils {

    public static long parseOctal (byte [] header, int offset, int length) {
        long result = 0;
        int end = offset + length;
        for (int i = offset;
        i < end; i ++) {
            if (header [i] == (byte) ' ') {
                break;
            }
            result = (result << 3) + (header [i] - '0');
        }
        return result;
    }

    public static StringBuffer parseName (byte [] header, int offset, int length) {
        StringBuffer result = new StringBuffer (length);
        int end = offset + length;
        for (int i = offset;
        i < end; i ++) {
            if (header [i] == ' ') {
                break;
            }
            result.append ((char) header [i]);
        }
        return result;
    }

    public static int getNameBytes (StringBuffer name, byte [] buf, int offset, int length) {
        int i;
        int c = name.length ();
        for (i = 0; i < length && i < c; i ++) {
            buf [offset + i] = (byte) name.charAt (i);
        }
        while (i < length) {
            buf [offset + i] = (byte) ' ';
            i ++;
        }
        return offset + length;
    }

    public static int getLongBytes (long value, byte [] buf, int offset, int length) {
        int i;
        String tmp = Long.toString (value);
        int c = tmp.length ();
        for (i = 0; i < length && i < c; i ++) {
            buf [offset + i] = (byte) tmp.charAt (i);
        }
        while (i < length) {
            buf [offset + i] = (byte) ' ';
            i ++;
        }
        return offset + length;
    }

    public static int getIntegerBytes (int value, byte [] buf, int offset, int length) {
        int i;
        String tmp = Integer.toString (value);
        int c = tmp.length ();
        for (i = 0; i < length && i < c; i ++) {
            buf [offset + i] = (byte) tmp.charAt (i);
        }
        while (i < length) {
            buf [offset + i] = (byte) ' ';
            i ++;
        }
        return offset + length;
    }

    public static int getOctalBytes (long value, byte [] buf, int offset, int length) {
        int i;
        String tmp = Long.toOctalString (value);
        int c = tmp.length ();
        for (i = 0; i < length && i < c; i ++) {
            buf [offset + i] = (byte) tmp.charAt (i);
        }
        while (i < length) {
            buf [offset + i] = (byte) ' ';
            i ++;
        }
        return offset + length;
    }

}

</source>
<source file="systems/java/jEdit/trunk/de/masters_of_disaster/ant/tasks/ar/ArOutputStream.java" startline="1" endline="168">
package de.masters_of_disaster.ant.tasks.ar;

import java.io.FilterOutputStream;

import java.io.OutputStream;

import java.io.IOException;

public class ArOutputStream extends FilterOutputStream {
    public static final int LONGFILE_ERROR = 0;
    public static final int LONGFILE_TRUNCATE = 1;
    public static final int LONGFILE_GNU = 2;
    public static final int LONGFILE_BSD = 3;
    protected int currSize;
    protected int currBytes;
    protected byte [] oneBuf;
    protected int longFileMode = LONGFILE_ERROR;
    protected boolean writingStarted = false;
    protected boolean inEntry = false;

    public ArOutputStream (OutputStream os) throws IOException {
        super (os);
        if (null == os) {
            throw new NullPointerException ("os must not be null");
        }
        this.out.write (ArConstants.ARMAGIC, 0, ArConstants.ARMAGIC.length);
        this.oneBuf = new byte [1];
    }

    public void setLongFileMode (int longFileMode) {
        if (writingStarted) {
            throw new IllegalStateException ("longFileMode cannot be changed after writing to the archive has begun");
        }
        if (LONGFILE_GNU == longFileMode) {
            throw new UnsupportedOperationException ("GNU variant isn't implemented yet");
        }
        if (LONGFILE_BSD == longFileMode) {
            throw new UnsupportedOperationException ("BSD variant isn't implemented yet");
        }
        this.longFileMode = longFileMode;
    }

    public void putNextEntry (ArEntry entry) throws IOException {
        writingStarted = true;
        if (inEntry) {
            throw new IOException ("the current entry has to be closed before starting a new one");
        }
        String filename = entry.getFilename ();
        if ((filename.length () >= ArConstants.NAMELEN) && (longFileMode != LONGFILE_TRUNCATE)) {
            throw new RuntimeException ("file name \"" + entry.getFilename () + "\" is too long ( > " + ArConstants.NAMELEN + " bytes )");
        }
        if (- 1 != filename.indexOf (' ')) {
            if (longFileMode == LONGFILE_TRUNCATE) {
                entry.setFilename (filename.replace (' ', '_'));
            } else {
                throw new RuntimeException ("file name \"" + entry.getFilename () + "\" contains spaces");
            }
        }
        byte [] headerBuf = new byte [ArConstants.HEADERLENGTH];
        entry.writeEntryHeader (headerBuf);
        this.out.write (headerBuf, 0, ArConstants.HEADERLENGTH);
        this.currBytes = 0;
        this.currSize = (int) entry.getSize ();
        inEntry = true;
    }

    public void closeEntry () throws IOException {
        if (! inEntry) {
            throw new IOException ("we are not in an entry currently");
        }
        if (this.currBytes < this.currSize) {
            throw new IOException ("entry closed at '" + this.currBytes + "' before the '" + this.currSize + "' bytes specified in the header were written");
        }
        if (1 == (this.currSize & 1)) {
            this.out.write (ArConstants.PADDING, 0, 1);
        }
        inEntry = false;
    }

    public void write (int b) throws IOException {
        this.oneBuf [0] = (byte) b;
        this.write (this.oneBuf, 0, 1);
    }

    public void write (byte [] wBuf) throws IOException {
        this.write (wBuf, 0, wBuf.length);
    }

    public void write (byte [] wBuf, int wOffset, int numToWrite) throws IOException {
        if (! inEntry) {
            throw new IOException ("we are not in an entry currently");
        }
        if ((this.currBytes + numToWrite) > this.currSize) {
            throw new IOException ("request to write '" + numToWrite + "' bytes exceeds size in header of '" + this.currSize + "' bytes");
        }
        if (numToWrite > 0) {
            this.out.write (wBuf, wOffset, numToWrite);
            this.currBytes += numToWrite;
        }
    }

}

</source>
<source file="systems/java/jEdit/trunk/installer/CBZip2InputStream.java" startline="1" endline="954">
package installer;

import java.io.IOException;

import java.io.InputStream;

public class CBZip2InputStream extends InputStream implements BZip2Constants {
    private static final int START_BLOCK_STATE = 1;
    private static final int RAND_PART_A_STATE = 2;
    private static final int RAND_PART_B_STATE = 3;
    private static final int RAND_PART_C_STATE = 4;
    private static final int NO_RAND_PART_A_STATE = 5;
    private static final int NO_RAND_PART_B_STATE = 6;
    private static final int NO_RAND_PART_C_STATE = 7;
    private CRC m_crc = new CRC ();
    private boolean [] m_inUse = new boolean [256];
    private char [] m_seqToUnseq = new char [256];
    private char [] m_unseqToSeq = new char [256];
    private char [] m_selector = new char [MAX_SELECTORS];
    private char [] m_selectorMtf = new char [MAX_SELECTORS];
    private int [] m_unzftab = new int [256];
    private int [] [] m_limit = new int [N_GROUPS] [MAX_ALPHA_SIZE];
    private int [] [] m_base = new int [N_GROUPS] [MAX_ALPHA_SIZE];
    private int [] [] m_perm = new int [N_GROUPS] [MAX_ALPHA_SIZE];
    private int [] m_minLens = new int [N_GROUPS];
    private boolean m_streamEnd;
    private int m_currentChar = - 1;
    private int m_currentState = START_BLOCK_STATE;
    private int m_rNToGo;
    private int m_rTPos;
    private int m_tPos;
    private int i2;
    private int count;
    private int chPrev;
    private int ch2;
    private int j2;
    private char z;
    private boolean m_blockRandomised;
    private int m_blockSize100k;
    private int m_bsBuff;
    private int m_bsLive;
    private InputStream m_input;
    private int m_computedBlockCRC;
    private int m_computedCombinedCRC;
    private int m_last;
    private char [] m_ll8;
    private int m_nInUse;
    private int m_origPtr;
    private int m_storedBlockCRC;
    private int m_storedCombinedCRC;
    private int [] m_tt;

    public CBZip2InputStream (final InputStream input) {
        bsSetStream (input);
        initialize ();
        initBlock ();
        setupBlock ();
    }

    private static void badBlockHeader () {
        cadvise ();
    }

    private static void blockOverrun () {
        cadvise ();
    }

    private static void cadvise () {
        System.out.println ("CRC Error");
    }

    private static void compressedStreamEOF () {
        cadvise ();
    }

    private static void crcError () {
        cadvise ();
    }

    public int read () {
        if (m_streamEnd) {
            return - 1;
        } else {
            int retChar = m_currentChar;
            switch (m_currentState) {
                case START_BLOCK_STATE :
                    break;
                case RAND_PART_A_STATE :
                    break;
                case RAND_PART_B_STATE :
                    setupRandPartB ();
                    break;
                case RAND_PART_C_STATE :
                    setupRandPartC ();
                    break;
                case NO_RAND_PART_A_STATE :
                    break;
                case NO_RAND_PART_B_STATE :
                    setupNoRandPartB ();
                    break;
                case NO_RAND_PART_C_STATE :
                    setupNoRandPartC ();
                    break;
                default :
                    break;
            }
            return retChar;
        }
    }

    private void setDecompressStructureSizes (int newSize100k) {
        if (! (0 <= newSize100k && newSize100k <= 9 && 0 <= m_blockSize100k && m_blockSize100k <= 9)) {
        }
        m_blockSize100k = newSize100k;
        if (newSize100k == 0) {
            return;
        }
        int n = BASE_BLOCK_SIZE * newSize100k;
        m_ll8 = new char [n];
        m_tt = new int [n];
    }

    private void setupBlock () {
        int [] cftab = new int [257];
        char ch;
        cftab [0] = 0;
        for (int i = 1;
        i <= 256; i ++) {
            cftab [i] = m_unzftab [i - 1];
        }
        for (int i = 1;
        i <= 256; i ++) {
            cftab [i] += cftab [i - 1];
        }
        for (int i = 0;
        i <= m_last; i ++) {
            ch = m_ll8 [i];
            m_tt [cftab [ch]] = i;
            cftab [ch] ++;
        }
        cftab = null;
        m_tPos = m_tt [m_origPtr];
        count = 0;
        i2 = 0;
        ch2 = 256;
        if (m_blockRandomised) {
            m_rNToGo = 0;
            m_rTPos = 0;
            setupRandPartA ();
        } else {
            setupNoRandPartA ();
        }
    }

    private void setupNoRandPartA () {
        if (i2 <= m_last) {
            chPrev = ch2;
            ch2 = m_ll8 [m_tPos];
            m_tPos = m_tt [m_tPos];
            i2 ++;
            m_currentChar = ch2;
            m_currentState = NO_RAND_PART_B_STATE;
            m_crc.updateCRC (ch2);
        } else {
            endBlock ();
            initBlock ();
            setupBlock ();
        }
    }

    private void setupNoRandPartB () {
        if (ch2 != chPrev) {
            m_currentState = NO_RAND_PART_A_STATE;
            count = 1;
            setupNoRandPartA ();
        } else {
            count ++;
            if (count >= 4) {
                z = m_ll8 [m_tPos];
                m_tPos = m_tt [m_tPos];
                m_currentState = NO_RAND_PART_C_STATE;
                j2 = 0;
                setupNoRandPartC ();
            } else {
                m_currentState = NO_RAND_PART_A_STATE;
                setupNoRandPartA ();
            }
        }
    }

    private void setupNoRandPartC () {
        if (j2 < z) {
            m_currentChar = ch2;
            m_crc.updateCRC (ch2);
            j2 ++;
        } else {
            m_currentState = NO_RAND_PART_A_STATE;
            i2 ++;
            count = 0;
            setupNoRandPartA ();
        }
    }

    private void setupRandPartA () {
        if (i2 <= m_last) {
            chPrev = ch2;
            ch2 = m_ll8 [m_tPos];
            m_tPos = m_tt [m_tPos];
            if (m_rNToGo == 0) {
                m_rNToGo = RAND_NUMS [m_rTPos];
                m_rTPos ++;
                if (m_rTPos == 512) {
                    m_rTPos = 0;
                }
            }
            m_rNToGo --;
            ch2 ^= ((m_rNToGo == 1) ? 1 : 0);
            i2 ++;
            m_currentChar = ch2;
            m_currentState = RAND_PART_B_STATE;
            m_crc.updateCRC (ch2);
        } else {
            endBlock ();
            initBlock ();
            setupBlock ();
        }
    }

    private void setupRandPartB () {
        if (ch2 != chPrev) {
            m_currentState = RAND_PART_A_STATE;
            count = 1;
            setupRandPartA ();
        } else {
            count ++;
            if (count >= 4) {
                z = m_ll8 [m_tPos];
                m_tPos = m_tt [m_tPos];
                if (m_rNToGo == 0) {
                    m_rNToGo = RAND_NUMS [m_rTPos];
                    m_rTPos ++;
                    if (m_rTPos == 512) {
                        m_rTPos = 0;
                    }
                }
                m_rNToGo --;
                z ^= ((m_rNToGo == 1) ? 1 : 0);
                j2 = 0;
                m_currentState = RAND_PART_C_STATE;
                setupRandPartC ();
            } else {
                m_currentState = RAND_PART_A_STATE;
                setupRandPartA ();
            }
        }
    }

    private void setupRandPartC () {
        if (j2 < z) {
            m_currentChar = ch2;
            m_crc.updateCRC (ch2);
            j2 ++;
        } else {
            m_currentState = RAND_PART_A_STATE;
            i2 ++;
            count = 0;
            setupRandPartA ();
        }
    }

    private void getAndMoveToFrontDecode () {
        int nextSym;
        int limitLast = BASE_BLOCK_SIZE * m_blockSize100k;
        m_origPtr = readVariableSizedInt (24);
        recvDecodingTables ();
        int EOB = m_nInUse + 1;
        int groupNo = - 1;
        int groupPos = 0;
        for (int i = 0;
        i <= 255; i ++) {
            m_unzftab [i] = 0;
        }
        final char [] yy = new char [256];
        for (int i = 0;
        i <= 255; i ++) {
            yy [i] = (char) i;
        }
        m_last = - 1;
        int zt;
        int zn;
        int zvec;
        int zj;
        groupNo ++;
        groupPos = G_SIZE - 1;
        zt = m_selector [groupNo];
        zn = m_minLens [zt];
        zvec = bsR (zn);
        while (zvec > m_limit [zt] [zn]) {
            zn ++;
            while (m_bsLive < 1) {
                int zzi;
                try {
                    zzi = m_input.read ();
                } catch (IOException e) {
                    compressedStreamEOF ();
                    break;
                }
                if (zzi == - 1) {
                    compressedStreamEOF ();
                    break;
                }
                m_bsBuff = (m_bsBuff << 8) | (zzi & 0xff);
                m_bsLive += 8;
            }
            zj = (m_bsBuff>> (m_bsLive - 1)) & 1;
            m_bsLive --;
            zvec = (zvec << 1) | zj;
        }
        nextSym = m_perm [zt] [zvec - m_base [zt] [zn]];
        while (true) {
            if (nextSym == EOB) {
                break;
            }
            if (nextSym == RUNA || nextSym == RUNB) {
                char ch;
                int s = - 1;
                int N = 1;
                do {
                    if (nextSym == RUNA) {
                        s = s + (0 + 1) * N;
                    } else {
                        s = s + (1 + 1) * N;
                    }
                    N = N * 2;
                    if (groupPos == 0) {
                        groupNo ++;
                        groupPos = G_SIZE;
                    }
                    groupPos --;
                    zt = m_selector [groupNo];
                    zn = m_minLens [zt];
                    zvec = bsR (zn);
                    while (zvec > m_limit [zt] [zn]) {
                        zn ++;
                        while (m_bsLive < 1) {
                            int zzi;
                            char thech = 0;
                            try {
                                thech = (char) m_input.read ();
                            } catch (IOException e) {
                                compressedStreamEOF ();
                            }
                            if (thech == - 1) {
                                compressedStreamEOF ();
                            }
                            zzi = thech;
                            m_bsBuff = (m_bsBuff << 8) | (zzi & 0xff);
                            m_bsLive += 8;
                        }
                        zj = (m_bsBuff>> (m_bsLive - 1)) & 1;
                        m_bsLive --;
                        zvec = (zvec << 1) | zj;
                    }
                    nextSym = m_perm [zt] [zvec - m_base [zt] [zn]];
                } while (nextSym == RUNA || nextSym == RUNB);
                s ++;
                ch = m_seqToUnseq [yy [0]];
                m_unzftab [ch] += s;
                while (s > 0) {
                    m_last ++;
                    m_ll8 [m_last] = ch;
                    s --;
                }
                if (m_last >= limitLast) {
                    blockOverrun ();
                }
                continue;
            } else {
                char tmp;
                m_last ++;
                if (m_last >= limitLast) {
                    blockOverrun ();
                }
                tmp = yy [nextSym - 1];
                m_unzftab [m_seqToUnseq [tmp]] ++;
                m_ll8 [m_last] = m_seqToUnseq [tmp];
                int j = nextSym - 1;
                for (; j > 3; j -= 4) {
                    yy [j] = yy [j - 1];
                    yy [j - 1] = yy [j - 2];
                    yy [j - 2] = yy [j - 3];
                    yy [j - 3] = yy [j - 4];
                }
                for (; j > 0; j --) {
                    yy [j] = yy [j - 1];
                }
                yy [0] = tmp;
                if (groupPos == 0) {
                    groupNo ++;
                    groupPos = G_SIZE;
                }
                groupPos --;
                zt = m_selector [groupNo];
                zn = m_minLens [zt];
                zvec = bsR (zn);
                while (zvec > m_limit [zt] [zn]) {
                    zn ++;
                    while (m_bsLive < 1) {
                        char ch = 0;
                        try {
                            ch = (char) m_input.read ();
                        } catch (IOException e) {
                            compressedStreamEOF ();
                        }
                        m_bsBuff = (m_bsBuff << 8) | (ch & 0xff);
                        m_bsLive += 8;
                    }
                    zj = (m_bsBuff>> (m_bsLive - 1)) & 1;
                    m_bsLive --;
                    zvec = (zvec << 1) | zj;
                }
                nextSym = m_perm [zt] [zvec - m_base [zt] [zn]];
                continue;
            }
        }
    }

    private void bsFinishedWithStream () {
        m_input = null;
    }

    private int readVariableSizedInt (final int numBits) {
        return bsR (numBits);
    }

    private char readUnsignedChar () {
        return (char) bsR (8);
    }

    private int readInt () {
        int u = 0;
        u = (u << 8) | bsR (8);
        u = (u << 8) | bsR (8);
        u = (u << 8) | bsR (8);
        u = (u << 8) | bsR (8);
        return u;
    }

    private int bsR (final int n) {
        while (m_bsLive < n) {
            char ch = 0;
            try {
                ch = (char) m_input.read ();
            } catch (final IOException ioe) {
                compressedStreamEOF ();
            }
            if (ch == - 1) {
                compressedStreamEOF ();
            }
            m_bsBuff = (m_bsBuff << 8) | (ch & 0xff);
            m_bsLive += 8;
        }
        final int result = (m_bsBuff>> (m_bsLive - n)) & ((1 << n) - 1);
        m_bsLive -= n;
        return result;
    }

    private void bsSetStream (final InputStream input) {
        m_input = input;
        m_bsLive = 0;
        m_bsBuff = 0;
    }

    private void complete () {
        m_storedCombinedCRC = readInt ();
        if (m_storedCombinedCRC != m_computedCombinedCRC) {
            crcError ();
        }
        bsFinishedWithStream ();
        m_streamEnd = true;
    }

    private void endBlock () {
        m_computedBlockCRC = m_crc.getFinalCRC ();
        if (m_storedBlockCRC != m_computedBlockCRC) {
            crcError ();
        }
        m_computedCombinedCRC = (m_computedCombinedCRC << 1) | (m_computedCombinedCRC>>> 31);
        m_computedCombinedCRC ^= m_computedBlockCRC;
    }

    private void hbCreateDecodeTables (final int [] limit, final int [] base, final int [] perm, final char [] length, final int minLen, final int maxLen, final int alphaSize) {
        int pp = 0;
        for (int i = minLen;
        i <= maxLen; i ++) {
            for (int j = 0;
            j < alphaSize; j ++) {
                if (length [j] == i) {
                    perm [pp] = j;
                    pp ++;
                }
            }
        }
        for (int i = 0;
        i < MAX_CODE_LEN; i ++) {
            base [i] = 0;
        }
        for (int i = 0;
        i < alphaSize; i ++) {
            base [length [i] + 1] ++;
        }
        for (int i = 1;
        i < MAX_CODE_LEN; i ++) {
            base [i] += base [i - 1];
        }
        for (int i = 0;
        i < MAX_CODE_LEN; i ++) {
            limit [i] = 0;
        }
        int vec = 0;
        for (int i = minLen;
        i <= maxLen; i ++) {
            vec += (base [i + 1] - base [i]);
            limit [i] = vec - 1;
            vec <<= 1;
        }
        for (int i = minLen + 1;
        i <= maxLen; i ++) {
            base [i] = ((limit [i - 1] + 1) << 1) - base [i];
        }
    }

    private void initBlock () {
        final char magic1 = readUnsignedChar ();
        final char magic2 = readUnsignedChar ();
        final char magic3 = readUnsignedChar ();
        final char magic4 = readUnsignedChar ();
        final char magic5 = readUnsignedChar ();
        final char magic6 = readUnsignedChar ();
        if (magic1 == 0x17 && magic2 == 0x72 && magic3 == 0x45 && magic4 == 0x38 && magic5 == 0x50 && magic6 == 0x90) {
            complete ();
            return;
        }
        if (magic1 != 0x31 || magic2 != 0x41 || magic3 != 0x59 || magic4 != 0x26 || magic5 != 0x53 || magic6 != 0x59) {
            badBlockHeader ();
            m_streamEnd = true;
            return;
        }
        m_storedBlockCRC = readInt ();
        if (bsR (1) == 1) {
            m_blockRandomised = true;
        } else {
            m_blockRandomised = false;
        }
        getAndMoveToFrontDecode ();
        m_crc.initialiseCRC ();
        m_currentState = START_BLOCK_STATE;
    }

    private void initialize () {
        final char magic3 = readUnsignedChar ();
        final char magic4 = readUnsignedChar ();
        if (magic3 != 'h' || magic4 < '1' || magic4 > '9') {
            bsFinishedWithStream ();
            m_streamEnd = true;
            return;
        }
        setDecompressStructureSizes (magic4 - '0');
        m_computedCombinedCRC = 0;
    }

    private void makeMaps () {
        m_nInUse = 0;
        for (int i = 0;
        i < 256; i ++) {
            if (m_inUse [i]) {
                m_seqToUnseq [m_nInUse] = (char) i;
                m_unseqToSeq [i] = (char) m_nInUse;
                m_nInUse ++;
            }
        }
    }

    private void recvDecodingTables () {
        buildInUseTable ();
        makeMaps ();
        final int alphaSize = m_nInUse + 2;
        final int groupCount = bsR (3);
        final int selectorCount = bsR (15);
        for (int i = 0;
        i < selectorCount; i ++) {
            int run = 0;
            while (bsR (1) == 1) {
                run ++;
            }
            m_selectorMtf [i] = (char) run;
        }
        final char [] pos = new char [N_GROUPS];
        for (char v = 0;
        v < groupCount; v ++) {
            pos [v] = v;
        }
        for (int i = 0;
        i < selectorCount; i ++) {
            int v = m_selectorMtf [i];
            final char tmp = pos [v];
            while (v > 0) {
                pos [v] = pos [v - 1];
                v --;
            }
            pos [0] = tmp;
            m_selector [i] = tmp;
        }
        final char [] [] len = new char [N_GROUPS] [MAX_ALPHA_SIZE];
        for (int i = 0;
        i < groupCount; i ++) {
            int curr = bsR (5);
            for (int j = 0;
            j < alphaSize; j ++) {
                while (bsR (1) == 1) {
                    if (bsR (1) == 0) {
                        curr ++;
                    } else {
                        curr --;
                    }
                }
                len [i] [j] = (char) curr;
            }
        }
        for (int k = 0;
        k < groupCount; k ++) {
            int minLen = 32;
            int maxLen = 0;
            for (int i = 0;
            i < alphaSize; i ++) {
                if (len [k] [i] > maxLen) {
                    maxLen = len [k] [i];
                }
                if (len [k] [i] < minLen) {
                    minLen = len [k] [i];
                }
            }
            hbCreateDecodeTables (m_limit [k], m_base [k], m_perm [k], len [k], minLen, maxLen, alphaSize);
            m_minLens [k] = minLen;
        }
    }

    private void buildInUseTable () {
        final boolean [] inUse16 = new boolean [16];
        for (int i = 0;
        i < 16; i ++) {
            if (bsR (1) == 1) {
                inUse16 [i] = true;
            } else {
                inUse16 [i] = false;
            }
        }
        for (int i = 0;
        i < 256; i ++) {
            m_inUse [i] = false;
        }
        for (int i = 0;
        i < 16; i ++) {
            if (inUse16 [i]) {
                for (int j = 0;
                j < 16; j ++) {
                    if (bsR (1) == 1) {
                        m_inUse [i * 16 + j] = true;
                    }
                }
            }
        }
    }

}

</source>
<source file="systems/java/jEdit/trunk/installer/Install.java" startline="1" endline="167">
package installer;

import javax.swing.plaf.metal.*;

import javax.swing.*;

import java.io.*;

import java.util.Properties;

import java.security.*;

import java.net.URL;

public class Install {

    public static boolean isRunningFromExclam () {
        Class me = Install.class;
        ProtectionDomain domaine = me.getProtectionDomain ();
        CodeSource source = domaine.getCodeSource ();
        URL mySource = source.getLocation ();
        return mySource.toString ().contains ("!");
    }

    public static void main (String [] args) {
        String javaVersion = System.getProperty ("java.version");
        if (javaVersion.compareTo ("1.5") < 0) {
            String message = "You are running Java version " + javaVersion + " from " + System.getProperty ("java.vendor") + ".\n" + "This installer requires Java 1.5 or later.";
            if (args.length == 0) {
                JOptionPane.showMessageDialog (null, message, "jEdit installer...", JOptionPane.ERROR_MESSAGE);
            } else {
                System.err.println (message);
            }
            System.exit (1);
        }
        if (isRunningFromExclam ()) {
            String message = "You are running the installer" + "\nfrom a directory with exclamation mark in it." + "\nIt is a known cause of failure of the installer," + "\nplease move the installer somewhere else and run it again.";
            if (args.length == 0) {
                JOptionPane.showMessageDialog (null, message, "jEdit installer...", JOptionPane.ERROR_MESSAGE);
            } else {
                System.err.println (message);
            }
            System.exit (1);
        }
        if (args.length == 0) new SwingInstall ();
        else if (args.length == 1 && args [0].equals ("text")) new ConsoleInstall ();
        else if (args.length >= 2 && args [0].equals ("auto")) new NonInteractiveInstall (args);
        else {
            System.err.println ("Usage:");
            System.err.println ("java -jar <installer JAR>");
            System.err.println ("java -jar <installer JAR> text");
            System.err.println ("java -jar <installer JAR> auto" + " <install dir> [unix-script=<dir>] [unix-man=<dir>]");
            System.err.println ("text parameter starts installer in text-only mode.");
            System.err.println ("auto parameter starts installer in non-interactive mode.");
        }

    }

    public Install () {
        props = new Properties ();
        try {
            InputStream in = getClass ().getResourceAsStream ("/installer/install.props");
            props.load (in);
            in.close ();
        } catch (IOException io) {
            System.err.println ("Error loading 'install.props':");
            io.printStackTrace ();
        }
        buf = new byte [32768];
    }

    public String getProperty (String name) {
        return props.getProperty (name);
    }

    public int getIntegerProperty (String name) {
        try {
            return Integer.parseInt (props.getProperty (name));
        } catch (Exception e) {
            return - 1;
        }
    }

    public void copy (InputStream in, String outfile, Progress progress) throws IOException {
        File outFile = new File (outfile);
        OperatingSystem.getOperatingSystem ().mkdirs (outFile.getParent ());
        BufferedOutputStream out = new BufferedOutputStream (new FileOutputStream (outFile));
        int count;
        for (;;) {
            count = in.read (buf, 0, Math.min (in.available (), buf.length));
            if (count == - 1 || count == 0) break;

            out.write (buf, 0, count);
            if (progress != null) progress.advance (count);

        }
        out.close ();
    }

    private Properties props;
    private byte [] buf;
}

</source>
<source file="systems/java/jEdit/trunk/installer/NonInteractiveInstall.java" startline="1" endline="92">
package installer;

import java.util.Vector;

public class NonInteractiveInstall {

    public NonInteractiveInstall (String [] args) {
        String installDir = args [1];
        installer = new Install ();
        OperatingSystem os = OperatingSystem.getOperatingSystem ();
        OperatingSystem.OSTask [] osTasks = os.getOSTasks (installer);
        for (int i = 2;
        i < args.length; i ++) {
            String arg = args [i];
            int index = arg.indexOf ('=');
            if (index == - 1) {
                System.err.println ("Invalid parameter: " + arg);
                continue;
            }
            String taskName = arg.substring (0, index);
            String taskDir = arg.substring (index + 1);
            for (int j = 0;
            j < osTasks.length; j ++) {
                OperatingSystem.OSTask osTask = osTasks [j];
                if (osTask.getName ().equals (taskName)) {
                    if (taskDir.equals ("off")) osTask.setEnabled (false);
                    else {
                        osTask.setEnabled (true);
                        osTask.setDirectory (taskDir);
                    }
                    break;
                }
            }
        }
        int compCount = installer.getIntegerProperty ("comp.count");
        Vector components = new Vector (compCount);
        for (int i = 0;
        i < compCount; i ++) {
            String fileset = installer.getProperty ("comp." + i + ".fileset");
            String osDep = installer.getProperty ("comp." + i + ".os");
            if (osDep != null) {
                if (! os.getClass ().getName ().endsWith (osDep)) {
                    continue;
                }
            }
            components.addElement (fileset);
        }
        ConsoleProgress progress = new ConsoleProgress ();
        InstallThread thread = new InstallThread (installer, progress, installDir, osTasks, 0, components);
        thread.start ();
    }

    private Install installer;
}

</source>
<source file="systems/java/jEdit/trunk/installer/OperatingSystem.java" startline="1" endline="377">
package installer;

import java.io.*;

import java.util.Vector;

public abstract class OperatingSystem {

    public abstract String getInstallDirectory (String name, String version);

    public abstract static class OSTask {
        protected Install installer;
        protected String name;
        protected String label;
        protected String directory;
        protected boolean enabled;

        public OSTask (Install installer, String name) {
            this.installer = installer;
            this.name = name;
            this.label = installer.getProperty ("ostask." + name + ".label");
            this.directory = getDefaultDirectory (installer);
            enabled = true;
        }

        public String getName () {
            return name;
        }

        public String getLabel () {
            return label;
        }

        public String getDefaultDirectory (Install installer) {
            return null;
        }

        public String getDirectory () {
            return directory;
        }

        public boolean isEnabled () {
            return enabled;
        }

        public void setEnabled (boolean enabled) {
            this.enabled = enabled;
        }

        public void setDirectory (String directory) {
            this.directory = directory;
        }

        public abstract void perform (String installDir, Vector filesets) throws IOException;

    }

    public OSTask [] getOSTasks (Install installer) {
        return new OSTask [0];
    }

    public void mkdirs (String directory) throws IOException {
        File file = new File (directory);
        if (! file.exists ()) file.mkdirs ();

    }

    public static OperatingSystem getOperatingSystem () {
        if (os != null) return os;

        if (System.getProperty ("mrj.version") != null) {
            os = new MacOS ();
        } else {
            String osName = System.getProperty ("os.name");
            if (osName.indexOf ("Windows") != - 1) os = new Windows ();
            else if (osName.indexOf ("OS/2") != - 1) os = new HalfAnOS ();
            else if (osName.indexOf ("VMS") != - 1) os = new VMS ();
            else os = new Unix ();

        }
        return os;
    }

    public static class Unix extends OperatingSystem {

        public String getInstallDirectory (String name, String version) {
            String dir = "/usr/local/share/";
            if (! new File (dir).canWrite ()) {
                dir = System.getProperty ("user.home");
            }
            return new File (dir, name.toLowerCase () + "/" + version).getPath ();
        }

        public String getExtraClassPath () {
            return "";
        }

        public class ScriptOSTask extends OSTask {

            public ScriptOSTask (Install installer) {
                super (installer, "unix-script");
            }

            public String getDefaultDirectory (Install installer) {
                String dir = "/usr/local/";
                if (! new File (dir).canWrite ()) {
                    dir = System.getProperty ("user.home");
                }
                return new File (dir, "bin").getPath ();
            }

            public void perform (String installDir, Vector filesets) throws IOException {
                if (! enabled) {
                    return;
                }
                mkdirs (directory);
                String name = installer.getProperty ("app.name");
                String script = directory + File.separatorChar + name.toLowerCase ();
                new File (script).delete ();
                FileWriter out = new FileWriter (script);
                out.write ("#!/bin/sh\n");
                out.write ("#\n");
                out.write ("# Runs jEdit - Programmer's Text Editor.\n");
                out.write ("#\n");
                out.write ("\n");
                out.write ("# Set jvm heap initial and maximum sizes (in megabytes).\n");
                out.write ("JAVA_HEAP_MAX_SIZE=192\n");
                out.write ("\n");
                out.write ("DEFAULT_JAVA_HOME=\"" + System.getProperty ("java.home") + "\"\n");
                out.write ("if [ -z \"$JAVA_HOME\" ]; then\n");
                out.write ("\tJAVA_HOME=\"$DEFAULT_JAVA_HOME\"\n");
                out.write ("fi\n");
                out.write ("\n");
                out.write ("# Launch application.\n");
                out.write ("\n");
                String jar = "\"" + installDir + File.separator + name.toLowerCase () + ".jar" + "\"";
                out.write ("exec \"$JAVA_HOME/bin/java\"" + " -Xmx${JAVA_HEAP_MAX_SIZE}M -jar " + jar + " \"$@\"\n");
                out.close ();
                String [] chmodArgs = {"chmod", "755", script};
                exec (chmodArgs);
            }

        }

        public class ManPageOSTask extends OSTask {

            public ManPageOSTask (Install installer) {
                super (installer, "unix-man");
            }

            public String getDefaultDirectory (Install installer) {
                String dir = "/usr/local/";
                if (! new File (dir).canWrite ()) dir = System.getProperty ("user.home");

                return new File (dir, "man/man1").getPath ();
            }

            public void perform (String installDir, Vector filesets) throws IOException {
                if (! enabled) return;

                mkdirs (directory);
                String name = installer.getProperty ("app.name");
                String manpage = installer.getProperty ("ostask.unix-man.manpage");
                InputStream in = getClass ().getResourceAsStream ("/" + manpage);
                installer.copy (in, new File (directory, manpage).getPath (), null);
            }

        }

        public OSTask [] getOSTasks (Install installer) {
            return new OSTask [] {new ScriptOSTask (installer), new ManPageOSTask (installer)};
        }

        public void mkdirs (String directory) throws IOException {
            File file = new File (directory);
            if (! file.exists ()) {
                String [] mkdirArgs = {"mkdir", "-m", "755", "-p", directory};
                exec (mkdirArgs);
            }
        }

        public void exec (String [] args) throws IOException {
            Process proc = Runtime.getRuntime ().exec (args);
            proc.getInputStream ().close ();
            proc.getOutputStream ().close ();
            proc.getErrorStream ().close ();
            try {
                proc.waitFor ();
            } catch (InterruptedException ie) {
            }
        }

    }

    public static class MacOS extends Unix {

        public String getInstallDirectory (String name, String version) {
            return "/Applications/" + name + " " + version;
        }

        public String getExtraClassPath () {
            return "/System/Library/Java/:";
        }

    }

    public static class Windows extends OperatingSystem {

        public String getInstallDirectory (String name, String version) {
            String programDir = System.getenv ("ProgramFiles");
            if (programDir == null) {
                programDir = "%ProgramFiles%";
            }
            return programDir + "\\" + name + " " + version;
        }

        public class JEditLauncherOSTask extends OSTask {

            public JEditLauncherOSTask (Install installer) {
                super (installer, "jedit-launcher");
            }

            public String getDefaultDirectory (Install installer) {
                return null;
            }

            public void perform (String installDir, Vector filesets) {
                if (! enabled || ! filesets.contains ("jedit-windows")) return;

                File executable = new File (installDir, "jedit.exe");
                if (! executable.exists ()) return;

                String [] args = {executable.getPath (), "/i", System.getProperty ("java.home") + File.separator + "bin"};
                try {
                    Runtime.getRuntime ().exec (args).waitFor ();
                } catch (IOException io) {
                } catch (InterruptedException ie) {
                }
            }

        }

        public OSTask [] getOSTasks (Install installer) {
            return new OSTask [] {};
        }

    }

    public static class HalfAnOS extends OperatingSystem {

        public String getInstallDirectory (String name, String version) {
            return "C:\\" + name + " " + version;
        }

    }

    public static class VMS extends OperatingSystem {

        public String getInstallDirectory (String name, String version) {
            return "./" + name.toLowerCase () + "/" + version;
        }

    }

    private static OperatingSystem os;
}

</source>
<source file="systems/java/jEdit/trunk/installer/InstallThread.java" startline="1" endline="115">
package installer;

import java.io.*;

import java.util.Vector;

import java.net.*;

public class InstallThread extends Thread {

    public InstallThread (Install installer, Progress progress, String installDir, OperatingSystem.OSTask [] osTasks, int size, Vector components) {
        super ("Install thread");
        this.installer = installer;
        this.progress = progress;
        this.installDir = installDir;
        this.osTasks = osTasks;
        this.size = size;
        this.components = components;
    }

    public void run () {
        progress.setMaximum (size * 1024);
        progress.message ("stopping any jEdit server");
        ServerKiller.quitjEditServer ();
        try {
            for (int i = 0;
            i < components.size (); i ++) {
                String comp = (String) components.elementAt (i);
                progress.message ("Installing " + comp);
                installComponent (comp);
            }
            for (int i = 0;
            i < osTasks.length; i ++) {
                progress.message ("Performing task " + osTasks [i].getName ());
                osTasks [i].perform (installDir, components);
            }
        } catch (FileNotFoundException fnf) {
            progress.error ("The installer could not create the " + "destination directory.\n" + "Maybe you do not have write permission?");
            return;
        } catch (IOException io) {
            progress.error (io.toString ());
            return;
        }
        progress.done ();
    }

    private Install installer;
    private Progress progress;
    private String installDir;
    private OperatingSystem.OSTask [] osTasks;
    private int size;
    private Vector components;

    private void installComponent (String name) throws IOException {
        InputStream in = new BufferedInputStream (getClass ().getResourceAsStream (name + ".tar.bz2"));
        in.read ();
        in.read ();
        TarInputStream tarInput = new TarInputStream (new CBZip2InputStream (in));
        TarEntry entry;
        while ((entry = tarInput.getNextEntry ()) != null) {
            if (entry.isDirectory ()) continue;

            String fileName = entry.getName ();
            String outfile = installDir + File.separatorChar + fileName.replace ('/', File.separatorChar);
            installer.copy (tarInput, outfile, progress);
        }
        tarInput.close ();
    }

}

</source>
<source file="systems/java/jEdit/trunk/installer/TarHeader.java" startline="1" endline="423">
package installer;

public class TarHeader extends Object {
    public static final int NAMELEN = 100;
    public static final int MODELEN = 8;
    public static final int UIDLEN = 8;
    public static final int GIDLEN = 8;
    public static final int CHKSUMLEN = 8;
    public static final int SIZELEN = 12;
    public static final int MAGICLEN = 8;
    public static final int MODTIMELEN = 12;
    public static final int UNAMELEN = 32;
    public static final int GNAMELEN = 32;
    public static final int DEVLEN = 8;
    public static final byte LF_OLDNORM = 0;
    public static final byte LF_NORMAL = (byte) '0';
    public static final byte LF_LINK = (byte) '1';
    public static final byte LF_SYMLINK = (byte) '2';
    public static final byte LF_CHR = (byte) '3';
    public static final byte LF_BLK = (byte) '4';
    public static final byte LF_DIR = (byte) '5';
    public static final byte LF_FIFO = (byte) '6';
    public static final byte LF_CONTIG = (byte) '7';
    public static final String TMAGIC = "ustar";
    public static final String GNU_TMAGIC = "ustar  ";
    public StringBuffer name;
    public int mode;
    public int userId;
    public int groupId;
    public long size;
    public long modTime;
    public int checkSum;
    public byte linkFlag;
    public StringBuffer linkName;
    public StringBuffer magic;
    public StringBuffer userName;
    public StringBuffer groupName;
    public int devMajor;
    public int devMinor;

    public TarHeader () {
        this.magic = new StringBuffer (TarHeader.TMAGIC);
        this.name = new StringBuffer ();
        this.linkName = new StringBuffer ();
        String user = System.getProperty ("user.name", "");
        if (user.length () > 31) user = user.substring (0, 31);

        this.userId = 0;
        this.groupId = 0;
        this.userName = new StringBuffer (user);
        this.groupName = new StringBuffer ("");
    }

    public Object clone () {
        TarHeader hdr = null;
        try {
            hdr = (TarHeader) super.clone ();
            hdr.name = (this.name == null) ? null : new StringBuffer (this.name.toString ());
            hdr.mode = this.mode;
            hdr.userId = this.userId;
            hdr.groupId = this.groupId;
            hdr.size = this.size;
            hdr.modTime = this.modTime;
            hdr.checkSum = this.checkSum;
            hdr.linkFlag = this.linkFlag;
            hdr.linkName = (this.linkName == null) ? null : new StringBuffer (this.linkName.toString ());
            hdr.magic = (this.magic == null) ? null : new StringBuffer (this.magic.toString ());
            hdr.userName = (this.userName == null) ? null : new StringBuffer (this.userName.toString ());
            hdr.groupName = (this.groupName == null) ? null : new StringBuffer (this.groupName.toString ());
            hdr.devMajor = this.devMajor;
            hdr.devMinor = this.devMinor;
        } catch (CloneNotSupportedException ex) {
            ex.printStackTrace ();
        }
        return hdr;
    }

    public String getName () {
        return this.name.toString ();
    }

    public static long parseOctal (byte [] header, int offset, int length) throws InvalidHeaderException {
        long result = 0;
        boolean stillPadding = true;
        int end = offset + length;
        for (int i = offset;
        i < end; ++ i) {
            if (header [i] == 0) break;

            if (header [i] == (byte) ' ' || header [i] == '0') {
                if (stillPadding) continue;

                if (header [i] == (byte) ' ') break;

            }
            stillPadding = false;
            result = (result << 3) + (header [i] - '0');
        }
        return result;
    }

    public static StringBuffer parseName (byte [] header, int offset, int length) throws InvalidHeaderException {
        StringBuffer result = new StringBuffer (length);
        int end = offset + length;
        for (int i = offset;
        i < end; ++ i) {
            if (header [i] == 0) break;

            result.append ((char) header [i]);
        }
        return result;
    }

    public static int getNameBytes (StringBuffer name, byte [] buf, int offset, int length) {
        int i;
        for (i = 0; i < length && i < name.length (); ++ i) {
            buf [offset + i] = (byte) name.charAt (i);
        }
        for (; i < length; ++ i) {
            buf [offset + i] = 0;
        }
        return offset + length;
    }

    public static int getOctalBytes (long value, byte [] buf, int offset, int length) {
        byte [] result = new byte [length];
        int idx = length - 1;
        buf [offset + idx] = 0;
        -- idx;
        buf [offset + idx] = (byte) ' ';
        -- idx;
        if (value == 0) {
            buf [offset + idx] = (byte) '0';
            -- idx;
        } else {
            for (long val = value;
            idx >= 0 && val > 0; -- idx) {
                buf [offset + idx] = (byte) ((byte) '0' + (byte) (val & 7));
                val = val>> 3;
            }
        }
        for (; idx >= 0; -- idx) {
            buf [offset + idx] = (byte) ' ';
        }
        return offset + length;
    }

    public static int getLongOctalBytes (long value, byte [] buf, int offset, int length) {
        byte [] temp = new byte [length + 1];
        TarHeader.getOctalBytes (value, temp, 0, length + 1);
        System.arraycopy (temp, 0, buf, offset, length);
        return offset + length;
    }

    public static int getCheckSumOctalBytes (long value, byte [] buf, int offset, int length) {
        TarHeader.getOctalBytes (value, buf, offset, length);
        buf [offset + length - 1] = (byte) ' ';
        buf [offset + length - 2] = 0;
        return offset + length;
    }

}

</source>
<source file="systems/java/jEdit/trunk/installer/Progress.java" startline="1" endline="31">
package installer;

public interface Progress {

    public void setMaximum (int max);

    public void advance (int value);

    public void done ();

    public void message (String message);

    public void error (String message);

}

</source>
<source file="systems/java/jEdit/trunk/installer/ConsoleProgress.java" startline="1" endline="45">
package installer;

public class ConsoleProgress implements Progress {

    public void setMaximum (int max) {
    }

    public void advance (int value) {
    }

    public void done () {
        System.out.println ("*** Installation complete");
    }

    public void message (String message) {
        System.out.println (message);
    }

    public void error (String message) {
        System.err.println ("*** An error occurred: " + message);
    }

}

</source>
<source file="systems/java/jEdit/trunk/installer/TarEntry.java" startline="1" endline="730">
package installer;

import java.io.*;

import java.util.Date;

public class TarEntry extends Object {
    protected File file;
    protected TarHeader header;

    public TarEntry (String name) {
        this.initialize ();
        this.nameTarHeader (this.header, name);
    }

    public TarEntry (File file) throws InvalidHeaderException {
        this.initialize ();
        this.getFileTarHeader (this.header, file);
    }

    public TarEntry (byte [] headerBuf) throws InvalidHeaderException {
        this.initialize ();
        this.parseTarHeader (this.header, headerBuf);
    }

    private void initialize () {
        this.file = null;
        this.header = new TarHeader ();
    }

    public boolean equals (TarEntry it) {
        return this.header.name.toString ().equals (it.header.name.toString ());
    }

    public boolean isDescendent (TarEntry desc) {
        return desc.header.name.toString ().startsWith (this.header.name.toString ());
    }

    public TarHeader getHeader () {
        return this.header;
    }

    public String getName () {
        return this.header.name.toString ();
    }

    public void setName (String name) {
        this.header.name = new StringBuffer (name);
    }

    public int getUserId () {
        return this.header.userId;
    }

    public void setUserId (int userId) {
        this.header.userId = userId;
    }

    public int getGroupId () {
        return this.header.groupId;
    }

    public void setGroupId (int groupId) {
        this.header.groupId = groupId;
    }

    public String getUserName () {
        return this.header.userName.toString ();
    }

    public void setUserName (String userName) {
        this.header.userName = new StringBuffer (userName);
    }

    public String getGroupName () {
        return this.header.groupName.toString ();
    }

    public void setGroupName (String groupName) {
        this.header.groupName = new StringBuffer (groupName);
    }

    public void setIds (int userId, int groupId) {
        this.setUserId (userId);
        this.setGroupId (groupId);
    }

    public void setNames (String userName, String groupName) {
        this.setUserName (userName);
        this.setGroupName (groupName);
    }

    public void setModTime (long time) {
        this.header.modTime = time / 1000;
    }

    public void setModTime (Date time) {
        this.header.modTime = time.getTime () / 1000;
    }

    public Date getModTime () {
        return new Date (this.header.modTime * 1000);
    }

    public File getFile () {
        return this.file;
    }

    public long getSize () {
        return this.header.size;
    }

    public void setSize (long size) {
        this.header.size = size;
    }

    public void adjustEntryName (byte [] outbuf, String newName) {
        int offset = 0;
        offset = TarHeader.getNameBytes (new StringBuffer (newName), outbuf, offset, TarHeader.NAMELEN);
    }

    public boolean isDirectory () {
        if (this.file != null) return this.file.isDirectory ();

        if (this.header != null) {
            if (this.header.linkFlag == TarHeader.LF_DIR) return true;

            if (this.header.name.toString ().endsWith ("/")) return true;

        }
        return false;
    }

    public void getFileTarHeader (TarHeader hdr, File file) throws InvalidHeaderException {
        this.file = file;
        String name = file.getPath ();
        String osname = System.getProperty ("os.name");
        if (osname != null) {
            String Win32Prefix = "windows";
            if (osname.toLowerCase ().startsWith (Win32Prefix)) {
                if (name.length () > 2) {
                    char ch1 = name.charAt (0);
                    char ch2 = name.charAt (1);
                    if (ch2 == ':' && ((ch1 >= 'a' && ch1 <= 'z') || (ch1 >= 'A' && ch1 <= 'Z'))) {
                        name = name.substring (2);
                    }
                }
            }
        }
        name = name.replace (File.separatorChar, '/');
        for (; name.startsWith ("/");) name = name.substring (1);

        hdr.linkName = new StringBuffer ("");
        hdr.name = new StringBuffer (name);
        if (file.isDirectory ()) {
            hdr.mode = 040755;
            hdr.linkFlag = TarHeader.LF_DIR;
            if (hdr.name.charAt (hdr.name.length () - 1) != '/') hdr.name.append ("/");

        } else {
            hdr.mode = 0100644;
            hdr.linkFlag = TarHeader.LF_NORMAL;
        }
        hdr.size = file.length ();
        hdr.modTime = file.lastModified () / 1000;
        hdr.checkSum = 0;
        hdr.devMajor = 0;
        hdr.devMinor = 0;
    }

    public TarEntry [] getDirectoryEntries () throws InvalidHeaderException {
        if (this.file == null || ! this.file.isDirectory ()) {
            return new TarEntry [0];
        }
        String [] list = this.file.list ();
        TarEntry [] result = new TarEntry [list.length];
        for (int i = 0;
        i < list.length; ++ i) {
            result [i] = new TarEntry (new File (this.file, list [i]));
        }
        return result;
    }

    public long computeCheckSum (byte [] buf) {
        long sum = 0;
        for (int i = 0;
        i < buf.length; ++ i) {
            sum += 255 & buf [i];
        }
        return sum;
    }

    public void writeEntryHeader (byte [] outbuf) {
        int offset = 0;
        offset = TarHeader.getNameBytes (this.header.name, outbuf, offset, TarHeader.NAMELEN);
        offset = TarHeader.getOctalBytes (this.header.mode, outbuf, offset, TarHeader.MODELEN);
        offset = TarHeader.getOctalBytes (this.header.userId, outbuf, offset, TarHeader.UIDLEN);
        offset = TarHeader.getOctalBytes (this.header.groupId, outbuf, offset, TarHeader.GIDLEN);
        long size = this.header.size;
        offset = TarHeader.getLongOctalBytes (size, outbuf, offset, TarHeader.SIZELEN);
        offset = TarHeader.getLongOctalBytes (this.header.modTime, outbuf, offset, TarHeader.MODTIMELEN);
        int csOffset = offset;
        for (int c = 0;
        c < TarHeader.CHKSUMLEN; ++ c) outbuf [offset ++] = (byte) ' ';

        outbuf [offset ++] = this.header.linkFlag;
        offset = TarHeader.getNameBytes (this.header.linkName, outbuf, offset, TarHeader.NAMELEN);
        offset = TarHeader.getNameBytes (this.header.magic, outbuf, offset, TarHeader.MAGICLEN);
        offset = TarHeader.getNameBytes (this.header.userName, outbuf, offset, TarHeader.UNAMELEN);
        offset = TarHeader.getNameBytes (this.header.groupName, outbuf, offset, TarHeader.GNAMELEN);
        offset = TarHeader.getOctalBytes (this.header.devMajor, outbuf, offset, TarHeader.DEVLEN);
        offset = TarHeader.getOctalBytes (this.header.devMinor, outbuf, offset, TarHeader.DEVLEN);
        for (; offset < outbuf.length;) outbuf [offset ++] = 0;

        long checkSum = this.computeCheckSum (outbuf);
        TarHeader.getCheckSumOctalBytes (checkSum, outbuf, csOffset, TarHeader.CHKSUMLEN);
    }

    public void parseTarHeader (TarHeader hdr, byte [] header) throws InvalidHeaderException {
        int offset = 0;
        hdr.name = TarHeader.parseName (header, offset, TarHeader.NAMELEN);
        offset += TarHeader.NAMELEN;
        hdr.mode = (int) TarHeader.parseOctal (header, offset, TarHeader.MODELEN);
        offset += TarHeader.MODELEN;
        hdr.userId = (int) TarHeader.parseOctal (header, offset, TarHeader.UIDLEN);
        offset += TarHeader.UIDLEN;
        hdr.groupId = (int) TarHeader.parseOctal (header, offset, TarHeader.GIDLEN);
        offset += TarHeader.GIDLEN;
        hdr.size = TarHeader.parseOctal (header, offset, TarHeader.SIZELEN);
        offset += TarHeader.SIZELEN;
        hdr.modTime = TarHeader.parseOctal (header, offset, TarHeader.MODTIMELEN);
        offset += TarHeader.MODTIMELEN;
        hdr.checkSum = (int) TarHeader.parseOctal (header, offset, TarHeader.CHKSUMLEN);
        offset += TarHeader.CHKSUMLEN;
        hdr.linkFlag = header [offset ++];
        hdr.linkName = TarHeader.parseName (header, offset, TarHeader.NAMELEN);
        offset += TarHeader.NAMELEN;
        hdr.magic = TarHeader.parseName (header, offset, TarHeader.MAGICLEN);
        offset += TarHeader.MAGICLEN;
        hdr.userName = TarHeader.parseName (header, offset, TarHeader.UNAMELEN);
        offset += TarHeader.UNAMELEN;
        hdr.groupName = TarHeader.parseName (header, offset, TarHeader.GNAMELEN);
        offset += TarHeader.GNAMELEN;
        hdr.devMajor = (int) TarHeader.parseOctal (header, offset, TarHeader.DEVLEN);
        offset += TarHeader.DEVLEN;
        hdr.devMinor = (int) TarHeader.parseOctal (header, offset, TarHeader.DEVLEN);
    }

    public void nameTarHeader (TarHeader hdr, String name) {
        boolean isDir = name.endsWith ("/");
        hdr.checkSum = 0;
        hdr.devMajor = 0;
        hdr.devMinor = 0;
        hdr.name = new StringBuffer (name);
        hdr.mode = isDir ? 040755 : 0100644;
        hdr.userId = 0;
        hdr.groupId = 0;
        hdr.size = 0;
        hdr.checkSum = 0;
        hdr.modTime = (new java.util.Date ()).getTime () / 1000;
        hdr.linkFlag = isDir ? TarHeader.LF_DIR : TarHeader.LF_NORMAL;
        hdr.linkName = new StringBuffer ("");
        hdr.userName = new StringBuffer ("");
        hdr.groupName = new StringBuffer ("");
        hdr.devMajor = 0;
        hdr.devMinor = 0;
    }

}

</source>
<source file="systems/java/jEdit/trunk/installer/TarBuffer.java" startline="1" endline="485">
package installer;

import java.io.*;

public class TarBuffer extends Object {
    public static final int DEFAULT_RCDSIZE = (512);
    public static final int DEFAULT_BLKSIZE = (DEFAULT_RCDSIZE * 20);
    private InputStream inStream;
    private OutputStream outStream;
    private byte [] blockBuffer;
    private int currBlkIdx;
    private int currRecIdx;
    private int blockSize;
    private int recordSize;
    private int recsPerBlock;
    private boolean debug;

    public TarBuffer (InputStream inStream) {
        this (inStream, TarBuffer.DEFAULT_BLKSIZE);
    }

    public TarBuffer (InputStream inStream, int blockSize) {
        this (inStream, blockSize, TarBuffer.DEFAULT_RCDSIZE);
    }

    public TarBuffer (InputStream inStream, int blockSize, int recordSize) {
        this.inStream = inStream;
        this.outStream = null;
        this.initialize (blockSize, recordSize);
    }

    public TarBuffer (OutputStream outStream) {
        this (outStream, TarBuffer.DEFAULT_BLKSIZE);
    }

    public TarBuffer (OutputStream outStream, int blockSize) {
        this (outStream, blockSize, TarBuffer.DEFAULT_RCDSIZE);
    }

    public TarBuffer (OutputStream outStream, int blockSize, int recordSize) {
        this.inStream = null;
        this.outStream = outStream;
        this.initialize (blockSize, recordSize);
    }

    private void initialize (int blockSize, int recordSize) {
        this.debug = false;
        this.blockSize = blockSize;
        this.recordSize = recordSize;
        this.recsPerBlock = (this.blockSize / this.recordSize);
        this.blockBuffer = new byte [this.blockSize];
        if (this.inStream != null) {
            this.currBlkIdx = - 1;
            this.currRecIdx = this.recsPerBlock;
        } else {
            this.currBlkIdx = 0;
            this.currRecIdx = 0;
        }
    }

    public int getBlockSize () {
        return this.blockSize;
    }

    public int getRecordSize () {
        return this.recordSize;
    }

    public void setDebug (boolean debug) {
        this.debug = debug;
    }

    public boolean isEOFRecord (byte [] record) {
        for (int i = 0, sz = this.getRecordSize ();
        i < sz; ++ i) if (record [i] != 0) return false;

        return true;
    }

    public void skipRecord () throws IOException {
        if (this.debug) {
            System.err.println ("SkipRecord: recIdx = " + this.currRecIdx + " blkIdx = " + this.currBlkIdx);
        }
        if (this.inStream == null) throw new IOException ("reading (via skip) from an output buffer");

        if (this.currRecIdx >= this.recsPerBlock) {
            if (! this.readBlock ()) return;

        }
        this.currRecIdx ++;
    }

    public byte [] readRecord () throws IOException {
        if (this.debug) {
            System.err.println ("ReadRecord: recIdx = " + this.currRecIdx + " blkIdx = " + this.currBlkIdx);
        }
        if (this.inStream == null) throw new IOException ("reading from an output buffer");

        if (this.currRecIdx >= this.recsPerBlock) {
            if (! this.readBlock ()) return null;

        }
        byte [] result = new byte [this.recordSize];
        System.arraycopy (this.blockBuffer, (this.currRecIdx * this.recordSize), result, 0, this.recordSize);
        this.currRecIdx ++;
        return result;
    }

    private boolean readBlock () throws IOException {
        if (this.debug) {
            System.err.println ("ReadBlock: blkIdx = " + this.currBlkIdx);
        }
        if (this.inStream == null) throw new IOException ("reading from an output buffer");

        this.currRecIdx = 0;
        int offset = 0;
        int bytesNeeded = this.blockSize;
        for (; bytesNeeded > 0;) {
            long numBytes = this.inStream.read (this.blockBuffer, offset, bytesNeeded);
            if (numBytes == - 1) break;

            offset += numBytes;
            bytesNeeded -= numBytes;
            if (numBytes != this.blockSize) {
                if (this.debug) {
                    System.err.println ("ReadBlock: INCOMPLETE READ " + numBytes + " of " + this.blockSize + " bytes read.");
                }
            }
        }
        this.currBlkIdx ++;
        return true;
    }

    public int getCurrentBlockNum () {
        return this.currBlkIdx;
    }

    public int getCurrentRecordNum () {
        return this.currRecIdx - 1;
    }

    public void writeRecord (byte [] record) throws IOException {
        if (this.debug) {
            System.err.println ("WriteRecord: recIdx = " + this.currRecIdx + " blkIdx = " + this.currBlkIdx);
        }
        if (this.outStream == null) throw new IOException ("writing to an input buffer");

        if (record.length != this.recordSize) throw new IOException ("record to write has length '" + record.length + "' which is not the record size of '" + this.recordSize + "'");

        if (this.currRecIdx >= this.recsPerBlock) {
            this.writeBlock ();
        }
        System.arraycopy (record, 0, this.blockBuffer, (this.currRecIdx * this.recordSize), this.recordSize);
        this.currRecIdx ++;
    }

    public void writeRecord (byte [] buf, int offset) throws IOException {
        if (this.debug) {
            System.err.println ("WriteRecord: recIdx = " + this.currRecIdx + " blkIdx = " + this.currBlkIdx);
        }
        if (this.outStream == null) throw new IOException ("writing to an input buffer");

        if ((offset + this.recordSize) > buf.length) throw new IOException ("record has length '" + buf.length + "' with offset '" + offset + "' which is less than the record size of '" + this.recordSize + "'");

        if (this.currRecIdx >= this.recsPerBlock) {
            this.writeBlock ();
        }
        System.arraycopy (buf, offset, this.blockBuffer, (this.currRecIdx * this.recordSize), this.recordSize);
        this.currRecIdx ++;
    }

    private void writeBlock () throws IOException {
        if (this.debug) {
            System.err.println ("WriteBlock: blkIdx = " + this.currBlkIdx);
        }
        if (this.outStream == null) throw new IOException ("writing to an input buffer");

        this.outStream.write (this.blockBuffer, 0, this.blockSize);
        this.outStream.flush ();
        this.currRecIdx = 0;
        this.currBlkIdx ++;
    }

    private void flushBlock () throws IOException {
        if (this.debug) {
            System.err.println ("TarBuffer.flushBlock() called.");
        }
        if (this.outStream == null) throw new IOException ("writing to an input buffer");

        if (this.currRecIdx > 0) {
            this.writeBlock ();
        }
    }

    public void close () throws IOException {
        if (this.debug) {
            System.err.println ("TarBuffer.closeBuffer().");
        }
        if (this.outStream != null) {
            this.flushBlock ();
            if (this.outStream != System.out && this.outStream != System.err) {
                this.outStream.close ();
                this.outStream = null;
            }
        } else if (this.inStream != null) {
            if (this.inStream != System.in) {
                this.inStream.close ();
                this.inStream = null;
            }
        }

    }

}

</source>
<source file="systems/java/jEdit/trunk/installer/TarOutputStream.java" startline="1" endline="331">
package installer;

import java.io.*;

public class TarOutputStream extends FilterOutputStream {
    protected boolean debug;
    protected int currSize;
    protected int currBytes;
    protected byte [] oneBuf;
    protected byte [] recordBuf;
    protected int assemLen;
    protected byte [] assemBuf;
    protected TarBuffer buffer;

    public TarOutputStream (OutputStream os) {
        this (os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);
    }

    public TarOutputStream (OutputStream os, int blockSize) {
        this (os, blockSize, TarBuffer.DEFAULT_RCDSIZE);
    }

    public TarOutputStream (OutputStream os, int blockSize, int recordSize) {
        super (os);
        this.buffer = new TarBuffer (os, blockSize, recordSize);
        this.debug = false;
        this.assemLen = 0;
        this.assemBuf = new byte [recordSize];
        this.recordBuf = new byte [recordSize];
        this.oneBuf = new byte [1];
    }

    public void setDebug (boolean debugF) {
        this.debug = debugF;
    }

    public void setBufferDebug (boolean debug) {
        this.buffer.setDebug (debug);
    }

    public void finish () throws IOException {
        this.writeEOFRecord ();
    }

    public void close () throws IOException {
        this.finish ();
        this.buffer.close ();
    }

    public int getRecordSize () {
        return this.buffer.getRecordSize ();
    }

    public void putNextEntry (TarEntry entry) throws IOException {
        if (entry.getHeader ().name.length () > TarHeader.NAMELEN) throw new InvalidHeaderException ("file name '" + entry.getHeader ().name + "' is too long ( > " + TarHeader.NAMELEN + " bytes )");

        entry.writeEntryHeader (this.recordBuf);
        this.buffer.writeRecord (this.recordBuf);
        this.currBytes = 0;
        if (entry.isDirectory ()) this.currSize = 0;
        else this.currSize = (int) entry.getSize ();

    }

    public void closeEntry () throws IOException {
        if (this.assemLen > 0) {
            for (int i = this.assemLen;
            i < this.assemBuf.length; ++ i) this.assemBuf [i] = 0;

            this.buffer.writeRecord (this.assemBuf);
            this.currBytes += this.assemLen;
            this.assemLen = 0;
        }
        if (this.currBytes < this.currSize) throw new IOException ("entry closed at '" + this.currBytes + "' before the '" + this.currSize + "' bytes specified in the header were written");

    }

    public void write (int b) throws IOException {
        this.oneBuf [0] = (byte) b;
        this.write (this.oneBuf, 0, 1);
    }

    public void write (byte [] wBuf) throws IOException {
        this.write (wBuf, 0, wBuf.length);
    }

    public void write (byte [] wBuf, int wOffset, int numToWrite) throws IOException {
        if ((this.currBytes + numToWrite) > this.currSize) throw new IOException ("request to write '" + numToWrite + "' bytes exceeds size in header of '" + this.currSize + "' bytes");

        if (this.assemLen > 0) {
            if ((this.assemLen + numToWrite) >= this.recordBuf.length) {
                int aLen = this.recordBuf.length - this.assemLen;
                System.arraycopy (this.assemBuf, 0, this.recordBuf, 0, this.assemLen);
                System.arraycopy (wBuf, wOffset, this.recordBuf, this.assemLen, aLen);
                this.buffer.writeRecord (this.recordBuf);
                this.currBytes += this.recordBuf.length;
                wOffset += aLen;
                numToWrite -= aLen;
                this.assemLen = 0;
            } else {
                System.arraycopy (wBuf, wOffset, this.assemBuf, this.assemLen, numToWrite);
                wOffset += numToWrite;
                this.assemLen += numToWrite;
                numToWrite -= numToWrite;
            }
        }
        for (; numToWrite > 0;) {
            if (numToWrite < this.recordBuf.length) {
                System.arraycopy (wBuf, wOffset, this.assemBuf, this.assemLen, numToWrite);
                this.assemLen += numToWrite;
                break;
            }
            this.buffer.writeRecord (wBuf, wOffset);
            int num = this.recordBuf.length;
            this.currBytes += num;
            numToWrite -= num;
            wOffset += num;
        }
    }

    private void writeEOFRecord () throws IOException {
        for (int i = 0;
        i < this.recordBuf.length; ++ i) this.recordBuf [i] = 0;

        this.buffer.writeRecord (this.recordBuf);
    }

}

</source>
<source file="systems/java/jEdit/trunk/installer/SwingInstall.java" startline="1" endline="785">
package installer;

import javax.swing.border.*;

import javax.swing.*;

import javax.swing.text.JTextComponent;

import java.awt.event.*;

import java.awt.*;

import java.io.File;

import java.io.IOException;

import java.util.*;

public class SwingInstall extends JFrame {

    public SwingInstall () {
        installer = new Install ();
        osTasks = OperatingSystem.getOperatingSystem ().getOSTasks (installer);
        appName = installer.getProperty ("app.name");
        appVersion = installer.getProperty ("app.version");
        setTitle (appName + " " + appVersion + " installer");
        JPanel content = new JPanel (new WizardLayout ());
        setContentPane (content);
        caption = new JLabel ();
        caption.setFont (new Font ("SansSerif", Font.BOLD, 18));
        ActionHandler actionHandler = new ActionHandler ();
        cancelButton = new JButton ("Cancel");
        cancelButton.setRequestFocusEnabled (false);
        cancelButton.addActionListener (actionHandler);
        prevButton = new JButton ("Previous");
        prevButton.setRequestFocusEnabled (false);
        prevButton.addActionListener (actionHandler);
        nextButton = new JButton ();
        nextButton.setRequestFocusEnabled (false);
        nextButton.addActionListener (actionHandler);
        content.add (caption);
        content.add (cancelButton);
        content.add (prevButton);
        content.add (nextButton);
        String clazz = OperatingSystem.getOperatingSystem ().getClass ().getName ();
        String completedInfo = "done-" + clazz.substring (clazz.indexOf ('$') + 1) + ".html";
        pages = new Component [] {new TextPanel (installer.getProperty ("app.readme")), new TextPanel (installer.getProperty ("app.license")), chooseDirectory = new ChooseDirectory (), selectComponents = new SelectComponents (), progress = new SwingProgress (), new TextPanel (completedInfo)};
        for (int i = 0;
        i < pages.length; i ++) content.add (pages [i]);

        pageChanged ();
        setDefaultCloseOperation (DO_NOTHING_ON_CLOSE);
        addWindowListener (new WindowHandler ());
        Dimension screen = getToolkit ().getScreenSize ();
        pack ();
        setLocation ((screen.width - getSize ().width) / 2, (screen.height - getSize ().height) / 2);
        setVisible (true);
    }

    Install installer;
    OperatingSystem.OSTask [] osTasks;
    String appName;
    String appVersion;
    JLabel caption;
    ChooseDirectory chooseDirectory;
    SelectComponents selectComponents;
    SwingProgress progress;
    JButton cancelButton;
    JButton prevButton;
    JButton nextButton;
    Component [] pages;
    int currentPage;
    private static final int PADDING = 12;

    void install () {
        Vector components = new Vector ();
        int size = 0;
        JPanel comp = selectComponents.comp;
        Vector ids = selectComponents.filesets;
        for (int i = 0;
        i < comp.getComponentCount (); i ++) {
            if (((JCheckBox) comp.getComponent (i)).getModel ().isSelected ()) {
                size += installer.getIntegerProperty ("comp." + ids.elementAt (i) + ".real-size");
                components.addElement (installer.getProperty ("comp." + ids.elementAt (i) + ".fileset"));
            }
        }
        String installDir = chooseDirectory.installDir.getText ();
        Map osTaskDirs = chooseDirectory.osTaskDirs;
        Iterator keys = osTaskDirs.keySet ().iterator ();
        while (keys.hasNext ()) {
            OperatingSystem.OSTask osTask = (OperatingSystem.OSTask) keys.next ();
            String dir = ((JTextField) osTaskDirs.get (osTask)).getText ();
            if (dir != null && dir.trim ().length () != 0) {
                osTask.setEnabled (true);
                osTask.setDirectory (dir);
            } else osTask.setEnabled (false);

        }
        InstallThread thread = new InstallThread (installer, progress, installDir, osTasks, size, components);
        progress.setThread (thread);
        thread.start ();
    }

    private void pageChanged () {
        switch (currentPage) {
            case 0 :
                caption.setText ("Installing " + appName);
                nextButton.setText ("Next");
                prevButton.setEnabled (false);
                nextButton.setEnabled (true);
                break;
            case 1 :
                caption.setText (installer.getProperty ("app.license.title"));
                nextButton.setText ("Next");
                prevButton.setEnabled (true);
                nextButton.setEnabled (true);
                break;
            case 2 :
                caption.setText ("Specify where " + appName + " is to be installed");
                nextButton.setText ("Next");
                prevButton.setEnabled (true);
                if (! chooseDirectory.isOK ()) nextButton.setEnabled (false);

                break;
            case 3 :
                caption.setText ("Choose components to install");
                nextButton.setText ("Install");
                prevButton.setEnabled (true);
                nextButton.setEnabled (true);
                break;
            case 4 :
                caption.setText ("Installing " + appName);
                nextButton.setText ("Finish");
                prevButton.setEnabled (false);
                nextButton.setEnabled (false);
                install ();
                break;
            case 5 :
                caption.setText ("Installation complete");
                nextButton.setText ("Finish");
                prevButton.setEnabled (false);
                nextButton.setEnabled (true);
                cancelButton.setEnabled (false);
                break;
        }
        getRootPane ().invalidate ();
        getRootPane ().validate ();
    }

    class ActionHandler implements ActionListener {

        public void actionPerformed (ActionEvent evt) {
            Object source = evt.getSource ();
            if (source == cancelButton) System.exit (0);
            else if (source == prevButton) {
                currentPage --;
                pageChanged ();
            } else if (source == nextButton) {
                if (currentPage == pages.length - 1) System.exit (0);
                else {
                    currentPage ++;
                    pageChanged ();
                }
            }

        }

    }

    class WindowHandler extends WindowAdapter {

        public void windowClosing (WindowEvent evt) {
            System.exit (0);
        }

    }

    class WizardLayout implements LayoutManager {

        public void addLayoutComponent (String name, Component comp) {
        }

        public void removeLayoutComponent (Component comp) {
        }

        public Dimension preferredLayoutSize (Container parent) {
            Dimension dim = new Dimension ();
            Dimension captionSize = caption.getPreferredSize ();
            dim.width = captionSize.width;
            for (int i = 0;
            i < pages.length; i ++) {
                Dimension _dim = pages [i].getPreferredSize ();
                dim.width = Math.max (_dim.width, dim.width);
                dim.height = Math.max (_dim.height, dim.height);
            }
            dim.width += PADDING * 2;
            dim.height += PADDING * 2;
            dim.height += nextButton.getPreferredSize ().height;
            dim.height += captionSize.height;
            return dim;
        }

        public Dimension minimumLayoutSize (Container parent) {
            return preferredLayoutSize (parent);
        }

        public void layoutContainer (Container parent) {
            Dimension size = parent.getSize ();
            Dimension captionSize = caption.getPreferredSize ();
            caption.setBounds (PADDING, PADDING, captionSize.width, captionSize.height);
            Dimension buttonSize = cancelButton.getPreferredSize ();
            buttonSize.width = Math.max (buttonSize.width, prevButton.getPreferredSize ().width);
            buttonSize.width = Math.max (buttonSize.width, nextButton.getPreferredSize ().width);
            cancelButton.setBounds (PADDING, size.height - buttonSize.height - PADDING, buttonSize.width, buttonSize.height);
            prevButton.setBounds (size.width - buttonSize.width * 2 - 6 - PADDING, size.height - buttonSize.height - PADDING, buttonSize.width, buttonSize.height);
            nextButton.setBounds (size.width - buttonSize.width - PADDING, size.height - buttonSize.height - PADDING, buttonSize.width, buttonSize.height);
            Rectangle currentPageBounds = new Rectangle ();
            currentPageBounds.x = PADDING;
            currentPageBounds.y = PADDING * 2 + captionSize.height;
            currentPageBounds.width = size.width - currentPageBounds.x - PADDING;
            currentPageBounds.height = size.height - buttonSize.height - currentPageBounds.y - PADDING * 2;
            for (int i = 0;
            i < pages.length; i ++) {
                Component page = pages [i];
                page.setBounds (currentPageBounds);
                page.setVisible (i == currentPage);
            }
        }

    }

    class TextPanel extends JPanel {

        TextPanel (String file) {
            super (new BorderLayout ());
            JEditorPane text = new JEditorPane ();
            try {
                text.setPage (TextPanel.this.getClass ().getResource (file));
            } catch (Exception e) {
                text.setText ("Error loading '" + file + "'");
                e.printStackTrace ();
            }
            text.setEditable (false);
            JScrollPane scrollPane = new JScrollPane (text);
            Dimension dim = new Dimension ();
            dim.width = 450;
            dim.height = 200;
            scrollPane.setPreferredSize (dim);
            TextPanel.this.add (BorderLayout.CENTER, scrollPane);
        }

    }

    class DirVerifier extends InputVerifier {
        private JTextComponent message;
        private Object pos;
        private JComponent parent;

        public DirVerifier (JComponent parent, Object pos) {
            super ();
            message = new JTextArea (" ");
            message.setEditable (false);
            message.setBackground (parent.getBackground ());
            this.parent = parent;
            this.pos = pos;
        }

        public boolean shouldYieldFocus (JComponent input) {
            return verify (input);
        }

        public boolean verify (JComponent input) {
            if (input instanceof JTextComponent) {
                String dir = ((JTextComponent) input).getText ();
                if (checkNull (dir) && checkExistNotDirectory (dir) && checkExistNotEmpty (dir) && checkRelative (dir)) {
                    if (message.getParent () != null) {
                        SwingUtilities.invokeLater (new Runnable () {

                            public void run () {
                                parent.remove (message);
                                parent.revalidate ();
                                parent.repaint ();
                            }

                        }

                        );
                    }
                } else {
                    if (message.getParent () == null) {
                        SwingUtilities.invokeLater (new Runnable () {

                            public void run () {
                                parent.add (message, pos);
                                parent.revalidate ();
                                parent.repaint ();
                            }

                        }

                        );
                    } else message.repaint ();

                }
            }
            return true;
        }

        private boolean checkNull (String file) {
            if (file.trim ().length () == 0) {
                message.setForeground (Color.red);
                message.setText (installer.getProperty ("dir.null"));
                return false;
            } else return true;

        }

        private boolean checkRelative (String dir) {
            File f = new File (dir);
            if (! f.isAbsolute ()) {
                String msg = installer.getProperty ("dir.relative");
                try {
                    String full = f.getCanonicalPath ();
                    message.setForeground (Color.orange);
                    message.setText (msg + '\n' + full);
                } catch (IOException ioe) {
                    message.setForeground (Color.red);
                    msg = installer.getProperty ("dir.cant-resolve");
                    message.setText (msg);
                }
                return false;
            } else return true;

        }

        private boolean checkExistNotDirectory (String dir) {
            File f = new File (dir);
            if (f.exists () && ! f.isDirectory ()) {
                message.setForeground (Color.red);
                message.setText (installer.getProperty ("dir.not-directory"));
                return false;
            } else return true;

        }

        private boolean checkExistNotEmpty (String dir) {
            File f = new File (dir);
            String [] cnt = f.list ();
            if (cnt != null && cnt.length > 0) {
                message.setForeground (Color.orange);
                message.setText (installer.getProperty ("dir.not-empty"));
                return false;
            } else return true;

        }

    }

    class ChooseDirectory extends JPanel {
        JTextField installDir;
        Map osTaskDirs;

        ChooseDirectory () {
            super (new BorderLayout ());
            osTaskDirs = new HashMap ();
            JPanel directoryPanel = new JPanel (new GridBagLayout ());
            installDir = addField (directoryPanel, "Install program in:", OperatingSystem.getOperatingSystem ().getInstallDirectory (appName, appVersion));
            installDir.addFocusListener (new FocusAdapter () {

                public void focusLost (FocusEvent fe) {
                    nextButton.setEnabled (isOK ());
                }

            }

            );
            for (int i = 0;
            i < osTasks.length; i ++) {
                OperatingSystem.OSTask osTask = osTasks [i];
                String label = osTask.getLabel ();
                if (label != null) {
                    JTextField field = addField (directoryPanel, label, osTask.getDirectory ());
                    osTaskDirs.put (osTask, field);
                }
            }
            ChooseDirectory.this.add (BorderLayout.NORTH, directoryPanel);
        }

        boolean isOK () {
            if (installDir.getText ().length () == 0) return false;

            File f = new File (installDir.getText ());
            return ! (f.exists () && ! f.isDirectory ());
        }

        private GridBagConstraints c = new GridBagConstraints ();

        private JTextField addField (JPanel directoryPanel, String label, String defaultText) {
            c.gridy ++;
            JTextField field = new JTextField (defaultText);
            c.insets.bottom = 3;
            c.gridx = 0;
            c.gridwidth = 3;
            c.insets.left = 0;
            c.insets.right = 0;
            c.anchor = GridBagConstraints.LINE_START;
            DirVerifier verif = new DirVerifier (directoryPanel, c.clone ());
            field.setInputVerifier (verif);
            c.insets.bottom = 12;
            c.gridx = 0;
            c.gridy ++;
            c.gridwidth = 1;
            c.anchor = GridBagConstraints.LINE_END;
            directoryPanel.add (new JLabel (label, SwingConstants.RIGHT), c);
            c.gridx = 1;
            c.fill = GridBagConstraints.HORIZONTAL;
            c.anchor = GridBagConstraints.CENTER;
            c.insets.left = 12;
            c.insets.right = 12;
            c.weightx = 1.0;
            directoryPanel.add (field, c);
            JButton choose = new JButton ("Choose...");
            choose.setRequestFocusEnabled (false);
            choose.addActionListener (new ActionHandler (field));
            c.gridx = 2;
            c.insets.left = 0;
            c.insets.right = 0;
            c.fill = GridBagConstraints.NONE;
            c.weightx = 0;
            directoryPanel.add (choose, c);
            return field;
        }

        class ActionHandler implements ActionListener {
            JTextField field;

            ActionHandler (JTextField field) {
                this.field = field;
            }

            public void actionPerformed (ActionEvent evt) {
                File directory = new File (field.getText ());
                JFileChooser chooser = new JFileChooser (directory.getParent ());
                chooser.setFileSelectionMode (JFileChooser.DIRECTORIES_ONLY);
                chooser.setSelectedFile (directory);
                if (chooser.showOpenDialog (SwingInstall.this) == JFileChooser.APPROVE_OPTION) {
                    field.setText (chooser.getSelectedFile ().getPath ());
                    field.getInputVerifier ().verify (field);
                }
            }

        }

    }

    class SelectComponents extends JPanel implements ActionListener {
        JPanel comp;
        JLabel sizeLabel;
        Vector filesets;

        SelectComponents () {
            super (new BorderLayout ());
            comp = createCompPanel ();
            SelectComponents.this.add (BorderLayout.NORTH, comp);
            sizeLabel = new JLabel ("", SwingConstants.LEFT);
            SelectComponents.this.add (BorderLayout.SOUTH, sizeLabel);
            updateSize ();
        }

        public void actionPerformed (ActionEvent evt) {
            updateSize ();
        }

        private JPanel createCompPanel () {
            filesets = new Vector ();
            int count = installer.getIntegerProperty ("comp.count");
            JPanel panel = new JPanel (new GridLayout (count, 1));
            String osClass = OperatingSystem.getOperatingSystem ().getClass ().getName ();
            osClass = osClass.substring (osClass.indexOf ('$') + 1);
            for (int i = 0;
            i < count; i ++) {
                String os = installer.getProperty ("comp." + i + ".os");
                if (os != null && ! osClass.equals (os)) continue;

                JCheckBox checkBox = new JCheckBox (installer.getProperty ("comp." + i + ".name") + " (" + installer.getProperty ("comp." + i + ".disk-size") + "Kb)");
                checkBox.getModel ().setSelected (true);
                checkBox.addActionListener (this);
                checkBox.setRequestFocusEnabled (false);
                filesets.addElement (new Integer (i));
                panel.add (checkBox);
            }
            Dimension dim = panel.getPreferredSize ();
            dim.width = Integer.MAX_VALUE;
            panel.setMaximumSize (dim);
            return panel;
        }

        private void updateSize () {
            int size = 0;
            for (int i = 0;
            i < filesets.size (); i ++) {
                if (((JCheckBox) comp.getComponent (i)).getModel ().isSelected ()) {
                    size += installer.getIntegerProperty ("comp." + filesets.elementAt (i) + ".disk-size");
                }
            }
            sizeLabel.setText ("Estimated disk usage of selected" + " components: " + size + "Kb");
        }

    }

    class SwingProgress extends JPanel implements Progress {
        JProgressBar progress;
        InstallThread thread;

        SwingProgress () {
            super (new BorderLayout ());
            progress = new JProgressBar ();
            progress.setStringPainted (true);
            SwingProgress.this.add (BorderLayout.NORTH, progress);
        }

        public void setMaximum (final int max) {
            SwingUtilities.invokeLater (new Runnable () {

                public void run () {
                    progress.setMaximum (max);
                }

            }

            );
        }

        public void advance (final int value) {
            try {
                SwingUtilities.invokeAndWait (new Runnable () {

                    public void run () {
                        progress.setValue (progress.getValue () + value);
                    }

                }

                );
                Thread.yield ();
            } catch (Exception e) {
            }
        }

        public void done () {
            SwingUtilities.invokeLater (new Runnable () {

                public void run () {
                    currentPage ++;
                    pageChanged ();
                }

            }

            );
        }

        public void error (final String message) {
            SwingUtilities.invokeLater (new Runnable () {

                public void run () {
                    dispose ();
                    JOptionPane.showMessageDialog (null, message, "Installation aborted", JOptionPane.ERROR_MESSAGE);
                    System.exit (1);
                }

            }

            );
        }

        public void message (final String message) {
            SwingUtilities.invokeLater (new Runnable () {

                public void run () {
                    progress.setString (message);
                }

            }

            );
        }

        public void setThread (InstallThread thread) {
            this.thread = thread;
        }

    }

}

</source>
<source file="systems/java/jEdit/trunk/installer/CBZip2OutputStream.java" startline="1" endline="2022">
package installer;

import java.io.IOException;

import java.io.OutputStream;

public class CBZip2OutputStream extends OutputStream implements BZip2Constants {
    private static final int LOWER_BYTE_MASK = 0x000000ff;
    private static final int UPPER_BYTE_MASK = 0xffffff00;
    private static final int SETMASK = (1 << 21);
    private static final int CLEARMASK = (~ SETMASK);
    private static final int GREATER_ICOST = 15;
    private static final int LESSER_ICOST = 0;
    private static final int SMALL_THRESH = 20;
    private static final int DEPTH_THRESH = 10;
    private static final int QSORT_STACK_SIZE = 1000;
    private CRC m_crc = new CRC ();
    private boolean [] m_inUse = new boolean [256];
    private char [] m_seqToUnseq = new char [256];
    private char [] m_unseqToSeq = new char [256];
    private char [] m_selector = new char [MAX_SELECTORS];
    private char [] m_selectorMtf = new char [MAX_SELECTORS];
    private int [] m_mtfFreq = new int [MAX_ALPHA_SIZE];
    private int m_currentChar = - 1;
    private int m_runLength;
    private boolean m_closed;
    private int [] m_incs = new int [] {1, 4, 13, 40, 121, 364, 1093, 3280, 9841, 29524, 88573, 265720, 797161, 2391484};
    private boolean m_blockRandomised;
    private int m_blockSize100k;
    private int m_bsBuff;
    private int m_bsLive;
    private int m_last;
    private int m_origPtr;
    private int m_allowableBlockSize;
    private char [] m_block;
    private int m_blockCRC;
    private int m_combinedCRC;
    private OutputStream m_bsStream;
    private boolean m_firstAttempt;
    private int [] m_ftab;
    private int m_nInUse;
    private int m_nMTF;
    private int [] m_quadrant;
    private short [] m_szptr;
    private int m_workDone;
    private int m_workFactor;
    private int m_workLimit;
    private int [] m_zptr;

    public CBZip2OutputStream (final OutputStream output) throws IOException {
        this (output, 9);
    }

    public CBZip2OutputStream (final OutputStream output, final int blockSize) throws IOException {
        bsSetStream (output);
        m_workFactor = 50;
        int outBlockSize = blockSize;
        if (outBlockSize > 9) {
            outBlockSize = 9;
        }
        if (outBlockSize < 1) {
            outBlockSize = 1;
        }
        m_blockSize100k = outBlockSize;
        allocateCompressStructures ();
        initialize ();
        initBlock ();
    }

    private static void hbMakeCodeLengths (char [] len, int [] freq, int alphaSize, int maxLen) {
        int nNodes;
        int nHeap;
        int n1;
        int n2;
        int i;
        int j;
        int k;
        boolean tooLong;
        int [] heap = new int [MAX_ALPHA_SIZE + 2];
        int [] weights = new int [MAX_ALPHA_SIZE * 2];
        int [] parent = new int [MAX_ALPHA_SIZE * 2];
        for (i = 0; i < alphaSize; i ++) {
            weights [i + 1] = (freq [i] == 0 ? 1 : freq [i]) << 8;
        }
        while (true) {
            nNodes = alphaSize;
            nHeap = 0;
            heap [0] = 0;
            weights [0] = 0;
            parent [0] = - 2;
            for (i = 1; i <= alphaSize; i ++) {
                parent [i] = - 1;
                nHeap ++;
                heap [nHeap] = i;
                {
                    int zz;
                    int tmp;
                    zz = nHeap;
                    tmp = heap [zz];
                    while (weights [tmp] < weights [heap [zz>> 1]]) {
                        heap [zz] = heap [zz>> 1];
                        zz>>= 1;
                    }
                    heap [zz] = tmp;
                }}
            if (! (nHeap < (MAX_ALPHA_SIZE + 2))) {
                panic ();
            }
            while (nHeap > 1) {
                n1 = heap [1];
                heap [1] = heap [nHeap];
                nHeap --;
                {
                    int zz = 0;
                    int yy = 0;
                    int tmp = 0;
                    zz = 1;
                    tmp = heap [zz];
                    while (true) {
                        yy = zz << 1;
                        if (yy > nHeap) {
                            break;
                        }
                        if (yy < nHeap && weights [heap [yy + 1]] < weights [heap [yy]]) {
                            yy ++;
                        }
                        if (weights [tmp] < weights [heap [yy]]) {
                            break;
                        }
                        heap [zz] = heap [yy];
                        zz = yy;
                    }
                    heap [zz] = tmp;
                } n2 = heap [1];
                heap [1] = heap [nHeap];
                nHeap --;
                {
                    int zz = 0;
                    int yy = 0;
                    int tmp = 0;
                    zz = 1;
                    tmp = heap [zz];
                    while (true) {
                        yy = zz << 1;
                        if (yy > nHeap) {
                            break;
                        }
                        if (yy < nHeap && weights [heap [yy + 1]] < weights [heap [yy]]) {
                            yy ++;
                        }
                        if (weights [tmp] < weights [heap [yy]]) {
                            break;
                        }
                        heap [zz] = heap [yy];
                        zz = yy;
                    }
                    heap [zz] = tmp;
                } nNodes ++;
                parent [n1] = nNodes;
                parent [n2] = nNodes;
                final int v1 = weights [n1];
                final int v2 = weights [n2];
                final int weight = calculateWeight (v1, v2);
                weights [nNodes] = weight;
                parent [nNodes] = - 1;
                nHeap ++;
                heap [nHeap] = nNodes;
                {
                    int zz = 0;
                    int tmp = 0;
                    zz = nHeap;
                    tmp = heap [zz];
                    while (weights [tmp] < weights [heap [zz>> 1]]) {
                        heap [zz] = heap [zz>> 1];
                        zz>>= 1;
                    }
                    heap [zz] = tmp;
                }}
            if (! (nNodes < (MAX_ALPHA_SIZE * 2))) {
                panic ();
            }
            tooLong = false;
            for (i = 1; i <= alphaSize; i ++) {
                j = 0;
                k = i;
                while (parent [k] >= 0) {
                    k = parent [k];
                    j ++;
                }
                len [i - 1] = (char) j;
                if (j > maxLen) {
                    tooLong = true;
                }
            }
            if (! tooLong) {
                break;
            }
            for (i = 1; i < alphaSize; i ++) {
                j = weights [i]>> 8;
                j = 1 + (j / 2);
                weights [i] = j << 8;
            }
        }
    }

    private static int calculateWeight (final int v1, final int v2) {
        final int upper = (v1 & UPPER_BYTE_MASK) + (v2 & UPPER_BYTE_MASK);
        final int v1Lower = (v1 & LOWER_BYTE_MASK);
        final int v2Lower = (v2 & LOWER_BYTE_MASK);
        final int nnnn = (v1Lower > v2Lower) ? v1Lower : v2Lower;
        return upper | (1 + nnnn);
    }

    private static void panic () {
        System.out.println ("panic");
    }

    public void close () throws IOException {
        if (m_closed) {
            return;
        }
        if (m_runLength > 0) {
            writeRun ();
        }
        m_currentChar = - 1;
        endBlock ();
        endCompression ();
        m_closed = true;
        super.close ();
        m_bsStream.close ();
    }

    public void finalize () throws Throwable {
        close ();
    }

    public void flush () throws IOException {
        super.flush ();
        m_bsStream.flush ();
    }

    public void write (int bv) throws IOException {
        int b = (256 + bv) % 256;
        if (m_currentChar != - 1) {
            if (m_currentChar == b) {
                m_runLength ++;
                if (m_runLength > 254) {
                    writeRun ();
                    m_currentChar = - 1;
                    m_runLength = 0;
                }
            } else {
                writeRun ();
                m_runLength = 1;
                m_currentChar = b;
            }
        } else {
            m_currentChar = b;
            m_runLength ++;
        }
    }

    private void allocateCompressStructures () {
        int n = BASE_BLOCK_SIZE * m_blockSize100k;
        m_block = new char [(n + 1 + NUM_OVERSHOOT_BYTES)];
        m_quadrant = new int [(n + NUM_OVERSHOOT_BYTES)];
        m_zptr = new int [n];
        m_ftab = new int [65537];
        if (m_block == null || m_quadrant == null || m_zptr == null || m_ftab == null) {
        }
        m_szptr = new short [2 * n];
    }

    private void bsFinishedWithStream () throws IOException {
        while (m_bsLive > 0) {
            int ch = (m_bsBuff>> 24);
            try {
                m_bsStream.write (ch);
            } catch (IOException e) {
                throw e;
            }
            m_bsBuff <<= 8;
            m_bsLive -= 8;
        }
    }

    private void bsPutIntVS (int numBits, int c) throws IOException {
        bsW (numBits, c);
    }

    private void bsPutUChar (int c) throws IOException {
        bsW (8, c);
    }

    private void bsPutint (int u) throws IOException {
        bsW (8, (u>> 24) & 0xff);
        bsW (8, (u>> 16) & 0xff);
        bsW (8, (u>> 8) & 0xff);
        bsW (8, u & 0xff);
    }

    private void bsSetStream (OutputStream f) {
        m_bsStream = f;
        m_bsLive = 0;
        m_bsBuff = 0;
    }

    private void bsW (int n, int v) throws IOException {
        while (m_bsLive >= 8) {
            int ch = (m_bsBuff>> 24);
            try {
                m_bsStream.write (ch);
            } catch (IOException e) {
                throw e;
            }
            m_bsBuff <<= 8;
            m_bsLive -= 8;
        }
        m_bsBuff |= (v << (32 - m_bsLive - n));
        m_bsLive += n;
    }

    private void doReversibleTransformation () {
        int i;
        m_workLimit = m_workFactor * m_last;
        m_workDone = 0;
        m_blockRandomised = false;
        m_firstAttempt = true;
        mainSort ();
        if (m_workDone > m_workLimit && m_firstAttempt) {
            randomiseBlock ();
            m_workLimit = 0;
            m_workDone = 0;
            m_blockRandomised = true;
            m_firstAttempt = false;
            mainSort ();
        }
        m_origPtr = - 1;
        for (i = 0; i <= m_last; i ++) {
            if (m_zptr [i] == 0) {
                m_origPtr = i;
                break;
            }
        }
        if (m_origPtr == - 1) {
            panic ();
        }
    }

    private void endBlock () throws IOException {
        m_blockCRC = m_crc.getFinalCRC ();
        m_combinedCRC = (m_combinedCRC << 1) | (m_combinedCRC>>> 31);
        m_combinedCRC ^= m_blockCRC;
        doReversibleTransformation ();
        bsPutUChar (0x31);
        bsPutUChar (0x41);
        bsPutUChar (0x59);
        bsPutUChar (0x26);
        bsPutUChar (0x53);
        bsPutUChar (0x59);
        bsPutint (m_blockCRC);
        if (m_blockRandomised) {
            bsW (1, 1);
        } else {
            bsW (1, 0);
        }
        moveToFrontCodeAndSend ();
    }

    private void endCompression () throws IOException {
        bsPutUChar (0x17);
        bsPutUChar (0x72);
        bsPutUChar (0x45);
        bsPutUChar (0x38);
        bsPutUChar (0x50);
        bsPutUChar (0x90);
        bsPutint (m_combinedCRC);
        bsFinishedWithStream ();
    }

    private boolean fullGtU (int i1, int i2) {
        int k;
        char c1;
        char c2;
        int s1;
        int s2;
        c1 = m_block [i1 + 1];
        c2 = m_block [i2 + 1];
        if (c1 != c2) {
            return (c1 > c2);
        }
        i1 ++;
        i2 ++;
        c1 = m_block [i1 + 1];
        c2 = m_block [i2 + 1];
        if (c1 != c2) {
            return (c1 > c2);
        }
        i1 ++;
        i2 ++;
        c1 = m_block [i1 + 1];
        c2 = m_block [i2 + 1];
        if (c1 != c2) {
            return (c1 > c2);
        }
        i1 ++;
        i2 ++;
        c1 = m_block [i1 + 1];
        c2 = m_block [i2 + 1];
        if (c1 != c2) {
            return (c1 > c2);
        }
        i1 ++;
        i2 ++;
        c1 = m_block [i1 + 1];
        c2 = m_block [i2 + 1];
        if (c1 != c2) {
            return (c1 > c2);
        }
        i1 ++;
        i2 ++;
        c1 = m_block [i1 + 1];
        c2 = m_block [i2 + 1];
        if (c1 != c2) {
            return (c1 > c2);
        }
        i1 ++;
        i2 ++;
        k = m_last + 1;
        do {
            c1 = m_block [i1 + 1];
            c2 = m_block [i2 + 1];
            if (c1 != c2) {
                return (c1 > c2);
            }
            s1 = m_quadrant [i1];
            s2 = m_quadrant [i2];
            if (s1 != s2) {
                return (s1 > s2);
            }
            i1 ++;
            i2 ++;
            c1 = m_block [i1 + 1];
            c2 = m_block [i2 + 1];
            if (c1 != c2) {
                return (c1 > c2);
            }
            s1 = m_quadrant [i1];
            s2 = m_quadrant [i2];
            if (s1 != s2) {
                return (s1 > s2);
            }
            i1 ++;
            i2 ++;
            c1 = m_block [i1 + 1];
            c2 = m_block [i2 + 1];
            if (c1 != c2) {
                return (c1 > c2);
            }
            s1 = m_quadrant [i1];
            s2 = m_quadrant [i2];
            if (s1 != s2) {
                return (s1 > s2);
            }
            i1 ++;
            i2 ++;
            c1 = m_block [i1 + 1];
            c2 = m_block [i2 + 1];
            if (c1 != c2) {
                return (c1 > c2);
            }
            s1 = m_quadrant [i1];
            s2 = m_quadrant [i2];
            if (s1 != s2) {
                return (s1 > s2);
            }
            i1 ++;
            i2 ++;
            if (i1 > m_last) {
                i1 -= m_last;
                i1 --;
            }
            if (i2 > m_last) {
                i2 -= m_last;
                i2 --;
            }
            k -= 4;
            m_workDone ++;
        } while (k >= 0);
        return false;
    }

    private void generateMTFValues () {
        char [] yy = new char [256];
        int i;
        int j;
        char tmp;
        char tmp2;
        int zPend;
        int wr;
        int EOB;
        makeMaps ();
        EOB = m_nInUse + 1;
        for (i = 0; i <= EOB; i ++) {
            m_mtfFreq [i] = 0;
        }
        wr = 0;
        zPend = 0;
        for (i = 0; i < m_nInUse; i ++) {
            yy [i] = (char) i;
        }
        for (i = 0; i <= m_last; i ++) {
            char ll_i;
            ll_i = m_unseqToSeq [m_block [m_zptr [i]]];
            j = 0;
            tmp = yy [j];
            while (ll_i != tmp) {
                j ++;
                tmp2 = tmp;
                tmp = yy [j];
                yy [j] = tmp2;
            }
            yy [0] = tmp;
            if (j == 0) {
                zPend ++;
            } else {
                if (zPend > 0) {
                    zPend --;
                    while (true) {
                        switch (zPend % 2) {
                            case 0 :
                                m_szptr [wr] = (short) RUNA;
                                wr ++;
                                m_mtfFreq [RUNA] ++;
                                break;
                            case 1 :
                                m_szptr [wr] = (short) RUNB;
                                wr ++;
                                m_mtfFreq [RUNB] ++;
                                break;
                        }
                        if (zPend < 2) {
                            break;
                        }
                        zPend = (zPend - 2) / 2;
                    }
                    zPend = 0;
                }
                m_szptr [wr] = (short) (j + 1);
                wr ++;
                m_mtfFreq [j + 1] ++;
            }
        }
        if (zPend > 0) {
            zPend --;
            while (true) {
                switch (zPend % 2) {
                    case 0 :
                        m_szptr [wr] = (short) RUNA;
                        wr ++;
                        m_mtfFreq [RUNA] ++;
                        break;
                    case 1 :
                        m_szptr [wr] = (short) RUNB;
                        wr ++;
                        m_mtfFreq [RUNB] ++;
                        break;
                }
                if (zPend < 2) {
                    break;
                }
                zPend = (zPend - 2) / 2;
            }
        }
        m_szptr [wr] = (short) EOB;
        wr ++;
        m_mtfFreq [EOB] ++;
        m_nMTF = wr;
    }

    private void hbAssignCodes (int [] code, char [] length, int minLen, int maxLen, int alphaSize) {
        int n;
        int vec;
        int i;
        vec = 0;
        for (n = minLen; n <= maxLen; n ++) {
            for (i = 0; i < alphaSize; i ++) {
                if (length [i] == n) {
                    code [i] = vec;
                    vec ++;
                }
            }
            vec <<= 1;
        }
    }

    private void initBlock () {
        m_crc.initialiseCRC ();
        m_last = - 1;
        for (int i = 0;
        i < 256; i ++) {
            m_inUse [i] = false;
        }
        m_allowableBlockSize = BASE_BLOCK_SIZE * m_blockSize100k - 20;
    }

    private void initialize () throws IOException {
        bsPutUChar ('h');
        bsPutUChar ('0' + m_blockSize100k);
        m_combinedCRC = 0;
    }

    private void mainSort () {
        int i;
        int j;
        int ss;
        int sb;
        int [] runningOrder = new int [256];
        int [] copy = new int [256];
        boolean [] bigDone = new boolean [256];
        int c1;
        int c2;
        for (i = 0; i < NUM_OVERSHOOT_BYTES; i ++) {
            m_block [m_last + i + 2] = m_block [(i % (m_last + 1)) + 1];
        }
        for (i = 0; i <= m_last + NUM_OVERSHOOT_BYTES; i ++) {
            m_quadrant [i] = 0;
        }
        m_block [0] = m_block [m_last + 1];
        if (m_last < 4000) {
            for (i = 0; i <= m_last; i ++) {
                m_zptr [i] = i;
            }
            m_firstAttempt = false;
            m_workDone = 0;
            m_workLimit = 0;
            simpleSort (0, m_last, 0);
        } else {
            for (i = 0; i <= 255; i ++) {
                bigDone [i] = false;
            }
            for (i = 0; i <= 65536; i ++) {
                m_ftab [i] = 0;
            }
            c1 = m_block [0];
            for (i = 0; i <= m_last; i ++) {
                c2 = m_block [i + 1];
                m_ftab [(c1 << 8) + c2] ++;
                c1 = c2;
            }
            for (i = 1; i <= 65536; i ++) {
                m_ftab [i] += m_ftab [i - 1];
            }
            c1 = m_block [1];
            for (i = 0; i < m_last; i ++) {
                c2 = m_block [i + 2];
                j = (c1 << 8) + c2;
                c1 = c2;
                m_ftab [j] --;
                m_zptr [m_ftab [j]] = i;
            }
            j = ((m_block [m_last + 1]) << 8) + (m_block [1]);
            m_ftab [j] --;
            m_zptr [m_ftab [j]] = m_last;
            for (i = 0; i <= 255; i ++) {
                runningOrder [i] = i;
            }
            {
                int vv;
                int h = 1;
                do {
                    h = 3 * h + 1;
                } while (h <= 256);
                do {
                    h = h / 3;
                    for (i = h; i <= 255; i ++) {
                        vv = runningOrder [i];
                        j = i;
                        while ((m_ftab [((runningOrder [j - h]) + 1) << 8] - m_ftab [(runningOrder [j - h]) << 8]) > (m_ftab [((vv) + 1) << 8] - m_ftab [(vv) << 8])) {
                            runningOrder [j] = runningOrder [j - h];
                            j = j - h;
                            if (j <= (h - 1)) {
                                break;
                            }
                        }
                        runningOrder [j] = vv;
                    }
                } while (h != 1);
            } for (i = 0; i <= 255; i ++) {
                ss = runningOrder [i];
                for (j = 0; j <= 255; j ++) {
                    sb = (ss << 8) + j;
                    if (! ((m_ftab [sb] & SETMASK) == SETMASK)) {
                        int lo = m_ftab [sb] & CLEARMASK;
                        int hi = (m_ftab [sb + 1] & CLEARMASK) - 1;
                        if (hi > lo) {
                            qSort3 (lo, hi, 2);
                            if (m_workDone > m_workLimit && m_firstAttempt) {
                                return;
                            }
                        }
                        m_ftab [sb] |= SETMASK;
                    }
                }
                bigDone [ss] = true;
                if (i < 255) {
                    int bbStart = m_ftab [ss << 8] & CLEARMASK;
                    int bbSize = (m_ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;
                    int shifts = 0;
                    while ((bbSize>> shifts) > 65534) {
                        shifts ++;
                    }
                    for (j = 0; j < bbSize; j ++) {
                        int a2update = m_zptr [bbStart + j];
                        int qVal = (j>> shifts);
                        m_quadrant [a2update] = qVal;
                        if (a2update < NUM_OVERSHOOT_BYTES) {
                            m_quadrant [a2update + m_last + 1] = qVal;
                        }
                    }
                    if (! (((bbSize - 1)>> shifts) <= 65535)) {
                        panic ();
                    }
                }
                for (j = 0; j <= 255; j ++) {
                    copy [j] = m_ftab [(j << 8) + ss] & CLEARMASK;
                }
                for (j = m_ftab [ss << 8] & CLEARMASK; j < (m_ftab [(ss + 1) << 8] & CLEARMASK); j ++) {
                    c1 = m_block [m_zptr [j]];
                    if (! bigDone [c1]) {
                        m_zptr [copy [c1]] = m_zptr [j] == 0 ? m_last : m_zptr [j] - 1;
                        copy [c1] ++;
                    }
                }
                for (j = 0; j <= 255; j ++) {
                    m_ftab [(j << 8) + ss] |= SETMASK;
                }
            }
        }
    }

    private void makeMaps () {
        int i;
        m_nInUse = 0;
        for (i = 0; i < 256; i ++) {
            if (m_inUse [i]) {
                m_seqToUnseq [m_nInUse] = (char) i;
                m_unseqToSeq [i] = (char) m_nInUse;
                m_nInUse ++;
            }
        }
    }

    private char med3 (char a, char b, char c) {
        char t;
        if (a > b) {
            t = a;
            a = b;
            b = t;
        }
        if (b > c) {
            t = b;
            b = c;
            c = t;
        }
        if (a > b) {
            b = a;
        }
        return b;
    }

    private void moveToFrontCodeAndSend () throws IOException {
        bsPutIntVS (24, m_origPtr);
        generateMTFValues ();
        sendMTFValues ();
    }

    private void qSort3 (int loSt, int hiSt, int dSt) {
        int unLo;
        int unHi;
        int ltLo;
        int gtHi;
        int med;
        int n;
        int m;
        int sp;
        int lo;
        int hi;
        int d;
        StackElem [] stack = new StackElem [QSORT_STACK_SIZE];
        for (int count = 0;
        count < QSORT_STACK_SIZE; count ++) {
            stack [count] = new StackElem ();
        }
        sp = 0;
        stack [sp].m_ll = loSt;
        stack [sp].m_hh = hiSt;
        stack [sp].m_dd = dSt;
        sp ++;
        while (sp > 0) {
            if (sp >= QSORT_STACK_SIZE) {
                panic ();
            }
            sp --;
            lo = stack [sp].m_ll;
            hi = stack [sp].m_hh;
            d = stack [sp].m_dd;
            if (hi - lo < SMALL_THRESH || d > DEPTH_THRESH) {
                simpleSort (lo, hi, d);
                if (m_workDone > m_workLimit && m_firstAttempt) {
                    return;
                }
                continue;
            }
            med = med3 (m_block [m_zptr [lo] + d + 1], m_block [m_zptr [hi] + d + 1], m_block [m_zptr [(lo + hi)>> 1] + d + 1]);
            unLo = lo;
            ltLo = lo;
            unHi = hi;
            gtHi = hi;
            while (true) {
                while (true) {
                    if (unLo > unHi) {
                        break;
                    }
                    n = m_block [m_zptr [unLo] + d + 1] - med;
                    if (n == 0) {
                        int temp = 0;
                        temp = m_zptr [unLo];
                        m_zptr [unLo] = m_zptr [ltLo];
                        m_zptr [ltLo] = temp;
                        ltLo ++;
                        unLo ++;
                        continue;
                    }
                    if (n > 0) {
                        break;
                    }
                    unLo ++;
                }
                while (true) {
                    if (unLo > unHi) {
                        break;
                    }
                    n = m_block [m_zptr [unHi] + d + 1] - med;
                    if (n == 0) {
                        int temp = 0;
                        temp = m_zptr [unHi];
                        m_zptr [unHi] = m_zptr [gtHi];
                        m_zptr [gtHi] = temp;
                        gtHi --;
                        unHi --;
                        continue;
                    }
                    if (n < 0) {
                        break;
                    }
                    unHi --;
                }
                if (unLo > unHi) {
                    break;
                }
                int temp = 0;
                temp = m_zptr [unLo];
                m_zptr [unLo] = m_zptr [unHi];
                m_zptr [unHi] = temp;
                unLo ++;
                unHi --;
            }
            if (gtHi < ltLo) {
                stack [sp].m_ll = lo;
                stack [sp].m_hh = hi;
                stack [sp].m_dd = d + 1;
                sp ++;
                continue;
            }
            n = ((ltLo - lo) < (unLo - ltLo)) ? (ltLo - lo) : (unLo - ltLo);
            vswap (lo, unLo - n, n);
            m = ((hi - gtHi) < (gtHi - unHi)) ? (hi - gtHi) : (gtHi - unHi);
            vswap (unLo, hi - m + 1, m);
            n = lo + unLo - ltLo - 1;
            m = hi - (gtHi - unHi) + 1;
            stack [sp].m_ll = lo;
            stack [sp].m_hh = n;
            stack [sp].m_dd = d;
            sp ++;
            stack [sp].m_ll = n + 1;
            stack [sp].m_hh = m - 1;
            stack [sp].m_dd = d + 1;
            sp ++;
            stack [sp].m_ll = m;
            stack [sp].m_hh = hi;
            stack [sp].m_dd = d;
            sp ++;
        }
    }

    private void randomiseBlock () {
        int i;
        int rNToGo = 0;
        int rTPos = 0;
        for (i = 0; i < 256; i ++) {
            m_inUse [i] = false;
        }
        for (i = 0; i <= m_last; i ++) {
            if (rNToGo == 0) {
                rNToGo = (char) RAND_NUMS [rTPos];
                rTPos ++;
                if (rTPos == 512) {
                    rTPos = 0;
                }
            }
            rNToGo --;
            m_block [i + 1] ^= ((rNToGo == 1) ? 1 : 0);
            m_block [i + 1] &= 0xFF;
            m_inUse [m_block [i + 1]] = true;
        }
    }

    private void sendMTFValues () throws IOException {
        char [] [] len = new char [N_GROUPS] [MAX_ALPHA_SIZE];
        int v;
        int t;
        int i;
        int j;
        int gs;
        int ge;
        int bt;
        int bc;
        int iter;
        int nSelectors = 0;
        int alphaSize;
        int minLen;
        int maxLen;
        int selCtr;
        int nGroups;
        alphaSize = m_nInUse + 2;
        for (t = 0; t < N_GROUPS; t ++) {
            for (v = 0; v < alphaSize; v ++) {
                len [t] [v] = (char) GREATER_ICOST;
            }
        }
        if (m_nMTF <= 0) {
            panic ();
        }
        if (m_nMTF < 200) {
            nGroups = 2;
        } else if (m_nMTF < 600) {
            nGroups = 3;
        } else if (m_nMTF < 1200) {
            nGroups = 4;
        } else if (m_nMTF < 2400) {
            nGroups = 5;
        } else {
            nGroups = 6;
        }

        {
            int nPart;
            int remF;
            int tFreq;
            int aFreq;
            nPart = nGroups;
            remF = m_nMTF;
            gs = 0;
            while (nPart > 0) {
                tFreq = remF / nPart;
                ge = gs - 1;
                aFreq = 0;
                while (aFreq < tFreq && ge < alphaSize - 1) {
                    ge ++;
                    aFreq += m_mtfFreq [ge];
                }
                if (ge > gs && nPart != nGroups && nPart != 1 && ((nGroups - nPart) % 2 == 1)) {
                    aFreq -= m_mtfFreq [ge];
                    ge --;
                }
                for (v = 0; v < alphaSize; v ++) {
                    if (v >= gs && v <= ge) {
                        len [nPart - 1] [v] = (char) LESSER_ICOST;
                    } else {
                        len [nPart - 1] [v] = (char) GREATER_ICOST;
                    }
                }
                nPart --;
                gs = ge + 1;
                remF -= aFreq;
            }
        } int [] [] rfreq = new int [N_GROUPS] [MAX_ALPHA_SIZE];
        int [] fave = new int [N_GROUPS];
        short [] cost = new short [N_GROUPS];
        for (iter = 0; iter < N_ITERS; iter ++) {
            for (t = 0; t < nGroups; t ++) {
                fave [t] = 0;
            }
            for (t = 0; t < nGroups; t ++) {
                for (v = 0; v < alphaSize; v ++) {
                    rfreq [t] [v] = 0;
                }
            }
            nSelectors = 0;
            gs = 0;
            while (true) {
                if (gs >= m_nMTF) {
                    break;
                }
                ge = gs + G_SIZE - 1;
                if (ge >= m_nMTF) {
                    ge = m_nMTF - 1;
                }
                for (t = 0; t < nGroups; t ++) {
                    cost [t] = 0;
                }
                if (nGroups == 6) {
                    short cost0 = 0;
                    short cost1 = 0;
                    short cost2 = 0;
                    short cost3 = 0;
                    short cost4 = 0;
                    short cost5 = 0;
                    for (i = gs; i <= ge; i ++) {
                        short icv = m_szptr [i];
                        cost0 += len [0] [icv];
                        cost1 += len [1] [icv];
                        cost2 += len [2] [icv];
                        cost3 += len [3] [icv];
                        cost4 += len [4] [icv];
                        cost5 += len [5] [icv];
                    }
                    cost [0] = cost0;
                    cost [1] = cost1;
                    cost [2] = cost2;
                    cost [3] = cost3;
                    cost [4] = cost4;
                    cost [5] = cost5;
                } else {
                    for (i = gs; i <= ge; i ++) {
                        short icv = m_szptr [i];
                        for (t = 0; t < nGroups; t ++) {
                            cost [t] += len [t] [icv];
                        }
                    }
                }
                bc = 999999999;
                bt = - 1;
                for (t = 0; t < nGroups; t ++) {
                    if (cost [t] < bc) {
                        bc = cost [t];
                        bt = t;
                    }
                }
                fave [bt] ++;
                m_selector [nSelectors] = (char) bt;
                nSelectors ++;
                for (i = gs; i <= ge; i ++) {
                    rfreq [bt] [m_szptr [i]] ++;
                }
                gs = ge + 1;
            }
            for (t = 0; t < nGroups; t ++) {
                hbMakeCodeLengths (len [t], rfreq [t], alphaSize, 20);
            }
        }
        rfreq = null;
        fave = null;
        cost = null;
        if (! (nGroups < 8)) {
            panic ();
        }
        if (! (nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {
            panic ();
        }
        {
            char [] pos = new char [N_GROUPS];
            char ll_i;
            char tmp2;
            char tmp;
            for (i = 0; i < nGroups; i ++) {
                pos [i] = (char) i;
            }
            for (i = 0; i < nSelectors; i ++) {
                ll_i = m_selector [i];
                j = 0;
                tmp = pos [j];
                while (ll_i != tmp) {
                    j ++;
                    tmp2 = tmp;
                    tmp = pos [j];
                    pos [j] = tmp2;
                }
                pos [0] = tmp;
                m_selectorMtf [i] = (char) j;
            }
        } int [] [] code = new int [N_GROUPS] [MAX_ALPHA_SIZE];
        for (t = 0; t < nGroups; t ++) {
            minLen = 32;
            maxLen = 0;
            for (i = 0; i < alphaSize; i ++) {
                if (len [t] [i] > maxLen) {
                    maxLen = len [t] [i];
                }
                if (len [t] [i] < minLen) {
                    minLen = len [t] [i];
                }
            }
            if (maxLen > 20) {
                panic ();
            }
            if (minLen < 1) {
                panic ();
            }
            hbAssignCodes (code [t], len [t], minLen, maxLen, alphaSize);
        }
        {
            boolean [] inUse16 = new boolean [16];
            for (i = 0; i < 16; i ++) {
                inUse16 [i] = false;
                for (j = 0; j < 16; j ++) {
                    if (m_inUse [i * 16 + j]) {
                        inUse16 [i] = true;
                    }
                }
            }
            for (i = 0; i < 16; i ++) {
                if (inUse16 [i]) {
                    bsW (1, 1);
                } else {
                    bsW (1, 0);
                }
            }
            for (i = 0; i < 16; i ++) {
                if (inUse16 [i]) {
                    for (j = 0; j < 16; j ++) {
                        if (m_inUse [i * 16 + j]) {
                            bsW (1, 1);
                        } else {
                            bsW (1, 0);
                        }
                    }
                }
            }
        } bsW (3, nGroups);
        bsW (15, nSelectors);
        for (i = 0; i < nSelectors; i ++) {
            for (j = 0; j < m_selectorMtf [i]; j ++) {
                bsW (1, 1);
            }
            bsW (1, 0);
        }
        for (t = 0; t < nGroups; t ++) {
            int curr = len [t] [0];
            bsW (5, curr);
            for (i = 0; i < alphaSize; i ++) {
                while (curr < len [t] [i]) {
                    bsW (2, 2);
                    curr ++;
                }
                while (curr > len [t] [i]) {
                    bsW (2, 3);
                    curr --;
                }
                bsW (1, 0);
            }
        }
        selCtr = 0;
        gs = 0;
        while (true) {
            if (gs >= m_nMTF) {
                break;
            }
            ge = gs + G_SIZE - 1;
            if (ge >= m_nMTF) {
                ge = m_nMTF - 1;
            }
            for (i = gs; i <= ge; i ++) {
                bsW (len [m_selector [selCtr]] [m_szptr [i]], code [m_selector [selCtr]] [m_szptr [i]]);
            }
            gs = ge + 1;
            selCtr ++;
        }
        if (! (selCtr == nSelectors)) {
            panic ();
        }
    }

    private void simpleSort (int lo, int hi, int d) {
        int i;
        int j;
        int h;
        int bigN;
        int hp;
        int v;
        bigN = hi - lo + 1;
        if (bigN < 2) {
            return;
        }
        hp = 0;
        while (m_incs [hp] < bigN) {
            hp ++;
        }
        hp --;
        for (; hp >= 0; hp --) {
            h = m_incs [hp];
            i = lo + h;
            while (true) {
                if (i > hi) {
                    break;
                }
                v = m_zptr [i];
                j = i;
                while (fullGtU (m_zptr [j - h] + d, v + d)) {
                    m_zptr [j] = m_zptr [j - h];
                    j = j - h;
                    if (j <= (lo + h - 1)) {
                        break;
                    }
                }
                m_zptr [j] = v;
                i ++;
                if (i > hi) {
                    break;
                }
                v = m_zptr [i];
                j = i;
                while (fullGtU (m_zptr [j - h] + d, v + d)) {
                    m_zptr [j] = m_zptr [j - h];
                    j = j - h;
                    if (j <= (lo + h - 1)) {
                        break;
                    }
                }
                m_zptr [j] = v;
                i ++;
                if (i > hi) {
                    break;
                }
                v = m_zptr [i];
                j = i;
                while (fullGtU (m_zptr [j - h] + d, v + d)) {
                    m_zptr [j] = m_zptr [j - h];
                    j = j - h;
                    if (j <= (lo + h - 1)) {
                        break;
                    }
                }
                m_zptr [j] = v;
                i ++;
                if (m_workDone > m_workLimit && m_firstAttempt) {
                    return;
                }
            }
        }
    }

    private void vswap (int p1, int p2, int n) {
        int temp = 0;
        while (n > 0) {
            temp = m_zptr [p1];
            m_zptr [p1] = m_zptr [p2];
            m_zptr [p2] = temp;
            p1 ++;
            p2 ++;
            n --;
        }
    }

    private void writeRun () throws IOException {
        if (m_last < m_allowableBlockSize) {
            m_inUse [m_currentChar] = true;
            for (int i = 0;
            i < m_runLength; i ++) {
                m_crc.updateCRC ((char) m_currentChar);
            }
            switch (m_runLength) {
                case 1 :
                    m_last ++;
                    m_block [m_last + 1] = (char) m_currentChar;
                    break;
                case 2 :
                    m_last ++;
                    m_block [m_last + 1] = (char) m_currentChar;
                    m_last ++;
                    m_block [m_last + 1] = (char) m_currentChar;
                    break;
                case 3 :
                    m_last ++;
                    m_block [m_last + 1] = (char) m_currentChar;
                    m_last ++;
                    m_block [m_last + 1] = (char) m_currentChar;
                    m_last ++;
                    m_block [m_last + 1] = (char) m_currentChar;
                    break;
                default :
                    m_inUse [m_runLength - 4] = true;
                    m_last ++;
                    m_block [m_last + 1] = (char) m_currentChar;
                    m_last ++;
                    m_block [m_last + 1] = (char) m_currentChar;
                    m_last ++;
                    m_block [m_last + 1] = (char) m_currentChar;
                    m_last ++;
                    m_block [m_last + 1] = (char) m_currentChar;
                    m_last ++;
                    m_block [m_last + 1] = (char) (m_runLength - 4);
                    break;
            }
        } else {
            endBlock ();
            initBlock ();
            writeRun ();
        }
    }

    private static class StackElem {
        int m_dd;
        int m_hh;
        int m_ll;
    }

}

</source>
<source file="systems/java/jEdit/trunk/installer/ServerKiller.java" startline="1" endline="134">
package installer;

import java.io.*;

import java.net.*;

public class ServerKiller {

    public static boolean quitjEditServer () {
        String settingsDirectory = System.getProperty ("user.home");
        File portFile;
        File f = new File (settingsDirectory);
        portFile = new File (f, ".jedit/server");
        if (portFile.exists ()) {
            try {
                BufferedReader in = new BufferedReader (new FileReader (portFile));
                String check = in.readLine ();
                if (! check.equals ("b")) {
                    System.out.println ("Wrong port file format");
                    return false;
                }
                int port = Integer.parseInt (in.readLine ());
                int key = Integer.parseInt (in.readLine ());
                Socket socket = new Socket (InetAddress.getByName ("127.0.0.1"), port);
                DataOutputStream out = new DataOutputStream (socket.getOutputStream ());
                out.writeInt (key);
                String script;
                script = "jEdit.exit(null,true);\n";
                out.writeUTF (script);
                try {
                    socket.getInputStream ().read ();
                } catch (Exception e) {
                }
                in.close ();
                out.close ();
            } catch (FileNotFoundException fnfe) {
            } catch (UnknownHostException uhe) {
            } catch (IOException ioe) {
                System.out.println ("Exception while trying to connect to existing server:");
                System.out.println (ioe);
                System.out.println ("Don't worry too much !");
                return false;
            }
        }
        return true;
    }

    public static void main (String [] args) {
        boolean success = quitjEditServer ();
        if (! success) {
            System.exit (- 1);
        }
    }

}

</source>
<source file="systems/java/jEdit/trunk/installer/ConsoleInstall.java" startline="1" endline="139">
package installer;

import java.io.*;

import java.util.Vector;

public class ConsoleInstall {

    public ConsoleInstall () {
        installer = new Install ();
        String appName = installer.getProperty ("app.name");
        String appVersion = installer.getProperty ("app.version");
        BufferedReader in = new BufferedReader (new InputStreamReader (System.in));
        System.out.println ("*** " + appName + " " + appVersion + " installer");
        OperatingSystem os = OperatingSystem.getOperatingSystem ();
        String installDir = os.getInstallDirectory (appName, appVersion);
        System.out.print ("Installation directory: [" + installDir + "] ");
        System.out.flush ();
        String _installDir = readLine (in);
        if (_installDir.length () != 0) installDir = _installDir;
        else System.out.println ("Will use default");

        OperatingSystem.OSTask [] osTasks = os.getOSTasks (installer);
        for (int i = 0;
        i < osTasks.length; i ++) {
            OperatingSystem.OSTask osTask = osTasks [i];
            String label = osTask.getLabel ();
            if (label != null) {
                String dir = osTask.getDirectory ();
                System.out.print (label + " [" + dir + "] ");
                System.out.flush ();
                dir = readLine (in);
                osTask.setEnabled (true);
                if (dir.length () != 0) {
                    if (dir.equals ("off")) osTask.setEnabled (false);
                    else osTask.setDirectory (dir);

                } else System.out.println ("will use default");

            }
        }
        int compCount = installer.getIntegerProperty ("comp.count");
        Vector components = new Vector (compCount);
        System.out.println ("*** Program components to install");
        for (int i = 0;
        i < compCount; i ++) {
            String fileset = installer.getProperty ("comp." + i + ".fileset");
            String osDep = installer.getProperty ("comp." + i + ".os");
            if (osDep != null) {
                if (! os.getClass ().getName ().endsWith (osDep)) {
                    continue;
                }
            }
            System.out.print ("Install " + installer.getProperty ("comp." + i + ".name") + " (" + installer.getProperty ("comp." + i + ".disk-size") + "Kb) [Y/n]? ");
            String line = readLine (in);
            if (line.length () == 0 || line.charAt (0) == 'y' || line.charAt (0) == 'Y') components.addElement (fileset);

        }
        System.out.println ("*** Starting installation...");
        ConsoleProgress progress = new ConsoleProgress ();
        InstallThread thread = new InstallThread (installer, progress, installDir, osTasks, 0, components);
        thread.start ();
    }

    private Install installer;

    private String readLine (BufferedReader in) {
        try {
            String line = in.readLine ();
            if (line == null) {
                System.err.println ("\nEOF in input!");
                System.exit (1);
                throw new InternalError ();
            }
            return line;
        } catch (IOException io) {
            System.err.println ("\nI/O error: " + io);
            System.exit (1);
            throw new InternalError ();
        }
    }

}

</source>
<source file="systems/java/jEdit/trunk/installer/CRC.java" startline="1" endline="114">
package installer;

class CRC {
    private static int [] CRC32_TABLE = new int [] {0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9, 0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005, 0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61, 0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd, 0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9, 0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75, 0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd, 0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039, 0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5, 0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d, 0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49, 0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95, 0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1, 0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d, 0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae, 0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072, 0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16, 0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca, 0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde, 0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02, 0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066, 0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba, 0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e, 0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692, 0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6, 0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a, 0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e, 0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2, 0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686, 0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a, 0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637, 0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb, 0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f, 0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53, 0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47, 0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b, 0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff, 0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623, 0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7, 0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b, 0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f, 0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3, 0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7, 0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b, 0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f, 0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3, 0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640, 0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c, 0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8, 0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24, 0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30, 0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec, 0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088, 0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654, 0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0, 0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c, 0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18, 0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4, 0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0, 0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c, 0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668, 0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4};
    private int m_globalCrc;

    protected CRC () {
        initialiseCRC ();
    }

    int getFinalCRC () {
        return ~ m_globalCrc;
    }

    void initialiseCRC () {
        m_globalCrc = 0xffffffff;
    }

    void updateCRC (final int inCh) {
        int temp = (m_globalCrc>> 24) ^ inCh;
        if (temp < 0) {
            temp = 256 + temp;
        }
        m_globalCrc = (m_globalCrc << 8) ^ CRC32_TABLE [temp];
    }

}

</source>
<source file="systems/java/jEdit/trunk/installer/BZip2Constants.java" startline="1" endline="85">
package installer;

interface BZip2Constants {
    int BASE_BLOCK_SIZE = 100000;
    int MAX_ALPHA_SIZE = 258;
    int MAX_CODE_LEN = 23;
    int RUNA = 0;
    int RUNB = 1;
    int N_GROUPS = 6;
    int G_SIZE = 50;
    int N_ITERS = 4;
    int MAX_SELECTORS = (2 + (900000 / G_SIZE));
    int NUM_OVERSHOOT_BYTES = 20;
    int [] RAND_NUMS = new int [] {619, 720, 127, 481, 931, 816, 813, 233, 566, 247, 985, 724, 205, 454, 863, 491, 741, 242, 949, 214, 733, 859, 335, 708, 621, 574, 73, 654, 730, 472, 419, 436, 278, 496, 867, 210, 399, 680, 480, 51, 878, 465, 811, 169, 869, 675, 611, 697, 867, 561, 862, 687, 507, 283, 482, 129, 807, 591, 733, 623, 150, 238, 59, 379, 684, 877, 625, 169, 643, 105, 170, 607, 520, 932, 727, 476, 693, 425, 174, 647, 73, 122, 335, 530, 442, 853, 695, 249, 445, 515, 909, 545, 703, 919, 874, 474, 882, 500, 594, 612, 641, 801, 220, 162, 819, 984, 589, 513, 495, 799, 161, 604, 958, 533, 221, 400, 386, 867, 600, 782, 382, 596, 414, 171, 516, 375, 682, 485, 911, 276, 98, 553, 163, 354, 666, 933, 424, 341, 533, 870, 227, 730, 475, 186, 263, 647, 537, 686, 600, 224, 469, 68, 770, 919, 190, 373, 294, 822, 808, 206, 184, 943, 795, 384, 383, 461, 404, 758, 839, 887, 715, 67, 618, 276, 204, 918, 873, 777, 604, 560, 951, 160, 578, 722, 79, 804, 96, 409, 713, 940, 652, 934, 970, 447, 318, 353, 859, 672, 112, 785, 645, 863, 803, 350, 139, 93, 354, 99, 820, 908, 609, 772, 154, 274, 580, 184, 79, 626, 630, 742, 653, 282, 762, 623, 680, 81, 927, 626, 789, 125, 411, 521, 938, 300, 821, 78, 343, 175, 128, 250, 170, 774, 972, 275, 999, 639, 495, 78, 352, 126, 857, 956, 358, 619, 580, 124, 737, 594, 701, 612, 669, 112, 134, 694, 363, 992, 809, 743, 168, 974, 944, 375, 748, 52, 600, 747, 642, 182, 862, 81, 344, 805, 988, 739, 511, 655, 814, 334, 249, 515, 897, 955, 664, 981, 649, 113, 974, 459, 893, 228, 433, 837, 553, 268, 926, 240, 102, 654, 459, 51, 686, 754, 806, 760, 493, 403, 415, 394, 687, 700, 946, 670, 656, 610, 738, 392, 760, 799, 887, 653, 978, 321, 576, 617, 626, 502, 894, 679, 243, 440, 680, 879, 194, 572, 640, 724, 926, 56, 204, 700, 707, 151, 457, 449, 797, 195, 791, 558, 945, 679, 297, 59, 87, 824, 713, 663, 412, 693, 342, 606, 134, 108, 571, 364, 631, 212, 174, 643, 304, 329, 343, 97, 430, 751, 497, 314, 983, 374, 822, 928, 140, 206, 73, 263, 980, 736, 876, 478, 430, 305, 170, 514, 364, 692, 829, 82, 855, 953, 676, 246, 369, 970, 294, 750, 807, 827, 150, 790, 288, 923, 804, 378, 215, 828, 592, 281, 565, 555, 710, 82, 896, 831, 547, 261, 524, 462, 293, 465, 502, 56, 661, 821, 976, 991, 658, 869, 905, 758, 745, 193, 768, 550, 608, 933, 378, 286, 215, 979, 792, 961, 61, 688, 793, 644, 986, 403, 106, 366, 905, 644, 372, 567, 466, 434, 645, 210, 389, 550, 919, 135, 780, 773, 635, 389, 707, 100, 626, 958, 165, 504, 920, 176, 193, 713, 857, 265, 203, 50, 668, 108, 645, 990, 626, 197, 510, 357, 358, 850, 858, 364, 936, 638};
}

</source>
<source file="systems/java/jEdit/trunk/installer/TarInputStream.java" startline="1" endline="520">
package installer;

import java.io.*;

public class TarInputStream extends FilterInputStream {
    protected boolean debug;
    protected boolean hasHitEOF;
    protected int entrySize;
    protected int entryOffset;
    protected byte [] oneBuf;
    protected byte [] readBuf;
    protected TarBuffer buffer;
    protected TarEntry currEntry;
    protected EntryFactory eFactory;

    public TarInputStream (InputStream is) {
        this (is, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);
    }

    public TarInputStream (InputStream is, int blockSize) {
        this (is, blockSize, TarBuffer.DEFAULT_RCDSIZE);
    }

    public TarInputStream (InputStream is, int blockSize, int recordSize) {
        super (is);
        this.buffer = new TarBuffer (is, blockSize, recordSize);
        this.readBuf = null;
        this.oneBuf = new byte [1];
        this.debug = false;
        this.hasHitEOF = false;
        this.eFactory = null;
    }

    public void setDebug (boolean debugF) {
        this.debug = debugF;
    }

    public void setEntryFactory (EntryFactory factory) {
        this.eFactory = factory;
    }

    public void setBufferDebug (boolean debug) {
        this.buffer.setDebug (debug);
    }

    public void close () throws IOException {
        this.buffer.close ();
    }

    public int getRecordSize () {
        return this.buffer.getRecordSize ();
    }

    public int available () throws IOException {
        return this.entrySize - this.entryOffset;
    }

    public void skip (int numToSkip) throws IOException {
        byte [] skipBuf = new byte [8 * 1024];
        for (int num = numToSkip;
        num > 0;) {
            int numRead = this.read (skipBuf, 0, (num > skipBuf.length ? skipBuf.length : num));
            if (numRead == - 1) break;

            num -= numRead;
        }
    }

    public boolean markSupported () {
        return false;
    }

    public void mark (int markLimit) {
    }

    public void reset () {
    }

    public TarEntry getNextEntry () throws IOException {
        if (this.hasHitEOF) return null;

        if (this.currEntry != null) {
            int numToSkip = this.entrySize - this.entryOffset;
            if (this.debug) System.err.println ("TarInputStream: SKIP currENTRY '" + this.currEntry.getName () + "' SZ " + this.entrySize + " OFF " + this.entryOffset + "  skipping " + numToSkip + " bytes");

            if (numToSkip > 0) {
                this.skip (numToSkip);
            }
            this.readBuf = null;
        }
        byte [] headerBuf = this.buffer.readRecord ();
        if (headerBuf == null) {
            if (this.debug) {
                System.err.println ("READ NULL RECORD");
            }
            this.hasHitEOF = true;
        } else if (this.buffer.isEOFRecord (headerBuf)) {
            if (this.debug) {
                System.err.println ("READ EOF RECORD");
            }
            this.hasHitEOF = true;
        }

        if (this.hasHitEOF) {
            this.currEntry = null;
        } else {
            try {
                if (this.eFactory == null) {
                    this.currEntry = new TarEntry (headerBuf);
                } else {
                    this.currEntry = this.eFactory.createEntry (headerBuf);
                }
                if (! (headerBuf [257] == 'u' && headerBuf [258] == 's' && headerBuf [259] == 't' && headerBuf [260] == 'a' && headerBuf [261] == 'r')) {
                    throw new InvalidHeaderException ("header magic is not 'ustar', but '" + headerBuf [257] + headerBuf [258] + headerBuf [259] + headerBuf [260] + headerBuf [261] + "', or (dec) " + ((int) headerBuf [257]) + ", " + ((int) headerBuf [258]) + ", " + ((int) headerBuf [259]) + ", " + ((int) headerBuf [260]) + ", " + ((int) headerBuf [261]));
                }
                if (this.debug) System.err.println ("TarInputStream: SET CURRENTRY '" + this.currEntry.getName () + "' size = " + this.currEntry.getSize ());

                this.entryOffset = 0;
                this.entrySize = (int) this.currEntry.getSize ();
            } catch (InvalidHeaderException ex) {
                this.entrySize = 0;
                this.entryOffset = 0;
                this.currEntry = null;
                throw new InvalidHeaderException ("bad header in block " + this.buffer.getCurrentBlockNum () + " record " + this.buffer.getCurrentRecordNum () + ", " + ex.getMessage ());
            }
        }
        return this.currEntry;
    }

    public int read () throws IOException {
        int num = this.read (this.oneBuf, 0, 1);
        if (num == - 1) return num;
        else return this.oneBuf [0];

    }

    public int read (byte [] buf) throws IOException {
        return this.read (buf, 0, buf.length);
    }

    public int read (byte [] buf, int offset, int numToRead) throws IOException {
        int totalRead = 0;
        if (this.entryOffset >= this.entrySize) return - 1;

        if ((numToRead + this.entryOffset) > this.entrySize) {
            numToRead = (this.entrySize - this.entryOffset);
        }
        if (this.readBuf != null) {
            int sz = (numToRead > this.readBuf.length) ? this.readBuf.length : numToRead;
            System.arraycopy (this.readBuf, 0, buf, offset, sz);
            if (sz >= this.readBuf.length) {
                this.readBuf = null;
            } else {
                int newLen = this.readBuf.length - sz;
                byte [] newBuf = new byte [newLen];
                System.arraycopy (this.readBuf, sz, newBuf, 0, newLen);
                this.readBuf = newBuf;
            }
            totalRead += sz;
            numToRead -= sz;
            offset += sz;
        }
        for (; numToRead > 0;) {
            byte [] rec = this.buffer.readRecord ();
            if (rec == null) {
                throw new IOException ("unexpected EOF with " + numToRead + " bytes unread");
            }
            int sz = numToRead;
            int recLen = rec.length;
            if (recLen > sz) {
                System.arraycopy (rec, 0, buf, offset, sz);
                this.readBuf = new byte [recLen - sz];
                System.arraycopy (rec, sz, this.readBuf, 0, recLen - sz);
            } else {
                sz = recLen;
                System.arraycopy (rec, 0, buf, offset, recLen);
            }
            totalRead += sz;
            numToRead -= sz;
            offset += sz;
        }
        this.entryOffset += totalRead;
        return totalRead;
    }

    public void copyEntryContents (OutputStream out) throws IOException {
        byte [] buf = new byte [32 * 1024];
        for (;;) {
            int numRead = this.read (buf, 0, buf.length);
            if (numRead == - 1) break;

            out.write (buf, 0, numRead);
        }
    }

    public interface EntryFactory {

        public TarEntry createEntry (String name);

        public TarEntry createEntry (File path) throws InvalidHeaderException;

        public TarEntry createEntry (byte [] headerBuf) throws InvalidHeaderException;

    }

    public class EntryAdapter implements EntryFactory {

        public TarEntry createEntry (String name) {
            return new TarEntry (name);
        }

        public TarEntry createEntry (File path) throws InvalidHeaderException {
            return new TarEntry (path);
        }

        public TarEntry createEntry (byte [] headerBuf) throws InvalidHeaderException {
            return new TarEntry (headerBuf);
        }

    }

}

</source>
<source file="systems/java/jEdit/trunk/installer/InvalidHeaderException.java" startline="1" endline="43">
package installer;

import java.io.IOException;

public class InvalidHeaderException extends IOException {

    public InvalidHeaderException () {
        super ();
    }

    public InvalidHeaderException (String msg) {
        super (msg);
    }

}

</source>
