<clones>
<systeminfo processor="nicad5" system="smart_contracts" granularity="functions-consistent" threshold="30%" minlines="2" maxlines="2500"/>
<cloneinfo npcs="8259" npairs="667044"/>
<runinfo ncompares="17637663" cputime="7781914"/>
<classinfo nclasses="353"/>

<class classid="1" nclones="234" nlines="2" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="8" endline="9" pcid="1">
    function name() public view returns (string);
    function symbol() public view returns (string);
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="292" endline="293" pcid="7365">
    function decimals() public view returns (uint8);
    function paused() public view returns (bool);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="770" endline="771" pcid="3876">
    function decimals() external view returns (uint8);
    function totalSupply() external view returns (uint256);
</source>
<source file="systems/smart_contracts/ProxyERC20.sol" startline="330" endline="332" pcid="5884">
    function totalSupply() public view returns (uint);

    function balanceOf(address owner) public view returns (uint);
</source>
<source file="systems/smart_contracts/MultiSendErc20.sol" startline="68" endline="69" pcid="5203">
    function totalSupply() public view returns (uint256);
    function balanceOf(address who) public view returns (uint256);
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="438" endline="447" pcid="2356">
    function getOwnerCount() public view returns (uint);


    /**
     * Gets the owner at `_index`
     *
     * @param _index The index of the owner
     * @return The address of the owner found at `_index`
     */
    function getOwnerAt(uint _index) public view returns (address);
</source>
<source file="systems/smart_contracts/Melodic.sol" startline="50" endline="51" pcid="4782">
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
</source>
<source file="systems/smart_contracts/BFGToken.sol" startline="43" endline="44" pcid="1181">
  function totalSupply() public view returns (uint256);
  function balanceOf(address addr) public view returns (uint256);
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="12" endline="13" pcid="2386">
  function totalSupply() external view returns (uint256);
  function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="32" endline="33" pcid="2422">
    function totalSupply() public view returns (uint);
    function balanceOf(address tokenOwner) public view returns (uint balance);
</source>
<source file="systems/smart_contracts/Oracle.sol" startline="167" endline="168" pcid="5522">
  function withdrawable() external view returns (uint256);
}
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="95" endline="100" pcid="945">
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="179" endline="181" pcid="7711">
    function totalSupply() external view returns (uint256);

    function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/magesh.sol" startline="339" endline="341" pcid="4635">
  function price() external view returns (uint256);

}
</source>
<source file="systems/smart_contracts/Byte.sol" startline="10" endline="11" pcid="1565">
  function totalSupply() external view returns (uint256);
  function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/Gacha.sol" startline="72" endline="74" pcid="3974">
    function totalSupply() public view returns (uint256);

    function balanceOf(address who) public view returns (uint256);
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="421" endline="422" pcid="6613">
	function totalSupply() public view returns (uint256);
	function balanceOf(address who) public view returns (uint256);
</source>
<source file="systems/smart_contracts/BEX.sol" startline="8" endline="9" pcid="1159">
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
</source>
<source file="systems/smart_contracts/AICRYPTO.sol" startline="47" endline="48" pcid="422">
    function totalSupply() public view returns (uint);
    function balanceOf(address tokenOwner) public view returns (uint balance);
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="249" endline="250" pcid="859">
    function getTotalTContracts() external view returns(uint256);
    function getTotalFPContracts() external view returns(uint256);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="61" endline="62" pcid="17">
    function name() public view returns (string);
    function symbol() public view returns (string);
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="451" endline="456" pcid="4763">
    function totalSupply()
        external
        view
        returns (uint256);

    function balanceOf(address _owner)
</source>
<source file="systems/smart_contracts/SuperMarket.sol" startline="14" endline="16" pcid="6756">
    function totalSupply() external view returns (uint256);

    function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="17" endline="22" pcid="1744">
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="496" endline="497" pcid="7042">
    function getMinterAddress() external view returns(address);
    function getWalletOnTopAddress() external view returns (address);
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="248" endline="249" pcid="858">
    function getTotalATContracts() external view returns(uint256);
    function getTotalTContracts() external view returns(uint256);
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="249" endline="251" pcid="3564">
    function totalSupply() external view returns (uint256);

    function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="100" endline="102" pcid="36">
    function token_decimals() public view returns (uint8);
    
    function token_totalSupply() public view returns (uint256);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="756" endline="757" pcid="3866">
    function getMembersNumber() external view returns (uint);
    function getMemberAddressByIndex(uint8) external view returns (address);
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="92" endline="93" pcid="2840">
    function token_name() public view returns (string);
    function token_symbol() public view returns (string);
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="14" endline="16" pcid="2733">
  function totalSupply() external view returns (uint256);

  function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/magesh.sol" startline="81" endline="83" pcid="4615">
    function totalSupply() external view returns (uint256);

    function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="148" endline="149" pcid="5343">
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="74" endline="75" pcid="6978">
    function decimals() external view returns (uint256);
    function totalSupply() external view returns (uint256);
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="12" endline="13" pcid="2546">
  function totalSupply() external view returns (uint256);
  function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="530" endline="531" pcid="7072">
    function getWLLength() external view returns(uint256);
    function setNewThreshold(uint256) external;
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="302" endline="304" pcid="6092">
  function isSane() public constant returns (bool);

  function distributeReservedTokens(uint reservedTokensDistributionBatch);
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="687" endline="688" pcid="936">
    function getFactoryAddress() external view returns(address);
}
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="8" endline="9" pcid="2807">
    function name() public view returns (string);
    function symbol() public view returns (string);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="10" endline="11" pcid="3">
    function decimals() public view returns (uint8);
    function totalSupply() public view returns (uint256);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="553" endline="554" pcid="133">
    function totalSupply() public view returns (uint256);
    function balanceOf(address _addr)public view returns(uint256);
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="317" endline="318" pcid="2350">
    function getOwner() public view returns (address);
}
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="313" endline="315" pcid="5685">
    function totalSupply() external view returns (uint256);

    function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="82" endline="83" pcid="3066">
  function totalSupply() public view returns (uint256);
  function tokenOfOwnerByIndex(
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="23" endline="32" pcid="2328">
    function totalSupply() external view returns (uint);


    /** 
     * Get balance of `_owner` 
     * 
     * @param _owner The address from which the balance will be retrieved
     * @return The balance
     */
    function balanceOf(address _owner) external view returns (uint);
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="247" endline="248" pcid="857">
    function getTotalDeployer() external view returns(uint256);
    function getTotalATContracts() external view returns(uint256);
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="542" endline="543" pcid="7080">
    function decimals() external view returns (uint8);
    function paused() external view returns (bool);
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="195" endline="197" pcid="579">
    function totalSupply() external view returns (uint256);

    function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/Factory.sol" startline="196" endline="197" pcid="3443">
    function totalSupply() external view returns (uint256);
    function balanceOf(address owner) external view returns (uint256);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="11" endline="12" pcid="4">
    function totalSupply() public view returns (uint256);
    function balanceOf(address _holder) public view returns (uint256);
</source>
<source file="systems/smart_contracts/SistContract.sol" startline="36" endline="37" pcid="6515">
  function totalSupply() public view returns (uint256);
  function balanceOf(address who) public view returns (uint256);
</source>
<source file="systems/smart_contracts/SAMPLE.sol" startline="53" endline="54" pcid="6247">
	function totalSupply() public view returns (uint);
	function balanceOf(address tokenOwner) public view returns (uint balance);
</source>
<source file="systems/smart_contracts/VACCToken.sol" startline="53" endline="54" pcid="7617">
    function totalSupply() public constant returns (uint256);
    function balanceOf(address tokenOwner) public constant returns (uint256 balance);
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="75" endline="76" pcid="6979">
    function totalSupply() external view returns (uint256);
    function balanceOf(address owner) external view returns (uint256);
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="100" endline="101" pcid="4382">
    function totalSupply() public view returns (uint256);
    function balanceOf(address who) public view returns (uint256);
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="17" endline="22" pcid="515">
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="12" endline="13" pcid="1459">
  function totalSupply() external view returns (uint256);
  function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="121" endline="126" pcid="8190">
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="227" endline="228" pcid="841">
    function getWLThresholdBalance() external view returns (uint256);
    function getMaxWLAmount(address) external view returns(uint256);
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="42" endline="43" pcid="1245">
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
</source>
<source file="systems/smart_contracts/CNG.sol" startline="12" endline="14" pcid="1840">
  function totalSupply() external view returns (uint256);

  function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="771" endline="772" pcid="3877">
    function totalSupply() external view returns (uint256);
    function balanceOf(address owner) external view returns (uint256);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="62" endline="63" pcid="18">
    function symbol() public view returns (string);
    function decimals() public view returns (uint8);
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="195" endline="196" pcid="813">
    function getMinterAddress() external view returns(address);
    function getWalletOnTopAddress() external view returns (address);
</source>
<source file="systems/smart_contracts/Factory.sol" startline="256" endline="257" pcid="3489">
    function getFactoryAddress() external view returns(address);
}
</source>
<source file="systems/smart_contracts/DGC.sol" startline="49" endline="50" pcid="2515">
    function totalSupply() public view returns (uint);
    function balanceOf(address tokenOwner) public view returns (uint balance);
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="117" endline="118" pcid="6431">
    function getTotalFPContracts() external view returns(uint256);
    function getContractsByIndex(uint256) external view returns (address, address, address, address);
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="60" endline="61" pcid="7452">
    function totalSupply() public view returns (uint256);
    function balanceOf(address who) public view returns (uint256);
</source>
<source file="systems/smart_contracts/FixedSupplyToken.sol" startline="49" endline="50" pcid="3600">
    function totalSupply() public view returns (uint);
    function balanceOf(address tokenOwner) public view returns (uint balance);
</source>
<source file="systems/smart_contracts/FUNNYTOKEN.sol" startline="36" endline="37" pcid="3945">
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="760" endline="761" pcid="4463">
    function totalSupply() public view returns (uint);
    function balanceOf(address tokenOwner) public view returns (uint balance);
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="93" endline="94" pcid="2841">
    function token_symbol() public view returns (string);
    function token_decimals() public view returns (uint8);
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="34" endline="35" pcid="8153">
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) public view returns (uint256 balance);
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="58" endline="59" pcid="2823">
    function name() public view returns (string);
    function symbol() public view returns (string);
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="497" endline="498" pcid="7043">
    function getWalletOnTopAddress() external view returns (address);
    function setWalletOnTopAddress(address) external returns(address);
</source>
<source file="systems/smart_contracts/WanCoinToken.sol" startline="35" endline="36" pcid="7877">
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="84" endline="86" pcid="2981">
  function totalSupply() external view returns (uint256);

  function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/JDC.sol" startline="30" endline="31" pcid="4334">
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="195" endline="196" pcid="3768">
    function getMinterAddress() external view returns(address);
    function getWalletOnTopAddress() external view returns (address);
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="293" endline="295" pcid="7366">
    function paused() public view returns (bool);

}
</source>
<source file="systems/smart_contracts/NSTTeamLock.sol" startline="18" endline="19" pcid="5454">
    function totalSupply() external view returns (uint256);
    function balanceOf(address owner) external view returns (uint256);
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="95" endline="100" pcid="2458">
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);
</source>
<source file="systems/smart_contracts/XTRLPAY.sol" startline="50" endline="51" pcid="8131">
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="8" endline="9" pcid="3912">
  function totalSupply() external view returns (uint256);
  function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="19" endline="24" pcid="8224">
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="23" endline="25" pcid="6408">
    function totalSupply() external view returns (uint256);

    function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/Factory.sol" startline="242" endline="243" pcid="3479">
    function getWLThresholdBalance() external view returns (uint256);
    function getMaxWLAmount(address) external view returns(uint256);
</source>
<source file="systems/smart_contracts/LanceToken.sol" startline="50" endline="51" pcid="4514">
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="291" endline="292" pcid="7364">
    function symbol() public view returns (string);
    function decimals() public view returns (uint8);
</source>
<source file="systems/smart_contracts/ProxyERC20.sol" startline="343" endline="344" pcid="5890">
    function name() public view returns (string);
    function symbol() public view returns (string);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="196" endline="197" pcid="3769">
    function getWalletOnTopAddress() external view returns (address);
    function setWalletOnTopAddress(address) external returns(address);
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="81" endline="83" pcid="4927">
    function totalSupply() external view returns (uint256);

    function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="163" endline="168" pcid="5416">
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);
</source>
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="61" endline="62" pcid="225">
    function totalSupply() public view returns(uint);
    function balanceOf(address tokenOwner) public view returns(uint balance);
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="196" endline="197" pcid="814">
    function getWalletOnTopAddress() external view returns (address);
    function setWalletOnTopAddress(address) external returns(address);
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="8" endline="9" pcid="7310">
  function totalSupply() external view returns (uint256);
  function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="42" endline="43" pcid="3410">
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="64" endline="65" pcid="20">
    function totalSupply() public view returns (uint256);
    function balanceOf(address _holder) public view returns (uint256);
</source>
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="99" endline="100" pcid="1628">
    function totalSupply() public view returns (uint256);
    function balanceOf(address who) public view returns (uint256);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="63" endline="64" pcid="19">
    function decimals() public view returns (uint8);
    function totalSupply() public view returns (uint256);
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="921" endline="922" pcid="5040">
    function totalSupply() public view returns (uint256);
    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="179" endline="181" pcid="6724">
    function totalSupply() external view returns (uint256);

    function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/ContractCoffeeToken.sol" startline="45" endline="46" pcid="1975">
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="80" endline="82" pcid="7982">
  function totalSupply() external view returns (uint256);

  function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="746" endline="747" pcid="7111">
    function getFactoryAddress() external view returns(address);
}
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="939" endline="944" pcid="6130">
  function isCrowdsaleFull() public constant returns (bool);

  /**
   * Create new tokens or transfer issued tokens to the investor depending on the cap model.
   */
  function assignTokens(address receiver, uint tokenAmount) private;
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="55" endline="56" pcid="5087">
  function totalSupply() external view returns (uint256);
  function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="99" endline="100" pcid="35">
    function token_symbol() public view returns (string);
    function token_decimals() public view returns (uint8);
</source>
<source file="systems/smart_contracts/SapientiaCharlesToken.sol" startline="49" endline="50" pcid="6271">
    function totalSupply() public view returns (uint);
    function balanceOf(address tokenOwner) public view returns (uint balance);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="744" endline="745" pcid="3854">
    function getFactoryDeployIndex() external view returns(uint);
    function isMemberInserted(address) external view returns(bool);
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="290" endline="291" pcid="7363">
    function name() public view returns (string);
    function symbol() public view returns (string);
</source>
<source file="systems/smart_contracts/SBC.sol" startline="289" endline="291" pcid="6332">
    function totalSupply() external view returns (uint256);

    function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="8" endline="9" pcid="2637">
  function totalSupply() external view returns (uint256);
  function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="116" endline="117" pcid="6430">
    function getTotalTContracts() external view returns(uint256);
    function getTotalFPContracts() external view returns(uint256);
</source>
<source file="systems/smart_contracts/NaorisToken.sol" startline="60" endline="61" pcid="5281">
    function totalSupply() public view returns (uint256);
    function balanceOf(address who) public view returns (uint256);
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="265" endline="274" pcid="2345">
    function getObserverCount() external view returns (uint);


    /**
     * Gets the observer at `_index`
     * 
     * @param _index The index of the observer
     * @return The observers address
     */
    function getObserverAtIndex(uint _index) external view returns (address);
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="42" endline="43" pcid="1221">
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="145" endline="150" pcid="5954">
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);
</source>
<source file="systems/smart_contracts/VENT.sol" startline="56" endline="57" pcid="7680">
        function totalSupply() public view returns (uint);
        function balanceOf(address tokenOwner) public view returns (uint balance);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="555" endline="558" pcid="135">
    function price() view public returns(uint256);
    //function costOfTxShares() view public returns(uint256);
    
	function calcTimedQuota(uint256 _rest, uint256 _full, uint256 _timespan, uint256 _period) public pure returns (uint256);
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="96" endline="97" pcid="2843">
    function token_totalSupply() public view returns (uint256);
    function token_balanceOf(address _owner) public view returns (uint256);
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="179" endline="181" pcid="2238">
    function totalSupply() external view returns (uint256);

    function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="10" endline="11" pcid="5984">
  function totalSupply() external view returns (uint256);
  function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="9" endline="10" pcid="2808">
    function symbol() public view returns (string);
    function decimals() public view returns (uint8);
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="20" endline="22" pcid="1362">
    function totalSupply() external view returns (uint256);

    function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/Comet.sol" startline="8" endline="9" pcid="1912">
  function totalSupply() external view returns (uint256);
  function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="95" endline="103" pcid="2334">
    function isLocked() external view returns (bool);


    /**
     * Locks the token so that the transfering of value is disabled 
     *
     * @return Whether the unlocking was successful or not
     */
    function lock() external returns (bool);
</source>
<source file="systems/smart_contracts/WanCoinSupplyToken.sol" startline="35" endline="36" pcid="7855">
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="42" endline="43" pcid="1299">
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="8" endline="9" pcid="4638">
  function totalSupply() public view returns (uint256);
  function balanceOf(address who) public view returns (uint256);
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="17" endline="22" pcid="5902">
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="34" endline="36" pcid="7638">
    function totalSupply() external view returns (uint256);

    function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/NBToken.sol" startline="13" endline="14" pcid="5295">
    function totalSupply() public view returns (uint256);
    function balanceOf(address who) public view returns (uint256);
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="190" endline="191" pcid="7787">
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="60" endline="61" pcid="2825">
    function decimals() public view returns (uint8);
    function totalSupply() public view returns (uint256);
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="95" endline="100" pcid="6017">
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="102" endline="103" pcid="37">
    function token_totalSupply() public view returns (uint256);
    function token_balanceOf(address _owner) public view returns (uint256);
</source>
<source file="systems/smart_contracts/GRAM.sol" startline="47" endline="48" pcid="4198">
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
</source>
<source file="systems/smart_contracts/WTA.sol" startline="61" endline="62" pcid="8045">
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="10" endline="11" pcid="2809">
    function decimals() public view returns (uint8);
    function totalSupply() public view returns (uint256);
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="115" endline="116" pcid="6429">
    function getTotalATContracts() external view returns(uint256);
    function getTotalTContracts() external view returns(uint256);
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="146" endline="148" pcid="5342">
    function decimals() external view returns (uint8);

    function totalSupply() external view returns (uint256);
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="8" endline="9" pcid="6195">
  function totalSupply() external view returns (uint256);
  function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="121" endline="126" pcid="4031">
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="23" endline="25" pcid="3012">
    function totalSupply() external view returns (uint256);

    function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="288" endline="289" pcid="7361">
    function owner() public view returns (address);
    function transferOwnership(address newOwner) public;
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="15" endline="20" pcid="299">
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="98" endline="99" pcid="34">
    function token_name() public view returns (string);
    function token_symbol() public view returns (string);
</source>
<source file="systems/smart_contracts/KingToken.sol" startline="9" endline="10" pcid="4475">
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
</source>
<source file="systems/smart_contracts/BlockPoolToken.sol" startline="13" endline="14" pcid="1405">
    function totalSupply() public view returns (uint256);
    function balanceOf(address who) public view returns (uint256);
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="42" endline="43" pcid="2040">
    function totalSupply() public view returns (uint256);
    function balanceOf(address who) public view returns (uint256);
</source>
<source file="systems/smart_contracts/VOTENOmodumtokenswapdotcom.sol" startline="50" endline="51" pcid="7833">
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="39" endline="40" pcid="7546">
    function totalSupply() public view returns (uint);
    function balanceOf(address tokenOwner) public view returns (uint balance);
</source>
<source file="systems/smart_contracts/FMT.sol" startline="10" endline="11" pcid="3645">
  function totalSupply() public view returns (uint256);
  function balanceOf(address who) public view returns (uint256);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="227" endline="228" pcid="3796">
    function getWLThresholdBalance() external view returns (uint256);
    function getMaxWLAmount(address) external view returns(uint256);
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="33" endline="34" pcid="5804">
    function totalSupply() public view returns (uint);
    function balanceOf(address tokenOwner) public view returns (uint balance);
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="12" endline="13" pcid="8068">
  function totalSupply() public view returns (uint256);
  function balanceOf(address who) public view returns (uint256);
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="188" endline="190" pcid="7786">
    function decimals() external view returns (uint8);

    function totalSupply() external view returns (uint256);
</source>
<source file="systems/smart_contracts/Factory.sol" startline="244" endline="245" pcid="3481">
    function getWLLength() external view returns(uint256);
    function setNewThreshold(uint256) external;
</source>
<source file="systems/smart_contracts/OSManagerToken.sol" startline="28" endline="29" pcid="5547">
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
</source>
<source file="systems/smart_contracts/BANG.sol" startline="12" endline="13" pcid="1035">
  function totalSupply() external view returns (uint256);
  function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="528" endline="529" pcid="7070">
    function getWLThresholdBalance() external view returns (uint256);
    function getMaxWLAmount(address) external view returns(uint256);
</source>
<source file="systems/smart_contracts/SolaToken.sol" startline="35" endline="36" pcid="6577">
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
</source>
<source file="systems/smart_contracts/ContractCargoberToken.sol" startline="45" endline="46" pcid="1953">
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="229" endline="230" pcid="3798">
    function getWLLength() external view returns(uint256);
    function setNewThreshold(uint256) external;
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="543" endline="544" pcid="3826">
    function paused() external view returns (bool);
    function pause() external;
</source>
<source file="systems/smart_contracts/PAYCASH.sol" startline="49" endline="50" pcid="5609">
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
</source>
<source file="systems/smart_contracts/PositionTokenV2.sol" startline="19" endline="20" pcid="5743">
  function totalSupply() public view returns (uint256);
  function balanceOf(address _who) public view returns (uint256);
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="20" endline="25" pcid="7011">
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);
</source>
<source file="systems/smart_contracts/MBA.sol" startline="56" endline="57" pcid="4702">
  function totalSupply() public view returns (uint256);
  function balanceOf(address who) public view returns (uint256);
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="266" endline="268" pcid="7288">
  function totalSupply() external view returns (uint256);

  function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="601" endline="602" pcid="160">
    function impl_quotaApply4Redeem() view public returns(uint256);
    function impl_apply4Redeem(address _from, uint256 _ms) public returns(uint256 ms2r);
</source>
<source file="systems/smart_contracts/TokenSwap.sol" startline="154" endline="156" pcid="7398">
    function totalSupply() external view returns (uint256);

    function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="16" endline="18" pcid="724">
  function totalSupply() external view returns (uint256);

  function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="29" endline="30" pcid="3161">
  function totalSupply() external view returns (uint256);
  function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="944" endline="949" pcid="4890">
  function isCrowdsaleFull() public constant returns (bool);

  /**
   * Create new tokens or transfer issued tokens to the investor depending on the cap model.
   */
  function assignTokens(address receiver, uint tokenAmount) private;
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="279" endline="280" pcid="7357">
    function totalSupply() public view returns (uint256);
    function balanceOf(address who) public view returns (uint256);
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="94" endline="96" pcid="2842">
    function token_decimals() public view returns (uint8);
    
    function token_totalSupply() public view returns (uint256);
</source>
<source file="systems/smart_contracts/Perlin.sol" startline="50" endline="51" pcid="5638">
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
</source>
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="17" endline="22" pcid="475">
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);
</source>
<source file="systems/smart_contracts/BIBCOINID.sol" startline="50" endline="51" pcid="1199">
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
</source>
<source file="systems/smart_contracts/CGT.sol" startline="49" endline="50" pcid="1685">
    function totalSupply() public view returns (uint);
    function balanceOf(address tokenOwner) public view returns (uint balance);
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="188" endline="193" pcid="7177">
    function totalSupply() external view returns (uint256);

    /**
     * Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="542" endline="543" pcid="3825">
    function decimals() external view returns (uint8);
    function paused() external view returns (bool);
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="59" endline="60" pcid="2824">
    function symbol() public view returns (string);
    function decimals() public view returns (uint8);
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="543" endline="544" pcid="7081">
    function paused() external view returns (bool);
    function pause() external;
</source>
<source file="systems/smart_contracts/UTC.sol" startline="63" endline="64" pcid="7575">
  function totalSupply() public view returns (uint256);
  function balanceOf(address who) public view returns (uint256);
</source>
<source file="systems/smart_contracts/Factory.sol" startline="211" endline="212" pcid="3452">
    function getWalletOnTopAddress() external view returns (address);
    function setWalletOnTopAddress(address) external returns(address);
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="78" endline="80" pcid="5837">
    function totalSupply() external view returns (uint256);

    function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="1137" endline="1138" pcid="3908">
    function getFactoryAddress() external view returns(address);
}
</source>
<source file="systems/smart_contracts/GNB.sol" startline="32" endline="33" pcid="4121">
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
</source>
<source file="systems/smart_contracts/LuckyAdvcedWoken.sol" startline="15" endline="17" pcid="4551">
    function totalSupply() external view returns (uint256);

    function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="246" endline="251" pcid="3804">
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="109" endline="110" pcid="6423">
    function getTotalDeployFees() external view returns (uint256);
    function isFactoryDeployer(address) external view returns(bool);
</source>
<source file="systems/smart_contracts/TorexToken.sol" startline="67" endline="68" pcid="7407">
  function totalSupply() public view returns (uint256);
  function balanceOf(address who) public view returns (uint256);
</source>
<source file="systems/smart_contracts/MAdvcedWoken.sol" startline="15" endline="17" pcid="4590">
    function totalSupply() external view returns (uint256);

    function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/Factory.sol" startline="263" endline="264" pcid="3492">
    function getFactoryAddress() external view returns(address);
}
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="9" endline="11" pcid="2296">
  function totalSupply() external view returns (uint256);

  function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/Factory.sol" startline="195" endline="196" pcid="3442">
    function decimals() external view returns (uint8);
    function totalSupply() external view returns (uint256);
</source>
<source file="systems/smart_contracts/AdminUpgradeabilityProxy.sol" startline="28" endline="36" pcid="349">
    function _implementation() internal view returns (address);

    /**
     * @dev Delegates execution to an implementation contract.
     * This is a low level function that doesn't return to its internal call site.
     * It will return to the external caller whatever the implementation returns.
     * @param implementation Address to delegate.
     */
    function _delegate(address implementation) internal {
</source>
<source file="systems/smart_contracts/PokaToken.sol" startline="14" endline="16" pcid="5728">
    function totalSupply() external view returns (uint256);

    function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/LBBT.sol" startline="40" endline="41" pcid="4536">
  function totalSupply() public view returns (uint256);
  function balanceOf(address who) public view returns (uint256);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="9" endline="10" pcid="2">
    function symbol() public view returns (string);
    function decimals() public view returns (uint8);
</source>
<source file="systems/smart_contracts/ProxyERC20.sol" startline="345" endline="347" pcid="5892">
    function decimals() public view returns (uint8);

    event Transfer(
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="61" endline="62" pcid="2826">
    function totalSupply() public view returns (uint256);
    function balanceOf(address _holder) public view returns (uint256);
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="11" endline="12" pcid="2810">
    function totalSupply() public view returns (uint256);
    function balanceOf(address _holder) public view returns (uint256);
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="30" endline="31" pcid="7428">
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
</source>
<source file="systems/smart_contracts/Multisig.sol" startline="8" endline="9" pcid="5211">
  function totalSupply() public view returns (uint);
  function balanceOf(address tokenOwner) public view returns (uint balance);
</source>
<source file="systems/smart_contracts/ProxyERC20.sol" startline="344" endline="345" pcid="5891">
    function symbol() public view returns (string);
    function decimals() public view returns (uint8);
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="127" endline="132" pcid="4420">
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);
</source>
<source file="systems/smart_contracts/Factory.sol" startline="210" endline="211" pcid="3451">
    function getMinterAddress() external view returns(address);
    function getWalletOnTopAddress() external view returns (address);
</source>
<source file="systems/smart_contracts/DNP.sol" startline="17" endline="18" pcid="2781">
    function totalSupply() public view returns (uint256);
    function balanceOf(address who) public view returns (uint256);
</source>
<source file="systems/smart_contracts/JUNDCOIN.sol" startline="46" endline="47" pcid="4356">
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="258" endline="259" pcid="864">
    function getFactoryDeployIndex() external view returns(uint);
    function isMemberInserted(address) external view returns(bool);
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="8" endline="9" pcid="2144">
  function totalSupply() external view returns (uint256);
  function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="86" endline="88" pcid="4234">
  function totalSupply() external view returns (uint256);

  function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="232" endline="234" pcid="7282">
  function totalSupply() external view returns (uint256);

  function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="106" endline="108" pcid="257">
    function totalSupply() public constant returns (uint);

    function balanceOf(address tokenOwner) public constant returns (uint balance);
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="339" endline="341" pcid="4947">
  function price() external view returns (uint256);

}
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="250" endline="251" pcid="860">
    function getTotalFPContracts() external view returns(uint256);
    function getContractsByIndex(uint256) external view returns (address, address, address, address);
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="114" endline="115" pcid="6428">
    function getTotalDeployer() external view returns(uint256);
    function getTotalATContracts() external view returns(uint256);
</source>
<source file="systems/smart_contracts/Factory.sol" startline="271" endline="272" pcid="3495">
    function getFactoryAddress() external view returns(address);
}
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="519" endline="521" pcid="110">
    function tailOfQueue() public view returns(uint256);
    
    function setColdWallet(address _coldWallet, uint256 _ratioAutoSave, uint256 _ratioAutoRemain) public;
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="11" endline="16" pcid="5769">
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="307" endline="309" pcid="4852">
  function isSane() public constant returns (bool);

  function distributeReservedTokens(uint reservedTokensDistributionBatch);
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="229" endline="230" pcid="843">
    function getWLLength() external view returns(uint256);
    function setNewThreshold(uint256) external;
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="44" endline="45" pcid="398">
    function totalSupply() public view returns (uint);
    function balanceOf(address tokenOwner) public view returns (uint balance);
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="261" endline="266" pcid="5156">
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);
</source>
<source file="systems/smart_contracts/GFNX.sol" startline="11" endline="13" pcid="4092">
  function totalSupply() external view returns (uint256);

  function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="17" endline="22" pcid="642">
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="270" endline="271" pcid="876">
    function getMembersNumber() external view returns (uint);
    function getMemberAddressByIndex(uint8) external view returns (address);
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="122" endline="127" pcid="7900">
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);
</source>
<source file="systems/smart_contracts/ankara.sol" startline="25" endline="27" pcid="678">
    function totalSupply() external view returns (uint256);

    function balanceOf(address who) external view returns (uint256);
</source>
<source file="systems/smart_contracts/AnxToken.sol" startline="50" endline="51" pcid="706">
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
</source>
</class>

<class classid="2" nclones="165" nlines="2" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="12" endline="14" pcid="5">
    function balanceOf(address _holder) public view returns (uint256);

    function transfer(address _to, uint256 _value) public returns (bool success);
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="25" endline="27" pcid="3013">
    function balanceOf(address who) external view returns (uint256);

    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="67" endline="68" pcid="1434">
    function balanceOf(address who) public constant returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/BFGToken.sol" startline="44" endline="45" pcid="1182">
  function balanceOf(address addr) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="181" endline="183" pcid="6725">
    function balanceOf(address who) external view returns (uint256);

    function allowance(address owner, address spender)
</source>
<source file="systems/smart_contracts/TimeLockedTokenStorage.sol" startline="66" endline="67" pcid="7225">
    function balanceOf(address _owner) public view returns (uint256);
    function approveForOtherContracts(address _sender, address _spender, uint256 _value) external;
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="150" endline="159" pcid="5955">
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a `Transfer` event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/Oracle.sol" startline="164" endline="165" pcid="5519">
  function getAuthorizationStatus(address node) external view returns (bool);
  function setFulfillmentPermission(address node, bool allowed) external;
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="82" endline="84" pcid="7983">
  function balanceOf(address who) external view returns (uint256);

  event Transfer(
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="772" endline="773" pcid="3878">
    function balanceOf(address owner) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/NBToken.sol" startline="14" endline="15" pcid="5296">
    function balanceOf(address who) public view returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="65" endline="66" pcid="21">
    function balanceOf(address _holder) public view returns (uint256);
    function allowance(address _from, address _spender) public view returns (uint256);
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="57" endline="58" pcid="6480">
    function balanceOf(address _owner) constant public returns (uint256);
    function transfer(address _to, uint256 _value) public returns (bool);
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="61" endline="62" pcid="7453">
    function balanceOf(address who) public view returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="62" endline="63" pcid="2827">
    function balanceOf(address _holder) public view returns (uint256);
    function allowance(address _from, address _spender) public view returns (uint256);
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="22" endline="31" pcid="1745">
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a `Transfer` event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="197" endline="199" pcid="580">
    function balanceOf(address who) external view returns (uint256);

    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/LBBT.sol" startline="41" endline="42" pcid="4537">
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="251" endline="253" pcid="3565">
    function balanceOf(address who) external view returns (uint256);

    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/SistContract.sol" startline="37" endline="38" pcid="6516">
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/PokaToken.sol" startline="16" endline="18" pcid="5729">
    function balanceOf(address who) external view returns (uint256);

    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="63" endline="64" pcid="6482">
    function balanceOf(address who) public constant returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="53" endline="54" pcid="4954">
    function balanceOf(address _owner) constant public returns (uint256);
    function transfer(address _to, uint256 _value) public returns (bool);
</source>
<source file="systems/smart_contracts/PositionTokenV2.sol" startline="20" endline="21" pcid="5744">
  function balanceOf(address _who) public view returns (uint256);
  function transfer(address _to, uint256 _value) public returns (bool);
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="9" endline="10" pcid="7311">
  function balanceOf(address who) external view returns (uint256);
  function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="2681" endline="2682" pcid="6931">
    function balanceOf(address account) public view returns (uint);
    function appendVestingEntry(address account, uint quantity) public;
</source>
<source file="systems/smart_contracts/magesh.sol" startline="83" endline="85" pcid="4616">
    function balanceOf(address who) external view returns (uint256);

    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="9" endline="10" pcid="6196">
  function balanceOf(address who) external view returns (uint256);
  function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/MAdvcedWoken.sol" startline="17" endline="19" pcid="4591">
    function balanceOf(address who) external view returns (uint256);

    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/BlockPoolToken.sol" startline="14" endline="15" pcid="1406">
    function balanceOf(address who) public view returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/Factory.sol" startline="197" endline="198" pcid="3444">
    function balanceOf(address owner) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="86" endline="88" pcid="2982">
  function balanceOf(address who) external view returns (uint256);

  event Transfer(
</source>
<source file="systems/smart_contracts/GoldenRings.sol" startline="44" endline="45" pcid="4170">
    function balanceOf(address who) public view returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="181" endline="183" pcid="2239">
    function balanceOf(address who) external view returns (uint256);

    function allowance(address owner, address spender)
</source>
<source file="systems/smart_contracts/BKN.sol" startline="16" endline="17" pcid="1319">
    function balanceOf(address who) public constant returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1246" endline="1248" pcid="1816">
    function withdrawalAllowed(address payee) public view returns (bool);

    function withdraw(address payable payee) public {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="101" endline="102" pcid="4383">
    function balanceOf(address who) public view returns (uint256);
    function allowance(address owner, address spender) public view returns (uint256);
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="61" endline="62" pcid="1432">
    function balanceOf(address _owner) constant public returns (uint256);
    function transfer(address _to, uint256 _value) public returns (bool);
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="132" endline="141" pcid="4421">
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a `Transfer` event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/FMT.sol" startline="11" endline="12" pcid="3646">
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="164" endline="165" pcid="5349">
    function reservedOf(address account) external view returns (uint256);
}
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="83" endline="85" pcid="4928">
    function balanceOf(address who) external view returns (uint256);

    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/XGP.sol" startline="72" endline="73" pcid="8103">
    function balanceOf(address who) public constant returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="127" endline="136" pcid="7901">
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a `Transfer` event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="20" endline="29" pcid="300">
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="13" endline="14" pcid="1460">
  function balanceOf(address who) external view returns (uint256);
  function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="9" endline="10" pcid="3913">
  function balanceOf(address who) external view returns (uint256);
  function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="18" endline="20" pcid="725">
  function balanceOf(address who) external view returns (uint256);

  function allowance(address owner, address spender)
</source>
<source file="systems/smart_contracts/Aigopay.sol" startline="66" endline="67" pcid="444">
    function balanceOf(address _owner) constant public returns (uint256);
    function transfer(address _to, uint256 _value) public returns (bool);
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="315" endline="317" pcid="5686">
    function balanceOf(address who) external view returns (uint256);

    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="485" endline="486" pcid="2360">
    function authenticate(address _account) public view returns (bool);
}
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="66" endline="67" pcid="4836">
  function balanceOf(address who) public constant returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/UTC.sol" startline="64" endline="65" pcid="7576">
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="53" endline="54" pcid="1269">
    function balanceOf(address _owner) constant public returns (uint256);
    function transfer(address _to, uint256 _value) public returns (bool);
</source>
<source file="systems/smart_contracts/CST_TOKEN.sol" startline="8" endline="9" pcid="2192">
  function balanceOf(address _owner) external view returns (uint256);
  function allowance(address _owner, address _spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="11" endline="13" pcid="2297">
  function balanceOf(address who) external view returns (uint256);

  function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="31" endline="32" pcid="2876">
    function balanceOf(address _owner) constant public returns (uint256);
    function transfer(address _to, uint256 _value) public returns (bool);
</source>
<source file="systems/smart_contracts/NaorisToken.sol" startline="61" endline="62" pcid="5282">
    function balanceOf(address who) public view returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="59" endline="60" pcid="1271">
    function balanceOf(address who) public constant returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/RETC.sol" startline="33" endline="34" pcid="6178">
    function balanceOf(address who) public constant returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="100" endline="101" pcid="1629">
    function balanceOf(address who) public view returns (uint256);
    function allowance(address owner, address spender) public view returns (uint256);
</source>
<source file="systems/smart_contracts/TorexToken.sol" startline="68" endline="69" pcid="7408">
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="214" endline="215" pcid="7794">
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/tharDex.sol" startline="14" endline="15" pcid="7142">
     function balanceOf(address account) external view returns(uint256);
     function allowance(address _owner, address _spender)external view returns(uint256);
</source>
<source file="systems/smart_contracts/WTA.sol" startline="62" endline="63" pcid="8046">
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/Aigopay.sol" startline="72" endline="73" pcid="446">
    function balanceOf(address who) public constant returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="100" endline="109" pcid="946">
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a `Transfer` event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="126" endline="135" pcid="8191">
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a `Transfer` event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/DNP.sol" startline="18" endline="19" pcid="2782">
    function balanceOf(address who) public view returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="108" endline="109" pcid="6777">
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="13" endline="14" pcid="2387">
  function balanceOf(address who) external view returns (uint256);
  function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="100" endline="109" pcid="6018">
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a `Transfer` event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="11" endline="12" pcid="5985">
  function balanceOf(address who) external view returns (uint256);
  function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="22" endline="24" pcid="1363">
    function balanceOf(address who) external view returns (uint256);

    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/XGP.sol" startline="66" endline="67" pcid="8101">
    function balanceOf(address _owner) constant public returns (uint256);
    function transfer(address _to, uint256 _value) public returns (bool);
</source>
<source file="systems/smart_contracts/BountyBoard.sol" startline="115" endline="116" pcid="1492">
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="251" endline="260" pcid="3805">
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a `Transfer` event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/Gacha.sol" startline="74" endline="76" pcid="3975">
    function balanceOf(address who) public view returns (uint256);

    function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/PDataToSHFund.sol" startline="19" endline="20" pcid="5629">
  function balanceOf(address who) public view returns (uint256);
}
</source>
<source file="systems/smart_contracts/TokenSwap.sol" startline="156" endline="158" pcid="7399">
    function balanceOf(address who) external view returns (uint256);

    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="309" endline="317" pcid="2349">
    function isOwner(address _account) public view returns (bool);


    /**
     * Gets the current owner
     *
     * @return address The current owner
     */
    function getOwner() public view returns (address);
</source>
<source file="systems/smart_contracts/Airdropper.sol" startline="21" endline="22" pcid="471">
  function balanceOf(address _owner) public constant returns (uint256 );
  function transfer(address _to, uint256 _value) public ;
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="16" endline="17" pcid="2091">
  function balanceOf(address who) public constant returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/BDAM.sol" startline="96" endline="97" pcid="1114">
  function balanceOf(address who) public constant returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="54" endline="56" pcid="1711">
    function balanceOf(address who) public view returns (uint256);

    function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="80" endline="82" pcid="5838">
    function balanceOf(address who) external view returns (uint256);

    function allowance(address owner, address spender)
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="50" endline="51" pcid="3516">
    function balanceOf(address _owner) constant public returns (uint256);
    function transfer(address _to, uint256 _value) public returns (bool);
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="149" endline="150" pcid="5344">
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/BANG.sol" startline="13" endline="14" pcid="1036">
  function balanceOf(address who) external view returns (uint256);
  function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="268" endline="270" pcid="7289">
  function balanceOf(address who) external view returns (uint256);

  function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="59" endline="60" pcid="6678">
    function balanceOf(address _owner) constant public returns (uint256);
    function transfer(address _to, uint256 _value) public returns (bool);
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="16" endline="18" pcid="2734">
  function balanceOf(address who) external view returns (uint256);

  function allowance(address owner, address spender)
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="280" endline="281" pcid="7358">
    function balanceOf(address who) public view returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="60" endline="61" pcid="2951">
    function balanceOf(address who) public constant returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/SBC.sol" startline="291" endline="293" pcid="6333">
    function balanceOf(address who) external view returns (uint256);

    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/MiniMeTokenFactory.sol" startline="14" endline="22" pcid="4800">
    function proxyPayment(address _owner) external payable returns(bool);

    /// @notice Notifies the controller about a token transfer allowing the
    ///  controller to react if desired
    /// @param _from The origin of the transfer
    /// @param _to The destination of the transfer
    /// @param _amount The amount of the transfer
    /// @return False if the controller does not authorize the transfer
    function onTransfer(address _from, address _to, uint _amount) external returns(bool);
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="430" endline="438" pcid="2355">
    function isOwner(address _account) public view returns (bool);


    /**
     * Returns the amount of owners
     *
     * @return The amount of owners
     */
    function getOwnerCount() public view returns (uint);
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="30" endline="31" pcid="3162">
  function balanceOf(address who) external view returns (uint256);
  function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="12" endline="14" pcid="2811">
    function balanceOf(address _holder) public view returns (uint256);

    function transfer(address _to, uint256 _value) public returns (bool success);
</source>
<source file="systems/smart_contracts/MBA.sol" startline="57" endline="58" pcid="4703">
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/MultiSendErc20.sol" startline="69" endline="70" pcid="5204">
    function balanceOf(address who) public view returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="168" endline="177" pcid="5417">
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/SuperMarket.sol" startline="16" endline="18" pcid="6757">
    function balanceOf(address who) external view returns (uint256);

    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="24" endline="33" pcid="8225">
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a `Transfer` event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/NSTTeamLock.sol" startline="19" endline="20" pcid="5455">
    function balanceOf(address owner) external view returns (uint256);
    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/ProxyERC20.sol" startline="332" endline="334" pcid="5885">
    function balanceOf(address owner) public view returns (uint);

    function allowance(address owner, address spender) public view returns (uint);
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="16" endline="17" pcid="6068">
  function balanceOf(address who) public constant returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="194" endline="195" pcid="1890">
    function balanceOf(address who) constant external returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="88" endline="90" pcid="4235">
  function balanceOf(address who) external view returns (uint256);

  function allowance(address owner, address spender)
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="22" endline="31" pcid="643">
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a `Transfer` event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/CRYPTOMZ.sol" startline="85" endline="86" pcid="2178">
  function balanceOf(address who) public constant returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="56" endline="57" pcid="5088">
  function balanceOf(address who) external view returns (uint256);
  function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/ankara.sol" startline="27" endline="29" pcid="679">
    function balanceOf(address who) external view returns (uint256);

    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="25" endline="27" pcid="6409">
    function balanceOf(address who) external view returns (uint256);

    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/GFNX.sol" startline="13" endline="15" pcid="4093">
  function balanceOf(address who) external view returns (uint256);

  function allowance(address owner, address spender)
</source>
<source file="systems/smart_contracts/GameGold.sol" startline="192" endline="193" pcid="3995">
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="54" endline="55" pcid="6546">
    function balanceOf(address _owner) constant public returns (uint256);
    function transfer(address _to, uint256 _value) public returns (bool);
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="76" endline="77" pcid="6980">
    function balanceOf(address owner) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/CNG.sol" startline="14" endline="16" pcid="1841">
  function balanceOf(address who) external view returns (uint256);

  function allowance(address owner, address spender)
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="234" endline="236" pcid="7283">
  function balanceOf(address who) external view returns (uint256);

  function allowance(address owner, address spender)
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="193" endline="202" pcid="7178">
    function balanceOf(address account) external view returns (uint256);

    /**
     * Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a `Transfer` event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="32" endline="42" pcid="2329">
    function balanceOf(address _owner) external view returns (uint);


    /** 
     * Send `_value` token to `_to` from `msg.sender`
     * 
     * @param _to The address of the recipient
     * @param _value The amount of token to be transferred
     * @return Whether the transfer was successful or not
     */
    function transfer(address _to, uint _value) external returns (bool);
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="126" endline="135" pcid="4032">
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a `Transfer` event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="456" endline="461" pcid="4764">
    function balanceOf(address _owner)
        external
        view
        returns (uint256);

    function allowance(address _owner, address _spender)
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="60" endline="61" pcid="6548">
    function balanceOf(address who) public constant returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/UGCoin.sol" startline="33" endline="34" pcid="7527">
    function balanceOf(address who) public constant returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="56" endline="57" pcid="3518">
    function balanceOf(address who) public constant returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="54" endline="55" pcid="2949">
    function balanceOf(address _owner) constant public returns (uint256);
    function transfer(address _to, uint256 _value) public returns (bool);
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="16" endline="25" pcid="5770">
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="103" endline="104" pcid="38">
    function token_balanceOf(address _owner) public view returns (uint256);
    function token_allowance(address _from, address _spender) public view returns (uint256);
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="22" endline="31" pcid="516">
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a `Transfer` event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="100" endline="109" pcid="2459">
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a `Transfer` event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/DABANKING_SWAP.sol" startline="18" endline="20" pcid="2270">
    function balanceOf(address who) public view returns (uint256);

    function allowance(address owner, address spender) public view returns (uint256);
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="422" endline="423" pcid="6614">
	function balanceOf(address who) public view returns (uint256);
	function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="97" endline="98" pcid="2844">
    function token_balanceOf(address _owner) public view returns (uint256);
    function token_allowance(address _from, address _spender) public view returns (uint256);
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="43" endline="44" pcid="2041">
    function balanceOf(address who) public view returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="266" endline="275" pcid="5157">
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a `Transfer` event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="9" endline="10" pcid="2638">
  function balanceOf(address who) external view returns (uint256);
  function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="9" endline="10" pcid="4639">
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="59" endline="60" pcid="4956">
    function balanceOf(address who) public constant returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/LuckyAdvcedWoken.sol" startline="17" endline="19" pcid="4552">
    function balanceOf(address who) external view returns (uint256);

    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="71" endline="72" pcid="4299">
    function balanceOf(address who) public constant returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="37" endline="38" pcid="8012">
    function balanceOf(address who) public constant returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="191" endline="192" pcid="7788">
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="257" endline="265" pcid="2344">
    function isObserver(address _account) external view returns (bool);


    /**
     * Gets the amount of registered observers
     * 
     * @return The amount of registered observers
     */
    function getObserverCount() external view returns (uint);
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="13" endline="14" pcid="2547">
  function balanceOf(address who) external view returns (uint256);
  function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="554" endline="555" pcid="134">
    function balanceOf(address _addr)public view returns(uint256);
    function price() view public returns(uint256);
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="13" endline="14" pcid="8069">
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/ITVR.sol" startline="19" endline="20" pcid="4325">
  function balanceOf(address who) public view returns (uint256);
}
</source>
<source file="systems/smart_contracts/Comet.sol" startline="9" endline="10" pcid="1913">
  function balanceOf(address who) external view returns (uint256);
  function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/AronCoin.sol" startline="14" endline="15" pcid="756">
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="37" endline="38" pcid="2878">
    function balanceOf(address who) public constant returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="65" endline="66" pcid="4297">
    function balanceOf(address _owner) constant public returns (uint256);
    function transfer(address _to, uint256 _value) public returns (bool);
</source>
<source file="systems/smart_contracts/SellableToken.sol" startline="36" endline="37" pcid="6459">
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="25" endline="34" pcid="7012">
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a `Transfer` event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="22" endline="31" pcid="5903">
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="36" endline="38" pcid="7639">
    function balanceOf(address who) external view returns (uint256);

    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="181" endline="183" pcid="7712">
    function balanceOf(address who) external view returns (uint256);

    function allowance(address owner, address spender)
</source>
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="22" endline="31" pcid="476">
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a `Transfer` event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="31" endline="32" pcid="8010">
    function balanceOf(address _owner) constant public returns (uint256);
    function transfer(address _to, uint256 _value) public returns (bool);
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="65" endline="66" pcid="6680">
    function balanceOf(address who) public constant returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/Byte.sol" startline="11" endline="12" pcid="1566">
  function balanceOf(address who) external view returns (uint256);
  function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="9" endline="10" pcid="2145">
  function balanceOf(address who) external view returns (uint256);
  function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="14" endline="15" pcid="7740">
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="206" endline="207" pcid="7793">
    function reservedOf(address account) external view returns (uint256);
}
</source>
</class>

<class classid="3" nclones="44" nlines="2" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="14" endline="15" pcid="6">
    function transfer(address _to, uint256 _value) public returns (bool success);
    function transfer(address _to, uint _value, bytes _data) public returns (bool success);
</source>
<source file="systems/smart_contracts/AzurToken.sol" startline="30" endline="37" pcid="1001">
  function transfer(address _to, uint256 _value) public returns (bool success);

  /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`
  /// @param _from The address of the sender
  /// @param _to The address of the recipient
  /// @param _value The amount of token to be transferred
  /// @return Whether the transfer was successful or not
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
</source>
<source file="systems/smart_contracts/BatchTransfer.sol" startline="9" endline="11" pcid="1084">
    function transfer(address _to, uint256 _value) public returns (bool success);

}
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="537" endline="538" pcid="124">
    function withdrawSharesTo(address _to, uint256 _amount) public returns(bool atonce);
    function withdrawOrder(uint256 _amount) public returns(bool atonce);
</source>
<source file="systems/smart_contracts/SAS.sol" startline="46" endline="47" pcid="6296">
  function approve(address _spender, uint256 _value)public returns (bool success);
  function allowance(address _owner, address _spender)public view returns (uint256 remaining);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="543" endline="545" pcid="130">
    function withdrawProjectTo(address _to, uint256 _amount)public returns(bool atonce);
    
	function() public payable;
</source>
<source file="systems/smart_contracts/AzurToken.sol" startline="43" endline="48" pcid="1003">
  function approve(address _spender, uint256 _value) public returns (bool success);

  /// @param _owner The address of the account owning tokens
  /// @param _spender The address of the account able to transfer the tokens
  /// @return Amount of remaining tokens allowed to spent
  function allowance(address _owner, address _spender) public view returns (uint256 remaining);
</source>
<source file="systems/smart_contracts/Oracle.sol" startline="184" endline="185" pcid="5532">
  function transfer(address to, uint256 value) external returns (bool success);
  function transferAndCall(address to, uint256 value, bytes data) external returns (bool success);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="394" endline="395" pcid="88">
    function transferMSI(address _to, uint256 _msi) public returns (bool success);
    function transferMSM(address _to, uint256 _msm) public returns (bool success);
</source>
<source file="systems/smart_contracts/GLOLocker.sol" startline="9" endline="10" pcid="4113">
    function transfer(address _to, uint256 _value) public returns (bool success);
}
</source>
<source file="systems/smart_contracts/CAC.sol" startline="46" endline="47" pcid="1614">
    function approve(address _spender, uint256 _value)public returns (bool success);
    function allowance(address _owner, address _spender)public view returns (uint256 remaining);
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="65" endline="66" pcid="2829">
    function transfer(address _to, uint256 _value) public returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
</source>
<source file="systems/smart_contracts/tharDex.sol" startline="12" endline="13" pcid="7140">
  function transfer(address to, uint256 value) public returns (bool success);
  function transferFrom(address from, address to, uint256 value) public returns (bool success);
</source>
<source file="systems/smart_contracts/AACD.sol" startline="46" endline="47" pcid="293">
    function approve(address _spender, uint256 _value)public returns (bool success);
    function allowance(address _owner, address _spender)public view returns (uint256 remaining);
</source>
<source file="systems/smart_contracts/NEM.sol" startline="46" endline="47" pcid="5323">
    function approve(address _spender, uint256 _value)public returns (bool success);
    function allowance(address _owner, address _spender)public view returns (uint256 remaining);
</source>
<source file="systems/smart_contracts/Oracle.sol" startline="176" endline="177" pcid="5524">
  function approve(address spender, uint256 value) external returns (bool success);
  function balanceOf(address owner) external returns (uint256 balance);
</source>
<source file="systems/smart_contracts/VACCToken.sol" startline="56" endline="57" pcid="7620">
    function transfer(address to, uint256 tokens) public returns (bool success);
    function approve(address spender, uint256 tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/VACCToken.sol" startline="57" endline="58" pcid="7621">
    function approve(address spender, uint256 tokens) public returns (bool success);
    function transferFrom(address from, address to, uint256 tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/BTGS.sol" startline="14" endline="15" pcid="1538">
    function transfer(address _to, uint256 _value) public returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="70" endline="72" pcid="25">
    function approve(address _spender, uint256 _value) public returns (bool success);
    
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
</source>
<source file="systems/smart_contracts/GasStorage.sol" startline="72" endline="73" pcid="4017">
     function transfer(address to, uint256 value) external returns (bool success);
} 
</source>
<source file="systems/smart_contracts/NEM.sol" startline="44" endline="45" pcid="5321">
    function transfer(address _to, uint256 _value)public returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="68" endline="69" pcid="23">
    function transfer(address _to, uint256 _value) public returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="541" endline="542" pcid="128">
    function withdrawMineralTo(address _to, uint256 _amount) public returns(bool atonce);
    function withdrawProject(uint256 _amount)public returns(bool atonce);
</source>
<source file="systems/smart_contracts/CAC.sol" startline="44" endline="45" pcid="1612">
    function transfer(address _to, uint256 _value)public returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success);
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="67" endline="69" pcid="2831">
    function approve(address _spender, uint256 _value) public returns (bool success);
    
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
</source>
<source file="systems/smart_contracts/MT.sol" startline="44" endline="45" pcid="5073">
    function transfer(address _to, uint256 _value)public returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success);
</source>
<source file="systems/smart_contracts/BACD.sol" startline="63" endline="64" pcid="1018">
  function approve(address _spender, uint256 _value) public returns (bool success);
  function allowance(address _owner, address _spender) public view returns (uint256 remaining);
</source>
<source file="systems/smart_contracts/MT.sol" startline="46" endline="47" pcid="5075">
    function approve(address _spender, uint256 _value)public returns (bool success);
    function allowance(address _owner, address _spender)public view returns (uint256 remaining);
</source>
<source file="systems/smart_contracts/BACD.sol" startline="61" endline="62" pcid="1016">
  function transfer(address _to, uint256 _value) public returns (bool success);
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
</source>
<source file="systems/smart_contracts/NMAI.sol" startline="46" endline="47" pcid="5445">
    function approve(address _spender, uint256 _value)public returns (bool success);
    function allowance(address _owner, address _spender)public view returns (uint256 remaining);
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="72" endline="74" pcid="1716">
    function approve(address _spender, uint256 _value) public returns (bool success);

    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);
</source>
<source file="systems/smart_contracts/Oracle.sol" startline="179" endline="180" pcid="5527">
  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);
  function increaseApproval(address spender, uint256 subtractedValue) external;
</source>
<source file="systems/smart_contracts/BTGS.sol" startline="16" endline="17" pcid="1540">
    function approve(address _spender, uint256 _value) public returns (bool success);
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);
</source>
<source file="systems/smart_contracts/DHF.sol" startline="44" endline="45" pcid="2538">
    function transfer(address _to, uint256 _value)public returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="393" endline="394" pcid="87">
    function transferMS(address _to, uint256 _ms) public returns (bool success);
    function transferMSI(address _to, uint256 _msi) public returns (bool success);
</source>
<source file="systems/smart_contracts/DHF.sol" startline="46" endline="47" pcid="2540">
    function approve(address _spender, uint256 _value)public returns (bool success);
    function allowance(address _owner, address _spender)public view returns (uint256 remaining);
</source>
<source file="systems/smart_contracts/AACD.sol" startline="44" endline="45" pcid="291">
    function transfer(address _to, uint256 _value)public returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success);
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="14" endline="15" pcid="2812">
    function transfer(address _to, uint256 _value) public returns (bool success);
    function transfer(address _to, uint _value, bytes _data) public returns (bool success);
</source>
<source file="systems/smart_contracts/SAS.sol" startline="43" endline="44" pcid="6294">
  function transfer(address _to, uint256 _value)public returns (bool success);
  function transferFrom(address _from, address _to, uint256 _value)public returns (bool success);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="395" endline="397" pcid="89">
    function transferMSM(address _to, uint256 _msm) public returns (bool success);

    function apply4Redeem(uint256 _ms) public returns(uint256 ms2r);
</source>
<source file="systems/smart_contracts/NMAI.sol" startline="44" endline="45" pcid="5443">
    function transfer(address _to, uint256 _value)public returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success);
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="68" endline="70" pcid="1714">
    function transfer(address _to, uint256 _value) public returns (bool success);

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="539" endline="540" pcid="126">
    function withdrawOrderTo(address _to, uint256 _amount) public returns(bool atonce);
    function withdrawMineral(uint256 _amount) public returns(bool atonce);
</source>
</class>

<class classid="4" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="15" endline="16" pcid="7">
    function transfer(address _to, uint _value, bytes _data) public returns (bool success);
    function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success);
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="15" endline="16" pcid="2813">
    function transfer(address _to, uint _value, bytes _data) public returns (bool success);
    function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success);
</source>
</class>

<class classid="5" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="16" endline="18" pcid="8">
    function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success);
    
    event Transfer(address indexed _from, address indexed _to, uint _value, bytes _data);
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="16" endline="18" pcid="2814">
    function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success);
    
    event Transfer(address indexed _from, address indexed _to, uint _value, bytes _data);
</source>
</class>

<class classid="6" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="30" endline="31" pcid="9">
    function tokenFallback(address _from, uint _value, bytes _data) public returns(bool);
}
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="29" endline="30" pcid="2815">
    function tokenFallback(address _from, uint _value, bytes _data) public returns(bool);
}
</source>
</class>

<class classid="7" nclones="515" nlines="3" similarity="75">
<source file="systems/smart_contracts/$martFund.sol" startline="35" endline="37" pcid="10">
    function owner() public pure returns (address) {}

    event OwnerUpdate(address _prevOwner, address _newOwner);
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="72" endline="75" pcid="2157">
  function decimals() public view returns(uint8) {
    return _decimals;
  }
}
</source>
<source file="systems/smart_contracts/Byte.sol" startline="103" endline="107" pcid="1579">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Factory.sol" startline="49" endline="60" pcid="3431">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Allows the current owner to relinquish control of the contract.
     * It will not be possible to call the functions with the `onlyOwner`
     * modifier anymore.
     * @notice Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="230" endline="237" pcid="7022">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See `IERC20.balanceOf`.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Bridge.sol" startline="173" endline="177" pcid="1509">
  function admin() external view returns (address) {
    return _admin();
  }

  function implementation() external view returns (address impl) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1026" endline="1033" pcid="1803">
    function closingTime() public view returns (uint256) {
        return _closingTime;
    }

    /**
     * @return true if the crowdsale is open, false otherwise.
     */
    function isOpen() public view returns (bool) {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="379" endline="382" pcid="3039">
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="119" endline="126" pcid="305">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="432" endline="439" pcid="5167">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See `IERC20.balanceOf`.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="457" endline="460" pcid="8211">
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="676" endline="692" pcid="7827">
    function endPage() public onlyProxy returns (bool) {
        require(_pageEthers[_page] > 0, "Ethers on current page is zero.");

        _pageEndingBlock[_page] = block.number;

        _page = _page.add(1);
        _pageVokenSum[_page] = _vokens;

        return true;
    }

    /**
     * @dev Push shareholders.
     *
     * Can only be called by a proxy.
     */
    function pushShareholders(address[] memory accounts, uint256[] memory values) public onlyProxy returns (bool) {
</source>
<source file="systems/smart_contracts/KingToken.sol" startline="100" endline="104" pcid="4488">
	function earningrate() public view returns (uint){
        return dailyminingpercent;
    }
	
	function referralrate() public view returns (uint){
</source>
<source file="systems/smart_contracts/MBA.sol" startline="72" endline="81" pcid="4705">
  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }

  /**
  * @dev Transfer token for a specified address
  * @param _to The address to transfer to.
  * @param _value The amount to be transferred.
  */
  function transfer(address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="170" endline="173" pcid="2857">
    function name() public view returns (string){
        return operator.token_name();
    }
    function symbol() public view returns (string){
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="563" endline="567" pcid="2621">
    function remainingTokens() public view returns (uint256) {
        return Math.min(token().balanceOf(_tokenWallet), token().allowance(_tokenWallet, address(this)));
    }

    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="293" endline="297" pcid="2586">
    function hasClosed() public view returns (bool) {
        return block.timestamp > _closingTime;
    }

    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal onlyWhileOpen view {
</source>
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="153" endline="157" pcid="1635">
    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }

    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="326" endline="333" pcid="493">
    function token() public view returns (IERC20) {
        return _token;
    }

    /**
     * @return the beneficiary of the tokens.
     */
    function beneficiary() public view returns (address) {
</source>
<source file="systems/smart_contracts/EtheleToken.sol" startline="136" endline="139" pcid="3212">
    function getPeriodLength() public pure returns (uint256) {
        return PERIOD_LENGTH; 
    }
    function getMintAmount() public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/EtheleToken.sol" startline="142" endline="145" pcid="3214">
    function getCurrentPeriod() public view returns (uint256) {
        return _currentPeriod; 
    }
    function getContractStartTime() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="31" endline="38" pcid="7338">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/LBBT.sol" startline="67" endline="71" pcid="4541">
  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }

  function transfer(address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="255" endline="261" pcid="5853">
    function decimals() public view returns(uint8) {
        return _decimals;
    }
    /**
    * @dev Total number of tokens in existence
    */
    function totalSupply() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/BFGToken.sol" startline="76" endline="80" pcid="1187">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  function balanceOf(address addr) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="242" endline="246" pcid="2671">
    function cap() public view returns (uint256) {
        return _cap;
    }

    function capReached() public view returns (bool) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="357" endline="361" pcid="2592">
    function primary() public view returns (address) {
        return _primary;
    }

    function transferPrimary(address recipient) public onlyPrimary {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="236" endline="244" pcid="6086">
  function isPricingStrategy() public constant returns (bool) {
    return true;
  }

  /** Self check if all references are correctly set.
   *
   * Checks that pricing strategy matches crowdsale parameters.
   */
  function isSane(address crowdsale) public constant returns (bool) {
</source>
<source file="systems/smart_contracts/Perlin.sol" startline="135" endline="143" pcid="5649">
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account `tokenOwner`
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="49" endline="53" pcid="4645">
  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }

  function transfer(address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="197" endline="201" pcid="2321">
    function owner() public view returns(address) {
        return _owner;
    }

    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="478" endline="485" pcid="2264">
    function name() public view returns (string) {
        return _name;
    }

    /**
     * @return the symbol of the token.
     */
    function symbol() public view returns (string) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="898" endline="907" pcid="6127">
  function isCrowdsale() public constant returns (bool) {
    return true;
  }

  //
  // Modifiers
  //

  /** Modified allowing execution only if the crowdsale is currently running.  */
  modifier inState(State state) {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="34" endline="41" pcid="940">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="349" endline="356" pcid="3810">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See `IERC20.balanceOf`.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/magesh.sol" startline="365" endline="371" pcid="4637">
    function price() public view returns (uint256){

      return price_;

    }

}
</source>
<source file="systems/smart_contracts/MiniMeTokenFactory.sol" startline="309" endline="322" pcid="4814">
    function totalSupply() public constant returns (uint) {
        return totalSupplyAt(block.number);
    }


////////////////
// Query balance and totalSupply in History
////////////////

    /// @dev Queries the balance of `_owner` at a specific `_blockNumber`
    /// @param _owner The address from which the balance will be retrieved
    /// @param _blockNumber The block number when the balance is queried
    /// @return The balance at `_blockNumber`
    function balanceOfAt(address _owner, uint _blockNumber) public constant returns (uint) {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="977" endline="987" pcid="5044">
    function totalSupply() public view returns (uint256) {
        return _allTokens.length;
    }

    /**
     * @dev Gets the token ID at a given index of all the tokens in this contract
     * Reverts if the index is greater or equal to the total number of tokens.
     * @param index uint256 representing the index to be accessed of the tokens list
     * @return uint256 token ID at the given index of the tokens list
     */
    function tokenByIndex(uint256 index) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="279" endline="286" pcid="5916">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="441" endline="448" pcid="539">
    function cliff() public view returns (uint256) {
        return _cliff;
    }

    /**
     * @return the start time of the token vesting.
     */
    function start() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/BEX.sol" startline="24" endline="28" pcid="1165">
	function totalSupply()public constant returns (uint) {
		return totalBEXSupply;
	}
	
	function balanceOf(address tokenOwner)public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="177" endline="181" pcid="2320">
    function decimals() public view returns(uint8) {
        return _decimals;
    }

}
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="106" endline="111" pcid="3421">
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/MatchingToken.sol" startline="37" endline="41" pcid="4685">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }
    
    function _transfer(address _from, address _to, uint256 _value) internal {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="131" endline="138" pcid="5843">
    function owner() public view returns(address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/Discover.sol" startline="186" endline="197" pcid="2768">
    function getDAppsCount() external view returns(uint) {
        return dapps.length;
    }

    /**
     * @notice Support for "approveAndCall".
     * @param _from Who approved.
     * @param _amount Amount being approved, needs to be equal `_amount` or `cost`.
     * @param _token Token being approved, needs to be `SNT`.
     * @param _data Abi encoded data with selector of `register(bytes32,address,bytes32,bytes32)`.
     */
    function receiveApproval(
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="206" endline="210" pcid="2322">
    function isOwner() public view returns(bool) {
        return msg.sender == _owner;
    }

    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/UtilityTokenFactory.sol" startline="77" endline="81" pcid="7595">
    function getNumOfTokens() public view returns (uint256) {
        return tokens.length;
    }

    function getNumOfIssuers() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="227" endline="234" pcid="653">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See `IERC20.balanceOf`.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="215" endline="224" pcid="8084">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  /**
   * @dev Gets the balance of the specified address.
   * @param _owner The address to query the the balance of.
   * @return An uint256 representing the amount owned by the passed address.
   */
  function balanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="91" endline="95" pcid="8051">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }
    
    function name() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="1213" endline="1217" pcid="4911">
  function isCrowdsaleFull() public constant returns (bool) {
    return tokensSold >= maximumSellableTokens;
  }

  function setMaximumSellableTokens(uint tokens) public onlyOwner {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="627" endline="634" pcid="3838">
    function decimals() external view returns (uint8) {
        return _decimals;
    }

    /**
     * @return true if the contract is paused, false otherwise.
     */
    function paused() external view returns (bool) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="378" endline="382" pcid="2594">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="398" endline="408" pcid="750">
    function isOwner() public view returns(bool) {
        return msg.sender == _owner;
    }

    /**
    * @dev Allows the current owner to relinquish control of the contract.
    * @notice Renouncing to ownership will leave the contract without an owner.
    * It will not be possible to call the functions with the `onlyOwner`
    * modifier anymore.
    */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="103" endline="107" pcid="8054">
    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function burn(uint256 amount) public {
</source>
<source file="systems/smart_contracts/UTC.sol" startline="85" endline="94" pcid="7578">
  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }

  /**
  * @dev transfer token for a specified address
  * @param _to The address to transfer to.
  * @param _value The amount to be transferred.
  */
  function transfer(address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="76" endline="79" pcid="1472">
  function decimals() public view returns(uint8) {
    return _decimals;
  }
}
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="241" endline="248" pcid="5851">
    function name() public view returns(string) {
        return _name;
    }

    /**
     * @return the symbol of the token.
     */
    function symbol() public view returns(string) {
</source>
<source file="systems/smart_contracts/multifund.sol" startline="47" endline="51" pcid="5140">
    function get_id() public view returns(bytes32){
        return wallet_id;
    }

    function () public payable {
</source>
<source file="systems/smart_contracts/KYCRegistry.sol" startline="49" endline="60" pcid="4502">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * > Note: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="293" endline="302" pcid="6091">
  function isFinalizeAgent() public constant returns(bool) {
    return true;
  }

  /** Return true if we can run finalizeCrowdsale() properly.
   *
   * This is a safety check function that doesn't allow crowdsale to begin
   * unless the finalizer has been set up properly.
   */
  function isSane() public constant returns (bool);
</source>
<source file="systems/smart_contracts/ComplianceRegistry.sol" startline="27" endline="34" pcid="1943">
    function owner() public view returns(address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="945" endline="949" pcid="6641">
	function getWithdrawableAmount() public view returns(uint256) {
		return withdrawableBalances[msg.sender];
	}

	function withdraw() public returns (bool) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1406" endline="1413" pcid="1827">
    function goalReached() public view returns (bool) {
        return weiRaised() >= _goal;
    }

    /**
     * @dev Escrow finalization task, called when finalize() is called.
     */
    function _finalization() internal {
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="143" endline="149" pcid="6687">
    function pauseICO() onlyOwner public returns (bool) {
        icoStart = true;
        emit PauseICO();
        return true;
    }

    function resetICO() onlyOwner public returns (bool) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="627" endline="634" pcid="7093">
    function decimals() external view returns (uint8) {
        return _decimals;
    }

    /**
     * @return true if the contract is paused, false otherwise.
     */
    function paused() external view returns (bool) {
</source>
<source file="systems/smart_contracts/TokenSwap.sol" startline="108" endline="119" pcid="7391">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Allows the current owner to relinquish control of the contract.
     * It will not be possible to call the functions with the `onlyOwner`
     * modifier anymore.
     * @notice Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/OSManagerToken.sol" startline="87" endline="91" pcid="5556">
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }

    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/ERC20Detailed.sol" startline="46" endline="55" pcid="3006">
  function decimals() public view returns(uint8) {
    return _decimals;
  }

  /**
   * @dev mint function, checks if the contract is allowed to mint
   * @param _to the receiver of the tokens when mint funtion is successful
   * @param _value the amount of tokens to mint
   */
  function mint(address _to, uint256 _value) public returns (bool)  {
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="499" endline="502" pcid="328">
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="123" endline="126" pcid="5100">
    function decimals() public view returns(uint8) {
        return _Tokendecimals;
    }
}
</source>
<source file="systems/smart_contracts/SuperMarket.sol" startline="32" endline="36" pcid="6759">
    function owner() public view returns (address) {
        return _owner;
    }
    
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="42" endline="54" pcid="5668">
  function isConstructor() private view returns (bool) {
    // extcodesize checks the size of the code stored in an address, and
    // address returns the current address. Since the code is still not
    // deployed when running a constructor, any checks on its code size will
    // yield zero, making it an effective way to detect if a contract is
    // under construction or not.
    uint256 cs;
    assembly { cs := extcodesize(address) }
    return cs == 0;
  }

  // Reserved storage space to allow for layout changes in the future.
  uint256[50] private ______gap;
</source>
<source file="systems/smart_contracts/TorexToken.sol" startline="89" endline="98" pcid="7410">
  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }

  /**
  * @dev transfer token for a specified address
  * @param _to The address to transfer to.
  * @param _value The amount to be transferred.
  */
  function transfer(address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="262" endline="267" pcid="237">
    function getChallengeNumber() public view returns(bytes32) {
        return challengeNumber;
    }

    //the number of zeroes the digest of the PoW solution requires.  Auto adjusts
    function getMiningDifficulty() public view returns(uint) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="634" endline="641" pcid="3839">
    function paused() external view returns (bool) {
        return _paused;
    }

    /**
     * @dev called by the owner to pause, triggers stopped state
     */
    function pause() external onlyOwner whenNotPaused {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="896" endline="904" pcid="562">
    function tokenAddress() public view returns (IERC20) {
        return token;
    }

    // MODIFIERS
    /**
    * @dev Allows to perform method by existing beneficiary
    */
    modifier onlyExistingBeneficiary(address _beneficiary) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1292" endline="1299" pcid="1818">
    function state() public view returns (State) {
        return _state;
    }

    /**
     * @return The beneficiary of the escrow.
     */
    function beneficiary() public view returns (address) {
</source>
<source file="systems/smart_contracts/PokaToken.sol" startline="32" endline="36" pcid="5731">
    function owner() public view returns (address) {
        return _owner;
    }
    
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="745" endline="752" pcid="6116">
  function getLastTier() public constant returns(address) {
    if (joinedCrowdsalesLen > 0)
      return joinedCrowdsales[joinedCrowdsalesLen - 1];
    else
      return address(0);
  }

  function setJoinedCrowdsales(address addr) private onlyOwner {
</source>
<source file="systems/smart_contracts/UtilityTokenFactory.sol" startline="85" endline="88" pcid="7597">
    function getFundsHolderAddress() public view returns (address) {
        return address(fundsHolder);
    }
}
</source>
<source file="systems/smart_contracts/Comet.sol" startline="72" endline="75" pcid="1925">
  function decimals() public view returns(uint8) {
    return _decimals;
  }
}
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1187" endline="1191" pcid="6145">
  function canUpgrade() public constant returns(bool) {
     return true;
  }

}
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="238" endline="242" pcid="4398">
    function getNowTime() public view returns(uint256) {
      return now;//now
    }

    function showLockState(address _holder) public view returns (bool, uint256, uint256) {
</source>
<source file="systems/smart_contracts/BlackJack.sol" startline="218" endline="227" pcid="1344">
    function deposit() public payable returns (bool){
        _deposit(msg.sender, msg.value);
        return true;
    }

    /**
    * @dev apply for withdrawal.
    * @param amount the amount to apply for withdrawal, should be less than balance subtract locked.
     */
    function apply(uint256 amount) public returns (bool){
</source>
<source file="systems/smart_contracts/EtheleToken.sol" startline="65" endline="69" pcid="3201">
    function getCreator() public view returns (address) {
    	return _creator;
    }

    function getTransmuteSource1() public view returns (address) {
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="173" endline="176" pcid="2858">
    function symbol() public view returns (string){
        return operator.token_symbol();
    }
    function decimals() public view returns (uint8){
</source>
<source file="systems/smart_contracts/ProxyERC20.sol" startline="417" endline="427" pcid="5896">
    function totalSupply() public view returns (uint256) {
        // Immutable static call from target contract
        return IERC20(target).totalSupply();
    }

    /**
    * @dev Gets the balance of the specified address.
    * @param owner The address to query the balance of.
    * @return An uint256 representing the amount owned by the passed address.
    */
    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="602" endline="609" pcid="4450">
    function paused() public view returns (bool) {
        return _paused;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     */
    modifier whenNotPaused() {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="658" endline="666" pcid="5134">
    function totalEthereumBalance()
        public
        view
        returns(uint)
    {
        return address (this).balance;
    }

    function getTotalBondValue()
</source>
<source file="systems/smart_contracts/ankara.sol" startline="84" endline="88" pcid="686">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="172" endline="176" pcid="2568">
    function token() public view returns (IERC20) {
        return _token;
    }

    function wallet() public view returns (address payable) {
</source>
<source file="systems/smart_contracts/RubyToken.sol" startline="33" endline="37" pcid="6225">
    function decimals() public view returns (uint256) {
        return _decimals;
    }
    
    function totalSupply() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="442" endline="449" pcid="7035">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="551" endline="555" pcid="3741">
function investorsNumber() public view returns(uint) {
return m_investors.size();
}

function balanceETH() public view returns(uint) {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="133" endline="142" pcid="7646">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev Gets the balance of the specified address.
     * @param owner The address to query the balance of.
     * @return A uint256 representing the amount owned by the passed address.
     */
    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="625" endline="636" pcid="6105">
  function canDistributeReservedTokens() public constant returns(bool) {
    CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());
    if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;
    return false;
  }

  /**
   * Finalize a succcesful crowdsale.
   *
   * The owner can triggre a call the contract that provides post-crowdsale actions, like releasing the tokens.
   */
  function finalize() public inState(State.Success) onlyOwner stopInEmergency {
</source>
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="300" endline="308" pcid="243">
    function totalSupply() public view returns(uint) {
        return _totalSupply - balances[address(0)];
    }

    // ------------------------------------------------------------------------
    // Get the token balance for account `tokenOwner`
    // ------------------------------------------------------------------------

    function balanceOf(address tokenOwner) public view returns(uint balance) {
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="106" endline="111" pcid="1256">
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="167" endline="170" pcid="8174">
    function getWhitelistRule() external view returns (byte){
        return listRule;
    }
}
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="184" endline="188" pcid="2571">
    function weiRaised() public view returns (uint256) {
        return _weiRaised;
    }

    function buyTokens(address beneficiary) public nonReentrant payable {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="258" endline="269" pcid="7798">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     *
     * Need to run {acceptOwnership} by the new owner.
     *
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/multifind.sol" startline="47" endline="51" pcid="5085">
    function get_id() public view returns(bytes32){
        return wallet_id;
    }

    function () public payable {
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="95" endline="99" pcid="2158">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="555" endline="561" pcid="3742">
function balanceETH() public view returns(uint) {
return address(this).balance;
}



function advertisingPercent() public view returns(uint numerator, uint denominator) {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="584" endline="591" pcid="926">
    function getWLThresholdBalance() public view returns (uint256) {
        return whitelistThresholdBalance;
    }

    /**
     * @return maxAmount for holder
     */
    function getMaxWLAmount(address _subscriber) external view returns(uint256) {
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="114" endline="118" pcid="3175">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/CommunityChest.sol" startline="31" endline="35" pcid="1942">
    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }
    
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/EJackpot.sol" startline="437" endline="441" pcid="2925">
    function random() private view returns (uint8) {
        return uint8(uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty, msg.sender, userCasesCount[msg.sender]))) % 100) + 1;
    }

    modifier notContract(address addr, bool referrer) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="317" endline="321" pcid="2680">
    function finalized() public view returns (bool) {
        return _finalized;
    }

    function finalize() public {
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="215" endline="221" pcid="8175">
    function totalSupply() external view returns (uint) {
        return _totalSupply.sub(balances[address(0)]);
    }

    // ------------------------------------------------------------------------
    // Get the token balance for account `tokenOwner`
    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="227" endline="230" pcid="7351">
    function hasEnded() public view returns (bool) {
        return now > endTime;
    }
}
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="485" endline="492" pcid="2265">
    function symbol() public view returns (string) {
        return _symbol;
    }

    /**
     * @return the number of decimals of the token.
     */
    function decimals() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="434" endline="441" pcid="538">
    function beneficiary() public view returns (address) {
        return _beneficiary;
    }

    /**
     * @return the cliff time of the token vesting.
     */
    function cliff() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1573" endline="1578" pcid="6167">
  function isSane() public constant returns (bool) {
    return (token.releaseAgent() == address(this));
  }

  //distributes reserved tokens. Should be called before finalization
  function distributeReservedTokens(uint reservedTokensDistributionBatch) public {
</source>
<source file="systems/smart_contracts/ProxyERC20.sol" startline="407" endline="417" pcid="5895">
    function decimals() public view returns (uint8){
         // Immutable static call from target contract
        return IERC20(target).decimals();
    }

    // ------------- ERC20 Interface ------------- //

    /**
    * @dev Total number of tokens in existence
    */
    function totalSupply() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/FMT.sol" startline="33" endline="42" pcid="3651">
  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }

  /**
  * @dev transfer token for a specified address
  * @param _to The address to transfer to.
  * @param _value The amount to be transferred.
  */
  function transfer(address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="109" endline="120" pcid="5776">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="191" endline="202" pcid="7278">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Allows the current owner to relinquish control of the contract.
     * It will not be possible to call the functions with the `onlyOwner`
     * modifier anymore.
     * @notice Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="261" endline="270" pcid="5854">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
    * @dev Gets the balance of the specified address.
    * @param owner The address to query the balance of.
    * @return An uint256 representing the amount owned by the passed address.
    */
    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/SolaToken.sol" startline="119" endline="127" pcid="6586">
    function totalSupply() public view returns (uint) {
        return _totalSupply.sub(balances[address(0)]);
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account `tokenOwner`
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public view returns (uint balance) {
</source>
<source file="systems/smart_contracts/AICRYPTO.sol" startline="131" endline="139" pcid="431">
    function totalSupply() public view returns (uint) {
        return _totalSupply.sub(balances[address(0)]);
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account `tokenOwner`
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public view returns (uint balance) {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="2294" endline="2306" pcid="6904">
    function lastDebtLedgerEntry()
        external
        view
        returns (uint)
    {
        return debtLedger[debtLedger.length - 1];
    }

    /**
     * @notice Query whether an account has issued and has an outstanding debt balance
     * @param account The address to query for
     */
    function hasIssued(address account)
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="113" endline="117" pcid="7555">
    function totalSupply() public view returns (uint) {
        return _totalSupply  - balances[address(0)];
    }

    function balanceOf(address tokenOwner) public view returns (uint balance) {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="34" endline="41" pcid="2453">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="267" endline="274" pcid="5422">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/JUNDCOIN.sol" startline="128" endline="136" pcid="4365">
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/SapientiaCharlesToken.sol" startline="133" endline="141" pcid="6280">
    function totalSupply() public view returns (uint) {
        return _totalSupply.sub(balances[address(0)]);
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account `tokenOwner`
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public view returns (uint balance) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="443" endline="450" pcid="5363">
    function cap() public view returns (uint256) {
        return _cap;
    }

    /**
     * @dev Returns the amount of VOKEN in existence.
     */
    function totalSupply() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="146" endline="156" pcid="5844">
    function isOwner() public view returns(bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Allows the current owner to relinquish control of the contract.
     * @notice Renouncing to ownership will leave the contract without an owner.
     * It will not be possible to call the functions with the `onlyOwner`
     * modifier anymore.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="313" endline="320" pcid="2469">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See `IERC20.balanceOf`.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="613" endline="624" pcid="7211">
    function cap() public view returns (uint256) {
        return _cap;
    }

    /**
     *  See `ERC20Mintable.mint`.
     *
     * Requirements:
     *
     * - `value` must not cause the total supply to go over the cap.
     */
    function _mint(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1299" endline="1307" pcid="1819">
    function beneficiary() public view returns (address) {
        return _beneficiary;
    }

    /**
     * @dev Stores funds that may later be refunded.
     * @param refundee The address funds will be sent to if a refund occurs.
     */
    function deposit(address refundee) public payable {
</source>
<source file="systems/smart_contracts/ComplianceRegistry.sol" startline="42" endline="52" pcid="1944">
    function isOwner() public view returns(bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Allows the current owner to relinquish control of the contract.
     * @notice Renouncing to ownership will leave the contract without an owner.
     * It will not be possible to call the functions with the `onlyOwner`
     * modifier anymore.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/EtheleToken.sol" startline="72" endline="75" pcid="3203">
    function getTransmuteSource2() public view returns (address) {
    	return _transmuteSource2;
    }
    function getTransmuteSource3() public view returns (address) {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="624" endline="631" pcid="977">
    function paused() public view returns (bool) {
        return _paused;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     */
    modifier whenNotPaused() {
</source>
<source file="systems/smart_contracts/KingToken.sol" startline="84" endline="88" pcid="4484">
    function totalSupply() public view returns (uint){
        return supply;
    }
	
	function frozenSupply() public view returns (uint){
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="650" endline="657" pcid="7383">
    function validPurchase() internal view returns (bool) {
        return now >= startTime && now <= endTime;
    }

    /**
     * @dev finalizes crowdsale
     */
    function finalization() internal {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1166" endline="1178" pcid="6143">
  function getUpgradeState() public constant returns(UpgradeState) {
    if(!canUpgrade()) return UpgradeState.NotAllowed;
    else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;
    else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;
    else return UpgradeState.Upgrading;
  }

  /**
   * Change the upgrade master.
   *
   * This allows us to set a new owner for the upgrade mechanism.
   */
  function setUpgradeMaster(address master) public {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="142" endline="159" pcid="6830">
    function preciseUnit()
        external
        pure 
        returns (uint)
    {
        return PRECISE_UNIT;
    }

    /**
     * @return The result of multiplying x and y, interpreting the operands as fixed-point
     * decimals.
     * 
     * @dev A unit factor is divided out after the product of x and y is evaluated,
     * so that product must be less than 2**256. As this is an integer division,
     * the internal division always rounds down. This helps save on gas. Rounding
     * is more expensive on gas.
     */
    function multiplyDecimal(uint x, uint y)
</source>
<source file="systems/smart_contracts/GNB.sol" startline="164" endline="171" pcid="4131">
    function now_() public constant returns (uint){
        return now;
    }

    // ------------------------------------------------------------------------
    // Total supply
    // ------------------------------------------------------------------------
    function totalSupply() public constant returns (uint) {
</source>
<source file="systems/smart_contracts/DNP.sol" startline="144" endline="153" pcid="2798">
    function totalSupply() public view returns (uint256) 
    {
        return totalSupply_;
    }
    /**
    * @dev transfer token for a specified address
    * @param _to The address to transfer to.
    * @param _value The amount to be transferred.
    */
    function transfer(address _to, uint256 _value) public running returns (bool) 
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1019" endline="1026" pcid="1802">
    function openingTime() public view returns (uint256) {
        return _openingTime;
    }

    /**
     * @return the crowdsale closing time.
     */
    function closingTime() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/LanceToken.sol" startline="132" endline="140" pcid="4523">
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="555" endline="559" pcid="2711">
    function tokenWallet() public view returns (address) {
        return _tokenWallet;
    }

    function remainingTokens() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="219" endline="228" pcid="6730">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev Gets the balance of the specified address.
     * @param owner The address to query the balance of.
     * @return An uint256 representing the amount owned by the passed address.
     */
    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/VENT.sol" startline="98" endline="104" pcid="7686">
        function totalSupply() public view returns (uint){
        return _totalSupply * 10**uint(decimals);
        }
        // ------------------------------------------------------------------------
        // Get the token balance for account `tokenOwner`
        // ------------------------------------------------------------------------
        function balanceOf(address tokenOwner) public view returns (uint balance) {
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="370" endline="374" pcid="2119">
  function canUpgrade() public constant returns(bool) {
     return true;
  }

}
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="125" endline="134" pcid="1370">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
    * @dev Gets the balance of the specified address.
    * @param owner The address to query the balance of.
    * @return An uint256 representing the amount owned by the passed address.
    */
    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="156" endline="167" pcid="807">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Allows the current owner to relinquish control of the contract.
     * It will not be possible to call the functions with the `onlyOwner`
     * modifier anymore.
     * @notice Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="449" endline="456" pcid="7919">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="455" endline="463" pcid="273">
    function getMiningTarget() public constant returns (uint) {
       return miningTarget;
   }



    //84m coins total
    //reward begins at 50 and is cut in half every reward era (as tokens are mined)
    function getMiningReward() public constant returns (uint) {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="365" endline="371" pcid="4949">
    function price() public view returns (uint256){

      return price_;

    }

}
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="393" endline="402" pcid="597">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
    * @dev Gets the balance of the specified address.
    * @param owner The address to query the balance of.
    * @return An uint256 representing the amount owned by the passed address.
    */
    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/KingToken.sol" startline="88" endline="92" pcid="4485">
	function frozenSupply() public view returns (uint){
        return allfrozen;
    }
	
	 function circulatingSupply() public view returns (uint){
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="502" endline="505" pcid="5437">
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="156" endline="167" pcid="3762">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Allows the current owner to relinquish control of the contract.
     * It will not be possible to call the functions with the `onlyOwner`
     * modifier anymore.
     * @notice Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/TimeLockedTokenStorage.sol" startline="408" endline="414" pcid="7248">
    function getSlotsQuantity() public view returns(uint256) {
        return totalSlot.length;
    }
    /**
     * @dev Returned total locked tokens
    */
    function getTotalLockedTokens() public view returns(uint256) {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="131" endline="142" pcid="6829">
    function unit()
        external
        pure
        returns (uint)
    {
        return UNIT;
    }

    /** 
     * @return Provides an interface to PRECISE_UNIT.
     */
    function preciseUnit()
</source>
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="418" endline="422" pcid="499">
    function beneficiariesCount() public view returns(uint) {
        return beneficiaries.length;
    }

    function allOperationsCount() public view returns(uint) {
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="451" endline="455" pcid="272">
     function getMiningDifficulty() public constant returns (uint) {
        return _MAXIMUM_TARGET.div(miningTarget);
    }

    function getMiningTarget() public constant returns (uint) {
</source>
<source file="systems/smart_contracts/FlatPricingExt.sol" startline="75" endline="83" pcid="3632">
  function isPricingStrategy() public constant returns (bool) {
    return true;
  }

  /** Self check if all references are correctly set.
   *
   * Checks that pricing strategy matches crowdsale parameters.
   */
  function isSane(address crowdsale) public constant returns (bool) {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="485" endline="492" pcid="6751">
    function symbol() public view returns (string) {
        return _symbol;
    }

    /**
     * @return the number of decimals of the token.
     */
    function decimals() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/VACCToken.sol" startline="135" endline="143" pcid="7626">
    function totalSupply() public constant returns (uint256) {
        return _totalSupply;
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/tharDex.sol" startline="33" endline="38" pcid="7144">
    function deposit() public payable returns(bool) {
        require(msg.value > 0);
        return true;
    }

    function withdraw(string memory message,uint8  v,bytes32 r,bytes32 s,uint8 type_,address tokenaddr,address payable to,uint256 amount) public  returns(bool) {
</source>
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="277" endline="284" pcid="240">
    function getMiningReward() public view returns(uint) {
        //once we get half way thru the coins, only get 1 per block
        //every reward era, the reward amount halves.
        return (2 * 10 ** uint(decimals)).div(2 ** rewardEra);
    }

    //help debug mining software
    function getMintDigest(uint256 nonce, bytes32 challenge_digest, bytes32 challenge_number) public view returns(bytes32 digesttest) {
</source>
<source file="systems/smart_contracts/EtheleToken.sol" startline="62" endline="65" pcid="3200">
    function decimals() public pure returns (uint8) {
        return 18;
    }
    function getCreator() public view returns (address) {
</source>
<source file="systems/smart_contracts/PDataToSHFund.sol" startline="76" endline="85" pcid="5631">
  function getBalance()
    constant
    public
    returns(uint)
  {
    return company_token.balanceOf(this);
  }


  function setOwner(address _owner) 
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="72" endline="75" pcid="2650">
  function decimals() public view returns(uint8) {
    return _decimals;
  }
}
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="784" endline="791" pcid="5389">
    function whitelistingMode() public view returns (bool) {
        return _whitelistingMode;
    }

    /**
     * @dev Returns the referee of an `account`.
     */
    function whitelistReferee(address account) public view returns (address) {
</source>
<source file="systems/smart_contracts/ankara.sol" startline="179" endline="182" pcid="701">
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="733" endline="737" pcid="6113">
  function whitelistedParticipantsLength() public constant returns (uint) {
    return whitelistedParticipants.length;
  }

  function isTierJoined(address addr) public constant returns(bool) {
</source>
<source file="systems/smart_contracts/EtheleToken.sol" startline="78" endline="81" pcid="3205">
    function getTransmuteSource4() public view returns (address) {
    	return _transmuteSource4;
    }
    function getAllowBurnsFrom(address addr) public view returns (bool) {
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="97" endline="101" pcid="1473">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="180" endline="184" pcid="2662">
    function weiRaised() public view returns (uint256) {
        return _weiRaised;
    }

    function buyTokens(address beneficiary) public nonReentrant payable {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="742" endline="745" pcid="6057">
    function getTrackerBalance() public view returns (uint256) {
        return token.balanceOf(address(this));
    }
}
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="457" endline="468" pcid="7036">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Allows the current owner to relinquish control of the contract.
     * It will not be possible to call the functions with the `onlyOwner`
     * modifier anymore.
     * @notice Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/KingToken.sol" startline="92" endline="96" pcid="4486">
	 function circulatingSupply() public view returns (uint){
        return (supply-allfrozen-balances[kcma]-balances[whitelist]-balances[whitelist2]);
    }
	
	function burningrate() public view returns (uint){
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="453" endline="456" pcid="7196">
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="450" endline="457" pcid="5364">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev Returns the amount of VOKEN owned by `account`.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/magesh.sol" startline="115" endline="124" pcid="4618">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev Gets the balance of the specified address.
     * @param owner The address to query the balance of.
     * @return A uint256 representing the amount owned by the passed address.
     */
    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/MpctLockupTeam.sol" startline="96" endline="112" pcid="5067">
    function getCurrLocking()
        public
		view
        returns (uint256)
	{
	    if (lockupDate >= now)
	        return initLockupAmt;
	    
        uint256 diff = (now - lockupDate) / 2592000; // month diff
        uint256 partition = 10;
    
        if (diff >= partition) 
            return 0;
        else
            return initLockupAmt.mul(partition-diff).div(partition);
    }
}
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="246" endline="250" pcid="2580">
    function cap() public view returns (uint256) {
        return _cap;
    }

    function capReached() public view returns (bool) {
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="583" endline="584" pcid="145">
	function data() public pure returns(IData){}
	function reserve() public pure returns(IReserve){}
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="345" endline="349" pcid="885">
    function getMinterAddress() external view returns(address) {
        return _minterAddress;
    }

    function setMinterAddress(address _minter) external onlyOwner returns(address) {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="362" endline="366" pcid="887">
    function getWalletOnTopAddress() external view returns (address) {
        return _walletOnTopAddress;
    }

    function setWalletOnTopAddress(address _wallet) external onlyOwner returns(address) {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="480" endline="487" pcid="7737">
    function name() public view returns (string) {
        return _name;
    }

    /**
     * @return the symbol of the token.
     */
    function symbol() public view returns (string) {
</source>
<source file="systems/smart_contracts/Byte.sol" startline="72" endline="76" pcid="1577">
  function decimals() public view returns(uint8) {
    return _Decimals;
  }
	
  function symbol() public view returns(string memory) {
</source>
<source file="systems/smart_contracts/VOTENOmodumtokenswapdotcom.sol" startline="132" endline="140" pcid="7842">
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="584" endline="585" pcid="146">
	function reserve() public pure returns(IReserve){}
	function formula() public pure returns(IFormula){}
</source>
<source file="systems/smart_contracts/WanCoinToken.sol" startline="119" endline="127" pcid="7886">
    function totalSupply() public view returns (uint) {
        return _totalSupply.sub(balances[address(0)]);
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account `tokenOwner`
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public view returns (uint balance) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="297" endline="304" pcid="5357">
    function paused() public view returns (bool) {
        return _paused;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     */
    modifier whenNotPaused() {
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="551" endline="553" pcid="132">
    function reserve() public pure returns(IReserve) { }

    function totalSupply() public view returns (uint256);
</source>
<source file="systems/smart_contracts/SistContract.sol" startline="68" endline="77" pcid="6521">
  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }

  /**
  * @dev transfer token for a specified address
  * @param _to The address to transfer to.
  * @param _value The amount to be transferred.
  */
  function transfer(address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="176" endline="180" pcid="2859">
    function decimals() public view returns (uint8){
        return operator.token_decimals();
    }
    
    function totalSupply() public view returns (uint256){
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="609" endline="613" pcid="2623">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="3005" endline="3018" pcid="6942">
    function availableSynthCount()
        public
        view
        returns (uint)
    {
        return availableSynths.length;
    }

    // ========== MUTATIVE FUNCTIONS ==========

    /**
     * @notice ERC20 transfer function.
     */
    function transfer(address to, uint value)
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="168" endline="172" pcid="2659">
    function token() public view returns (IERC20) {
        return _token;
    }

    function wallet() public view returns (address payable) {
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="518" endline="519" pcid="109">
    function headOfQueue() public pure returns(uint256){}
    function tailOfQueue() public view returns(uint256);
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="114" endline="121" pcid="2983">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  /**
   * @dev See `IERC20.balanceOf`.
   */
  function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="517" endline="518" pcid="108">
    function balanceOfQueue() public pure returns(uint256) {}
    function headOfQueue() public pure returns(uint256){}
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="585" endline="587" pcid="147">
	function formula() public pure returns(IFormula){}
	
    function dequeueOrder(uint256 gaslimit, bool force) public returns(uint256 dealt);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="516" endline="517" pcid="107">
    function balanceOfProject() public pure returns(uint256) {}
    function balanceOfQueue() public pure returns(uint256) {}
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="241" endline="249" pcid="4846">
  function isPricingStrategy() public constant returns (bool) {
    return true;
  }

  /** Self check if all references are correctly set.
   *
   * Checks that pricing strategy matches crowdsale parameters.
   */
  function isSane(address crowdsale) public constant returns (bool) {
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="515" endline="516" pcid="106">
    function balanceOfMineral() public pure returns(uint256) {}
    function balanceOfProject() public pure returns(uint256) {}
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="514" endline="515" pcid="105">
    function balanceOfOrder() public pure returns(uint256) {}
    function balanceOfMineral() public pure returns(uint256) {}
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="774" endline="783" pcid="3104">
  function symbol() external view returns (string) {
    return symbol_;
  }

  /**
   * @dev Returns an URI for a given token ID
   * Throws if the token ID does not exist. May return an empty string.
   * @param _tokenId uint256 ID of the token to query
   */
  function tokenURI(uint256 _tokenId) public view returns (string) {
</source>
<source file="systems/smart_contracts/ERC20Detailed.sol" startline="32" endline="39" pcid="3004">
  function name() public view returns(string) {
    return _name;
  }

  /**
   * @return the symbol of the token.
   */
  function symbol() public view returns(string) {
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="176" endline="183" pcid="7277">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="500" endline="514" pcid="277">
    function totalSupply() public constant returns (uint) {

        return _totalSupply  - balances[address(0)];

    }



    // ------------------------------------------------------------------------

    // Get the token balance for account `tokenOwner`

    // ------------------------------------------------------------------------

    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="2283" endline="2294" pcid="6903">
    function debtLedgerLength()
        external
        view
        returns (uint)
    {
        return debtLedger.length;
    }

    /**
     * @notice Retrieve the most recent entry from the debt ledger
     */
    function lastDebtLedgerEntry()
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="49" endline="60" pcid="2454">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * > Note: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="513" endline="514" pcid="104">
    function balanceOfShares() public pure returns(uint256) {}
    function balanceOfOrder() public pure returns(uint256) {}
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="72" endline="76" pcid="2307">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="223" endline="230" pcid="8196">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See `IERC20.balanceOf`.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="464" endline="475" pcid="7920">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * > Note: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="355" endline="362" pcid="7662">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="303" endline="310" pcid="590">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/Ethertime.sol" startline="376" endline="379" pcid="3315">
    function getOwner() public view returns (address) {
        return _owner;
    }
    function getTotalFee() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="340" endline="347" pcid="495">
    function releaseTime() public view returns (uint256) {
        return _releaseTime;
    }

    /**
     * @notice Transfers tokens held by timelock to beneficiary.
     */
    function release() public {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="634" endline="641" pcid="7094">
    function paused() external view returns (bool) {
        return _paused;
    }

    /**
     * @dev called by the owner to pause, triggers stopped state
     */
    function pause() external onlyOwner whenNotPaused {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="727" endline="734" pcid="7934">
    function rate() public view returns (uint256) {
        return _rate;
    }

    /**
     * @return the amount of wei raised.
     */
    function weiRaised() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="289" endline="298" pcid="3570">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
    * @dev Gets the balance of the specified address.
    * @param owner The address to query the balance of.
    * @return An uint256 representing the amount owned by the passed address.
    */
    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="230" endline="237" pcid="7906">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See `IERC20.balanceOf`.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="598" endline="606" pcid="928">
    function getWLLength() external view returns(uint256) {
        return whitelistLength;
    }

    /**
     * @dev set new anonymous threshold
     * @param _newThreshold The new anonymous threshold.
     */
    function setNewThreshold(uint256 _newThreshold) external onlyWLManagers {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="176" endline="180" pcid="2661">
    function rate() public view returns (uint256) {
        return _rate;
    }

    function weiRaised() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/PositionTokenV2.sol" startline="306" endline="314" pcid="5760">
    function totalSupply()
        public
        view
        returns (uint256)
    {
        return denormalize(totalSupply_);
    }

    function balanceOf(
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="348" endline="355" pcid="2756">
  function name() public view returns(string) {
    return _name;
  }

  /**
   * @return the symbol of the token.
   */
  function symbol() public view returns(string) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1387" endline="1395" pcid="1825">
    function goal() public view returns (uint256) {
        return _goal;
    }

    /**
     * @dev Investors can claim refunds here if crowdsale is unsuccessful.
     * @param refundee Whose refund will be claimed.
     */
    function claimRefund(address payable refundee) public {
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="367" endline="370" pcid="2352">
    function getOwner() public view returns (address) {
        return owner;
    }
}
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="106" endline="111" pcid="1310">
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="264" endline="271" pcid="6995">
    function decimals() public view returns (uint256) {
        return _decimals;
    }

    /**
     * @return the cap for the token minting.
     */
    function cap() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="482" endline="485" pcid="3584">
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}
</source>
<source file="systems/smart_contracts/EthNote.sol" startline="36" endline="47" pcid="3351">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * > Note: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="929" endline="938" pcid="1799">
    function capReached() public view returns (bool) {
        return weiRaised() >= _cap;
    }

    /**
     * @dev Extend parent behavior requiring purchase to respect the funding cap.
     * @param beneficiary Token purchaser
     * @param weiAmount Amount of wei contributed
     */
    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="578" endline="587" pcid="3273">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev Returns whether the specified token exists
     * @param tokenId uint256 ID of the token to query the existence of
     * @return whether the token exists
     */
    function exists(uint256 tokenId) external view returns (bool) {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="84" endline="93" pcid="3017">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev Gets the balance of the specified address.
     * @param owner The address to query the balance of.
     * @return A uint256 representing the amount owned by the passed address.
     */
    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="362" endline="365" pcid="2758">
  function decimals() public view returns(uint8) {
    return _decimals;
  }
}
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="374" endline="378" pcid="2685">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1550" endline="1557" pcid="1835">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/FUNNYTOKEN.sol" startline="95" endline="99" pcid="3954">
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }

    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/OMGToken.sol" startline="308" endline="317" pcid="5502">
  function pause() onlyOwner whenNotPaused returns (bool) {
    paused = true;
    Pause();
    return true;
  }

  /**
   * @dev called by the owner to unpause, returns to normal state
   */
  function unpause() onlyOwner whenPaused returns (bool) {
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="512" endline="513" pcid="103">
    function balanceOfColdWallet() public pure returns(uint256) {}
    function balanceOfShares() public pure returns(uint256) {}
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="110" endline="117" pcid="7984">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  /**
   * @dev See `IERC20.balanceOf`.
   */
  function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="95" endline="99" pcid="5998">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="463" endline="466" pcid="668">
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}
</source>
<source file="systems/smart_contracts/EtheleToken.sol" startline="145" endline="148" pcid="3215">
    function getContractStartTime() public view returns (uint256) {
        return _contractStartTime; 
    }
    function getCumulTokenPerEth(uint256 period) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="773" endline="780" pcid="1786">
    function token() public view returns (IERC20) {
        return _token;
    }

    /**
     * @return the address where funds are collected.
     */
    function wallet() public view returns (address payable) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="935" endline="942" pcid="3886">
    function getMembersNumber() external view returns (uint) {
        return membersList.length;
    }

    /**
     * @dev only operator memebers can enable a member
     */
    function enableMember(address _memberAddress) external onlyFundingOperators {
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="76" endline="79" pcid="2399">
  function decimals() public view returns(uint8) {
    return _decimals;
  }
}
</source>
<source file="systems/smart_contracts/TimeLockedTokenStorage.sol" startline="287" endline="296" pcid="7239">
    function getWithdrawableTokens() public view returns(uint256) {
        return withdrawableTokens;
    }

    /**
    * @dev Withdrawn lost tokens
    * Usage of this method only owner
    * @param _lockSlotId uint256 unique id lockSlot
    */
    function withdrawLostToken(uint256 _lockSlotId) public onlyGovernanceContracts {
</source>
<source file="systems/smart_contracts/CNG.sol" startline="130" endline="139" pcid="1851">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param owner The address to query the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="289" endline="293" pcid="2677">
    function hasClosed() public view returns (bool) {
        return block.timestamp > _closingTime;
    }

    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal onlyWhileOpen view {
</source>
<source file="systems/smart_contracts/EthNote.sol" startline="21" endline="28" pcid="3350">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="281" endline="285" pcid="2583">
    function openingTime() public view returns (uint256) {
        return _openingTime;
    }

    function closingTime() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/KingToken.sol" startline="108" endline="111" pcid="4490">
	function myfrozentokens() public view returns (uint){
		return frozen[msg.sender];
	}
	function myBalance() public view returns (uint balance){
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="154" endline="158" pcid="4389">
    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }

    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="777" endline="784" pcid="5388">
    function whitelistCounter() public view returns (uint256) {
        return _whitelistCounter;
    }

    /**
     * @dev Returns true if the sign-up for whitelist is allowed.
     */
    function whitelistingMode() public view returns (bool) {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="32" endline="39" pcid="4731">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/WanCoinSupplyToken.sol" startline="119" endline="127" pcid="7864">
    function totalSupply() public view returns (uint) {
        return _totalSupply.sub(balances[address(0)]);
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account `tokenOwner`
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public view returns (uint balance) {
</source>
<source file="systems/smart_contracts/GLOLocker.sol" startline="23" endline="27" pcid="4114">
    function balance() public view returns(uint){
        return token.balanceOf(address(this));
    }

    function balanceOf(address addr) public view returns(uint){
</source>
<source file="systems/smart_contracts/customIcoToken.sol" startline="69" endline="73" pcid="2212">
    function totalSupply() public view returns (uint256) {
        return totalSupply;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="45" endline="52" pcid="8074">
  function owner() public view returns (address) {
      return _owner;
  }

  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/EtheleToken.sol" startline="75" endline="78" pcid="3204">
    function getTransmuteSource3() public view returns (address) {
    	return _transmuteSource3;
    }
    function getTransmuteSource4() public view returns (address) {
</source>
<source file="systems/smart_contracts/Factory.sol" startline="34" endline="41" pcid="3430">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="180" endline="184" pcid="2570">
    function rate() public view returns (uint256) {
        return _rate;
    }

    function weiRaised() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="47" endline="58" pcid="4732">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="271" endline="277" pcid="239">
    function getMiningTarget() public view returns(uint) {
        return miningTarget;
    }

    //0.021m coins total
    //reward begins at 2 and is cut in half every reward era (as tokens are mined)
    function getMiningReward() public view returns(uint) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="281" endline="285" pcid="2675">
    function closingTime() public view returns (uint256) {
        return _closingTime;
    }

    function isOpen() public view returns (bool) {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="649" endline="658" pcid="5133">
    function getTotalDivsProduced()
        public
        view
        returns(uint)
    {
     
        return totalDivsProduced;
    }

    function totalEthereumBalance()
</source>
<source file="systems/smart_contracts/SAMPLE.sol" startline="131" endline="139" pcid="6255">
	function totalSupply() public view returns (uint) {
		return _totalSupply.sub(balances[address(0)]);
	}


	// ------------------------------------------------------------------------
	// Stop Trade
	// ------------------------------------------------------------------------
	function stopTrade() public onlyOwner {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="436" endline="443" pcid="5362">
    function decimals() public view returns (uint8) {
        return _decimals;
    }

    /**
     * @dev Returns the cap on VOKEN's total supply.
     */
    function cap() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/EtheleToken.sol" startline="85" endline="88" pcid="3207">
    function getTotalLocked() public view returns (uint256) {
    	return _totalLocked;
    }
    function getLockedBalance(address addr) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="289" endline="293" pcid="2585">
    function isOpen() public view returns (bool) {
        return block.timestamp >= _openingTime && block.timestamp <= _closingTime;
    }

    function hasClosed() public view returns (bool) {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="370" endline="381" pcid="7663">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Allows the current owner to relinquish control of the contract.
     * It will not be possible to call the functions with the `onlyOwner`
     * modifier anymore.
     * @notice Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="293" endline="300" pcid="3032">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="141" endline="148" pcid="806">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="492" endline="495" pcid="6752">
    function decimals() public view returns (uint256) {
        return _decimals;
    }
}
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="630" endline="641" pcid="4865">
  function canDistributeReservedTokens() public constant returns(bool) {
    CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());
    if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;
    return false;
  }

  /**
   * Finalize a succcesful crowdsale.
   *
   * The owner can triggre a call the contract that provides post-crowdsale actions, like releasing the tokens.
   */
  function finalize() public inState(State.Success) onlyOwner stopInEmergency {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="605" endline="609" pcid="2714">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="337" endline="348" pcid="534">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * > Note: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="208" endline="217" pcid="5351">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     *
     * IMPORTANT: Need to run {acceptOwnership} by the new owner.
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/ERC20Detailed.sol" startline="39" endline="46" pcid="3005">
  function symbol() public view returns(string) {
    return _symbol;
  }

  /**
   * @return the number of decimals of the token.
   */
  function decimals() public view returns(uint8) {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="593" endline="596" pcid="8259">
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="110" endline="118" pcid="2431">
    function totalSupply() public view returns (uint) {
        return _totalSupply.sub(balances[address(0)]);
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account `tokenOwner`
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public view returns (uint balance) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="1026" endline="1033" pcid="3896">
    function getTokenAddress() external view returns (address) {
        return tokenAddress;
    }

    /**
     * @return get the operator members URL and hash
     */
    function getOwnerData() external view returns (string memory, bytes32) {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="389" endline="396" pcid="7806">
    function vokens() public view returns (uint256) {
        return _vokens;
    }

    /**
     * @dev Returns the shareholders counter on `pageNumber`.
     */
    function counter(uint256 pageNumber) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="135" endline="144" pcid="4240">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param owner The address to query the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="235" endline="242" pcid="1755">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See `IERC20.balanceOf`.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/KingToken.sol" startline="96" endline="100" pcid="4487">
	function burningrate() public view returns (uint){
        return burning;
    }
	
	function earningrate() public view returns (uint){
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="127" endline="135" pcid="409">
    function totalSupply() public view returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public view returns (uint balance) {
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="470" endline="476" pcid="6812">
    function getLiquidity() public view returns (uint) {
        return 500000000 * 10 ** uint(_decimals) + businessPoll.totalMine + communityPoll.totalMine + techPoll.totalMine;
    }


    /* 提取矿代币池接口 */
    function _minePoll(Poll storage poll, uint value) private {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="49" endline="60" pcid="6013">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * > Note: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="333" endline="340" pcid="494">
    function beneficiary() public view returns (address) {
        return _beneficiary;
    }

    /**
     * @return the time when the tokens are released.
     */
    function releaseTime() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="135" endline="144" pcid="2744">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param owner The address to query the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="278" endline="287" pcid="6997">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev Gets the balance of the specified address.
     * @param owner The address to query the balance of.
     * @return A uint256 representing the amount owned by the passed address.
     */
    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="106" endline="113" pcid="6985">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1565" endline="1576" pcid="1836">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * > Note: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="245" endline="248" pcid="4428">
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="455" endline="462" pcid="541">
    function duration() public view returns (uint256) {
        return _duration;
    }

    /**
     * @return true if the vesting is revocable.
     */
    function revocable() public view returns (bool) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="626" endline="630" pcid="4864">
  function areReservedTokensDistributed() public constant returns (bool) {
    return finalizeAgent.reservedTokensAreDistributed();
  }

  function canDistributeReservedTokens() public constant returns(bool) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="353" endline="357" pcid="2683">
    function primary() public view returns (address) {
        return _primary;
    }

    function transferPrimary(address recipient) public onlyPrimary {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="94" endline="101" pcid="5775">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="422" endline="430" pcid="500">
    function allOperationsCount() public view returns(uint) {
        return allOperations.length;
    }

    /*
      Internal functions
    */

    function _operationLimitByBeneficiaryIndex(uint8 beneficiaryIndex) internal view returns(bool) {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="250" endline="254" pcid="5679">
  function getParentBlockInterval() public view returns (uint256) {
    return parentBlockInterval;
  }

  function setParentBlockInterval(uint256 _parentBlockInterval) public ifAdmin {
</source>
<source file="systems/smart_contracts/CGT.sol" startline="133" endline="141" pcid="1694">
    function totalSupply() public view returns (uint) {
        return _totalSupply.sub(balances[address(0)]);
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account `tokenOwner`
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public view returns (uint balance) {
</source>
<source file="systems/smart_contracts/RubyToken.sol" startline="37" endline="41" pcid="6226">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }
    
    function _transfer(address _from, address _to, uint256 _value) internal {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="321" endline="324" pcid="1383">
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="93" endline="97" pcid="6209">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="810" endline="820" pcid="3107">
  function totalSupply() public view returns (uint256) {
    return allTokens.length;
  }

  /**
   * @dev Gets the token ID at a given index of all the tokens in this contract
   * Reverts if the index is greater or equal to the total number of tokens
   * @param _index uint256 representing the index to be accessed of the tokens list
   * @return uint256 token ID at the given index of the tokens list
   */
  function tokenByIndex(uint256 _index) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="502" endline="505" pcid="6350">
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}
</source>
<source file="systems/smart_contracts/BCCT.sol" startline="55" endline="62" pcid="1091">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="216" endline="223" pcid="3251">
    function paused() public view returns (bool) {
        return _paused;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     */
    modifier whenNotPaused() {
</source>
<source file="systems/smart_contracts/XTRLPAY.sol" startline="132" endline="140" pcid="8140">
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="76" endline="79" pcid="2559">
  function decimals() public view returns(uint8) {
    return _decimals;
  }
}
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="72" endline="75" pcid="3925">
  function decimals() public view returns(uint8) {
    return _decimals;
  }
}
</source>
<source file="systems/smart_contracts/AnxToken.sol" startline="131" endline="139" pcid="715">
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="269" endline="276" pcid="5785">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="93" endline="96" pcid="3174">
  function decimals() public view returns(uint8) {
    return _decimals;
  }
}
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="143" endline="150" pcid="1885">
  function owner() public view returns(address) {
    return _owner;
  }

  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="817" endline="822" pcid="6634">
	function removeOracleAddress() public onlyOwner returns(bool) {
		oracleAddress = address(0);
		return true;
	}

	function setMaximumGasPrice(uint256 gweiPrice) public onlyManyOwners(keccak256(msg.data)) returns(bool) {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="624" endline="631" pcid="2490">
    function paused() public view returns (bool) {
        return _paused;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     */
    modifier whenNotPaused() {
</source>
<source file="systems/smart_contracts/BKN.sol" startline="55" endline="58" pcid="1324">
    function totalSupply() public constant returns (uint256) {
        return totalSupply;
    }
    function balanceOf(address src) public constant returns (uint256) {
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="72" endline="75" pcid="6208">
  function decimals() public view returns(uint8) {
    return _decimals;
  }
}
</source>
<source file="systems/smart_contracts/BlocklogyCertificate.sol" startline="62" endline="68" pcid="1402">
    function viewLatestCertificateNumber() public view returns (uint256) {
        return certificateDatabase.length-1;
    }
    
    /// @notice views the Total certificate issued
    /// @return total certificate issued by Blocklogy
    function getTotalCertificateCount() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/BlockPoolToken.sol" startline="73" endline="80" pcid="1412">
    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }

    /**
     * @dev total number of tokens already burned
     */
    function totalBurned() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="239" endline="246" pcid="8235">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See `IERC20.balanceOf`.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="305" endline="309" pcid="4945">
  function getPrice() public view returns (uint256) {
    return oracle.price();
  }

  function withdraw(uint256 amountCent) public returns (uint256 amountWei){
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="180" endline="183" pcid="2860">
    function totalSupply() public view returns (uint256){
        return operator.token_totalSupply();
    }
    function balanceOf(address addr)public view returns(uint256){
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="149" endline="156" pcid="6688">
    function resetICO() onlyOwner public returns (bool) {
        icoStart = false;
        distributionFinished = false;
        emit ResetICO();
        return true;
    }

    function finishDistribution() onlyOwner canDistr public returns (bool) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="1166" endline="1184" pcid="3910">
    function getFactoryAddress() external view returns(address) {
        return fAddress;
    }

    /**
     * @dev deployment of a new Funding Panel contract
     * @param _caller address that will take the ownership of the contract
     * @param _setDocURL URL of the document describing the Panel
     * @param _setDocHash hash of the document describing the Panel
     * @param _exchRateSeed exchange rate between SEED tokens received and tokens given to the SEED sender (multiply by 10^_exchRateDecim)
     * @param _exchRateOnTop exchange rate between SEED token received and tokens minted on top (multiply by 10^_exchRateDecim)
     * @param _seedTokenAddress address of SEED token contract
     * @param _seedMaxSupply max supply of SEED tokens accepted by this contract
     * @param _tokenAddress address of the corresponding Token contract
     * @param _ATAddress address of the corresponding AdminTools contract
     * @param newLength number of this contract in the corresponding array in the Factory contract
     * @return address of the deployed Token contract
     */
    function newFundingPanel(address _caller, string calldata _setDocURL, bytes32 _setDocHash, uint256 _exchRateSeed, uint256 _exchRateOnTop,
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="418" endline="425" pcid="7809">
    function VOKEN() public view returns (IVoken) {
        return _voken;
    }

    /**
     * Returns the ending block number of `pageNumber`.
     */
    function pageEndingBlock(uint256 pageNumber) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="142" endline="146" pcid="5102">
    function myTokens() public view returns (uint256) {
        return _FOMOTokenBalances[msg.sender];
    }

    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="285" endline="289" pcid="2584">
    function closingTime() public view returns (uint256) {
        return _closingTime;
    }

    function isOpen() public view returns (bool) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1033" endline="1042" pcid="1804">
    function isOpen() public view returns (bool) {
        // solhint-disable-next-line not-rely-on-time
        return block.timestamp >= _openingTime && block.timestamp <= _closingTime;
    }

    /**
     * @dev Checks whether the period in which the crowdsale is open has already elapsed.
     * @return Whether crowdsale period has elapsed
     */
    function hasClosed() public view returns (bool) {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="49" endline="60" pcid="941">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * > Note: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/PAYCASH.sol" startline="131" endline="139" pcid="5619">
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="46" endline="56" pcid="7339">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Allows the current owner to relinquish control of the contract.
     * @notice Renouncing to ownership will leave the contract without an owner.
     * It will not be possible to call the functions with the `onlyOwner`
     * modifier anymore.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="921" endline="929" pcid="1798">
    function cap() public view returns (uint256) {
        return _cap;
    }

    /**
     * @dev Checks whether the cap has been reached.
     * @return Whether the cap was reached
     */
    function capReached() public view returns (bool) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1517" endline="1530" pcid="6163">
  function canUpgrade() public constant returns(bool) {
    return released && super.canUpgrade();
  }

  /**
   * Owner can update token information here.
   *
   * It is often useful to conceal the actual token association, until
   * the token operations, like central issuance or reissuance have been completed.
   *
   * This function allows the token owner to rename the token after the operations
   * have been completed and then point the audience to use the token contract.
   */
  function setTokenInformation(string _name, string _symbol) onlyOwner {
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="93" endline="97" pcid="7324">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="256" endline="263" pcid="4040">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See `IERC20.balanceOf`.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Ethertime.sol" startline="379" endline="382" pcid="3316">
    function getTotalFee() public view returns (uint256) {
        return _totalFee;
    }
    function getAdmins() public view returns (address[] memory) {
</source>
<source file="systems/smart_contracts/CDS.sol" startline="167" endline="176" pcid="1661">
  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/FixedSupplyToken.sol" startline="133" endline="141" pcid="3609">
    function totalSupply() public view returns (uint) {
        return _totalSupply.sub(balances[address(0)]);
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account `tokenOwner`
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public view returns (uint balance) {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="174" endline="181" pcid="6989">
    function paused() public view returns (bool) {
        return _paused;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     */
    modifier whenNotPaused() {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="313" endline="320" pcid="956">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See `IERC20.balanceOf`.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="734" endline="744" pcid="7935">
    function weiRaised() public view returns (uint256) {
        return _weiRaised;
    }

    /**
     * @dev low level token purchase ***DO NOT OVERRIDE***
     * This function has a non-reentrancy guard, so it shouldn't be called by
     * another `nonReentrant` function.
     * @param beneficiary Recipient of the token purchase
     */
    function buyTokens(address beneficiary) public nonReentrant payable {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="742" endline="745" pcid="2498">
    function getTrackerBalance() public view returns (uint256) {
        return token.balanceOf(address(this));
    }
}
</source>
<source file="systems/smart_contracts/ITVR.sol" startline="76" endline="85" pcid="4327">
  function getBalance()
    constant
    public
    returns(uint)
  {
    return company_token.balanceOf(this);
  }


  function setOwner(address _owner) 
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="355" endline="362" pcid="2757">
  function symbol() public view returns(string) {
    return _symbol;
  }

  /**
   * @return the number of decimals of the token.
   */
  function decimals() public view returns(uint8) {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="494" endline="497" pcid="7739">
    function decimals() public view returns (uint256) {
        return _decimals;
    }
}
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="242" endline="246" pcid="2112">
  function isUpgradeAgent() public constant returns (bool) {
    return true;
  }

  function upgradeFrom(address _from, uint256 _value) public;
</source>
<source file="systems/smart_contracts/ICOImplementation.sol" startline="172" endline="182" pcid="4276">
    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }


    /**
    * @dev Transfer token for a specified address
    * @param _to The address to transfer to.
    * @param _value The amount to be transferred.
    */
    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/DNP.sol" startline="137" endline="144" pcid="2797">
    function isStopped() public view returns(bool)
    {
        return stopped;
    }
    /**
    * @dev total number of tokens in existence
    */
    function totalSupply() public view returns (uint256) 
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="446" endline="451" pcid="271">
    function getChallengeNumber() public constant returns (bytes32) {
        return challengeNumber;
    }

    //the number of zeroes the digest of the PoW solution requires.  Auto adjusts
     function getMiningDifficulty() public constant returns (uint) {
</source>
<source file="systems/smart_contracts/Bridge.sol" startline="128" endline="140" pcid="1508">
  function isConstructor() private view returns (bool) {
    // extcodesize checks the size of the code stored in an address, and
    // address returns the current address. Since the code is still not
    // deployed when running a constructor, any checks on its code size will
    // yield zero, making it an effective way to detect if a contract is
    // under construction or not.
    uint256 cs;
    assembly { cs := extcodesize(address) }
    return cs == 0;
  }

  // Reserved storage space to allow for layout changes in the future.
  uint256[50] private ______gap;
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="382" endline="389" pcid="7805">
    function ethers() public view returns (uint256) {
        return _ethers;
    }

    /**
     * @dev Returns the amount of VOKEN holding by all shareholders.
     */
    function vokens() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="766" endline="778" pcid="7113">
    function getFactoryAddress() external view returns(address) {
        return fAddress;
    }

    /**
     * @dev deploy a new Token contract and transfer ownership to _caller address
     * @param _caller address that will take the ownership of the contract
     * @param _name name of the token to be deployed
     * @param _symbol symbol of the token to be deployed
     * @param _ATAddress address of the corresponding AT contract
     * @return address of the deployed Token contract
     */
    function newToken(address _caller, string calldata _name, string calldata _symbol, address _ATAddress) external onlyFactory returns(address) {
</source>
<source file="systems/smart_contracts/KYCRegistry.sol" startline="34" endline="41" pcid="4501">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="101" endline="105" pcid="2050">
    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }

    function transfer(address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/DGC.sol" startline="133" endline="141" pcid="2524">
    function totalSupply() public view returns (uint) {
        return _totalSupply.sub(balances[address(0)]);
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account `tokenOwner`
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public view returns (uint balance) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="890" endline="898" pcid="3883">
    function getFactoryDeployIndex() public view returns(uint) {
        return factoryDeployIndex;
    }

    /**
     * @dev find if a member is inserted
     * @return bool for success
     */
    function isMemberInserted(address memberWallet) public view returns(bool) {
</source>
<source file="systems/smart_contracts/UtilityTokenFactory.sol" startline="81" endline="85" pcid="7596">
    function getNumOfIssuers() public view returns (uint256) {
        return issuers.length;
    }

    function getFundsHolderAddress() public view returns (address) {
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="658" endline="669" pcid="2361">
    function isDeploying() public view returns (bool) {
        return stage == Stages.Deploying;
    }


    /**
     * Returns whether the proposal is deployed. The proposal is deployed 
     * when it receives Ether from the prev proxy contract
     *
     * @return Whether the proposal is deployed
     */
    function isDeployed() public view returns (bool) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="787" endline="794" pcid="1788">
    function rate() public view returns (uint256) {
        return _rate;
    }

    /**
     * @return the amount of wei raised.
     */
    function weiRaised() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="349" endline="361" pcid="2117">
  function getUpgradeState() public constant returns(UpgradeState) {
    if(!canUpgrade()) return UpgradeState.NotAllowed;
    else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;
    else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;
    else return UpgradeState.Upgrading;
  }

  /**
   * Change the upgrade master.
   *
   * This allows us to set a new owner for the upgrade mechanism.
   */
  function setUpgradeMaster(address master) public {
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="93" endline="97" pcid="3926">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="137" endline="146" pcid="735">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
    * @dev Gets the balance of the specified address.
    * @param owner The address to query the balance of.
    * @return An uint256 representing the amount owned by the passed address.
    */
    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="562" endline="565" pcid="5871">
    function _service() public view returns (ComplianceService) {
        return ComplianceService(registry.service());
    }
}
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="716" endline="724" pcid="938">
    function getFactoryAddress() external view returns(address) {
        return fAddress;
    }

    /**
     * @dev deployment of a new AdminTools contract
     * @return address of the deployed AdminTools contract
     */
    function newAdminTools(uint256 _whitelistThresholdBalance) external onlyFactory returns(address) {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="138" endline="142" pcid="5101">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function myTokens() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="478" endline="485" pcid="6750">
    function name() public view returns (string) {
        return _name;
    }

    /**
     * @return the symbol of the token.
     */
    function symbol() public view returns (string) {
</source>
<source file="systems/smart_contracts/Comet.sol" startline="93" endline="97" pcid="1926">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="116" endline="124" pcid="5815">
    function totalSupply() public view returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public view returns (uint balance) {
</source>
<source file="systems/smart_contracts/BlocklogyCertificate.sol" startline="68" endline="79" pcid="1403">
    function getTotalCertificateCount() public view returns (uint256) {
        return certificateDatabase.length;
    }
    
    /// @notice This function will issue the certificate for the multiple courses on nextgen technologies
    /// @param _userId is the unique ID of student
    /// @param _name inputs the name of student
    /// @param _course inputs the course for which the certificate is issued
    /// @param _belt inputs the belt level of each course in integer
    /// @param _percentile inputs the percentage which student scored in the exam
    /// @return certificate number
    function issueCertificate(
</source>
<source file="systems/smart_contracts/BIBCOINID.sol" startline="132" endline="140" pcid="1208">
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="624" endline="631" pcid="6049">
    function paused() public view returns (bool) {
        return _paused;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     */
    modifier whenNotPaused() {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="313" endline="320" pcid="6028">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See `IERC20.balanceOf`.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="715" endline="726" pcid="4459">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * > Note: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="308" endline="319" pcid="3033">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Allows the current owner to relinquish control of the contract.
     * It will not be possible to call the functions with the `onlyOwner`
     * modifier anymore.
     * @notice Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="271" endline="278" pcid="7183">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     *  See `IERC20.balanceOf`.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/BCCT.sol" startline="280" endline="283" pcid="1107">
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="219" endline="228" pcid="2244">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev Gets the balance of the specified address.
     * @param owner The address to query the balance of.
     * @return An uint256 representing the amount owned by the passed address.
     */
    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="276" endline="279" pcid="589">
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="66" endline="70" pcid="4379">
    function acceptOwnership() public onlyNewOwner returns(bool) {
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/ContractCoffeeToken.sol" startline="129" endline="137" pcid="1984">
    function totalSupply() public view returns (uint) {
        return _totalSupply.sub(balances[address(0)]);
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account `tokenOwner`
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public view returns (uint balance) {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="713" endline="720" pcid="7932">
    function token() public view returns (IERC20) {
        return _token;
    }

    /**
     * @return the address where funds are collected.
     */
    function wallet() public view returns (address payable) {
</source>
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="65" endline="69" pcid="1625">
    function acceptOwnership() public onlyNewOwner returns(bool) {
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="307" endline="319" pcid="5789">
    function decimals() public view returns (uint8) {
        return _decimals;
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="742" endline="745" pcid="985">
    function getTrackerBalance() public view returns (uint256) {
        return token.balanceOf(address(this));
    }
}
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="669" endline="679" pcid="2362">
    function isDeployed() public view returns (bool) {
        return stage == Stages.Deployed;
    }


    /**
     * Returns whether the proposal is executed
     *
     * @return Whether the proposal is deployed
     */
    function isExecuted() public view returns (bool) {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="375" endline="382" pcid="7804">
    function page() public view returns (uint256) {
        return _page;
    }

    /**
     * @dev Returns the amount of deposited Ether.
     */
    function ethers() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/BANG.sol" startline="76" endline="79" pcid="1048">
  function decimals() public view returns(uint8) {
    return _decimals;
  }
}
</source>
<source file="systems/smart_contracts/EmpowCreateEosAccount.sol" startline="131" endline="141" pcid="2938">
    function ownerWithdrawUSDT ()
        public
        onlyOwner
        returns(bool)
    {
        USDT_CONTRACT.transfer(owner, USDT_CONTRACT.balanceOf(address(this)));
        return true;
    }
    
    // HELPER FUNCTIONS
    function getStringLength (string memory _string)
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="248" endline="256" pcid="4039">
    function decimals() public view returns (uint8) {
        return _decimals;
    }


    /**
     * @dev See `IERC20.totalSupply`.
     */
    function totalSupply() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="250" endline="254" pcid="2581">
    function capReached() public view returns (bool) {
        return weiRaised() >= _cap;
    }

    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="603" endline="607" pcid="551">
    function beneficiariesCount() public view returns(uint) {
        return beneficiaries.length;
    }

    function allOperationsCount() public view returns(uint) {
</source>
<source file="systems/smart_contracts/ProxyERC20.sol" startline="402" endline="407" pcid="5894">
    function symbol() public view returns (string){
         // Immutable static call from target contract
        return IERC20(target).symbol();
    }

    function decimals() public view returns (uint8){
</source>
<source file="systems/smart_contracts/RETC.sol" startline="91" endline="94" pcid="6184">
     function nowInSeconds() public view returns (uint256){
        return now;
    }
    function transferOwnership(address newOwner) onlyOwner public {
</source>
<source file="systems/smart_contracts/Factory.sol" startline="452" endline="459" pcid="3504">
    function getTotalFPContracts() external view returns(uint256) {
        return FPContractsList.length;
    }

    /**
     * @dev get if address is a deployer
     */
    function isFactoryDeployer(address _addr) external view returns(bool) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="794" endline="804" pcid="1789">
    function weiRaised() public view returns (uint256) {
        return _weiRaised;
    }

    /**
     * @dev low level token purchase ***DO NOT OVERRIDE***
     * This function has a non-reentrancy guard, so it shouldn't be called by
     * another `nonReentrant` function.
     * @param beneficiary Recipient of the token purchase
     */
    function buyTokens(address beneficiary) public nonReentrant payable {
</source>
<source file="systems/smart_contracts/GRAM.sol" startline="130" endline="138" pcid="4207">
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="463" endline="473" pcid="274">
    function getMiningReward() public constant returns (uint) {
        //once we get half way thru the coins, only get 25 per block

         //every reward era, the reward amount halves.

         return (50 * 10**uint(decimals) ).div( 2**rewardEra ) ;

    }

    //help debug mining software
    function getMintDigest(uint256 nonce, bytes32 challenge_digest, bytes32 challenge_number) public view returns (bytes32 digesttest) {
</source>
<source file="systems/smart_contracts/GNB.sol" startline="171" endline="179" pcid="4132">
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="580" endline="587" pcid="334">
    function paused() public view returns (bool) {
        return _paused;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     */
    modifier whenNotPaused() {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="328" endline="331" pcid="7661">
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}
</source>
<source file="systems/smart_contracts/EtheleToken.sol" startline="139" endline="142" pcid="3213">
    function getMintAmount() public pure returns (uint256) {
        return MINT_AMOUNT; 
    }
    function getCurrentPeriod() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Factory.sol" startline="431" endline="438" pcid="3501">
    function getTotalDeployer() external view returns(uint256) {
        return deployerList.length;
    }

    /**
     * @dev get AT contracts number
     */
    function getTotalATContracts() external view returns(uint256) {
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="103" endline="107" pcid="2400">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="237" endline="241" pcid="1644">
    function getNowTime() public view returns(uint256) {
      return now;
    }

    function showLockState(address _holder) public view returns (bool, uint256, uint256) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="559" endline="563" pcid="2620">
    function tokenWallet() public view returns (address) {
        return _tokenWallet;
    }

    function remainingTokens() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="1086" endline="1090" pcid="6656">
	function getHowMuchUntilHardCap() public view returns(uint256) {
		return getHowMuchUntilHardCap_(openGroupNumber);
	}

	function addMemberToGroup(address walletAddress, uint256 groupNumber) public onlyOwner returns(bool) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="486" endline="493" pcid="7197">
    function paused() public view returns (bool) {
        return _paused;
    }

    /**
     *  Modifier to make a function callable only when the contract is not paused.
     */
    modifier whenNotPaused() {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="298" endline="307" pcid="4851">
  function isFinalizeAgent() public constant returns(bool) {
    return true;
  }

  /** Return true if we can run finalizeCrowdsale() properly.
   *
   * This is a safety check function that doesn't allow crowdsale to begin
   * unless the finalizer has been set up properly.
   */
  function isSane() public constant returns (bool);
</source>
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="721" endline="730" pcid="509">
        function pendingBeneficiary() public view returns (address) {
            return _pendingBeneficiary;
        }

        /**
            * @dev Allows beneficiaries to change beneficiaryShip and set first beneficiary as default
            * @param _newBeneficiaries defines array of addresses of new beneficiaries
            * @param _newHowManyBeneficiariesDecide defines how many beneficiaries can decide
        */
        function transferBeneficiaryShipWithHowMany(address[] memory _newBeneficiaries, uint256 _newHowManyBeneficiariesDecide) public {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="248" endline="255" pcid="5852">
    function symbol() public view returns(string) {
        return _symbol;
    }

    /**
     * @return the number of decimals of the token.
     */
    function decimals() public view returns(uint8) {
</source>
<source file="systems/smart_contracts/TimeLockedTokenStorage.sol" startline="401" endline="408" pcid="7247">
    function getHoldersQuantity() public view returns(uint256) {
        return holdersList.length;
    }

    /**
   * @dev Returned total locked slots
   */
    function getSlotsQuantity() public view returns(uint256) {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="271" endline="278" pcid="6996">
    function cap() public view returns (uint256) {
        return _cap;
    }

    /**
     * @dev Total number of tokens in existence.
     */
    function totalSupply() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/EtheleToken.sol" startline="69" endline="72" pcid="3202">
    function getTransmuteSource1() public view returns (address) {
		return _transmuteSource1;
    }
    function getTransmuteSource2() public view returns (address) {
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="60" endline="68" pcid="8075">
  function isOwner() public view returns (bool) {
      return msg.sender == _owner;
  }

  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1042" endline="1052" pcid="1805">
    function hasClosed() public view returns (bool) {
        // solhint-disable-next-line not-rely-on-time
        return block.timestamp > _closingTime;
    }

    /**
     * @dev Extend parent behavior requiring to be within contributing period.
     * @param beneficiary Token purchaser
     * @param weiAmount Amount of wei contributed
     */
    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal onlyWhileOpen view {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="246" endline="250" pcid="2672">
    function capReached() public view returns (bool) {
        return weiRaised() >= _cap;
    }

    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="80" endline="89" pcid="7455">
    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }

    /**
    * @dev transfer token for a specified address
    * @param _to The address to transfer to.
    * @param _value The amount to be transferred.
    */
    function transfer(address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="607" endline="615" pcid="552">
    function allOperationsCount() public view returns(uint) {
        return allOperations.length;
    }

    /*
      Internal functions
    */

    function _operationLimitByBeneficiaryIndex(uint8 beneficiaryIndex) internal view returns(bool) {
</source>
<source file="systems/smart_contracts/FogCoin.sol" startline="46" endline="55" pcid="3679">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev Gets the balance of the specified address.
     * @param owner The address to query the balance of.
     * @return A uint256 representing the amount owned by the passed address.
     */
    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="1470" endline="1479" pcid="3153">
  function _getNewEstateId() internal view returns (uint256) {
    return totalSupply().add(1);
  }

  /**
   * @dev Appends a new LAND id to an Estate updating all related storage
   * @param estateId Estate where the LAND should go
   * @param landId Transfered LAND
   */
  function _pushLandId(uint256 estateId, uint256 landId) internal {
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="85" endline="87" pcid="2836">
    function dummy() public pure returns (IDummyToken) {}
    
	function emitEventTransfer(address _from, address _to, uint256 _amount) public;
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="679" endline="687" pcid="2363">
    function isExecuted() public view returns (bool) {
        return stage == Stages.Executed;
    }


    /**
     * Accept eth from the prev proxy while deploying
     */
    function () external payable only_at_stage(Stages.Deploying) {
</source>
<source file="systems/smart_contracts/NBToken.sol" startline="112" endline="121" pcid="5304">
    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }

    /**
     * @dev transfer token for a specified address
     * @param _to The address to transfer to.
     * @param _value The amount to be transferred.
     */
    function transfer(address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/PokaToken.sol" startline="41" endline="45" pcid="5732">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }
    
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="621" endline="625" pcid="6104">
  function areReservedTokensDistributed() public constant returns (bool) {
    return finalizeAgent.reservedTokensAreDistributed();
  }

  function canDistributeReservedTokens() public constant returns(bool) {
</source>
<source file="systems/smart_contracts/Factory.sol" startline="438" endline="445" pcid="3502">
    function getTotalATContracts() external view returns(uint256) {
        return ATContractsList.length;
    }

    /**
     * @dev get T contracts number
     */
    function getTotalTContracts() external view returns(uint256) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="277" endline="281" pcid="2674">
    function openingTime() public view returns (uint256) {
        return _openingTime;
    }

    function closingTime() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/BTGS.sol" startline="71" endline="85" pcid="1543">
    function totalSupply()
        public
        constant
        returns (uint256) {
        return _totalSupply;
    }





    /// @dev Gets account's balance
    /// @param _addr Address of the account
    /// @return Account balance
    function balanceOf(address _addr)
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="903" endline="912" pcid="4887">
  function isCrowdsale() public constant returns (bool) {
    return true;
  }

  //
  // Modifiers
  //

  /** Modified allowing execution only if the crowdsale is currently running.  */
  modifier inState(State state) {
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="91" endline="93" pcid="30">
    function dummy() public pure returns (IDummyToken) {}
    
	function emitEventTransfer(address _from, address _to, uint256 _amount) public;
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="106" endline="111" pcid="1232">
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/ParkingResolver.sol" startline="48" endline="52" pcid="5596">
    function owner() external view returns (address) {
        return _owner;
    }

    function setOwner(address owner) external {
</source>
<source file="systems/smart_contracts/SuperMarket.sol" startline="41" endline="45" pcid="6760">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }
    
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="349" endline="358" pcid="5688">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
    * @dev Gets the balance of the specified address.
    * @param owner The address to query the balance of.
    * @return An uint256 representing the amount owned by the passed address.
    */
    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="74" endline="77" pcid="5997">
  function decimals() public view returns(uint8) {
    return _decimals;
  }
}
</source>
<source file="systems/smart_contracts/GFNX.sol" startline="141" endline="146" pcid="4105">
    function totalSupply() public view returns (uint) {
        return supply;
    }
 
    // Get the token balance for account `tokenOwner`
    function balanceOf(address tokenOwner) public view returns (uint balance) {
</source>
<source file="systems/smart_contracts/BlackJack.sol" startline="81" endline="90" pcid="1336">
    function totalBalance() public view returns (uint256) {
        return _totalBalance;
    }

    /**
    * @dev Gets the balance of specified address.
    * @param owner The address to query the balance of.
    * @return An uint256 representing the amount owned by the passed address.
    */
    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1159" endline="1167" pcid="1811">
    function primary() public view returns (address) {
        return _primary;
    }

    /**
     * @dev Transfers contract to a new primary.
     * @param recipient The address of new primary.
     */
    function transferPrimary(address recipient) public onlyPrimary {
</source>
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="267" endline="271" pcid="238">
    function getMiningDifficulty() public view returns(uint) {
        return _MAXIMUM_TARGET.div(miningTarget);
    }

    function getMiningTarget() public view returns(uint) {
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="74" endline="76" pcid="2832">
    function operator() public pure returns(ITokenOperator) {}
    //ITokenOperator public operator;
}
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="322" endline="329" pcid="533">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/NaorisToken.sol" startline="80" endline="89" pcid="5284">
    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }

    /**
    * @dev transfer token for a specified address
    * @param _to The address to transfer to.
    * @param _value The amount to be transferred.
    */
    function transfer(address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="78" endline="80" pcid="26">
    function operator() public pure returns(ITokenOperator) {}
    //ITokenOperator public operator;
}
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="727" endline="741" pcid="2366">
    function getTotalSupply() public view returns (uint) {
        uint sum = 0; 
        sum += drpsToken.totalSupply();
        sum += drpuToken.totalSupply();
        return sum;
    }


    /**
     * Returns true if `_owner` has a balance allocated
     *
     * @param _owner The account that the balance is allocated for
     * @return True if there is a balance that belongs to `_owner`
     */
    function hasBalance(address _owner) public view returns (bool) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="738" endline="742" pcid="4873">
  function whitelistedParticipantsLength() public constant returns (uint) {
    return whitelistedParticipants.length;
  }

  function isTierJoined(address addr) public constant returns(bool) {
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="158" endline="168" pcid="1886">
  function isOwner() public view returns(bool) {
    return msg.sender == _owner;
  }

  /**
   * @dev Allows the current owner to relinquish control of the contract.
   * @notice Renouncing to ownership will leave the contract without an owner.
   * It will not be possible to call the functions with the `onlyOwner`
   * modifier anymore.
   */
  function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="559" endline="563" pcid="2712">
    function remainingTokens() public view returns (uint256) {
        return Math.min(token().balanceOf(_tokenWallet), token().allowance(_tokenWallet, address(this)));
    }

    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="247" endline="254" pcid="5960">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See `IERC20.balanceOf`.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="766" endline="774" pcid="3103">
  function name() external view returns (string) {
    return name_;
  }

  /**
   * @dev Gets the token symbol
   * @return string representing the token symbol
   */
  function symbol() external view returns (string) {
</source>
<source file="systems/smart_contracts/TokenSwap.sol" startline="93" endline="100" pcid="7390">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/OMGToken.sol" startline="317" endline="322" pcid="5503">
  function unpause() onlyOwner whenPaused returns (bool) {
    paused = false;
    Unpause();
    return true;
  }
}
</source>
<source file="systems/smart_contracts/Melodic.sol" startline="132" endline="140" pcid="4791">
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="137" endline="143" pcid="6686">
    function startICO() onlyOwner public returns (bool) {
        icoStart = true;
        emit StartICO();
        return true;
    }
    
    function pauseICO() onlyOwner public returns (bool) {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="207" endline="214" pcid="3561">
    function paused() public view returns (bool) {
        return _paused;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     */
    modifier whenNotPaused() {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="141" endline="148" pcid="3761">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="245" endline="252" pcid="6326">
    function paused() public view returns (bool) {
        return _paused;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     */
    modifier whenNotPaused() {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="462" endline="469" pcid="542">
    function revocable() public view returns (bool) {
        return _revocable;
    }

    /**
     * @return the amount of the token released.
     */
    function released(address token) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="383" endline="390" pcid="749">
    function owner() public view returns(address) {
        return _owner;
    }

    /**
    * @dev Throws if called by any account other than the owner.
    */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="899" endline="908" pcid="5397">
    function safeMode() public view returns (bool) {
        return _safeMode;
    }

    /**
     * @dev Disable/enable non-whitelist transaction.
     *
     * Can only be called by the current owner.
     */
    function setSafeMode(bool value) public onlyOwner {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="700" endline="707" pcid="4458">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="519" endline="522" pcid="5931">
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}
</source>
<source file="systems/smart_contracts/ContractCargoberToken.sol" startline="129" endline="137" pcid="1962">
    function totalSupply() public view returns (uint) {
        return _totalSupply.sub(balances[address(0)]);
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account `tokenOwner`
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public view returns (uint balance) {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="318" endline="328" pcid="591">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Allows the current owner to relinquish control of the contract.
     * @notice Renouncing to ownership will leave the contract without an owner.
     * It will not be possible to call the functions with the `onlyOwner`
     * modifier anymore.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="34" endline="41" pcid="6012">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="219" endline="228" pcid="7717">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev Gets the balance of the specified address.
     * @param owner The address to query the balance of.
     * @return An uint256 representing the amount owned by the passed address.
     */
    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="487" endline="494" pcid="7738">
    function symbol() public view returns (string) {
        return _symbol;
    }

    /**
     * @return the number of decimals of the token.
     */
    function decimals() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/TimeLockedTokenStorage.sol" startline="414" endline="421" pcid="7249">
    function getTotalLockedTokens() public view returns(uint256) {
        return totalLockedTokens;
    }
    /**
    * @dev Returned params for lockSlot
    * @param _lockSlotId uint256 unique id lockSlot
    */
    function getLock(uint256 _lockSlotId) public view returns(  uint256 _amountTokens,
</source>
<source file="systems/smart_contracts/Factory.sol" startline="445" endline="452" pcid="3503">
    function getTotalTContracts() external view returns(uint256) {
        return TContractsList.length;
    }

    /**
     * @dev get FP contracts number
     */
    function getTotalFPContracts() external view returns(uint256) {
</source>
<source file="systems/smart_contracts/Bridge.sol" startline="243" endline="247" pcid="1514">
  function getParentBlockInterval() public view returns (uint256) {
    return parentBlockInterval;
  }

  function setParentBlockInterval(uint256 _parentBlockInterval) public ifAdmin {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="285" endline="289" pcid="2676">
    function isOpen() public view returns (bool) {
        return block.timestamp >= _openingTime && block.timestamp <= _closingTime;
    }

    function hasClosed() public view returns (bool) {
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="494" endline="503" pcid="6619">
	function totalSupply() public view returns (uint256) {
		return totalSupply_;
	}

	/**
	* @dev Transfer token for a specified address
	* @param _to The address to transfer to.
	* @param _value The amount to be transferred.
	*/
	function transfer(address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="99" endline="106" pcid="7343">
    function paused() public view returns (bool) {
        return _paused;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     */
    modifier whenNotPaused() {
</source>
<source file="systems/smart_contracts/BANG.sol" startline="97" endline="101" pcid="1049">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/KingToken.sol" startline="104" endline="108" pcid="4489">
	function referralrate() public view returns (uint){
        return refrate;
    }
	
	function myfrozentokens() public view returns (uint){
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="115" endline="124" pcid="4930">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev Gets the balance of the specified address.
     * @param owner The address to query the balance of.
     * @return A uint256 representing the amount owned by the passed address.
     */
    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="180" endline="184" pcid="5674">
  function admin() external view returns (address) {
    return _admin();
  }

  function implementation() external view returns (address impl) {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="291" endline="298" pcid="4429">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See `IERC20.balanceOf`.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="492" endline="495" pcid="2266">
    function decimals() public view returns (uint256) {
        return _decimals;
    }
}
</source>
<source file="systems/smart_contracts/magesh.sol" startline="305" endline="309" pcid="4633">
  function getPrice() public view returns (uint256) {
    return oracle.price();
  }

  function withdraw(uint256 amountCent) public returns (uint256 amountWei){
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1095" endline="1103" pcid="1808">
    function finalized() public view returns (bool) {
        return _finalized;
    }

    /**
     * @dev Must be called after crowdsale ends, to do some extra finalization
     * work. Calls the contract's finalization function.
     */
    function finalize() public {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="448" endline="455" pcid="540">
    function start() public view returns (uint256) {
        return _start;
    }

    /**
     * @return the duration of the token vesting.
     */
    function duration() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="750" endline="757" pcid="4876">
  function getLastTier() public constant returns(address) {
    if (joinedCrowdsalesLen > 0)
      return joinedCrowdsales[joinedCrowdsalesLen - 1];
    else
      return address(0);
  }

  function setJoinedCrowdsales(address addr) private onlyOwner {
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="72" endline="75" pcid="7323">
  function decimals() public view returns(uint8) {
    return _decimals;
  }
}
</source>
<source file="systems/smart_contracts/ProxyERC20.sol" startline="397" endline="402" pcid="5893">
    function name() public view returns (string){
        // Immutable static call from target contract
        return IERC20(target).name();
    }

    function symbol() public view returns (string){
</source>
<source file="systems/smart_contracts/BlockPoolToken.sol" startline="80" endline="84" pcid="1413">
    function totalBurned() public view returns (uint256) {
        return burnedTotalNum_;
    }

    function burn(uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="745" endline="758" pcid="2141">
  function canUpgrade() public constant returns(bool) {
    return released && super.canUpgrade();
  }

  /**
   * Owner can update token information here.
   *
   * It is often useful to conceal the actual token association, until
   * the token operations, like central issuance or reissuance have been completed.
   *
   * This function allows the token owner to rename the token after the operations
   * have been completed and then point the audience to use the token contract.
   */
  function setTokenInformation(string _name, string _symbol) onlyOwner {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="321" endline="325" pcid="2589">
    function finalized() public view returns (bool) {
        return _finalized;
    }

    function finalize() public {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="918" endline="926" pcid="563">
    function pendingBeneficiary() public view returns (address) {
        return _pendingBeneficiary;
    }

     /**
        * @dev Allows beneficiaries to change beneficiaryShip and set first beneficiary as default
        * @param _newBeneficiaries defines array of addresses of new beneficiaries
    */
    function transferBeneficiaryShip(address[] memory _newBeneficiaries) public {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1059" endline="1063" pcid="6138">
  function isUpgradeAgent() public constant returns (bool) {
    return true;
  }

  function upgradeFrom(address _from, uint256 _value) public;
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="428" endline="435" pcid="1392">
    function paused() public view returns (bool) {
        return _paused;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     */
    modifier whenNotPaused() {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="312" endline="321" pcid="6335">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev Gets the balance of the specified address.
     * @param owner The address to query the balance of.
     * @return An uint256 representing the amount owned by the passed address.
     */
    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="347" endline="351" pcid="748">
    function decimals() public view returns(uint8) {
        return _decimals;
    }

}
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="33" endline="35" pcid="2816">
    function owner() public pure returns (address) {}

    event OwnerUpdate(address _prevOwner, address _newOwner);
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="122" endline="131" pcid="2404">
    function returnRate() public view returns(uint256) {
        if                                       ( block.number < heightEnd20Percent)  return 50;
        if (block.number >= heightEnd20Percent  && block.number < heightEnd10Percent)  return 100;
        if (block.number >= heightEnd10Percent  && block.number < heightEnd05Percent)  return 200;
        if (block.number >= heightEnd05Percent)                                        return 400;
    }



  function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/JDC.sol" startline="98" endline="104" pcid="4343">
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }



    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/MatchingToken.sol" startline="33" endline="37" pcid="4684">
    function decimals() public view returns (uint256) {
        return _decimals;
    }
    
    function totalSupply() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/MultiSigWallet.sol" startline="342" endline="353" pcid="5256">
    function getOwners()
        public
        constant
        returns (address[])
    {
        return owners;
    }

    /// @dev Returns array with owner addresses, which confirmed transaction.
    /// @param transactionId Transaction ID.
    /// @return Returns array of owner addresses.
    function getConfirmations(uint transactionId)
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="730" endline="735" pcid="7107">
    function checkMintAllowed (address, uint256) public pure returns (byte) {
        //require(ATContract.isOperator(_minter), "Not Minter!");
        return STATUS_ALLOWED;
    }

    function checkBurnAllowed (address, uint256) public pure returns (byte) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="735" endline="740" pcid="7108">
    function checkBurnAllowed (address, uint256) public pure returns (byte) {
        // default
        return STATUS_ALLOWED;
    }

}
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="730" endline="735" pcid="3852">
    function checkMintAllowed (address, uint256) public pure returns (byte) {
        //require(ATContract.isOperator(_minter), "Not Minter!");
        return STATUS_ALLOWED;
    }

    function checkBurnAllowed (address, uint256) public pure returns (byte) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="735" endline="740" pcid="3853">
    function checkBurnAllowed (address, uint256) public pure returns (byte) {
        // default
        return STATUS_ALLOWED;
    }

}
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="437" endline="440" pcid="6805">
    function getAvailableBPoll() public view returns (uint, uint, uint) {
        return _getAvailablePoll(businessPoll);
    }
    function getAvailableCpoll() public view returns (uint, uint, uint) {
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="440" endline="443" pcid="6806">
    function getAvailableCpoll() public view returns (uint, uint, uint) {
        return _getAvailablePoll(communityPoll);
    }
    function getAvailableTpoll() public view returns (uint, uint, uint) {
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="443" endline="448" pcid="6807">
    function getAvailableTpoll() public view returns (uint, uint, uint) {
        return _getAvailablePoll(techPoll);
    }

    /* 获取矿池信息接口 */
    function _getPollInfo(Poll memory poll) private view
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1343" endline="1346" pcid="1824">
    function withdrawalAllowed(address) public view returns (bool) {
        return _state == State.Refunding;
    }
}
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="45" endline="47" pcid="13">
    function callers(address) public pure returns (bool) { }

    function appendCaller(address _caller) public;  // ownerOnly
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="43" endline="45" pcid="2819">
    function callers(address) public pure returns (bool) { }

    function appendCaller(address _caller) public;  // ownerOnly
</source>
</class>

<class classid="8" nclones="13" nlines="2" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="39" endline="40" pcid="11">
    function transferOwnership(address _newOwner) public;
    function acceptOwnership() public;
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="289" endline="290" pcid="7362">
    function transferOwnership(address newOwner) public;
    function name() public view returns (string);
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="389" endline="390" pcid="2353">
    function transferOwnership(address _newOwner) external;
}
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="455" endline="463" pcid="2358">
    function addOwner(address _account) public;


    /**
     * Removes `_account` as an owner
     *
     * @param _account The account to remove as an owner
     */
    function removeOwner(address _account) public;
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="210" endline="211" pcid="2342">
    function retrieveTokens(address _tokenContract) external;
}
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="37" endline="38" pcid="2817">
    function transferOwnership(address _newOwner) public;
    function acceptOwnership() public;
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="45" endline="46" pcid="2820">
    function appendCaller(address _caller) public;  // ownerOnly
    function removeCaller(address _caller) public;  // ownerOnly
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="46" endline="48" pcid="2821">
    function removeCaller(address _caller) public;  // ownerOnly
    
    event AppendCaller(ICaller _caller);
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="463" endline="464" pcid="2359">
    function removeOwner(address _account) public;
}
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="48" endline="50" pcid="15">
    function removeCaller(address _caller) public;  // ownerOnly
    
    event AppendCaller(ICaller _caller);
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="290" endline="291" pcid="2348">
    function unregisterObserver(address _observer) external;
}
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="282" endline="290" pcid="2347">
    function registerObserver(address _observer) external;


    /**
     * Unregister `_observer` as an observer
     * 
     * @param _observer The account to remove as an observer
     */
    function unregisterObserver(address _observer) external;
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="47" endline="48" pcid="14">
    function appendCaller(address _caller) public;  // ownerOnly
    function removeCaller(address _caller) public;  // ownerOnly
</source>
</class>

<class classid="9" nclones="33" nlines="2" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="40" endline="41" pcid="12">
    function acceptOwnership() public;
}
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="206" endline="208" pcid="823">
    function renounceWLOperators() external;

    function addFundingManagers(address) external;
</source>
<source file="systems/smart_contracts/Factory.sol" startline="228" endline="229" pcid="3467">
    function renounceFundingManager() external;
    function isFundingOperator(address) external view returns (bool);
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="204" endline="205" pcid="821">
    function renounceWLManager() external;
    function isWLOperator(address) external view returns (bool);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="206" endline="208" pcid="3778">
    function renounceWLOperators() external;

    function addFundingManagers(address) external;
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="317" endline="318" pcid="53">
	function disinvest() public;
}
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="514" endline="515" pcid="7058">
    function renounceFundingManager() external;
    function isFundingOperator(address) external view returns (bool);
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="224" endline="226" pcid="839">
    function renounceFundsUnlockerOperators() external;

    function isWhitelisted(address) external view returns(bool);
</source>
<source file="systems/smart_contracts/Factory.sol" startline="239" endline="241" pcid="3477">
    function renounceFundsUnlockerOperators() external;

    function isWhitelisted(address) external view returns(bool);
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="38" endline="39" pcid="2818">
    function acceptOwnership() public;
}
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="516" endline="518" pcid="7060">
    function renounceFundingOperators() external;

    function addFundsUnlockerManagers(address) external;
</source>
<source file="systems/smart_contracts/Factory.sol" startline="237" endline="238" pcid="3475">
    function renounceFundsUnlockerManager() external;
    function isFundsUnlockerOperator(address) external view returns (bool);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="545" endline="546" pcid="3828">
    function unpause() external;
    function isImportedContract(address) external view returns (bool);
</source>
<source file="systems/smart_contracts/Factory.sol" startline="230" endline="232" pcid="3469">
    function renounceFundingOperators() external;

    function addFundsUnlockerManagers(address) external;
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="215" endline="217" pcid="3786">
    function renounceFundingOperators() external;

    function addFundsUnlockerManagers(address) external;
</source>
<source file="systems/smart_contracts/Factory.sol" startline="221" endline="223" pcid="3461">
    function renounceWLOperators() external;

    function addFundingManagers(address) external;
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="1010" endline="1011" pcid="3122">
  function ping() public;
  function ownerOf(uint256 tokenId) public returns (address);
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="545" endline="546" pcid="7083">
    function unpause() external;
    function isImportedContract(address) external view returns (bool);
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="215" endline="217" pcid="831">
    function renounceFundingOperators() external;

    function addFundsUnlockerManagers(address) external;
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="544" endline="545" pcid="3827">
    function pause() external;
    function unpause() external;
</source>
<source file="systems/smart_contracts/Factory.sol" startline="219" endline="220" pcid="3459">
    function renounceWLManager() external;
    function isWLOperator(address) external view returns (bool);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="213" endline="214" pcid="3784">
    function renounceFundingManager() external;
    function isFundingOperator(address) external view returns (bool);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="204" endline="205" pcid="3776">
    function renounceWLManager() external;
    function isWLOperator(address) external view returns (bool);
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="222" endline="223" pcid="837">
    function renounceFundsUnlockerManager() external;
    function isFundsUnlockerOperator(address) external view returns (bool);
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="505" endline="506" pcid="7050">
    function renounceWLManager() external;
    function isWLOperator(address) external view returns (bool);
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="525" endline="527" pcid="7068">
    function renounceFundsUnlockerOperators() external;

    function isWhitelisted(address) external view returns(bool);
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="544" endline="545" pcid="7082">
    function pause() external;
    function unpause() external;
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="222" endline="223" pcid="3792">
    function renounceFundsUnlockerManager() external;
    function isFundsUnlockerOperator(address) external view returns (bool);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="224" endline="226" pcid="3794">
    function renounceFundsUnlockerOperators() external;

    function isWhitelisted(address) external view returns(bool);
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="213" endline="214" pcid="829">
    function renounceFundingManager() external;
    function isFundingOperator(address) external view returns (bool);
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="523" endline="524" pcid="7066">
    function renounceFundsUnlockerManager() external;
    function isFundsUnlockerOperator(address) external view returns (bool);
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="369" endline="370" pcid="7372">
    function splitStarFunds() public;
}
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="507" endline="509" pcid="7052">
    function renounceWLOperators() external;

    function addFundingManagers(address) external;
</source>
</class>

<class classid="10" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="55" endline="57" pcid="16">
	function calledUpdate(address _oldCalled, address _newCalled) public;  // ownerOnly
	
	event CalledUpdate(address _oldCalled, address _newCalled);
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="53" endline="55" pcid="2822">
	function calledUpdate(address _oldCalled, address _newCalled) public;  // ownerOnly
	
	event CalledUpdate(address _oldCalled, address _newCalled);
</source>
</class>

<class classid="11" nclones="134" nlines="2" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="66" endline="68" pcid="22">
    function allowance(address _from, address _spender) public view returns (uint256);

    function transfer(address _to, uint256 _value) public returns (bool success);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="269" endline="285" pcid="3807">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="13" endline="15" pcid="2298">
  function allowance(address owner, address spender) external view returns (uint256);

  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="461" endline="465" pcid="4765">
    function allowance(address _owner, address _spender)
        external
        view
        returns (uint256);
}
</source>
<source file="systems/smart_contracts/magesh.sol" startline="85" endline="87" pcid="4617">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="186" endline="187" pcid="6782">
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/DABANKING_SWAP.sol" startline="20" endline="22" pcid="2271">
    function allowance(address owner, address spender) public view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/SuperMarket.sol" startline="18" endline="20" pcid="6758">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="69" endline="70" pcid="6484">
    function allowance(address owner, address spender) public constant returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/ankara.sol" startline="29" endline="31" pcid="680">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="20" endline="23" pcid="726">
  function allowance(address owner, address spender)
    external view returns (uint256);

  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/TorexToken.sol" startline="156" endline="159" pcid="7415">
  function allowance(address owner, address spender)
    public view returns (uint256);

  function transferFrom(address from, address to, uint256 value)
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="270" endline="272" pcid="7290">
  function allowance(address owner, address spender) external view returns (uint256);

  function transfer(address to, uint256 value) external;
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="168" endline="184" pcid="5957">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/BlockPoolToken.sol" startline="128" endline="129" pcid="1417">
    function allowance(address owner, address spender) public view returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/FMT.sol" startline="17" endline="18" pcid="3648">
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/ProxyERC20.sol" startline="334" endline="336" pcid="5886">
    function allowance(address owner, address spender) public view returns (uint);

    function transfer(address to, uint value) public returns (bool);
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="530" endline="532" pcid="6622">
	function allowance(address owner, address spender) public view returns (uint256);

	function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="40" endline="56" pcid="645">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="284" endline="300" pcid="5159">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="70" endline="73" pcid="4648">
  function allowance(address owner, address spender)
    public view returns (uint256);

  function transferFrom(address from, address to, uint256 value)
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="14" endline="15" pcid="1461">
  function allowance(address owner, address spender) external view returns (uint256);
  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="57" endline="58" pcid="5089">
  function allowance(address owner, address spender) external view returns (uint256);
  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="317" endline="319" pcid="5687">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="82" endline="85" pcid="5839">
    function allowance(address owner, address spender)
    external view returns (uint256);

    function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/BountyBoard.sol" startline="117" endline="118" pcid="1494">
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/Factory.sol" startline="201" endline="202" pcid="3448">
    function allowance(address owner, address spender) external view returns (uint256);
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="10" endline="11" pcid="7312">
  function allowance(address owner, address spender) external view returns (uint256);
  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/BKN.sol" startline="18" endline="19" pcid="1321">
    function allowance(address owner, address spender) public constant returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="40" endline="56" pcid="1747">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="38" endline="40" pcid="7640">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/LuckyAdvcedWoken.sol" startline="19" endline="21" pcid="4553">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="66" endline="67" pcid="6550">
    function allowance(address owner, address spender) public constant returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="183" endline="186" pcid="2240">
    function allowance(address owner, address spender)
    external view returns (uint256);

    function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="145" endline="161" pcid="7903">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="40" endline="56" pcid="5905">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="40" endline="56" pcid="478">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="24" endline="25" pcid="7742">
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="253" endline="255" pcid="3566">
    function allowance(address owner, address spender) external view returns (uint256);

    function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/AronCoin.sol" startline="24" endline="25" pcid="758">
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/TokenSwap.sol" startline="158" endline="160" pcid="7400">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="118" endline="134" pcid="948">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="90" endline="93" pcid="4236">
  function allowance(address owner, address spender)
  external view returns (uint256);

  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="10" endline="11" pcid="2146">
  function allowance(address owner, address spender) external view returns (uint256);
  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="334" endline="335" pcid="4855">
  function allowance(address owner, address spender) public constant returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="115" endline="116" pcid="7458">
    function allowance(address owner, address spender) public view returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="10" endline="11" pcid="6197">
  function allowance(address owner, address spender) external view returns (uint256);
  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="43" endline="59" pcid="7014">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/Comet.sol" startline="10" endline="11" pcid="1914">
  function allowance(address owner, address spender) external view returns (uint256);
  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="65" endline="66" pcid="1273">
    function allowance(address owner, address spender) public constant returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="24" endline="26" pcid="1364">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/Byte.sol" startline="12" endline="13" pcid="1567">
  function allowance(address owner, address spender) external view returns (uint256);
  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="153" endline="155" pcid="5348">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/CST_TOKEN.sol" startline="9" endline="10" pcid="2193">
  function allowance(address _owner, address _spender) external view returns (uint256);
  function transfer(address _to, uint256 _value) external returns (bool);
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="73" endline="74" pcid="1436">
    function allowance(address owner, address spender) public constant returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="65" endline="66" pcid="4958">
    function allowance(address owner, address spender) public constant returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="101" endline="102" pcid="1630">
    function allowance(address owner, address spender) public view returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="276" endline="277" pcid="7354">
    function allowance(address owner, address spender) public view returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="236" endline="239" pcid="7284">
  function allowance(address owner, address spender)
    external view returns (uint256);

  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="200" endline="201" pcid="1892">
    function allowance(address owner, address spender) public constant returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/Gacha.sol" startline="61" endline="63" pcid="3969">
    function isApprovedForAll(address owner, address operator) public view returns (bool);

    function transfer(address to, uint256 tokenId) public;
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="104" endline="106" pcid="39">
    function token_allowance(address _from, address _spender) public view returns (uint256);

    function token_transfer(address _from, address _to, uint256 _value) public returns (bool success);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="776" endline="777" pcid="3882">
    function allowance(address owner, address spender) external view returns (uint256);
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="27" endline="29" pcid="6410">
    function allowance(address owner, address spender) external view returns (uint256);

    function okToTransferTokens(address _holder, uint256 _amountToAdd) external view returns (bool);
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="142" endline="143" pcid="2103">
  function allowance(address owner, address spender) public constant returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/RETC.sol" startline="39" endline="40" pcid="6180">
    function allowance(address owner, address spender) public constant returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="10" endline="11" pcid="3914">
  function allowance(address owner, address spender) external view returns (uint256);
  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="85" endline="87" pcid="4929">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/BFGToken.sol" startline="54" endline="55" pcid="1184">
  function allowance(address owner, address agent) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/Aigopay.sol" startline="78" endline="79" pcid="448">
    function allowance(address owner, address spender) public constant returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="62" endline="63" pcid="3520">
    function allowance(address owner, address spender) public constant returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/MAdvcedWoken.sol" startline="19" endline="21" pcid="4592">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/SellableToken.sol" startline="42" endline="43" pcid="6461">
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="38" endline="54" pcid="302">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/NSTTeamLock.sol" startline="20" endline="22" pcid="5456">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/SistContract.sol" startline="48" endline="49" pcid="6518">
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/CNG.sol" startline="16" endline="19" pcid="1842">
  function allowance(address owner, address spender)
    external view returns (uint256);

  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="80" endline="81" pcid="6984">
    function allowance(address owner, address spender) external view returns (uint256);
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/LBBT.sol" startline="44" endline="47" pcid="4539">
  function allowance(address owner, address spender)
    public view returns (uint256);

  function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="71" endline="72" pcid="6682">
    function allowance(address owner, address spender) public constant returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="102" endline="103" pcid="4384">
    function allowance(address owner, address spender) public view returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="144" endline="160" pcid="4034">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="49" endline="52" pcid="2043">
    function allowance(address owner, address spender)
        public view returns (uint256);

    function transferFrom(address from, address to, uint256 value)
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="183" endline="186" pcid="7713">
    function allowance(address owner, address spender)
    external view returns (uint256);

    function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/BDAM.sol" startline="173" endline="174" pcid="1122">
  function allowance(address owner, address spender) public constant returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="31" endline="32" pcid="3163">
  function allowance(address owner, address spender) external view returns (uint256);
  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/NBToken.sol" startline="144" endline="145" pcid="5307">
    function allowance(address owner, address spender) public view returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="14" endline="15" pcid="2548">
  function allowance(address owner, address spender) external view returns (uint256);
  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/PositionTokenV2.sol" startline="30" endline="33" pcid="5746">
  function allowance(address _owner, address _spender)
    public view returns (uint256);

  function transferFrom(address _from, address _to, uint256 _value)
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="77" endline="78" pcid="4301">
    function allowance(address owner, address spender) public constant returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/PokaToken.sol" startline="18" endline="20" pcid="5730">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/UGCoin.sol" startline="39" endline="40" pcid="7529">
    function allowance(address owner, address spender) public constant returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/MultiSendErc20.sol" startline="74" endline="75" pcid="5206">
    function allowance(address owner, address spender) public view returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/NaorisToken.sol" startline="115" endline="116" pcid="5287">
    function allowance(address owner, address spender) public view returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="40" endline="56" pcid="518">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="199" endline="201" pcid="581">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/MBA.sol" startline="103" endline="106" pcid="4708">
  function allowance(address owner, address spender)
    public view returns (uint256);

  function transferFrom(address from, address to, uint256 value)
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="193" endline="194" pcid="7790">
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="43" endline="44" pcid="8014">
    function allowance(address owner, address spender) public constant returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="150" endline="166" pcid="4423">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="34" endline="50" pcid="5772">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/BANG.sol" startline="14" endline="15" pcid="1037">
  function allowance(address owner, address spender) external view returns (uint256);
  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/UTC.sol" startline="123" endline="124" pcid="7581">
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/tharDex.sol" startline="15" endline="16" pcid="7143">
     function allowance(address _owner, address _spender)external view returns(uint256);
}
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="186" endline="202" pcid="5419">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="10" endline="11" pcid="2639">
  function allowance(address owner, address spender) external view returns (uint256);
  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="329" endline="330" pcid="6095">
  function allowance(address owner, address spender) public constant returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/GFNX.sol" startline="15" endline="18" pcid="4094">
  function allowance(address owner, address spender)
    external view returns (uint256);

  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="211" endline="227" pcid="7180">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="118" endline="134" pcid="6020">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="59" endline="62" pcid="3062">
  function isApprovedForAll(address _owner, address _operator)
    public view returns (bool);

  function transferFrom(address _from, address _to, uint256 _tokenId) public;
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="102" endline="104" pcid="3236">
    function isApprovedForAll(address owner, address operator) public view returns (bool);

    function transferFrom(address from, address to, uint256 tokenId) public;
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="454" endline="457" pcid="5009">
    function isApprovedForAll(address owner, address operator) public view returns (bool);


    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="12" endline="13" pcid="5986">
  function allowance(address owner, address spender) external view returns (uint256);
  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/GoldenRings.sol" startline="46" endline="47" pcid="4172">
    function allowance(address owner, address spender) public view returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="27" endline="29" pcid="3014">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="73" endline="74" pcid="2333">
    function allowance(address _owner, address _spender) external view returns (uint);
}
</source>
<source file="systems/smart_contracts/WTA.sol" startline="64" endline="65" pcid="8048">
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="118" endline="134" pcid="2461">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="66" endline="67" pcid="2953">
    function allowance(address owner, address spender) public constant returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="42" endline="58" pcid="8227">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="15" endline="16" pcid="8071">
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/XGP.sol" startline="78" endline="79" pcid="8105">
    function allowance(address owner, address spender) public constant returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="183" endline="186" pcid="6726">
    function allowance(address owner, address spender)
    external view returns (uint256);

    function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="43" endline="44" pcid="2880">
    function allowance(address owner, address spender) public constant returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="98" endline="100" pcid="2845">
    function token_allowance(address _from, address _spender) public view returns (uint256);

    function token_transfer(address _from, address _to, uint256 _value) public returns (bool success);
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="63" endline="65" pcid="2828">
    function allowance(address _from, address _spender) public view returns (uint256);

    function transfer(address _to, uint256 _value) public returns (bool success);
</source>
<source file="systems/smart_contracts/DNP.sol" startline="72" endline="73" pcid="2788">
    function allowance(address owner, address spender) public view returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/GameGold.sol" startline="194" endline="195" pcid="3997">
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/CRYPTOMZ.sol" startline="129" endline="130" pcid="2182">
  function allowance(address owner, address spender) public constant returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="14" endline="15" pcid="2388">
  function allowance(address owner, address spender) external view returns (uint256);
  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/SBC.sol" startline="293" endline="295" pcid="6334">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="144" endline="160" pcid="8193">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="18" endline="21" pcid="2735">
  function allowance(address owner, address spender)
    external view returns (uint256);

  function transfer(address to, uint256 value) external returns (bool);
</source>
</class>

<class classid="12" nclones="21" nlines="2" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="69" endline="70" pcid="24">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
    function approve(address _spender, uint256 _value) public returns (bool success);
</source>
<source file="systems/smart_contracts/MT.sol" startline="45" endline="46" pcid="5074">
    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success);
    function approve(address _spender, uint256 _value)public returns (bool success);
</source>
<source file="systems/smart_contracts/multiSend.sol" startline="9" endline="10" pcid="5195">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
}
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="70" endline="72" pcid="1715">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    function approve(address _spender, uint256 _value) public returns (bool success);
</source>
<source file="systems/smart_contracts/tharDex.sol" startline="13" endline="14" pcid="7141">
  function transferFrom(address from, address to, uint256 value) public returns (bool success);
     function balanceOf(address account) external view returns(uint256);
</source>
<source file="systems/smart_contracts/AACD.sol" startline="45" endline="46" pcid="292">
    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success);
    function approve(address _spender, uint256 _value)public returns (bool success);
</source>
<source file="systems/smart_contracts/SAS.sol" startline="44" endline="46" pcid="6295">
  function transferFrom(address _from, address _to, uint256 _value)public returns (bool success);
  
  function approve(address _spender, uint256 _value)public returns (bool success);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="110" endline="112" pcid="44">
    function token_approve(address _from, address _spender, uint256 _value) public returns (bool success);
    
    function fallback(address _from, bytes _data) public payable;                      		// eth input
</source>
<source file="systems/smart_contracts/BACD.sol" startline="62" endline="63" pcid="1017">
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
  function approve(address _spender, uint256 _value) public returns (bool success);
</source>
<source file="systems/smart_contracts/AzurToken.sol" startline="37" endline="43" pcid="1002">
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

  /// @notice `msg.sender` approves `_spender` to spend `_value` tokens
  /// @param _spender The address of the account able to transfer the tokens
  /// @param _value The amount of tokens to be approved for transfer
  /// @return Whether the approval was successful or not
  function approve(address _spender, uint256 _value) public returns (bool success);
</source>
<source file="systems/smart_contracts/NEM.sol" startline="45" endline="46" pcid="5322">
    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success);
    function approve(address _spender, uint256 _value)public returns (bool success);
</source>
<source file="systems/smart_contracts/Oracle.sol" startline="186" endline="187" pcid="5534">
  function transferFrom(address from, address to, uint256 value) external returns (bool success);
}
</source>
<source file="systems/smart_contracts/BTGS.sol" startline="15" endline="16" pcid="1539">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
    function approve(address _spender, uint256 _value) public returns (bool success);
</source>
<source file="systems/smart_contracts/NMAI.sol" startline="45" endline="46" pcid="5444">
    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success);
    function approve(address _spender, uint256 _value)public returns (bool success);
</source>
<source file="systems/smart_contracts/DHF.sol" startline="45" endline="46" pcid="2539">
    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success);
    function approve(address _spender, uint256 _value)public returns (bool success);
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="66" endline="67" pcid="2830">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
    function approve(address _spender, uint256 _value) public returns (bool success);
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="100" endline="101" pcid="2846">
    function token_transfer(address _from, address _to, uint256 _value) public returns (bool success);
    function token_transfer(address _from, address _to, uint _value, bytes _data) public returns (bool success);
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="104" endline="106" pcid="2850">
    function token_approve(address _from, address _spender, uint256 _value) public returns (bool success);
    
    function fallback(address _from, bytes _data) public payable;                      		// eth input
</source>
<source file="systems/smart_contracts/CAC.sol" startline="45" endline="46" pcid="1613">
    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success);
    function approve(address _spender, uint256 _value)public returns (bool success);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="106" endline="107" pcid="40">
    function token_transfer(address _from, address _to, uint256 _value) public returns (bool success);
    function token_transfer(address _from, address _to, uint _value, bytes _data) public returns (bool success);
</source>
<source file="systems/smart_contracts/VACCToken.sol" startline="58" endline="60" pcid="7622">
    function transferFrom(address from, address to, uint256 tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint256 tokens);
</source>
</class>

<class classid="13" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="83" endline="84" pcid="27">
    function disableTransfers(bool _disable) public;
    function issue(address _to, uint256 _amount) public;
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="78" endline="79" pcid="2833">
    function disableTransfers(bool _disable) public;
    function issue(address _to, uint256 _amount) public;
</source>
</class>

<class classid="14" nclones="19" nlines="2" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="84" endline="85" pcid="28">
    function issue(address _to, uint256 _amount) public;
    function destroy(address _from, uint256 _amount) public;
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="574" endline="575" pcid="5704">
  function approve(address _to, uint256 _value) public;
}
</source>
<source file="systems/smart_contracts/Airdropper.sol" startline="22" endline="23" pcid="472">
  function transfer(address _to, uint256 _value) public ;
  event Transfer(address indexed _from, address indexed _to, uint256 _value);
</source>
<source file="systems/smart_contracts/Oracle.sol" startline="166" endline="167" pcid="5521">
  function withdraw(address recipient, uint256 amount) external;
  function withdrawable() external view returns (uint256);
</source>
<source file="systems/smart_contracts/Gacha.sol" startline="63" endline="65" pcid="3970">
    function transfer(address to, uint256 tokenId) public;

    function transferFrom(address from, address to, uint256 tokenId) public;
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="1074" endline="1075" pcid="219">
    function destroy(address _from, uint256 _eth) public;
}
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="79" endline="80" pcid="2834">
    function issue(address _to, uint256 _amount) public;
    function destroy(address _from, uint256 _amount) public;
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="272" endline="274" pcid="7291">
  function transfer(address to, uint256 value) external;

  function approve(address spender, uint256 value) external;
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="274" endline="276" pcid="7292">
  function approve(address spender, uint256 value) external;

  function transferFrom(address from, address to, uint256 value) external;
</source>
<source file="systems/smart_contracts/Oracle.sol" startline="180" endline="181" pcid="5528">
  function increaseApproval(address spender, uint256 subtractedValue) external;
  function name() external returns (string tokenName);
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1063" endline="1065" pcid="6139">
  function upgradeFrom(address _from, uint256 _value) public;

}
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="98" endline="99" pcid="3233">
    function approve(address to, uint256 tokenId) public;
    function getApproved(uint256 tokenId) public view returns (address operator);
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="246" endline="248" pcid="2113">
  function upgradeFrom(address _from, uint256 _value) public;

}
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="450" endline="451" pcid="5006">
    function approve(address to, uint256 tokenId) public;
    function getApproved(uint256 tokenId) public view returns (address operator);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="595" endline="596" pcid="155">
    function impl_forging(address _from, uint256 _msm) public;
    function impl_purchase(address _from, bool _wantDividend, bool _nonInvate, bytes32 _channel) public payable;
</source>
<source file="systems/smart_contracts/Gacha.sol" startline="55" endline="57" pcid="3966">
    function approve(address to, uint256 tokenId) public;

    function getApproved(uint256 tokenId) public view returns (address operator);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="85" endline="87" pcid="29">
    function destroy(address _from, uint256 _amount) public;
	//function() public payable;
}
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="54" endline="55" pcid="3059">
  function approve(address _to, uint256 _tokenId) public;
  function getApproved(uint256 _tokenId)
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="80" endline="82" pcid="2835">
    function destroy(address _from, uint256 _amount) public;
	//function() public payable;
}
</source>
</class>

<class classid="15" nclones="13" nlines="2" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="93" endline="95" pcid="31">
	function emitEventTransfer(address _from, address _to, uint256 _amount) public;

    function updateChanges(address) public;
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="573" endline="574" pcid="5703">
  function transferFrom(address _from, address _to, uint256 _valueOrTokenId) public;
  function approve(address _to, uint256 _value) public;
</source>
<source file="systems/smart_contracts/Gacha.sol" startline="65" endline="67" pcid="3971">
    function transferFrom(address from, address to, uint256 tokenId) public;

    function safeTransferFrom(address from, address to, uint256 tokenId) public;
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="276" endline="277" pcid="7293">
  function transferFrom(address from, address to, uint256 value) external;
}
</source>
<source file="systems/smart_contracts/Gacha.sol" startline="67" endline="69" pcid="3972">
    function safeTransferFrom(address from, address to, uint256 tokenId) public;

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="105" endline="107" pcid="3238">
    function safeTransferFrom(address from, address to, uint256 tokenId) public;

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="104" endline="105" pcid="3237">
    function transferFrom(address from, address to, uint256 tokenId) public;
    function safeTransferFrom(address from, address to, uint256 tokenId) public;
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="63" endline="66" pcid="3064">
  function safeTransferFrom(address _from, address _to, uint256 _tokenId)
    public;

  function safeTransferFrom(
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="62" endline="63" pcid="3063">
  function transferFrom(address _from, address _to, uint256 _tokenId) public;
  function safeTransferFrom(address _from, address _to, uint256 _tokenId)
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="87" endline="89" pcid="2837">
	function emitEventTransfer(address _from, address _to, uint256 _amount) public;

    function updateChanges(address) public;
</source>
<source file="systems/smart_contracts/TimeLockedTokenStorage.sol" startline="67" endline="68" pcid="7226">
    function approveForOtherContracts(address _sender, address _spender, uint256 _value) external;
    function transfer(address _to, uint256 _value) public returns (bool);
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="440" endline="449" pcid="5004">
    function safeTransferFrom(address from, address to, uint256 tokenId) public;
    /**
     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to
     * another (`to`).
     *
     * Requirements:
     * - If the caller is not `from`, it must be approved to move this NFT by
     * either {approve} or {setApprovalForAll}.
     */
    function transferFrom(address from, address to, uint256 tokenId) public;
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="449" endline="450" pcid="5005">
    function transferFrom(address from, address to, uint256 tokenId) public;
    function approve(address to, uint256 tokenId) public;
</source>
</class>

<class classid="16" nclones="72" nlines="2" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="95" endline="96" pcid="32">
    function updateChanges(address) public;
    function updateChangesByBrother(address, uint256, uint256) public;
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="212" endline="213" pcid="828">
    function removeFundingOperators(address) external;
    function renounceFundingManager() external;
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="518" endline="519" pcid="7061">
    function addFundsUnlockerManagers(address) external;
    function removeFundsUnlockerManagers(address) external;
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="209" endline="210" pcid="3780">
    function removeFundingManagers(address) external;
    function isFundingManager(address) external view returns (bool);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="202" endline="203" pcid="3774">
    function addWLOperators(address) external;
    function removeWLOperators(address) external;
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="203" endline="204" pcid="820">
    function removeWLOperators(address) external;
    function renounceWLManager() external;
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="104" endline="105" pcid="6418">
    function changeTDeployerAddress(address) external;
    function changeFPDeployerAddress(address) external;
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="686" endline="687" pcid="935">
    function setFactoryAddress(address) external;
    function getFactoryAddress() external view returns(address);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="220" endline="221" pcid="3790">
    function addFundsUnlockerOperators(address) external;
    function removeFundsUnlockerOperators(address) external;
</source>
<source file="systems/smart_contracts/Factory.sol" startline="233" endline="234" pcid="3471">
    function removeFundsUnlockerManagers(address) external;
    function isFundsUnlockerManager(address) external view returns (bool);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="212" endline="213" pcid="3783">
    function removeFundingOperators(address) external;
    function renounceFundingManager() external;
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="217" endline="218" pcid="832">
    function addFundsUnlockerManagers(address) external;
    function removeFundsUnlockerManagers(address) external;
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="218" endline="219" pcid="833">
    function removeFundsUnlockerManagers(address) external;
    function isFundsUnlockerManager(address) external view returns (bool);
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="262" endline="263" pcid="868">
    function disableMemberByStaffRetire(address) external;
    function disableMemberByStaffForExit(address) external;
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="200" endline="201" pcid="3772">
    function removeWLManagers(address) external;
    function isWLManager(address) external view returns (bool);
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="103" endline="104" pcid="6417">
    function changeATFactoryAddress(address) external;
    function changeTDeployerAddress(address) external;
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="501" endline="502" pcid="7046">
    function removeWLManagers(address) external;
    function isWLManager(address) external view returns (bool);
</source>
<source file="systems/smart_contracts/Factory.sol" startline="270" endline="271" pcid="3494">
    function setFactoryAddress(address) external;
    function getFactoryAddress() external view returns(address);
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="509" endline="510" pcid="7053">
    function addFundingManagers(address) external;
    function removeFundingManagers(address) external;
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="199" endline="200" pcid="3771">
    function addWLManagers(address) external;
    function removeWLManagers(address) external;
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="264" endline="265" pcid="870">
    function disableMemberByMember(address) external;
    function changeMemberData(address, string calldata, bytes32) external;
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="503" endline="504" pcid="7048">
    function addWLOperators(address) external;
    function removeWLOperators(address) external;
</source>
<source file="systems/smart_contracts/Factory.sol" startline="232" endline="233" pcid="3470">
    function addFundsUnlockerManagers(address) external;
    function removeFundsUnlockerManagers(address) external;
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="208" endline="209" pcid="824">
    function addFundingManagers(address) external;
    function removeFundingManagers(address) external;
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="750" endline="751" pcid="3860">
    function disableMemberByMember(address) external;
    function changeMemberData(address, string calldata, bytes32) external;
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="521" endline="522" pcid="7064">
    function addFundsUnlockerOperators(address) external;
    function removeFundsUnlockerOperators(address) external;
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="107" endline="108" pcid="6421">
    function changeFeesCollector (address) external;
    function deployPanelContracts(string calldata, string calldata, string calldata, bytes32, uint8, uint8, uint8, uint256) external;
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="221" endline="222" pcid="836">
    function removeFundsUnlockerOperators(address) external;
    function renounceFundsUnlockerManager() external;
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="241" endline="242" pcid="851">
    function changeFPDeployerAddress(address) external;
    function deployPanelContracts(string calldata, string calldata, string calldata, bytes32, uint8, uint8, uint256, uint256) external;
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="504" endline="505" pcid="7049">
    function removeWLOperators(address) external;
    function renounceWLManager() external;
</source>
<source file="systems/smart_contracts/Factory.sol" startline="262" endline="263" pcid="3491">
    function setFactoryAddress(address) external;
    function getFactoryAddress() external view returns(address);
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="500" endline="501" pcid="7045">
    function addWLManagers(address) external;
    function removeWLManagers(address) external;
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="217" endline="218" pcid="3787">
    function addFundsUnlockerManagers(address) external;
    function removeFundsUnlockerManagers(address) external;
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="745" endline="746" pcid="7110">
    function setFactoryAddress(address) external;
    function getFactoryAddress() external view returns(address);
</source>
<source file="systems/smart_contracts/Factory.sol" startline="227" endline="228" pcid="3466">
    function removeFundingOperators(address) external;
    function renounceFundingManager() external;
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="105" endline="106" pcid="6419">
    function changeFPDeployerAddress(address) external;
    function changeDeployFees (uint256) external;
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="203" endline="204" pcid="3775">
    function removeWLOperators(address) external;
    function renounceWLManager() external;
</source>
<source file="systems/smart_contracts/Factory.sol" startline="226" endline="227" pcid="3465">
    function addFundingOperators(address) external;
    function removeFundingOperators(address) external;
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="263" endline="264" pcid="869">
    function disableMemberByStaffForExit(address) external;
    function disableMemberByMember(address) external;
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="221" endline="222" pcid="3791">
    function removeFundsUnlockerOperators(address) external;
    function renounceFundsUnlockerManager() external;
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="211" endline="212" pcid="3782">
    function addFundingOperators(address) external;
    function removeFundingOperators(address) external;
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="748" endline="749" pcid="3858">
    function disableMemberByStaffRetire(address) external;
    function disableMemberByStaffForExit(address) external;
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="522" endline="523" pcid="7065">
    function removeFundsUnlockerOperators(address) external;
    function renounceFundsUnlockerManager() external;
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="89" endline="90" pcid="2838">
    function updateChanges(address) public;
    function updateChangesByBrother(address, uint256, uint256) public;
</source>
<source file="systems/smart_contracts/Factory.sol" startline="214" endline="215" pcid="3454">
    function addWLManagers(address) external;
    function removeWLManagers(address) external;
</source>
<source file="systems/smart_contracts/Factory.sol" startline="224" endline="225" pcid="3463">
    function removeFundingManagers(address) external;
    function isFundingManager(address) external view returns (bool);
</source>
<source file="systems/smart_contracts/Factory.sol" startline="223" endline="224" pcid="3462">
    function addFundingManagers(address) external;
    function removeFundingManagers(address) external;
</source>
<source file="systems/smart_contracts/Factory.sol" startline="218" endline="219" pcid="3458">
    function removeWLOperators(address) external;
    function renounceWLManager() external;
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="510" endline="511" pcid="7054">
    function removeFundingManagers(address) external;
    function isFundingManager(address) external view returns (bool);
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="261" endline="262" pcid="867">
    function enableMember(address) external;
    function disableMemberByStaffRetire(address) external;
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="512" endline="513" pcid="7056">
    function addFundingOperators(address) external;
    function removeFundingOperators(address) external;
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="240" endline="241" pcid="850">
    function changeTDeployerAddress(address) external;
    function changeFPDeployerAddress(address) external;
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="747" endline="748" pcid="3857">
    function enableMember(address) external;
    function disableMemberByStaffRetire(address) external;
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="513" endline="514" pcid="7057">
    function removeFundingOperators(address) external;
    function renounceFundingManager() external;
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="208" endline="209" pcid="3779">
    function addFundingManagers(address) external;
    function removeFundingManagers(address) external;
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="749" endline="750" pcid="3859">
    function disableMemberByStaffForExit(address) external;
    function disableMemberByMember(address) external;
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="1136" endline="1137" pcid="3907">
    function setFactoryAddress(address) external;
    function getFactoryAddress() external view returns(address);
</source>
<source file="systems/smart_contracts/Factory.sol" startline="217" endline="218" pcid="3457">
    function addWLOperators(address) external;
    function removeWLOperators(address) external;
</source>
<source file="systems/smart_contracts/Factory.sol" startline="236" endline="237" pcid="3474">
    function removeFundsUnlockerOperators(address) external;
    function renounceFundsUnlockerManager() external;
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="199" endline="200" pcid="816">
    function addWLManagers(address) external;
    function removeWLManagers(address) external;
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="239" endline="240" pcid="849">
    function changeATFactoryAddress(address) external;
    function changeTDeployerAddress(address) external;
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="220" endline="221" pcid="835">
    function addFundsUnlockerOperators(address) external;
    function removeFundsUnlockerOperators(address) external;
</source>
<source file="systems/smart_contracts/Factory.sol" startline="215" endline="216" pcid="3455">
    function removeWLManagers(address) external;
    function isWLManager(address) external view returns (bool);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="218" endline="219" pcid="3788">
    function removeFundsUnlockerManagers(address) external;
    function isFundsUnlockerManager(address) external view returns (bool);
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="209" endline="210" pcid="825">
    function removeFundingManagers(address) external;
    function isFundingManager(address) external view returns (bool);
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="202" endline="203" pcid="819">
    function addWLOperators(address) external;
    function removeWLOperators(address) external;
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="519" endline="520" pcid="7062">
    function removeFundsUnlockerManagers(address) external;
    function isFundsUnlockerManager(address) external view returns (bool);
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="123" endline="124" pcid="6437">
    function withdraw(address) external;
}
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="211" endline="212" pcid="827">
    function addFundingOperators(address) external;
    function removeFundingOperators(address) external;
</source>
<source file="systems/smart_contracts/Factory.sol" startline="255" endline="256" pcid="3488">
    function setFactoryAddress(address) external;
    function getFactoryAddress() external view returns(address);
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="200" endline="201" pcid="817">
    function removeWLManagers(address) external;
    function isWLManager(address) external view returns (bool);
</source>
<source file="systems/smart_contracts/Factory.sol" startline="235" endline="236" pcid="3473">
    function addFundsUnlockerOperators(address) external;
    function removeFundsUnlockerOperators(address) external;
</source>
</class>

<class classid="17" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="96" endline="98" pcid="33">
    function updateChangesByBrother(address, uint256, uint256) public;
    
    function token_name() public view returns (string);
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="90" endline="92" pcid="2839">
    function updateChangesByBrother(address, uint256, uint256) public;
    
    function token_name() public view returns (string);
</source>
</class>

<class classid="18" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="107" endline="108" pcid="41">
    function token_transfer(address _from, address _to, uint _value, bytes _data) public returns (bool success);
    function token_transfer(address _from, address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success);
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="101" endline="102" pcid="2847">
    function token_transfer(address _from, address _to, uint _value, bytes _data) public returns (bool success);
    function token_transfer(address _from, address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success);
</source>
</class>

<class classid="19" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="108" endline="109" pcid="42">
    function token_transfer(address _from, address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success);
    function token_transferFrom(address _spender, address _from, address _to, uint256 _value) public returns (bool success);
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="102" endline="103" pcid="2848">
    function token_transfer(address _from, address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success);
    function token_transferFrom(address _spender, address _from, address _to, uint256 _value) public returns (bool success);
</source>
</class>

<class classid="20" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="109" endline="110" pcid="43">
    function token_transferFrom(address _spender, address _from, address _to, uint256 _value) public returns (bool success);
    function token_approve(address _from, address _spender, uint256 _value) public returns (bool success);
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="103" endline="104" pcid="2849">
    function token_transferFrom(address _spender, address _from, address _to, uint256 _value) public returns (bool success);
    function token_approve(address _from, address _spender, uint256 _value) public returns (bool success);
</source>
</class>

<class classid="21" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="112" endline="113" pcid="45">
    function fallback(address _from, bytes _data) public payable;                      		// eth input
    function token_fallback(address _token, address _from, uint _value, bytes _data) public returns(bool);    // token input from IERC233
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="106" endline="107" pcid="2851">
    function fallback(address _from, bytes _data) public payable;                      		// eth input
    function token_fallback(address _token, address _from, uint _value, bytes _data) public returns(bool);    // token input from IERC233
</source>
</class>

<class classid="22" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="113" endline="114" pcid="46">
    function token_fallback(address _token, address _from, uint _value, bytes _data) public returns(bool);    // token input from IERC233
}
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="107" endline="108" pcid="2852">
    function token_fallback(address _token, address _from, uint _value, bytes _data) public returns(bool);    // token input from IERC233
}
</source>
</class>

<class classid="23" nclones="551" nlines="4" similarity="75">
<source file="systems/smart_contracts/$martFund.sol" startline="118" endline="126" pcid="47">
    function isContract(address _addr) internal view returns (bool is_contract) {
        uint length;
        assembly {
              //retrieve the size of the code on target address, this needs assembly
              length := extcodesize(_addr)
        }
        return (length>0);
    }
}
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1361" endline="1365" pcid="6153">
  function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {
    return reservedTokensList[addr].isDistributed;
  }

  function getReservedTokens(address addr) public constant returns (uint inTokens) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="1098" endline="1102" pcid="4900">
  function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {
    return reservedTokensList[addr].isDistributed;
  }

  function getReservedTokens(address addr) public constant returns (uint inTokens) {
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="112" endline="120" pcid="2853">
    function isContract(address _addr) internal view returns (bool is_contract) {
        uint length;
        assembly {
              //retrieve the size of the code on target address, this needs assembly
              length := extcodesize(_addr)
        }
        return (length>0);
    }
}
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1357" endline="1361" pcid="6152">
  function isAddressReserved(address addr) public constant returns (bool isReserved) {
    return reservedTokensList[addr].isReserved;
  }

  function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="585" endline="589" pcid="2130">
  function isAddressReserved(address addr) public constant returns (bool isReserved) {
    return reservedTokensList[addr].isReserved;
  }

  function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="1094" endline="1098" pcid="4899">
  function isAddressReserved(address addr) public constant returns (bool isReserved) {
    return reservedTokensList[addr].isReserved;
  }

  function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="589" endline="593" pcid="2131">
  function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {
    return reservedTokensList[addr].isDistributed;
  }

  function getReservedTokens(address addr) public constant returns (uint inTokens) {
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="597" endline="601" pcid="2133">
  function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {
    return reservedTokensList[addr].inPercentageUnit;
  }

  function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="1110" endline="1114" pcid="4903">
  function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {
    return reservedTokensList[addr].inPercentageDecimals;
  }

  function setReservedTokensListMultiple(
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1373" endline="1377" pcid="6156">
  function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {
    return reservedTokensList[addr].inPercentageDecimals;
  }

  function setReservedTokensListMultiple(
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1369" endline="1373" pcid="6155">
  function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {
    return reservedTokensList[addr].inPercentageUnit;
  }

  function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1365" endline="1369" pcid="6154">
  function getReservedTokens(address addr) public constant returns (uint inTokens) {
    return reservedTokensList[addr].inTokens;
  }

  function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="1102" endline="1106" pcid="4901">
  function getReservedTokens(address addr) public constant returns (uint inTokens) {
    return reservedTokensList[addr].inTokens;
  }

  function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="593" endline="597" pcid="2132">
  function getReservedTokens(address addr) public constant returns (uint inTokens) {
    return reservedTokensList[addr].inTokens;
  }

  function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="1106" endline="1110" pcid="4902">
  function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {
    return reservedTokensList[addr].inPercentageUnit;
  }

  function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="601" endline="605" pcid="2134">
  function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {
    return reservedTokensList[addr].inPercentageDecimals;
  }

  function setReservedTokensListMultiple(
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="111" endline="116" pcid="1257">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/CGT.sol" startline="141" endline="151" pcid="1695">
    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to `to` account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/AnxToken.sol" startline="139" endline="149" pcid="716">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to to account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="111" endline="116" pcid="1311">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BIBCOINID.sol" startline="140" endline="150" pcid="1209">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to to account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ContractCoffeeToken.sol" startline="137" endline="147" pcid="1985">
    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to `to` account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SAMPLE.sol" startline="157" endline="167" pcid="6258">
	function balanceOf(address tokenOwner) public view returns (uint balance) {
		return balances[tokenOwner];
	}


	// ------------------------------------------------------------------------
	// Transfer the balance from token owner's account to `to` account
	// - Owner's account must have sufficient balance to transfer
	// - 0 value transfers are allowed
	// ------------------------------------------------------------------------
	function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="124" endline="134" pcid="5816">
    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to to account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SolaToken.sol" startline="127" endline="137" pcid="6587">
    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to `to` account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Perlin.sol" startline="143" endline="153" pcid="5650">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to `to` account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/PAYCASH.sol" startline="139" endline="149" pcid="5620">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to to account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="111" endline="116" pcid="1233">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/OSManagerToken.sol" startline="91" endline="95" pcid="5557">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }

    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BEX.sol" startline="28" endline="32" pcid="1166">
	function balanceOf(address tokenOwner)public constant returns (uint balance) {
		return balances[tokenOwner];
	}

	function transfer(address to, uint tokens)public returns (bool success) {
</source>
<source file="systems/smart_contracts/ContractCargoberToken.sol" startline="137" endline="147" pcid="1963">
    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to `to` account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/AICRYPTO.sol" startline="139" endline="149" pcid="432">
    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to `to` account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Melodic.sol" startline="140" endline="150" pcid="4792">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to to account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/LanceToken.sol" startline="140" endline="150" pcid="4524">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to to account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/KingToken.sol" startline="118" endline="124" pcid="4492">
    function balanceOf(address tokenOwner) public view returns (uint balance){
        return balances[tokenOwner];
    }
    // ------------------------------------------------------------------------
    // Public Function to transfer tokens
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success){
</source>
<source file="systems/smart_contracts/JUNDCOIN.sol" startline="136" endline="146" pcid="4366">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to to account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="514" endline="532" pcid="278">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {

        return balances[tokenOwner];

    }



    // ------------------------------------------------------------------------

    // Transfer the balance from token owner's account to `to` account

    // - Owner's account must have sufficient balance to transfer

    // - 0 value transfers are allowed

    // ------------------------------------------------------------------------

    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/JDC.sol" startline="104" endline="110" pcid="4344">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }



    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="308" endline="318" pcid="244">
    function balanceOf(address tokenOwner) public view returns(uint balance) {
        return balances[tokenOwner];
    }

    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to `to` account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------

    function transfer(address to, uint tokens) public returns(bool success) {
</source>
<source file="systems/smart_contracts/GRAM.sol" startline="138" endline="148" pcid="4208">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to to account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="120" endline="130" pcid="7440">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to to account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SapientiaCharlesToken.sol" startline="141" endline="151" pcid="6281">
    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to `to` account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="135" endline="145" pcid="410">
    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to to account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/GNB.sol" startline="179" endline="183" pcid="4133">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }

    function checkRate(uint unlockIndex) public constant returns (uint rate_ ){
</source>
<source file="systems/smart_contracts/GFNX.sol" startline="146" endline="151" pcid="4106">
    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return _balances[tokenOwner];
    }
 
    // Get the allowance of funds beteen a token holder and a spender
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="118" endline="128" pcid="2432">
    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to `to` account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/DGC.sol" startline="141" endline="151" pcid="2525">
    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to `to` account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="117" endline="121" pcid="7556">
    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return balances[tokenOwner];
    }

    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/XTRLPAY.sol" startline="140" endline="150" pcid="8141">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to to account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/FUNNYTOKEN.sol" startline="99" endline="103" pcid="3955">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }

    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/WanCoinToken.sol" startline="127" endline="137" pcid="7887">
    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to `to` account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="111" endline="116" pcid="3422">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/VENT.sol" startline="104" endline="112" pcid="7687">
        function balanceOf(address tokenOwner) public view returns (uint balance) {
            return balances[tokenOwner];
        }
        // ------------------------------------------------------------------------
        // Transfer the balance from token owner's account `to` account
        // - Owner's account must have sufficient balance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="576" endline="580" pcid="3746">
function investorDividendsAtNow(address investorAddr) public view returns(uint dividends) {
dividends = calcDividends(investorAddr);
}

function dailyPercentAtNow() public view returns(uint numerator, uint denominator) {
</source>
<source file="systems/smart_contracts/WanCoinSupplyToken.sol" startline="127" endline="137" pcid="7865">
    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to `to` account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/FixedSupplyToken.sol" startline="141" endline="151" pcid="3610">
    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to `to` account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/VOTENOmodumtokenswapdotcom.sol" startline="140" endline="150" pcid="7843">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to to account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/AzurToken.sol" startline="81" endline="85" pcid="1007">
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

  function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="758" endline="766" pcid="627">
    function freezingBalanceOf(address _owner) public view returns (uint256 balance) {
        return freezingBalance[_owner];
    }

    /**
     * @dev gets freezing count
     * @param _addr Address of freeze tokens owner.
     */
    function freezingCount(address _addr) public view returns (uint count) {
</source>
<source file="systems/smart_contracts/BACD.sol" startline="90" endline="103" pcid="1020">
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return accounts [_owner];
  }

  /**
   * Transfer given number of tokens from message sender to given recipient.
   *
   * @param _to address to transfer tokens to the owner of
   * @param _value number of tokens to transfer to the owner of given address
   * @return true if tokens were transferred successfully, false otherwise
   * accounts [_to] + _value > accounts [_to] for overflow check
   * which is already in safeMath
   */
  function transfer(address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BFGToken.sol" startline="80" endline="84" pcid="1188">
  function balanceOf(address addr) public view returns (uint256 balance) {
    return _balances[addr];
  }

  function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/customIcoToken.sol" startline="73" endline="77" pcid="2213">
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function allowance(address _owner, address _spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/CST_TOKEN.sol" startline="64" endline="68" pcid="2201">
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

  function allowance(address _owner, address _spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DENARIO.sol" startline="59" endline="63" pcid="2450">
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="224" endline="234" pcid="8085">
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return _balances[_owner];
  }
 
 
  /**
   * @dev transfer token for a specified address
   * @param _to The address to transfer to.
   * @param _value The amount to be transferred.
   */
  function transfer(address _to, uint256 _value) returns (bool) {    
</source>
<source file="systems/smart_contracts/Warpcoin.sol" startline="59" endline="63" pcid="7948">
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/CRYPTOMZ.sol" startline="120" endline="123" pcid="2181">
  function balanceOf(address _owner) public constant returns (uint256 balance) {
    return balances[_owner];
  }
}
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="95" endline="99" pcid="7750">
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

}
</source>
<source file="systems/smart_contracts/FMT.sol" startline="58" endline="62" pcid="3653">
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

}
</source>
<source file="systems/smart_contracts/VCTAToken.sol" startline="52" endline="56" pcid="7671">
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/VACCToken.sol" startline="143" endline="153" pcid="7627">
    function balanceOf(address tokenOwner) public constant returns (uint256 balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to to account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint256 tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/UTC.sol" startline="110" endline="114" pcid="7580">
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

}
</source>
<source file="systems/smart_contracts/UNT.sol" startline="52" endline="56" pcid="7568">
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BDAM.sol" startline="163" endline="166" pcid="1121">
  function balanceOf(address _owner) public constant returns (uint256 balance) {
    return balances[_owner];
  }
}
</source>
<source file="systems/smart_contracts/GameGold.sol" startline="245" endline="255" pcid="4001">
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

  /**
   * @dev Transfer tokens from one address to another
   * @param _from address The address which you want to send tokens from
   * @param _to address The address which you want to transfer to
   * @param _value uint256 the amount of tokens to be transferred
   */
  function transferFrom(address _from, address _to, uint256 _value)
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="105" endline="108" pcid="7457">
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }
}
</source>
<source file="systems/smart_contracts/GoldenRings.sol" startline="80" endline="91" pcid="4176">
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }


    /**
    * @dev Transfer tokens from one address to another
    * @param _from address The address which you want to send tokens from
    * @param _to address The address which you want to transfer to
    * @param _value uint256 the amount of tokens to be transferred
    */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/TimeLockedTokenStorage.sol" startline="234" endline="239" pcid="7236">
    function getAllLockSlotIdsToAddress(address _holder) public view returns(uint256[] _lockSlotIds) {
        return lockSlotIdList[_holder];
    }


    function _createLockSlot(uint256[] _lockTokens, uint256[] _lockPeriods) internal view returns(LockSlot memory _lockSlot) {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="243" endline="247" pcid="4663">
    function freezingBalanceOf(address _owner) public view returns (uint256 balance) {
        return freezingBalance[_owner];
    }

    function freezingCount(address _addr) public view returns (uint count) {
</source>
<source file="systems/smart_contracts/AronCoin.sol" startline="95" endline="99" pcid="766">
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

}
</source>
<source file="systems/smart_contracts/TECToken.sol" startline="66" endline="70" pcid="7135">
    function balanceOf(address _owner) constant returns (uint) {
        return balances[_owner];
    }

    function approve(address _spender, uint _value) returns (bool) {
</source>
<source file="systems/smart_contracts/BTToken.sol" startline="70" endline="74" pcid="1560">
    function balanceOf(address _owner) constant returns (uint) {
        return balances[_owner];
    }

    function approve(address _spender, uint _value) returns (bool) {
</source>
<source file="systems/smart_contracts/SellableToken.sol" startline="63" endline="66" pcid="6465">
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }
}
</source>
<source file="systems/smart_contracts/SHPC.sol" startline="52" endline="56" pcid="6510">
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SistContract.sol" startline="93" endline="97" pcid="6523">
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

}
</source>
<source file="systems/smart_contracts/P21.sol" startline="66" endline="70" pcid="5587">
    function balanceOf(address _owner) constant returns (uint) {
        return balances[_owner];
    }

    function approve(address _spender, uint _value) returns (bool) {
</source>
<source file="systems/smart_contracts/OBK.sol" startline="52" endline="56" pcid="5470">
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="139" endline="143" pcid="6780">
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

}
</source>
<source file="systems/smart_contracts/NaorisToken.sol" startline="105" endline="108" pcid="5286">
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }
}
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="106" endline="110" pcid="1719">
    function balanceOf(address _owner) public constant returns (uint256 balance) {
        return balances[_owner];
    }

}
</source>
<source file="systems/smart_contracts/NSTTeamLock.sol" startline="78" endline="82" pcid="5459">
    function setToken(address _token) public onlyOwner {
        token = IERC20(_token);
    }
    
    function changeOwner(address _addr) public onlyOwner {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="878" endline="885" pcid="6855">
    function setIntegrationProxy(address _integrationProxy)
        external
        onlyOwner
    {
        integrationProxy = Proxy(_integrationProxy);
    }

    function setMessageSender(address sender)
</source>
<source file="systems/smart_contracts/ProxyERC20.sol" startline="285" endline="292" pcid="5882">
    function setIntegrationProxy(address _integrationProxy)
        external
        onlyOwner
    {
        integrationProxy = Proxy(_integrationProxy);
    }

    function setMessageSender(address sender)
</source>
<source file="systems/smart_contracts/RegulatedToken.sol" startline="21" endline="25" pcid="6058">
    function replaceRegulatorService(address _newRegulatorService) public onlyReplaceRegulatorServicePermission {
        regulatorService = IRegulatorService(_newRegulatorService);
    }

    function changeSymbol(string memory _newSymbol) public onlyAttributesPermission {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="820" endline="824" pcid="990">
    function setReferralTracker(address contractAddress) public onlyOwner {
        ref = ReferralTracker(contractAddress);
    }

    function setAdministrator(address _admin) public onlyOwner {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="820" endline="824" pcid="2503">
    function setReferralTracker(address contractAddress) public onlyOwner {
        ref = ReferralTracker(contractAddress);
    }

    function setAdministrator(address _admin) public onlyOwner {
</source>
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="172" endline="176" pcid="1637">
    function balanceOf(address _holder) public view returns (uint256 balance) {
        return balances[_holder] + lockupInfo[_holder].lockupBalance;
    }

    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/DaiSwap.sol" startline="25" endline="26" pcid="2284">
  function balanceOf(address _owner) public view returns (uint256 balance) {}
  function transfer(address _to, uint256 _value) public returns (bool success) {}
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="754" endline="758" pcid="626">
    function actualBalanceOf(address _owner) public view returns (uint256 balance) {
        return super.balanceOf(_owner);
    }

    function freezingBalanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="745" endline="754" pcid="625">
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return super.balanceOf(_owner) + freezingBalance[_owner];
    }

    /**
     * @dev Gets the balance of the specified address without freezing tokens.
     * @param _owner The address to query the the balance of.
     * @return An uint256 representing the amount owned by the passed address.
     */
    function actualBalanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="567" endline="574" pcid="7821">
    function allocations(address account) public view returns (uint256 allocationsCounter) {
        allocationsCounter = _allocations[account].length;
    }

    /**
     * @dev Returns the allocation on `account` and an `index`.
     */
    function allocation(address account, uint256 index) public view returns (uint256 amount,
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="1225" endline="1229" pcid="6670">
	function getLockedTokens(address walletAddress) public view returns(uint256 balance) {
		return getLockedTokens_(walletAddress);
	}

	function getUndistributedBalanceOf_(address walletAddress, uint256 groupNumber) internal view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/ESCHToken.sol" startline="96" endline="100" pcid="3049">
    function cxesch (address _c1) public view returns(uint256 _j1){
        return( balanceOf[_c1]);
    }

    function SetAw0(address _adA0) public {
</source>
<source file="systems/smart_contracts/Ownable.sol" startline="166" endline="169" pcid="5578">
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return getBalance( _owner );
    }
}
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="173" endline="177" pcid="4391">
    function balanceOf(address _holder) public view returns (uint256 balance) {
        return balances[_holder] + lockupInfo[_holder].lockupBalance;
    }

    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/MiniMeTokenFactory.sol" startline="248" endline="258" pcid="4810">
    function balanceOf(address _owner) public constant returns (uint256 balance) {
        return balanceOfAt(_owner, block.number);
    }

    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on
    ///  its behalf. This is a modified version of the ERC20 approve function
    ///  to be a little bit safer
    /// @param _spender The address of the account able to transfer the tokens
    /// @param _amount The amount of tokens to be approved for transfer
    /// @return True if the approval was successful
    function approve(address _spender, uint256 _amount) public returns (bool success) {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="239" endline="243" pcid="4662">
    function actualBalanceOf(address _owner) public view returns (uint256 balance) {
        return super.balanceOf(_owner);
    }

    function freezingBalanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="235" endline="239" pcid="4661">
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return super.balanceOf(_owner) + freezingBalance[_owner];
    }

    function actualBalanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/Controller.sol" startline="104" endline="110" pcid="2013">
    function sweeperOf(address _token) public returns (address) {
        address sweeper = sweepers[_token];
        if (sweeper == address(0)) sweeper = defaultSweeper;
        return sweeper;
    }

    function logSweep(address from, address token, uint amount) public {
</source>
<source file="systems/smart_contracts/Controller.sol" startline="9" endline="10" pcid="2002">
    function balanceOf(address a) external returns (uint) {return 0;}
    function transfer(address a, uint val) external returns (bool) {return false;}
</source>
<source file="systems/smart_contracts/AdminUpgradeabilityProxy.sol" startline="233" endline="244" pcid="359">
    function changeAdmin(address newAdmin) external ifAdmin {
        require(newAdmin != address(0), "Cannot change the admin of a proxy to the zero address");
        emit AdminChanged(_admin(), newAdmin);
        _setAdmin(newAdmin);
    }

    /**
     * @dev Upgrade the backing implementation of the proxy.
     * Only the admin can call this function.
     * @param newImplementation Address of the new implementation.
     */
    function upgradeTo(address newImplementation) external ifAdmin {
</source>
<source file="systems/smart_contracts/NBToken.sol" startline="86" endline="94" pcid="5302">
    function transferOwnership(address _newOwner) public onlyOwner {
        _transferOwnership(_newOwner);
    }

    /**
     * @dev Transfers control of the contract to a newOwner.
     * @param _newOwner The address to transfer ownership to.
     */
    function _transferOwnership(address _newOwner) internal {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="390" endline="398" pcid="7665">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="113" endline="117" pcid="7705">
  function transferOwnership(address _newOwner) public onlyOwner {
    _transferOwnership(_newOwner);
  }
  
  function _transferOwnership(address _newOwner) internal {
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="74" endline="77" pcid="3418">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="497" endline="501" pcid="2611">
    function addMinter(address account) public onlyMinter {
        _addMinter(account);
    }

    function renounceMinter() public {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="994" endline="1004" pcid="5406">
    function addMinter(address account) public onlyOwner {
        _minters.add(account);
        emit MinterAdded(account);
    }

    /**
     * @dev Remove an `account` access from the Minter role.
     *
     * Can only be called by the current owner.
     */
    function removeMinter(address account) public onlyOwner {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="67" endline="74" pcid="4734">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="535" endline="539" pcid="917">
    function removeFundsUnlockerOperators(address account) external onlyFundsUnlockerManagers {
        _removeFundsUnlockerOperators(account);
    }

    function renounceFundsUnlockerManager() external onlyFundsUnlockerManagers {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="545" endline="549" pcid="4446">
    function addPauser(address account) public onlyPauser {
        _addPauser(account);
    }

    function renouncePauser() public {
</source>
<source file="systems/smart_contracts/JDC.sol" startline="64" endline="67" pcid="4341">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/ContractCoffeeToken.sol" startline="85" endline="88" pcid="1982">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/MBA.sol" startline="374" endline="387" pcid="4725">
    function setDaicoManager(address _daicoManager) onlyOwner public {
        require(address(0) != _daicoManager);
        require(address(this) != _daicoManager);
        
        daicoManager = _daicoManager;
        emit DaicoManagerSet(daicoManager);
    } 
    
    /**
	 * @dev The DAICO fund contract calls this function to burn the user's token
	 * to avoid over refund.
	 * @param _from The address which just took its refund.
	 */
	function burnFromDaico(address _from) onlyDaicoManager external {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="94" endline="98" pcid="2228">
  function setController(address _controller) public onlyOwner {       
    _setController(_controller);
  }

  function _setController(address _controller) internal { 
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="531" endline="535" pcid="916">
    function addFundsUnlockerOperators(address account) external onlyFundsUnlockerManagers {
        _addFundsUnlockerOperators(account);
    }

    function removeFundsUnlockerOperators(address account) external onlyFundsUnlockerManagers {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="549" endline="559" pcid="7819">
    function addProxy(address account) public onlyOwner {
        _proxies.add(account);
        emit ProxyAdded(account);
    }

    /**
     * @dev Remove an `account` access from the Proxy role.
     *
     * Can only be called by the current owner.
     */
    function removeProxy(address account) public onlyOwner {
</source>
<source file="systems/smart_contracts/OeroToken.sol" startline="16" endline="19" pcid="5473">
        function transferOwnership(address newOwner) public onlyOwner {
            owner = newOwner;
        }
    }
</source>
<source file="systems/smart_contracts/MyAdvancedToken.sol" startline="19" endline="22" pcid="5260">
    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/CRYPTOMZ.sol" startline="72" endline="77" pcid="2177">
  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));
    emit OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
}
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="1157" endline="1166" pcid="3909">
    function setFactoryAddress(address _fAddress) external onlyOwner {
        require(block.number < 8850000, "Time expired!");
        require(_fAddress != address(0), "Address not allowed");
        fAddress = _fAddress;
    }

    /**
     * @dev Get the factory address for deployment.
     */
    function getFactoryAddress() external view returns(address) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="942" endline="951" pcid="3887">
    function enableMember(address _memberAddress) external onlyFundingOperators {
        require(membersArray[_memberAddress].isInserted, "Member not present");
        membersArray[_memberAddress].disabled = 0;
        emit MemberEnabled(membersArray[_memberAddress].listPointer);
    }

    /**
     * @dev operator members can disable an already inserted member
     */
    function disableMemberByStaffRetire(address _memberAddress) external onlyFundingOperators {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="523" endline="527" pcid="914">
    function removeFundsUnlockerManagers(address account) external onlyOwner {
        _removeFundsUnlockerManagers(account);
    }

    function isFundsUnlockerManager(address account) public view returns (bool) {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="946" endline="952" pcid="3115">
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    emit OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}
</source>
<source file="systems/smart_contracts/SapientiaCharlesToken.sol" startline="89" endline="92" pcid="6278">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/Airdropper.sol" startline="40" endline="45" pcid="474">
     function withdrawalToken(address _tokenAddress) onlyOwner public { 
        Token token = Token(_tokenAddress);
        token.transfer(owner, token.balanceOf(this));
    }

}
</source>
<source file="systems/smart_contracts/FixedSupplyToken.sol" startline="89" endline="92" pcid="3607">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/VENT.sol" startline="21" endline="24" pcid="7674">
        function transferOwnership(address _newOwner) public onlyOwner {
            newOwner = _newOwner;
        }
        function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="477" endline="485" pcid="7038">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="519" endline="523" pcid="913">
    function addFundsUnlockerManagers(address account) external onlyOwner {
        _addFundsUnlockerManagers(account);
    }

    function removeFundsUnlockerManagers(address account) external onlyOwner {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="729" endline="742" pcid="2497">
    function withdraw(address to) public whenNotPaused {
        require(unclaimedReferrals[msg.sender] > 0, "no referrals to claim");
        uint256 trackerBalance = token.balanceOf(address(this));
        uint256 amount = REFERRAL_BONUS * unclaimedReferrals[msg.sender];

        require(trackerBalance >= amount, "Not enough funds");
        delete unclaimedReferrals[msg.sender];

        token.transfer(to, amount);

        emit ReferralBonusWithdrawn(address(this), msg.sender, amount, trackerBalance);
    }

    function getTrackerBalance() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/MBA.sol" startline="387" endline="391" pcid="4726">
	function burnFromDaico(address _from) onlyDaicoManager external {
	    require(0 != balances[_from]);
	    _burn(_from, balances[_from]);
	}
}
</source>
<source file="systems/smart_contracts/Factory.sol" startline="69" endline="77" pcid="3433">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/KYCRegistry.sol" startline="114" endline="119" pcid="4509">
    function addAddressToKYC(address addr) public onlyAdmin {
        require(!KYCConfirmed[addr], "Address already KYCed");
        KYCConfirmed[addr] = true;
        emit AddedToKYC(addr);
    }
}
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="707" endline="711" pcid="2493">
    function setAdministrator(address _admin) public onlyOwner {
        admin = _admin;
    }

    function addFunds(uint256 amount) public onlyAdmin whenNotPaused {
</source>
<source file="systems/smart_contracts/MBA.sol" startline="159" endline="167" pcid="4712">
  function transferOwnership(address _newOwner) public onlyOwner {
    _transferOwnership(_newOwner);
  }

  /**
   * @dev Transfers control of the contract to a newOwner.
   * @param _newOwner The address to transfer ownership to.
   */
  function _transferOwnership(address _newOwner) internal {
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="492" endline="497" pcid="3735">
function disqualifyAddress2(address addr) public onlyOwner {
m_investors.disqalify2(addr);
}


function doDisown() public onlyOwner {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="92" endline="100" pcid="4736">
    function addMember(address member)
        public
        onlyOwner
    {
        require(!whitelist[member], "ALREADY_EXISTS");
        whitelist[member] = true;
    }

    function removeMember(address member)
</source>
<source file="systems/smart_contracts/SBC.sol" startline="594" endline="598" pcid="6361">
    function addBlacklisted(address account) public onlyBlacklistAdmin {
        _addBlacklisted(account);
    }

    function removeBlacklisted(address account) public onlyBlacklistAdmin {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="824" endline="828" pcid="991">
    function setAdministrator(address _admin) public onlyOwner {
        admin = _admin;
    }

    function depositFor(address from) public {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="113" endline="117" pcid="2232">
  function transferOwnership(address _newOwner) public onlyOwner {
    _transferOwnership(_newOwner);
  }
  
  function _transferOwnership(address _newOwner) internal {
</source>
<source file="systems/smart_contracts/WanCoinSupplyToken.sol" startline="75" endline="78" pcid="7862">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="749" endline="756" pcid="512">
        function changeBeneficiary(address _newBeneficiary) public onlyManyBeneficiaries {
            _setPendingBeneficiary(_newBeneficiary);
        }

        /**
            * @dev Claim Beneficiary
        */
        function claimBeneficiary() public onlyPendingBeneficiary {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="772" endline="778" pcid="2501">
    function removeAddressFromKYC(address addr) public onlyAdmin {
        require(KYCConfirmed[addr], "Address not KYCed");
        KYCConfirmed[addr] = false;
        emit RemovedFromKYC(addr);
    }

    function addAddressToKYC(address addr) public onlyAdmin {
</source>
<source file="systems/smart_contracts/CGT.sol" startline="89" endline="92" pcid="1692">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="757" endline="769" pcid="4877">
  function setJoinedCrowdsales(address addr) private onlyOwner {
    assert(addr != address(0));
    assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);
    assert(!isTierJoined(addr));
    joinedCrowdsales.push(addr);
    joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({
      isJoined: true,
      position: joinedCrowdsalesLen
    });
    joinedCrowdsalesLen++;
  }

  function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {
</source>
<source file="systems/smart_contracts/Oracle.sol" startline="57" endline="65" pcid="5510">
  function transferOwnership(address _newOwner) public onlyOwner {
    _transferOwnership(_newOwner);
  }

  /**
   * @dev Transfers control of the contract to a newOwner.
   * @param _newOwner The address to transfer ownership to.
   */
  function _transferOwnership(address _newOwner) internal {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="357" endline="364" pcid="536">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/WanCoinToken.sol" startline="75" endline="78" pcid="7884">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="171" endline="175" pcid="3557">
    function addPauser(address account) public onlyPauser {
        _addPauser(account);
    }

    function renouncePauser() public {
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="74" endline="77" pcid="1307">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="598" endline="602" pcid="6362">
    function removeBlacklisted(address account) public onlyBlacklistAdmin {
        _removeBlacklisted(account);
    }

    function _addBlacklisted(address account) internal {
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="186" endline="192" pcid="4086">
    function setMigrateContract(address _newContractAddr) isOwner external {
        if (_newContractAddr == newContractAddr) throw;
        newContractAddr = _newContractAddr;
    }
 
    /// 设置新的所有者地址
    function changeOwner(address _newFundDeposit) isOwner() external {
</source>
<source file="systems/smart_contracts/ICOImplementation.sol" startline="295" endline="308" pcid="4282">
    function transferOwnership(address _newOwner) public onlyOwner {
        require(_newOwner != address(0), "cannot transfer ownership to address zero");
        emit OwnershipTransferred(owner, _newOwner);
        owner = _newOwner;
    }


    // PAUSABILITY FUNCTIONALITY


    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     */
    modifier whenNotPaused() {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="1004" endline="1008" pcid="5407">
    function removeMinter(address account) public onlyOwner {
        _minters.remove(account);
        emit MinterRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="559" endline="564" pcid="7488">
    function revokeVestedTokensFor(address _owner) public onlyOwner {
        TokenVesting(vestingOf[_owner]).revoke(this);
    }

    /// @dev Create a ReserveTokenVault 
    function makeReserveToVault() external onlyOwner {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="100" endline="107" pcid="4737">
    function removeMember(address member)
        public
        onlyOwner
    {
        require(whitelist[member], "NOT_EXISTS");
        whitelist[member] = false;
    }
}
</source>
<source file="systems/smart_contracts/BIBCOINID.sol" startline="90" endline="93" pcid="1206">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="489" endline="493" pcid="1772">
    function addMinter(address account) public onlyMinter {
        _addMinter(account);
    }

    function renounceMinter() public {
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="536" endline="541" pcid="3739">
function setAdminsAddress(address addr) public onlyOwner {
addr.requireNotZero();
adminsAddress = addr;
}

function privateEntranceProvideAccessFor(address[] addrs) public onlyOwner {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="408" endline="413" pcid="889">
    function addWLManagers(address account) external onlyOwner {
        _addWLManagers(account);
        _addWLOperators(account);
    }

    function removeWLManagers(address account) external onlyOwner {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="385" endline="389" pcid="4256">
  function addMinter(address account) public onlyMinter {
    _addMinter(account);
  }

  function renounceMinter() public {
</source>
<source file="systems/smart_contracts/Melodic.sol" startline="90" endline="93" pcid="4789">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="824" endline="828" pcid="2504">
    function setAdministrator(address _admin) public onlyOwner {
        admin = _admin;
    }

    function depositFor(address from) public {
</source>
<source file="systems/smart_contracts/EthNote.sol" startline="56" endline="63" pcid="3353">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/DGC.sol" startline="89" endline="92" pcid="2522">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/AronCoin.sol" startline="216" endline="222" pcid="773">
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="410" endline="413" pcid="2354">
    function transferOwnership(address _newOwner) public only_owner {
        owner = _newOwner;
    }
}
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="124" endline="128" pcid="8167">
    function addToReceiveAllowed(address _to) external onlyManager {
        whiteList[_to] = whiteList[_to] | WHITELISTED_CAN_RX_CODE; // just add the code 2
    }

    function removeFromSendAllowed(address _to) public onlyManager {
</source>
<source file="systems/smart_contracts/BDAM.sol" startline="82" endline="87" pcid="1113">
  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
}
</source>
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="60" endline="65" pcid="1624">
    function transferOwnership(address _newOwner) public onlyOwner {
        require(_newOwner != address(0));
        newOwner = _newOwner;
    }

    function acceptOwnership() public onlyNewOwner returns(bool) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1542" endline="1552" pcid="6165">
  function claimTokens(address _token) public onlyOwner {
    require(_token != address(0));

    ERC20 token = ERC20(_token);
    uint balance = token.balanceOf(this);
    token.transfer(owner, balance);

    ClaimedTokens(_token, owner, balance);
  }

}
</source>
<source file="systems/smart_contracts/SolaToken.sol" startline="75" endline="78" pcid="6584">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="484" endline="491" pcid="7922">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="269" endline="278" pcid="7799">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Accept ownership of the contract.
     *
     * Can only be called by the new owner.
     */
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="361" endline="366" pcid="2593">
    function transferPrimary(address recipient) public onlyPrimary {
        require(recipient != address(0), "Secondary: new primary is the zero address");
        _primary = recipient;
        emit PrimaryTransferred(_primary);
    }
}
</source>
<source file="systems/smart_contracts/GasStorage.sol" startline="42" endline="48" pcid="4009">
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    emit OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="165" endline="173" pcid="5846">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/PAYCASH.sol" startline="89" endline="92" pcid="5616">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="176" endline="184" pcid="3764">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="283" endline="287" pcid="2994">
  function addAdmin(address somebody) public onlyOwner {
    _admins[somebody] = true;
  }

  function removeAdmin(address somebody) public onlyOwner {
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="528" endline="532" pcid="330">
    function addPauser(address account) public onlyPauser {
        _addPauser(account);
    }

    function renouncePauser() public {
</source>
<source file="systems/smart_contracts/Ownable.sol" startline="54" endline="60" pcid="5570">
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="752" endline="764" pcid="6117">
  function setJoinedCrowdsales(address addr) private onlyOwner {
    assert(addr != address(0));
    assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);
    assert(!isTierJoined(addr));
    joinedCrowdsales.push(addr);
    joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({
      isJoined: true,
      position: joinedCrowdsalesLen
    });
    joinedCrowdsalesLen++;
  }

  function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {
</source>
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="104" endline="108" pcid="232">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }

    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/GRAM.sol" startline="87" endline="90" pcid="4205">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/GasStorage.sol" startline="106" endline="110" pcid="4019">
    function setGasToken(address gasToken) public onlyOwner{
        _gasToken = gasToken;
    } 
 
    function setBaseBurn(uint256 baseBurn) public onlyOwner{
</source>
<source file="systems/smart_contracts/ThpToken.sol" startline="23" endline="26" pcid="7156">
    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/MAdvcedWoken.sol" startline="70" endline="73" pcid="4597">
    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="74" endline="77" pcid="1253">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="772" endline="778" pcid="988">
    function removeAddressFromKYC(address addr) public onlyAdmin {
        require(KYCConfirmed[addr], "Address not KYCed");
        KYCConfirmed[addr] = false;
        emit RemovedFromKYC(addr);
    }

    function addAddressToKYC(address addr) public onlyAdmin {
</source>
<source file="systems/smart_contracts/FMT.sol" startline="179" endline="185" pcid="3660">
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}
</source>
<source file="systems/smart_contracts/Proxy.sol" startline="25" endline="30" pcid="5872">
  function setTarget(address _target) public onlyOwner {
    target = _target;
    emit ProxyTargetSet(_target);
  }

  function setOwner(address _owner) public onlyOwner {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="596" endline="605" pcid="6101">
  function invest(address addr) public payable {
    investInternal(addr, 0);
  }

  /**
   * The basic entry point to participate the crowdsale process.
   *
   * Pay for funding, get invested tokens back in the sender address.
   */
  function buy() public payable {
</source>
<source file="systems/smart_contracts/TokenSwap.sol" startline="128" endline="136" pcid="7393">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="1143" endline="1150" pcid="3130">
  function setLANDRegistry(address _registry) external onlyOwner {
    require(_registry.isContract(), "The LAND registry address should be a contract");
    require(_registry != 0, "The LAND registry address should be valid");
    registry = LANDRegistry(_registry);
    emit SetLANDRegistry(registry);
  }

  function ping() external {
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="177" endline="185" pcid="1888">
  function transferOwnership(address newOwner) public onlyOwner {
    _transferOwnership(newOwner);
  }

  /**
   * @dev Transfers control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="185" endline="191" pcid="7971">
    function setMigrateContract(address _newContractAddr) isOwner external {
        if (_newContractAddr == newContractAddr) throw;
        newContractAddr = _newContractAddr;
    }
 
    /// @dev set a new owner.
    function changeOwner(address _newFundDeposit) isOwner() external {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="924" endline="934" pcid="5400">
    function addGlobal(address account) public onlyOwner {
        _globals.add(account);
        emit GlobalAdded(account);
    }

    /**
     * @dev Remove an `account` access from the Global role.
     *
     * Can only be called by the current owner.
     */
    function removeGlobal(address account) public onlyOwner {
</source>
<source file="systems/smart_contracts/SellableToken.sol" startline="127" endline="133" pcid="6471">
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    emit OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}
</source>
<source file="systems/smart_contracts/Factory.sol" startline="324" endline="337" pcid="3496">
    function changeATFactoryAddress(address _newATD) external onlyOwner {
        require(block.number < 8850000, "Time expired!");
        require(_newATD != address(0), "Address not suitable!");
        require(_newATD != ATDAddress, "AT factory address not changed!");
        ATDAddress = _newATD;
        deployerAT = IATDeployer(ATDAddress);
        emit ATFactoryAddressChanged();
    }

    /**
     * @dev change Token deployer address
     * @param _newTD new T deployer address
     */
    function changeTDeployerAddress(address _newTD) external onlyOwner {
</source>
<source file="systems/smart_contracts/Proxy.sol" startline="30" endline="35" pcid="5873">
  function setOwner(address _owner) public onlyOwner {
    owner = _owner;
    emit ProxyOwnerChanged(_owner);
  }

  function () payable public {
</source>
<source file="systems/smart_contracts/Governance.sol" startline="270" endline="292" pcid="4190">
    function addVoter(address _address) public onlyMe {
        require(_address != address(0), "Need non-zero address");
        require(!isVoter[_address], "Already in voters list");
        voters.push(_address);
        isVoter[_address] = true;
        votersCount = votersCount.add(1);
        emit VoterAdded(_address);
    }

    /**
    * @dev Removes `_address` from the voters list.
    * This method can be executed only via proposal of this Governance contract.
    *
    * Emits a `delVoter` event.
    *
    * Requirements:
    *
    * - `_address` must be in voters list.
    * - Num of voters must be more than one.
    *
    * @param _address Address of voter to delete
    */
    function delVoter(address _address) public onlyMe {
</source>
<source file="systems/smart_contracts/GNB.sol" startline="79" endline="82" pcid="4129">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/ProxyERC20.sol" startline="67" endline="78" pcid="5875">
    function nominateNewOwner(address _owner)
        external
        onlyOwner
    {
        nominatedOwner = _owner;
        emit OwnerNominated(_owner);
    }

    /**
     * @notice Accept the nomination to be owner.
     */
    function acceptOwnership()
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="488" endline="492" pcid="3734">
function disqualifyAddress(address addr) public onlyOwner {
m_investors.disqalify(addr);
}

function disqualifyAddress2(address addr) public onlyOwner {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="152" endline="158" pcid="6083">
  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}
</source>
<source file="systems/smart_contracts/GasStorage.sol" startline="102" endline="106" pcid="4018">
    function setDex(address dex) public onlyOwner{
        _dex = dex;
    }

    function setGasToken(address gasToken) public onlyOwner{
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="68" endline="76" pcid="8076">
  function transferOwnership(address newOwner) public onlyOwner {
      _transferOwnership(newOwner);
  }

  /**
   * @dev Transfers control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="84" endline="87" pcid="406">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="94" endline="98" pcid="7701">
  function setController(address _controller) public onlyOwner {       
    _setController(_controller);
  }

  function _setController(address _controller) internal { 
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="140" endline="148" pcid="8170">
    function removeFromBothSendAndReceiveAllowed (address _to) external onlyManager {
        removeFromSendAllowed(_to);
        removeFromReceiveAllowed(_to);
    }

    /*  this overides the individual whitelisting and manager positions so a
        frozen account can not be unfrozen by a lower level manager
    */
    function freeze(address _to) external onlyOwner {
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="244" endline="248" pcid="1900">
  function addConverter(address account) public onlyConverter {
    _addConverter(account);
  }

  function renounceConverter() public {
</source>
<source file="systems/smart_contracts/RegulatedToken.sol" startline="42" endline="51" pcid="6063">
    function removeWhitelisted(address _account) public onlyRemoveWhitelistPermission {
        (bool _isWhitelistedAccount, string memory _iso) = isWhitelisted(_account);

        require(_isWhitelistedAccount, "Account is not whitelisted");
        require(regulatorService.canRemoveFromWhitelist(_account, _iso), "Regulator service is not allowed remove this account from whitelist");

        super.removeWhitelisted(_account);
    }

    function transfer(address _to, uint _amount) public onlyUnlocked returns(bool) {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="729" endline="742" pcid="6056">
    function withdraw(address to) public whenNotPaused {
        require(unclaimedReferrals[msg.sender] > 0, "no referrals to claim");
        uint256 trackerBalance = token.balanceOf(address(this));
        uint256 amount = REFERRAL_BONUS * unclaimedReferrals[msg.sender];

        require(trackerBalance >= amount, "Not enough funds");
        delete unclaimedReferrals[msg.sender];

        token.transfer(to, amount);

        emit ReferralBonusWithdrawn(address(this), msg.sender, amount, trackerBalance);
    }

    function getTrackerBalance() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="760" endline="766" pcid="7112">
    function setFactoryAddress(address _fAddress) external onlyOwner {
        require(block.number < 8850000, "Time expired!");
        require(_fAddress != address(0), "Address not allowed");
        fAddress = _fAddress;
    }

    function getFactoryAddress() external view returns(address) {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="716" endline="723" pcid="6054">
    function removeFunds(address to) public onlyAdmin {
        uint256 amount = token.balanceOf(address(this));
        require(amount > 0, "ReferralTracker has no funds to withdraw");
        token.transfer(to, amount);
        emit FundsRemoved(address(this), msg.sender, amount);
    }

    function registerReferral(address referrer, address user) public onlyRegistry whenNotPaused {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="582" endline="592" pcid="6847">
    function setAssociatedContract(address _associatedContract)
        external
        onlyOwner
    {
        associatedContract = _associatedContract;
        emit AssociatedContractUpdated(_associatedContract);
    }

    /* ========== MODIFIERS ========== */

    modifier onlyAssociatedContract
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="707" endline="711" pcid="6052">
    function setAdministrator(address _admin) public onlyOwner {
        admin = _admin;
    }

    function addFunds(uint256 amount) public onlyAdmin whenNotPaused {
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="152" endline="160" pcid="48">
    function transferOwnership(address _newOwner) public ownerOnly {
        require(_newOwner != owner);
        newOwner = _newOwner;
    }

    /**
        @dev used by a new owner to accept an ownership transfer
    */
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="960" endline="969" pcid="3889">
    function disableMemberByStaffForExit(address _memberAddress) external onlyFundingOperators {
        require(membersArray[_memberAddress].isInserted, "Member not present");
        membersArray[_memberAddress].disabled = 1;
        emit MemberDisabled(membersArray[_memberAddress].listPointer);
    }

    /**
     * @dev member can disable itself if already inserted and enabled
     */
    function disableMemberByMember(address _memberAddress) external onlyMemberEnabled {
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="65" endline="73" pcid="7341">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="134" endline="138" pcid="7273">
    function addIssuer(address account) public onlyIssuer {
        _addIssuer(account);
    }

    function renounceIssuer() public {
</source>
<source file="systems/smart_contracts/EJackpot.sol" startline="44" endline="49" pcid="2904">
    function transferOwnership(address newOwner) onlyOwner public {
        require(newOwner != address(0));
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/byzbit.sol" startline="26" endline="30" pcid="1593">
	function transferOwnership (address newOwner) public onlyOwner {
		owner = newOwner;
	}
	
}
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="770" endline="780" pcid="2143">
  function claimTokens(address _token) public onlyOwner {
    require(_token != address(0));

    ERC20 token = ERC20(_token);
    uint balance = token.balanceOf(this);
    token.transfer(owner, balance);

    ClaimedTokens(_token, owner, balance);
  }

}
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="565" endline="569" pcid="7206">
    function addMinter(address account) public onlyOwner {
        _addMinter(account);
    }

    function removeMinter(address account) public onlyOwner {
</source>
<source file="systems/smart_contracts/Gacha.sol" startline="39" endline="45" pcid="3963">
    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0));
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }

}
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="312" endline="321" pcid="7367">
    function addToWhitelist(address _address) external onlyOwner {
        allowedAddresses[_address] = true;
        emit WhitelistUpdated(now, "Added", _address);
    }

    /**
     * @dev add various whitelist addresses
     * @param _addresses Array of ethereum addresses
     */
    function addManyToWhitelist(address[] _addresses) external onlyOwner {
</source>
<source file="systems/smart_contracts/CDS.sol" startline="395" endline="399" pcid="1676">
  function frozenCheck(address target) internal view {
    require(!frozenAccount[target]);
  }

  function freezeAccount(address target, bool frozen) public onlyOwner {
</source>
<source file="systems/smart_contracts/DABANKING_SWAP.sol" startline="42" endline="47" pcid="2272">
  function transferOwnership(address _newOwner) onlyAdmin internal {
    require(_newOwner != address(0x0), "Invalid admin address");
    admin = _newOwner;
    emit OwnershipTransferred(msg.sender, _newOwner);
  }
}
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="216" endline="222" pcid="7757">
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="73" endline="76" pcid="5812">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="2136" endline="2147" pcid="6895">
    function clearIssuanceData(address account)
        external
        onlyAssociatedContract
    {
        delete issuanceData[account];
    }

    /**
     * @notice Increment the total issuer count
     * @dev Only the associated contract may call this.
     */
    function incrementTotalIssuerCount()
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="885" endline="892" pcid="6856">
    function setMessageSender(address sender)
        external
        onlyProxy
    {
        messageSender = sender;
    }

    modifier onlyProxy {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="768" endline="772" pcid="987">
    function setAdministrator(address _admin) public onlyOwner {
        admin = _admin;
    }

    function removeAddressFromKYC(address addr) public onlyAdmin {
</source>
<source file="systems/smart_contracts/GNB.sol" startline="332" endline="337" pcid="4144">
	function deleteFromBlacklist(address _addr) public onlyOwner{
		blacklist[_addr] = -1;
		emit DeleteFromBlacklist(_addr);
	}
	
}
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="69" endline="76" pcid="2456">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/Controller.sol" startline="66" endline="70" pcid="2006">
    function changeAuthorizedCaller(address _newCaller) public onlyOwner {
        authorizedCaller = _newCaller;
    }

    function changeDestination(address _dest) public onlyOwner {
</source>
<source file="systems/smart_contracts/BRZE.sol" startline="60" endline="63" pcid="1524">
  function transferOwnership(address newOwner) onlyOwner public {
    owner = newOwner;
  }
}
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1585" endline="1592" pcid="1838">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="778" endline="783" pcid="2502">
    function addAddressToKYC(address addr) public onlyAdmin {
        require(!KYCConfirmed[addr], "Address already KYCed");
        KYCConfirmed[addr] = true;
        emit AddedToKYC(addr);
    }
}
</source>
<source file="systems/smart_contracts/ComplianceRegistry.sol" startline="61" endline="69" pcid="1946">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/PositionTokenV2.sol" startline="384" endline="392" pcid="5766">
    function setTarget(
        address _newTarget)
        public
        onlyOwner
    {
        _setTarget(_newTarget);
    }

    function _setTarget(
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="351" endline="354" pcid="6798">
    function setTechAccount(address account) public onlyOwner {
        _setPollAccount(account, techPoll);
    }
    function setAllAccount(address businessAcc, address communityAcc, address techAcc) public onlyOwner {
</source>
<source file="systems/smart_contracts/VACCToken.sol" startline="93" endline="96" pcid="7624">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="417" endline="425" pcid="752">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
    * @dev Transfers control of the contract to a newOwner.
    * @param newOwner The address to transfer ownership to.
    */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/KYCRegistry.sol" startline="104" endline="108" pcid="4507">
    function setAdministrator(address _admin) public onlyOwner {
        admin = _admin;
    }

    function removeAddressFromKYC(address addr) public onlyAdmin {
</source>
<source file="systems/smart_contracts/KYCRegistry.sol" startline="69" endline="76" pcid="4504">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="93" endline="96" pcid="8164">
    function removeManager (address managerAddress) external onlyOwner {
        managers[managerAddress] = false;
    }
}
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="567" endline="571" pcid="973">
    function addPauser(address account) public onlyPauser {
        _addPauser(account);
    }

    function renouncePauser() public {
</source>
<source file="systems/smart_contracts/XTRLPAY.sol" startline="90" endline="93" pcid="8138">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="735" endline="742" pcid="4461">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="870" endline="878" pcid="6854">
    function setProxy(address _proxy)
        external
        onlyOwner
    {
        proxy = Proxy(_proxy);
        emit ProxyUpdated(_proxy);
    }

    function setIntegrationProxy(address _integrationProxy)
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="872" endline="878" pcid="995">
    function unlockAddressForWithdrawal(address user) public onlyAdmin {
        require(deposits[user].deposited, "address has not deposited");
        deposits[user].unlockedForWithdrawal = true;
        emit AddressUnlockedForWithdrawal(address(this), user);
    }

    function hasDeposited(address user) public view returns (bool) {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="113" endline="117" pcid="6718">
  function transferOwnership(address _newOwner) public onlyOwner {
    _transferOwnership(_newOwner);
  }
  
  function _transferOwnership(address _newOwner) internal {
</source>
<source file="systems/smart_contracts/Controller.sol" startline="70" endline="74" pcid="2007">
    function changeDestination(address _dest) public onlyOwner {
        destination = _dest;
    }

    function changeOwner(address _owner) public onlyOwner {
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="148" endline="152" pcid="8171">
    function freeze(address _to) external onlyOwner {
        whiteList[_to] = whiteList[_to] | WHITELISTED_FREEZE_CODE; // 4 [0100]
    }

    function unFreeze(address _to) external onlyOwner {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="178" endline="182" pcid="4657">
  function transferOwnership(address _newOwner) public onlyOwner {
    _transferOwnership(_newOwner);
  }

  function _transferOwnership(address _newOwner) internal {
</source>
<source file="systems/smart_contracts/JUNDCOIN.sol" startline="86" endline="89" pcid="4363">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/MpctLockupTeam.sol" startline="48" endline="53" pcid="5059">
    function transferOwnership(address newOwner) onlyOwner public {
        require(newOwner != address(0));
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="74" endline="77" pcid="7553">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="1736" endline="1748" pcid="6881">
    function setOracle(address _oracle)
        external
        onlyOwner
    {
        oracle = _oracle;
        emit OracleUpdated(oracle);
    }

    /**
     * @notice Set the stale period on the updated rate variables
     * @param _time The new rateStalePeriod
     */
    function setRateStalePeriod(uint _time)
</source>
<source file="systems/smart_contracts/ProxyERC20.sol" startline="277" endline="285" pcid="5881">
    function setProxy(address _proxy)
        external
        onlyOwner
    {
        proxy = Proxy(_proxy);
        emit ProxyUpdated(_proxy);
    }

    function setIntegrationProxy(address _integrationProxy)
</source>
<source file="systems/smart_contracts/LanceToken.sol" startline="90" endline="93" pcid="4521">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="481" endline="485" pcid="905">
    function removeFundingOperators(address account) external onlyFundingManagers {
        _removeFundingOperators(account);
    }

    function renounceFundingManager() external onlyFundingManagers {
</source>
<source file="systems/smart_contracts/AnxToken.sol" startline="89" endline="92" pcid="713">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="559" endline="567" pcid="7820">
    function removeProxy(address account) public onlyOwner {
        _proxies.remove(account);
        emit ProxyRemoved(account);
    }

    /**
     * @dev Returns the allocations counter on `account`.
     */
    function allocations(address account) public view returns (uint256 allocationsCounter) {
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="215" endline="219" pcid="2324">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/FMT.sol" startline="306" endline="312" pcid="3671">
  function declareCheater(address _cheater) external onlyOwner {
    require(_cheater != address(0));
    ICDClaims[_cheater] = false;
    etherBalances[_cheater] = 0;
  }

  function declareCheaters(address[] _cheaters) external onlyOwner {
</source>
<source file="systems/smart_contracts/ContractCargoberToken.sol" startline="85" endline="88" pcid="1960">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/KYCRegistry.sol" startline="108" endline="114" pcid="4508">
    function removeAddressFromKYC(address addr) public onlyAdmin {
        require(KYCConfirmed[addr], "Address not KYCed");
        KYCConfirmed[addr] = false;
        emit RemovedFromKYC(addr);
    }

    function addAddressToKYC(address addr) public onlyAdmin {
</source>
<source file="systems/smart_contracts/UtilityTokenFactory.sol" startline="23" endline="28" pcid="7590">
    function setFundsHolderAddress(address _fundsHolder) external onlyOwner {
        require(_fundsHolder!=address(0), "address cannot be 0x");
        fundsHolder = FundsHolder(_fundsHolder);
    }

    function setPrice(uint256 _price) external onlyOwner {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1307" endline="1316" pcid="1820">
    function deposit(address refundee) public payable {
        require(_state == State.Active, "RefundEscrow: can only deposit while active");
        super.deposit(refundee);
    }

    /**
     * @dev Allows for the beneficiary to withdraw their funds, rejecting
     * further deposits.
     */
    function close() public onlyPrimary {
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="669" endline="673" pcid="343">
    function addMinter(address account) public onlyMinter {
        _addMinter(account);
    }

    function renounceMinter() public {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="535" endline="542" pcid="671">
    function transferOwnership(address newOwner) public onlyOwner {
        pendingOwner = newOwner;
    }

    /**
    * @dev Allows the pendingOwner address to finalize the transfer.
    */
    function claimOwnership() public onlyPendingOwner {
</source>
<source file="systems/smart_contracts/Controller.sol" startline="74" endline="78" pcid="2008">
    function changeOwner(address _owner) public onlyOwner {
        owner = _owner;
    }

    function makeWallet() public onlyAdmins returns (address wallet)  {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="716" endline="723" pcid="2495">
    function removeFunds(address to) public onlyAdmin {
        uint256 amount = token.balanceOf(address(this));
        require(amount > 0, "ReferralTracker has no funds to withdraw");
        token.transfer(to, amount);
        emit FundsRemoved(address(this), msg.sender, amount);
    }

    function registerReferral(address referrer, address user) public onlyRegistry whenNotPaused {
</source>
<source file="systems/smart_contracts/Factory.sol" startline="337" endline="350" pcid="3497">
    function changeTDeployerAddress(address _newTD) external onlyOwner {
        require(block.number < 8850000, "Time expired!");
        require(_newTD != address(0), "Address not suitable!");
        require(_newTD != TDAddress, "AT factory address not changed!");
        TDAddress = _newTD;
        deployerT = ITDeployer(TDAddress);
        emit TFactoryAddressChanged();
    }

    /**
     * @dev change Funding Panel deployer address
     * @param _newFPD new FP deployer address
     */
    function changeFPDeployerAddress(address _newFPD) external onlyOwner {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="337" endline="345" pcid="593">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="271" endline="276" pcid="2063">
    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0));
        candidate = newOwner;
    }

    function confirmOwnership() public {
</source>
<source file="systems/smart_contracts/AICRYPTO.sol" startline="87" endline="90" pcid="429">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="180" endline="184" pcid="3247">
    function addPauser(address account) public onlyPauser {
        _addPauser(account);
    }

    function renouncePauser() public {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="969" endline="977" pcid="5404">
    function removeProxy(address account) public onlyOwner {
        _proxies.remove(account);
        emit ProxyRemoved(account);
    }

    /**
     * @dev Throws if called by account which is not a minter.
     */
    modifier onlyMinter() {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="165" endline="173" pcid="7175">
    function transferOwnership(address _newOwner) public onlyOwner {
        _transferOwnership(_newOwner);
    }

    /**
     * Transfers control of the contract to a newOwner.
     * @param _newOwner The address to transfer ownership to.
     */
    function _transferOwnership(address _newOwner) internal {
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="120" endline="124" pcid="8166">
    function addToSendAllowed(address _to) external onlyManager {
        whiteList[_to] = whiteList[_to] | WHITELISTED_CAN_TX_CODE; // just add the code 1
    }

    function addToReceiveAllowed(address _to) external onlyManager {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="94" endline="98" pcid="6714">
  function setController(address _controller) public onlyOwner {       
    _setController(_controller);
  }

  function _setController(address _controller) internal { 
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="413" endline="417" pcid="890">
    function removeWLManagers(address account) external onlyOwner {
        _removeWLManagers(account);
    }

    function isWLManager(address account) public view returns (bool) {
</source>
<source file="systems/smart_contracts/Dividends.sol" startline="51" endline="58" pcid="2778">
    function transferOwnership(address newOwner) public onlyOwner {
        pendingOwner = newOwner;
    }

    /**
    * @dev Allows the pendingOwner address to finalize the transfer.
    */
    function claimOwnership() public onlyPendingOwner {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="558" endline="562" pcid="6357">
    function addBlacklistAdmin(address account) public onlyBlacklistAdmin {
        _addBlacklistAdmin(account);
    }

    function _addBlacklistAdmin(address account) internal {
</source>
<source file="systems/smart_contracts/GameGold.sol" startline="39" endline="44" pcid="3984">
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    delegate = newOwner;
  }

  function confirmChangeOwnership() public {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="328" endline="336" pcid="3035">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="345" endline="348" pcid="6796">
    function setBusinessAccount(address account) public onlyOwner {
        _setPollAccount(account, businessPoll);
    }
    function setCommunityAccount(address account) public onlyOwner {
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="74" endline="77" pcid="1229">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/SAS.sol" startline="64" endline="68" pcid="6298">
    function transferOwnerShip(address newOwer) public onlyOwner {
        owner = newOwer;
    }

}
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="567" endline="571" pcid="6045">
    function addPauser(address account) public onlyPauser {
        _addPauser(account);
    }

    function renouncePauser() public {
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="70" endline="73" pcid="7436">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="469" endline="473" pcid="902">
    function removeFundingManagers(address account) external onlyOwner {
        _removeFundingManagers(account);
    }

    function isFundingManager(address account) public view returns (bool) {
</source>
<source file="systems/smart_contracts/PositionTokenV2.sol" startline="155" endline="163" pcid="5756">
  function transferOwnership(address _newOwner) public onlyOwner {
    _transferOwnership(_newOwner);
  }

  /**
   * @dev Transfers control of the contract to a newOwner.
   * @param _newOwner The address to transfer ownership to.
   */
  function _transferOwnership(address _newOwner) internal {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="946" endline="953" pcid="566">
    function changeBeneficiary(address _newBeneficiary) public onlyManyBeneficiaries {
        _setPendingBeneficiary(_newBeneficiary);
    }

    /**
        * @dev Claim Beneficiary
    */
    function claimBeneficiary() public onlyPendingBeneficiary {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="229" endline="238" pcid="5353">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Accept ownership of the contract.
     *
     * Can only be called by the new owner.
     */
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/OSManagerToken.sol" startline="58" endline="61" pcid="5554">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="211" endline="219" pcid="7280">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="707" endline="716" pcid="937">
    function setFactoryAddress(address _fAddress) external onlyOwner {
        require(block.number < 8850000, "Time expired!");
        require(_fAddress != address(0), "Address not allowed");
        fAddress = _fAddress;
    }

    /**
     * @dev Get the factory address for deployment.
     */
    function getFactoryAddress() external view returns(address) {
</source>
<source file="systems/smart_contracts/MpctLockupTeam.sol" startline="83" endline="87" pcid="5065">
    function setWallet(address _dest) public onlyOwner {
        wallet = _dest;
    }

    function withdraw() onlyOwner public {
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="177" endline="183" pcid="265">
    function transferOwnership(address _newOwner) public onlyOwner {

        newOwner = _newOwner;

    }

    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="464" endline="469" pcid="901">
    function addFundingManagers(address account) external onlyOwner {
        _addFundingManagers(account);
        _addFundingOperators(account);
    }

    function removeFundingManagers(address account) external onlyOwner {
</source>
<source file="systems/smart_contracts/Bridge.sol" startline="238" endline="243" pcid="1513">
  function setOperator(address _operator) public ifAdmin {
    operator = _operator;
    emit NewOperator(_operator);
  }

  function getParentBlockInterval() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/ICOImplementation.sol" startline="358" endline="369" pcid="4286">
    function freeze(address _addr) public onlyLawEnforcementRole {
        require(!frozen[_addr], "address already frozen");
        frozen[_addr] = true;
        emit AddressFrozen(_addr);
    }


    /**
     * @dev Unfreezes an address balance allowing transfer.
     * @param _addr The new address to unfreeze.
     */
    function unfreeze(address _addr) public onlyLawEnforcementRole {
</source>
<source file="systems/smart_contracts/PokaToken.sol" startline="50" endline="54" pcid="5734">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }
   
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="54" endline="58" pcid="3694">
function requireNotZero(address addr) internal pure {
require(addr != address(0), "require not zero address");
}

function requireNotZero(uint val) internal pure {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="567" endline="571" pcid="2486">
    function addPauser(address account) public onlyPauser {
        _addPauser(account);
    }

    function renouncePauser() public {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="768" endline="772" pcid="2500">
    function setAdministrator(address _admin) public onlyOwner {
        admin = _admin;
    }

    function removeAddressFromKYC(address addr) public onlyAdmin {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="951" endline="960" pcid="3888">
    function disableMemberByStaffRetire(address _memberAddress) external onlyFundingOperators {
        require(membersArray[_memberAddress].isInserted, "Member not present");
        membersArray[_memberAddress].disabled = 2;
        emit MemberDisabled(membersArray[_memberAddress].listPointer);
    }

    /**
     * @dev operator members can disable an already inserted member
     */
    function disableMemberByStaffForExit(address _memberAddress) external onlyFundingOperators {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="421" endline="425" pcid="892">
    function addWLOperators(address account) external onlyWLManagers {
        _addWLOperators(account);
    }

    function removeWLOperators(address account) external onlyWLManagers {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="129" endline="136" pcid="5778">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/SuperMarket.sol" startline="50" endline="54" pcid="6762">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }
   
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="569" endline="573" pcid="7207">
    function removeMinter(address account) public onlyOwner {
        _removeMinter(account);
    }

    function _addMinter(address account) internal {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="934" endline="942" pcid="5401">
    function removeGlobal(address account) public onlyOwner {
        _globals.remove(account);
        emit GlobalRemoved(account);
    }

    /**
     * @dev Throws if called by account which is not a proxy.
     */
    modifier onlyProxy() {
</source>
<source file="systems/smart_contracts/ITVR.sol" startline="85" endline="95" pcid="4328">
  function setOwner(address _owner) 
    public 
    onlyOwner 
  {
    require(_owner != 0);
    
    owner = _owner;
    emit OwnerChanged(owner);
  }
  
  function sendCurrentPayment() public {
</source>
<source file="systems/smart_contracts/BlocklogyCertificate.sol" startline="56" endline="62" pcid="1401">
    function removeAdmin(address _adminAddress) public onlySuperAdmin {
        isAdmin[_adminAddress] = false;
    }
    
    /// @notice views the latest certificate number
    /// @return latest certificate number issued by Blocklogy 
    function viewLatestCertificateNumber() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="245" endline="250" pcid="5678">
  function setOperator(address _operator) public ifAdmin {
    operator = _operator;
    emit NewOperator(_operator);
  }

  function getParentBlockInterval() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/AdminUpgradeabilityProxy.sol" startline="244" endline="258" pcid="360">
    function upgradeTo(address newImplementation) external ifAdmin {
        _upgradeTo(newImplementation);
    }

    /**
     * @dev Upgrade the backing implementation of the proxy and call a function
     * on the new implementation.
     * This is useful to initialize the proxied contract.
     * @param newImplementation Address of the new implementation.
     * @param data Data to send as msg.data in the low level call.
     * It should include the signature and the parameters of the function to be
     * called, as described in
     * https://solidity.readthedocs.io/en/develop/abi-spec.html#function-selector-and-argument-encoding.
     */
    function upgradeToAndCall(address newImplementation, bytes data) payable external ifAdmin {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="601" endline="610" pcid="4861">
  function invest(address addr) public payable {
    investInternal(addr, 0);
  }

  /**
   * The basic entry point to participate the crowdsale process.
   *
   * Pay for funding, get invested tokens back in the sender address.
   */
  function buy() public payable {
</source>
<source file="systems/smart_contracts/FUNNYTOKEN.sol" startline="66" endline="69" pcid="3952">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/GNB.sol" startline="323" endline="332" pcid="4143">
	function blacklisting(address _addr) public onlyOwner{
		blacklist[_addr] = 1;
		emit Blacklisted(_addr);
	}
	
	
	// ------------------------------------------------------------------------
    // Owner can delete from blacklist the wallet address.
    // ------------------------------------------------------------------------
	function deleteFromBlacklist(address _addr) public onlyOwner{
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="729" endline="742" pcid="984">
    function withdraw(address to) public whenNotPaused {
        require(unclaimedReferrals[msg.sender] > 0, "no referrals to claim");
        uint256 trackerBalance = token.balanceOf(address(this));
        uint256 amount = REFERRAL_BONUS * unclaimedReferrals[msg.sender];

        require(trackerBalance >= amount, "Not enough funds");
        delete unclaimedReferrals[msg.sender];

        token.transfer(to, amount);

        emit ReferralBonusWithdrawn(address(this), msg.sender, amount, trackerBalance);
    }

    function getTrackerBalance() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/BermToken.sol" startline="195" endline="201" pcid="1153">
    function setMigrateContract(address _newContractAddr) isOwner external {
        if (_newContractAddr == newContractAddr) throw;
        newContractAddr = _newContractAddr;
    }

    /// @dev set a new owner.
    function changeOwner(address _newFundDeposit) isOwner() external {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="357" endline="362" pcid="2684">
    function transferPrimary(address recipient) public onlyPrimary {
        require(recipient != address(0), "Secondary: new primary is the zero address");
        _primary = recipient;
        emit PrimaryTransferred(_primary);
    }
}
</source>
<source file="systems/smart_contracts/BlocklogyCertificate.sol" startline="50" endline="56" pcid="1400">
    function addAdmin(address _adminAddress) public onlySuperAdmin {
        isAdmin[_adminAddress] = true;
    }
    
    /// @notice superAdmin Deletes the existing Admin 
    /// @param _adminAddress will take admin address which needs to be removed   
    function removeAdmin(address _adminAddress) public onlySuperAdmin {
</source>
<source file="systems/smart_contracts/Ethertime.sol" startline="158" endline="162" pcid="3304">
    function transferOwnership(address addr) public onlyOwner {
        _owner = addr;
        emit TransferOwnershipEvent(msg.sender, addr);
    }
    function transferAdminPart(address addr, uint256 part)
</source>
<source file="systems/smart_contracts/ICOImplementation.sol" startline="369" endline="381" pcid="4287">
    function unfreeze(address _addr) public onlyLawEnforcementRole {
        require(frozen[_addr], "address already unfrozen");
        frozen[_addr] = false;
        emit AddressUnfrozen(_addr);
    }


    /**
     * @dev Wipes the balance of a frozen address, burning the tokens
     * and setting the approval to zero.
     * @param _addr The new frozen address to wipe.
     */
    function wipeFrozenAddress(address _addr) public onlyLawEnforcementRole {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="69" endline="76" pcid="6015">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/Factory.sol" startline="363" endline="383" pcid="3499">
    function setInternalDEXAddress(address _dexAddress) external onlyOwner {
        require(block.number < 8850000, "Time expired!");
        require(_dexAddress != address(0), "Address not suitable!");
        require(_dexAddress != internalDEXAddress, "AT factory address not changed!");
        internalDEXAddress = _dexAddress;
        emit InternalDEXAddressChanged();
    }

    /**
     * @dev deploy a new set of contracts for the Panel, with all params needed by contracts. Set the minter address for Token contract,
     * Owner is set as a manager in WL, Funding and FundsUnlocker, DEX is whitelisted
     * @param _name name of the token to be deployed
     * @param _symbol symbol of the token to be deployed
     * @param _setDocURL URL of the document describing the Panel
     * @param _setDocHash hash of the document describing the Panel
     * @param _exchRateSeed exchange rate between SEED tokens received and tokens given to the SEED sender (multiply by 10^_exchRateDecim)
     * @param _exchRateOnTop exchange rate between SEED token received and tokens minted on top (multiply by 10^_exchRateDecim)
     * @param _seedMaxSupply max supply of SEED tokens accepted by this contract
     * @param _WLAnonymThr max anonym threshold
     */
    function deployPanelContracts(string memory _name, string memory _symbol, string memory _setDocURL, bytes32 _setDocHash,
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="287" endline="291" pcid="2995">
  function removeAdmin(address somebody) public onlyOwner {
    _admins[somebody] = false;
  }

  function isAdmin(address somebody) public view returns(bool) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1167" endline="1172" pcid="1812">
    function transferPrimary(address recipient) public onlyPrimary {
        require(recipient != address(0), "Secondary: new primary is the zero address");
        _primary = recipient;
        emit PrimaryTransferred(_primary);
    }
}
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="129" endline="135" pcid="5953">
    function setOwner(address _owner) external onlyOwner {
        require(_owner != address(0), "new owner must not be null");
        owner = _owner;
        emit OwnerChanged(_owner);
    }

}
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="57" endline="63" pcid="2094">
  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}
</source>
<source file="systems/smart_contracts/ICOImplementation.sol" startline="381" endline="397" pcid="4288">
    function wipeFrozenAddress(address _addr) public onlyLawEnforcementRole {
        require(frozen[_addr], "address is not frozen");
        uint256 _balance = balances[_addr];
        balances[_addr] = 0;
        totalSupply_ = totalSupply_.sub(_balance);
        emit FrozenAddressWiped(_addr);
        emit SupplyDecreased(_addr, _balance);
        emit Transfer(_addr, address(0), _balance);
    }


    /**
    * @dev Gets the balance of the specified address.
    * @param _addr The address to check if frozen.
    * @return A bool representing whether the given address is frozen.
    */
    function isFrozen(address _addr) public view returns (bool) {
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="145" endline="153" pcid="2854">
    function transferOwnership(address _newOwner) public ownerOnly {
        require(_newOwner != owner);
        newOwner = _newOwner;
    }

    /**
        @dev used by a new owner to accept an ownership transfer
    */
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="274" endline="278" pcid="3255">
    function addMinter(address account) public onlyMinter {
        _addMinter(account);
    }

    function renounceMinter() public {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="289" endline="296" pcid="7996">
  function removeAdmin(address somebody) public onlyOwner {
    _admins[somebody] = false;
  }

  /**
   * Returns true if somebody is admin. Owner is always an admin.
   */
  function isAdmin(address somebody) public view returns(bool) {
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="68" endline="72" pcid="8161">
    function transferOwnership(address _newOwner) external onlyOwner {
        newOwner = _newOwner;
    }

    function acceptOwnership() external {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="493" endline="497" pcid="2702">
    function addMinter(address account) public onlyMinter {
        _addMinter(account);
    }

    function renounceMinter() public {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="425" endline="429" pcid="893">
    function removeWLOperators(address account) external onlyWLManagers {
        _removeWLOperators(account);
    }

    function renounceWLManager() external onlyWLManagers {
</source>
<source file="systems/smart_contracts/Perlin.sol" startline="90" endline="93" pcid="5646">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/LuckyAdvcedWoken.sol" startline="70" endline="73" pcid="4558">
    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/FlatPricingExt.sol" startline="43" endline="49" pcid="3631">
  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="531" endline="536" pcid="3738">
function setAdvertisingAddress(address addr) public onlyOwner {
addr.requireNotZero();
advertisingAddress = addr;
}

function setAdminsAddress(address addr) public onlyOwner {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="69" endline="76" pcid="943">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="152" endline="158" pcid="4843">
  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}
</source>
<source file="systems/smart_contracts/ProxyERC20.sol" startline="292" endline="299" pcid="5883">
    function setMessageSender(address sender)
        external
        onlyProxy
    {
        messageSender = sender;
    }

    modifier onlyProxy {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="778" endline="783" pcid="989">
    function addAddressToKYC(address addr) public onlyAdmin {
        require(!KYCConfirmed[addr], "Address already KYCed");
        KYCConfirmed[addr] = true;
        emit AddedToKYC(addr);
    }
}
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="707" endline="711" pcid="980">
    function setAdministrator(address _admin) public onlyOwner {
        admin = _admin;
    }

    function addFunds(uint256 amount) public onlyAdmin whenNotPaused {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="473" endline="487" pcid="6843">
    function setSelfDestructBeneficiary(address _beneficiary)
        external
        onlyOwner
    {
        require(_beneficiary != address(0), "Beneficiary must not be zero");
        selfDestructBeneficiary = _beneficiary;
        emit SelfDestructBeneficiaryUpdated(_beneficiary);
    }

    /**
     * @notice Begin the self-destruction counter of this contract.
     * Once the delay has elapsed, the contract may be self-destructed.
     * @dev Only the contract owner may call this.
     */
    function initiateSelfDestruct()
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="131" endline="135" pcid="3552">
    function addAdmin(address account) public onlyAdmin {
        _addAdmin(account);
    }

    function renounceAdmin() public {
</source>
<source file="systems/smart_contracts/Factory.sol" startline="350" endline="363" pcid="3498">
    function changeFPDeployerAddress(address _newFPD) external onlyOwner {
        require(block.number < 8850000, "Time expired!");
        require(_newFPD != address(0), "Address not suitable!");
        require(_newFPD != ATDAddress, "AT factory address not changed!");
        FPDAddress = _newFPD;
        deployerFP = IFPDeployer(FPDAddress);
        emit FPFactoryAddressChanged();
    }

    /**
     * @dev set internal DEX address
     * @param _dexAddress internal DEX address
     */
    function setInternalDEXAddress(address _dexAddress) external onlyOwner {
</source>
<source file="systems/smart_contracts/FMT.sol" startline="276" endline="280" pcid="3667">
  function setERC721Address(address _ERC721Address) external onlyOwner {
    ERC721Address = _ERC721Address;
  }

  function setMaxReferrals(uint256 _maxReferrals) external onlyOwner {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="390" endline="394" pcid="1388">
    function addPauser(address account) public onlyPauser {
        _addPauser(account);
    }

    function renouncePauser() public {
</source>
<source file="systems/smart_contracts/GFNX.sol" startline="106" endline="109" pcid="4103">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/PDataToSHFund.sol" startline="85" endline="95" pcid="5632">
  function setOwner(address _owner) 
    public 
    onlyOwner 
  {
    require(_owner != 0);
    
    owner = _owner;
    emit OwnerChanged(owner);
  }
  
  function sendCurrentPayment() public {
</source>
<source file="systems/smart_contracts/ICBB.sol" startline="23" endline="26" pcid="4263">
    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/SBC.sol" startline="207" endline="211" pcid="6322">
    function addPauser(address account) public onlyPauser {
        _addPauser(account);
    }

    function renouncePauser() public {
</source>
<source file="systems/smart_contracts/MiniMeTokenFactory.sol" startline="70" endline="73" pcid="4804">
    function changeController(address _newController) onlyController  public {
        controller = _newController;
    }
}
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="348" endline="351" pcid="6797">
    function setCommunityAccount(address account) public onlyOwner {
        _setPollAccount(account, communityPoll);
    }
    function setTechAccount(address account) public onlyOwner {
</source>
<source file="systems/smart_contracts/VOTENOmodumtokenswapdotcom.sol" startline="90" endline="93" pcid="7840">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="61" endline="66" pcid="4378">
    function transferOwnership(address _newOwner) public onlyOwner {
        require(_newOwner != address(0));
        newOwner = _newOwner;
    }

    function acceptOwnership() public onlyNewOwner returns(bool) {
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="604" endline="610" pcid="6822">
    function changeAdmin(address newAdmin) public onlyOwner {
        // owner can re-assign the admin
        emit AdminTransferred(admin, newAdmin);
        admin = newAdmin;
    }

    function changeAll(address newOwner) public onlyOwner{
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="969" endline="977" pcid="3890">
    function disableMemberByMember(address _memberAddress) external onlyMemberEnabled {
        membersArray[_memberAddress].disabled = 3;
        emit MemberDisabledByMember(membersArray[_memberAddress].listPointer);
    }

    /**
     * @dev operator members can change URL and hash of an already inserted member
     */
    function changeMemberData(address _memberAddress, string calldata newURL, bytes32 newHash) external onlyFundingOperators {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="959" endline="969" pcid="5403">
    function addProxy(address account) public onlyOwner {
        _proxies.add(account);
        emit ProxyAdded(account);
    }

    /**
     * @dev Remove an `account` access from the Proxy role.
     *
     * Can only be called by the current owner.
     */
    function removeProxy(address account) public onlyOwner {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="282" endline="289" pcid="7995">
  function addAdmin(address somebody) public onlyOwner {
    _admins[somebody] = true;
  }

  /**
   * Removes somebody from admin. This method is allowed by owner only.
   */
  function removeAdmin(address somebody) public onlyOwner {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="716" endline="723" pcid="982">
    function removeFunds(address to) public onlyAdmin {
        uint256 amount = token.balanceOf(address(this));
        require(amount > 0, "ReferralTracker has no funds to withdraw");
        token.transfer(to, amount);
        emit FundsRemoved(address(this), msg.sender, amount);
    }

    function registerReferral(address referrer, address user) public onlyRegistry whenNotPaused {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="872" endline="878" pcid="2508">
    function unlockAddressForWithdrawal(address user) public onlyAdmin {
        require(deposits[user].deposited, "address has not deposited");
        deposits[user].unlockedForWithdrawal = true;
        emit AddressUnlockedForWithdrawal(address(this), user);
    }

    function hasDeposited(address user) public view returns (bool) {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="495" endline="499" pcid="8252">
    function addMinter(address account) public onlyMinter {
        _addMinter(account);
    }

    function renounceMinter() public {
</source>
<source file="systems/smart_contracts/CDS.sol" startline="83" endline="91" pcid="1657">
  function transferOwnership(address _newOwner) public onlyOwner {
    _transferOwnership(_newOwner);
  }

  /**
   * @dev Transfers control of the contract to a newOwner.
   * @param _newOwner The address to transfer ownership to.
   */
  function _transferOwnership(address _newOwner) internal {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="167" endline="171" pcid="6317">
    function addMinter(address account) public onlyMinter {
        _addMinter(account);
    }

    function renounceMinter() public {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="68" endline="72" pcid="4981">
    function addMinter(address account) public onlyMinter {
        _addMinter(account);
    }

    function renounceMinter() public {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="176" endline="184" pcid="809">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/TimeLockedTokenStorage.sol" startline="114" endline="122" pcid="7230">
    function transferOwnership(address _newOwner) public onlyOwner {
        _transferOwnership(_newOwner);
    }

    /**
     * @dev Transfers control of the contract to a newOwner.
     * @param _newOwner The address to transfer ownership to.
     */
    function _transferOwnership(address _newOwner) internal {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="477" endline="481" pcid="904">
    function addFundingOperators(address account) external onlyFundingManagers {
        _addFundingOperators(account);
    }

    function removeFundingOperators(address account) external onlyFundingManagers {
</source>
<source file="systems/smart_contracts/NSTTeamLock.sol" startline="82" endline="86" pcid="5460">
    function changeOwner(address _addr) public onlyOwner {
            TeamOwner = _addr;
    }
    
    function releaseToken() public onlyOwner returns(bool success){
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="38" endline="44" pcid="6771">
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0), "Owner can't be set to zero address");
    emit OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="391" endline="402" pcid="6841">
    function nominateNewOwner(address _owner)
        external
        onlyOwner
    {
        nominatedOwner = _owner;
        emit OwnerNominated(_owner);
    }

    /**
     * @notice Accept the nomination to be owner.
     */
    function acceptOwnership()
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="122" endline="135" pcid="6986">
    function transferOwnership(address newOwner) external onlyOwner {
        require(newOwner != address(0));
        _owner = newOwner;
        emit OwnershipTransferred(_owner, newOwner);
    }

    /**
     * @dev Rescue compatible ERC20 Token
     *
     * @param tokenAddr ERC20 The address of the ERC20 token contract
     * @param receiver The address of the receiver
     * @param amount uint256
     */
    function rescueTokens(address tokenAddr, address receiver, uint256 amount) external onlyOwner {
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="89" endline="93" pcid="8163">
    function addManager (address managerAddress) public onlyOwner {
        managers[managerAddress] = true;
    }

    function removeManager (address managerAddress) external onlyOwner {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="215" endline="219" pcid="5850">
    function check(address _token,address _spender,address _from,address _to,uint256 _amount) public view returns (uint8){
        return 0;
    }

}
</source>
<source file="systems/smart_contracts/DefaultService.sol" startline="20" endline="24" pcid="2385">
    function check(address _token,address _spender,address _from,address _to,uint256 _amount) public view returns (uint8){
        return 0;
    }

}
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="244" endline="250" pcid="2061">
    function lockTransfer(bool _lock) public onlyOwner {
        lockTransfers = _lock;
    }



    function() external payable {
</source>
<source file="systems/smart_contracts/MiniMeTokenFactory.sol" startline="448" endline="460" pcid="4820">
    function enableTransfers(bool _transfersEnabled) onlyController public {
        transfersEnabled = _transfersEnabled;
    }

////////////////
// Internal helper functions to query and set a value in a snapshot array
////////////////

    /// @dev `getValueAt` retrieves the number of tokens at a given block number
    /// @param checkpoints The history of values being queried
    /// @param _block The block number to retrieve the value at
    /// @return The number of tokens being queried
    function getValueAt(Checkpoint[] storage checkpoints, uint _block) constant internal returns (uint) {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="930" endline="937" pcid="3114">
  function initialize(address _sender) public isInitializer("Ownable", "1.9.0") {
    owner = _sender;
  }

  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/magesh.sol" startline="359" endline="365" pcid="4636">
    function setPrice(uint256 price) public onlyOwner {
    
      price_ = price;

    }

    function price() public view returns (uint256){
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="359" endline="365" pcid="4948">
    function setPrice(uint256 price) public onlyOwner {
    
      price_ = price;

    }

    function price() public view returns (uint256){
</source>
<source file="systems/smart_contracts/ScipayToken.sol" startline="16" endline="20" pcid="6374">
    function changeSymbol(string memory _newSymbol) public onlyAttributesPermission {
        symbol = _newSymbol;
    }

    function changename(string memory _newName) public onlyAttributesPermission {
</source>
<source file="systems/smart_contracts/ScipayToken.sol" startline="20" endline="24" pcid="6375">
    function changename(string memory _newName) public onlyAttributesPermission {
        name = _newName;
    }

    function transfer(address _to, uint _amount) public returns(bool) {
</source>
<source file="systems/smart_contracts/MpctLockupTeam.sol" startline="75" endline="79" pcid="5063">
    function setLockupAmt(uint256 _amt) public onlyOwner {
        initLockupAmt = _amt;
    }

    function setLockupDate(uint _date) public onlyOwner {
</source>
<source file="systems/smart_contracts/GameGold.sol" startline="132" endline="136" pcid="3990">
  function setTransferable(bool status) public onlyOwner {
      isTransferable = status;
  }

  function isInPassFilter(address user) public view returns (bool) {
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="66" endline="69" pcid="2429">
    function transferOwnership(address payable _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="505" endline="508" pcid="102">
	function disable(bool _disable) public ownerOnly {
		disabled = _disable;
	}
}
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="754" endline="763" pcid="5385">
    function rename(string calldata value) external onlyOwner {
        _name = value;
    }

    /**
     * @dev Sets the symbol of VOKEN.
     *
     * Can only be called by the current owner.
     */
    function setSymbol(string calldata value) external onlyOwner {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="763" endline="770" pcid="5386">
    function setSymbol(string calldata value) external onlyOwner {
        _symbol = value;
    }

    /**
     * @dev Returns true if the `account` is whitelisted.
     */
    function whitelisted(address account) public view returns (bool) {
</source>
<source file="systems/smart_contracts/BDAM.sol" startline="126" endline="130" pcid="1118">
  function setLocked(bool _locked) public onlyOwner {
    locked = _locked;
  }

  function canTransfer(address _addr) public constant returns (bool) {
</source>
<source file="systems/smart_contracts/MpctLockupTeam.sol" startline="79" endline="83" pcid="5064">
    function setLockupDate(uint _date) public onlyOwner {
        lockupDate = _date;
    }

    function setWallet(address _dest) public onlyOwner {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="908" endline="915" pcid="5398">
    function setSafeMode(bool value) public onlyOwner {
        _safeMode = value;
    }

    /**
     * @dev Returns true if the `account` has the Global role
     */
    function isGlobal(address account) public view returns (bool) {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="2877" endline="2888" pcid="6936">
    function setExchangeEnabled(bool _exchangeEnabled)
        external
        optionalProxy_onlyOwner
    {
        exchangeEnabled = _exchangeEnabled;
    }

    /**
     * @notice Add an associated Synth contract to the Synthetix system
     * @dev Only the contract owner may call this.
     */
    function addSynth(Synth synth)
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="2870" endline="2877" pcid="6935">
    function setProtectionCircuit(bool _protectionCircuitIsActivated)
        external
        onlyOracle
    {
        protectionCircuit = _protectionCircuitIsActivated;
    }

    function setExchangeEnabled(bool _exchangeEnabled)
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="426" endline="436" pcid="5109">
    function setName(string _name)
        onlyOwner()
        public
    {
        name = _name;
    }
    
    /**
     * If we want to rebrand, we can.
     */
    function setSymbol(string _symbol)
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="436" endline="443" pcid="5110">
    function setSymbol(string _symbol)
        onlyOwner()
        public
    {
        symbol = _symbol;
    }

    function setInitialPrice(uint _price)
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="443" endline="450" pcid="5111">
    function setInitialPrice(uint _price)
        onlyOwner()
        public
    {
        initialPrice = _price;
    }

    function setMaxbonds(uint _bond)  
</source>
<source file="systems/smart_contracts/RegulatedToken.sol" startline="33" endline="37" pcid="6061">
    function changename(string memory _newName) public onlyAttributesPermission {
        name = _newName;
    }

    function addWhitelisted(address _account, string memory _iso) public onlyAddWhitelistPermission {
</source>
<source file="systems/smart_contracts/RegulatedToken.sol" startline="29" endline="33" pcid="6060">
    function changeCIK(string memory _newCIK) public onlyAttributesPermission {
        CIK = _newCIK;
    }

    function changename(string memory _newName) public onlyAttributesPermission {
</source>
<source file="systems/smart_contracts/RegulatedToken.sol" startline="25" endline="29" pcid="6059">
    function changeSymbol(string memory _newSymbol) public onlyAttributesPermission {
        symbol = _newSymbol;
    }

    function changeCIK(string memory _newCIK) public onlyAttributesPermission {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="450" endline="457" pcid="5112">
    function setMaxbonds(uint _bond)  
        onlyOwner()
        public
    {
        maxBonds = _bond;
    }

    function setBondDeadline(uint _value)  
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="457" endline="464" pcid="5113">
    function setBondDeadline(uint _value)  
        onlyOwner()
        public
    {
        bondDeadlineInc = _value;
    }

    function setBondPrice(uint _bond, uint _price)   //Allow the changing of a bond price owner if the dev owns it 
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="164" endline="167" pcid="8173">
    function setWhitelistRule(byte _newRule) external onlyOwner {
        listRule = _newRule;
    }
    function getWhitelistRule() external view returns (byte){
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="495" endline="502" pcid="5116">
    function setAllowReferral(bool _allowReferral)   
        onlyOwner()
        public
    {
        allowReferral = _allowReferral;
    }

    function setAutoNewbond(bool _autoNewBond)   
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="502" endline="509" pcid="5117">
    function setAutoNewbond(bool _autoNewBond)   
        onlyOwner()
        public
    {
        allowAutoNewBond = _autoNewBond;
    }

    function setRates(uint8 _newPotRate, uint8 _newDevRate,  uint8 _newOwnerRate)   
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="2617" endline="2626" pcid="6925">
    function setTotalSupply(uint amount)
        external
        optionalProxy_onlyOwner
    {
        totalSupply = amount;
    }

    // Allow synthetix to trigger a token fallback call from our synths so users get notified on
    // exchange as well as transfer
    function triggerTokenFallbackIfNeeded(address sender, address recipient, uint amount)
</source>
<source file="systems/smart_contracts/ProxyERC20.sol" startline="148" endline="155" pcid="5878">
    function setUseDELEGATECALL(bool value) 
        external
        onlyOwner
    {
        useDELEGATECALL = value;
    }

    function _emit(bytes callData, uint numTopics, bytes32 topic1, bytes32 topic2, bytes32 topic3, bytes32 topic4)
</source>
<source file="systems/smart_contracts/Bridge.sol" startline="247" endline="251" pcid="1515">
  function setParentBlockInterval(uint256 _parentBlockInterval) public ifAdmin {
    parentBlockInterval = _parentBlockInterval;
  }

  function submitPeriod(
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="741" endline="748" pcid="6851">
    function setUseDELEGATECALL(bool value) 
        external
        onlyOwner
    {
        useDELEGATECALL = value;
    }

    function _emit(bytes callData, uint numTopics, bytes32 topic1, bytes32 topic2, bytes32 topic3, bytes32 topic4)
</source>
<source file="systems/smart_contracts/BRZE.sol" startline="206" endline="209" pcid="1535">
  function freezeToken(bool freeze) onlyOwner public {
    tokenFrozen = freeze;
  }
}
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="1760" endline="1774" pcid="6883">
    function setPriceUpdateLock(bool _priceUpdateLock)
        external
        onlyOracle
    {
        priceUpdateLock = _priceUpdateLock;
    }

    /**
     * @notice Set an inverse price up for the currency key
     * @param currencyKey The currency to update
     * @param entryPoint The entry price point of the inverted price
     * @param upperLimit The upper limit, at or above which the price will be frozen
     * @param lowerLimit The lower limit, at or below which the price will be frozen
     */
    function setInversePricing(bytes4 currencyKey, uint entryPoint, uint upperLimit, uint lowerLimit)
</source>
<source file="systems/smart_contracts/BlackJack.sol" startline="368" endline="376" pcid="1356">
    function setStatedPeriod(uint256 input) public onlyOwner {
        statedPeriod = input;
    }

    /**
    * @dev Withdraw funds to cover costs of operation.
    * @param amount should ensure the total balances of palyers.
     */
    function withdrawFunds(uint256 amount) public onlyOwner {
</source>
<source file="systems/smart_contracts/FMT.sol" startline="280" endline="284" pcid="3668">
  function setMaxReferrals(uint256 _maxReferrals) external onlyOwner {
    maxReferrals = _maxReferrals;
  }

  function registerEtherBalance(address _referral) external forRegistration {
</source>
<source file="systems/smart_contracts/BlackJack.sol" startline="360" endline="368" pcid="1355">
    function setExpireBlocks(uint256 input) public onlyOwner {
        expireBlocks = input;
    }

    /**
    * @dev Set stated apply period.
    * @param input new number of stated apply period.
     */
    function setStatedPeriod(uint256 input) public onlyOwner {
</source>
<source file="systems/smart_contracts/GoaToken.sol" startline="96" endline="100" pcid="4153">
    function transferOwnership(address payable _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }

    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/BlackJack.sol" startline="352" endline="360" pcid="1354">
    function setFeeRatio(uint256 input) public onlyOwner {
        feeRatio = input;
    }

    /**
    * @dev Set expiration blocks.
    * @param input new number of expiration blocks.
     */
    function setExpireBlocks(uint256 input) public onlyOwner {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="254" endline="258" pcid="5680">
  function setParentBlockInterval(uint256 _parentBlockInterval) public ifAdmin {
    parentBlockInterval = _parentBlockInterval;
  }

  function submitPeriod(
</source>
<source file="systems/smart_contracts/BlackJack.sol" startline="344" endline="352" pcid="1353">
    function setMinBet(uint256 input) public onlyOwner {
        minBet = input;
    }

    /**
    * @dev Set fee ratio.
    * @param input new fee ratio, div by 1000.
     */
    function setFeeRatio(uint256 input) public onlyOwner {
</source>
<source file="systems/smart_contracts/PositionTokenV2.sol" startline="229" endline="236" pcid="5758">
    function pauseMinting(
        bool _isPaused)
        public
        onlyOwner
    {
        mintingPaused = _isPaused;
    }
    function pauseBurning(
</source>
<source file="systems/smart_contracts/PositionTokenV2.sol" startline="236" endline="243" pcid="5759">
    function pauseBurning(
        bool _isPaused)
        public
        onlyOwner
    {
        burningPaused = _isPaused;
    }
}
</source>
<source file="systems/smart_contracts/GasStorage.sol" startline="110" endline="118" pcid="4020">
    function setBaseBurn(uint256 baseBurn) public onlyOwner{
        _baseBurn = baseBurn;
    }
 
   /**
   * @dev  setEachBurnBase
   * @param eachBurnBase  gt1 = 20000, gt2 = 48000
   */
    function setEachBurnBase(uint256 eachBurnBase) public onlyOwner{
</source>
<source file="systems/smart_contracts/BlackJack.sol" startline="336" endline="344" pcid="1352">
    function setMaxBet(uint256 input) public onlyOwner {
        maxBet = input;
    }

    /**
    * @dev Set min bet amount.
    * @param input in wei.
     */
    function setMinBet(uint256 input) public onlyOwner {
</source>
<source file="systems/smart_contracts/KFCToken.sol" startline="91" endline="95" pcid="4412">
    function setName(string _name) public isOwner {
        name = _name;
    }

    function setSymbol(string _symbol) public isOwner {
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="368" endline="372" pcid="1734">
    function enableTransfers(bool _transfersEnabled) onlyOwner public {
        transfersEnabled = _transfersEnabled;
    }

    function claimTokens() public onlyOwner {
</source>
<source file="systems/smart_contracts/GasStorage.sol" startline="118" endline="126" pcid="4021">
    function setEachBurnBase(uint256 eachBurnBase) public onlyOwner{
        _eachBurnBase = eachBurnBase;
    }

   /**
   * @dev  mint gas token
   * @param value  the value to mint
   */
    function mint(uint256 value)  public
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="627" endline="635" pcid="3278">
    function setBaseTokenURI(string memory baseTokenURI) public onlyMinter {
        _baseTokenURI = baseTokenURI;
    }

    /**
     * @dev Returns prefix of token URI
     * @return string representing the token URI prefix
     */
    function baseTokenURI() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/KFCToken.sol" startline="95" endline="99" pcid="4413">
    function setSymbol(string _symbol) public isOwner {
        symbol = _symbol;
    }

    function burn(uint256 _value) public {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="2170" endline="2183" pcid="6898">
    function appendDebtLedgerValue(uint value)
        external
        onlyAssociatedContract
    {
        debtLedger.push(value);
    }

    /**
     * @notice Set preferred currency for a user
     * @dev Only the associated contract may call this.
     * @param account The account to set the preferred currency for
     * @param currencyKey The new preferred currency
     */
    function setPreferredCurrency(address account, bytes4 currencyKey)
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="541" endline="551" pcid="3740">
function privateEntranceProvideAccessFor(address[] addrs) public onlyOwner {
m_privEnter.provideAccessFor(addrs);
}

/*
function rapidGrowthProtectionmMaxInvestmentAtNow() public view returns(uint investment) {
investment = m_rgp.maxInvestmentAtNow();
}
*/

function investorsNumber() public view returns(uint) {
</source>
<source file="systems/smart_contracts/XGP.sol" startline="180" endline="185" pcid="8115">
    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
        tokensPerEth = _tokensPerEth;
        emit TokensPerEthUpdated(_tokensPerEth);
    }
           
    function () external payable {
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="168" endline="173" pcid="1283">
    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
        tokensPerEth = _tokensPerEth;
        emit TokensPerEthUpdated(_tokensPerEth);
    }
           
    function () external payable {
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="184" endline="189" pcid="1445">
    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
        tokensPerEth = _tokensPerEth;
        emit TokensPerEthUpdated(_tokensPerEth);
    }
           
    function () external payable {
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="162" endline="167" pcid="4967">
    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
        tokensPerEth = _tokensPerEth;
        emit TokensPerEthUpdated(_tokensPerEth);
    }
           
    function () external payable {
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="173" endline="178" pcid="3529">
    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
        tokensPerEth = _tokensPerEth;
        emit TokensPerEthUpdated(_tokensPerEth);
    }
           
    function () external payable {
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="197" endline="202" pcid="6694">
    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
        tokensPerEth = _tokensPerEth;
        emit TokensPerEthUpdated(_tokensPerEth);
    }
           
    function () external payable {
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="188" endline="193" pcid="4310">
    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
        tokensPerEth = _tokensPerEth;
        emit TokensPerEthUpdated(_tokensPerEth);
    }
           
    function () external payable {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="967" endline="971" pcid="568">
    function _setPendingBeneficiary(address _newBeneficiary) internal onlyExistingBeneficiary(_newBeneficiary) {
        _pendingBeneficiary = _newBeneficiary;
        emit LogBeneficiaryTransferProposed(_newBeneficiary);
    }
}
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="177" endline="182" pcid="2962">
    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
        tokensPerEth = _tokensPerEth;
        emit TokensPerEthUpdated(_tokensPerEth);
    }
           
    function () external payable {
</source>
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="770" endline="774" pcid="514">
        function _setPendingBeneficiary(address _newBeneficiary) internal onlyExistingBeneficiary(_newBeneficiary) {
            _pendingBeneficiary = _newBeneficiary;
            emit LogBeneficiaryTransferProposed(_newBeneficiary);
        }
}
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="181" endline="186" pcid="6493">
    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
        tokensPerEth = _tokensPerEth;
        emit TokensPerEthUpdated(_tokensPerEth);
    }
           
    function () external payable {
</source>
<source file="systems/smart_contracts/Aigopay.sol" startline="180" endline="185" pcid="458">
    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
        tokensPerEth = _tokensPerEth;
        emit TokensPerEthUpdated(_tokensPerEth);
    }
           
    function () external payable {
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="177" endline="182" pcid="6559">
    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
        tokensPerEth = _tokensPerEth;
        emit TokensPerEthUpdated(_tokensPerEth);
    }
           
    function () external payable {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="1436" endline="1446" pcid="6875">
    function setMinterReward(uint _amount)
        external
        onlyOwner
    {
        minterReward = _amount;
        emit MinterRewardUpdated(_amount);
    }

    // ========== MODIFIERS ==========

    modifier onlySynthetix() {
</source>
<source file="systems/smart_contracts/TrueProfileLogic.sol" startline="165" endline="169" pcid="7509">
    function deleteAddress(bytes32 _key) accessible external {
        delete addressStorage[_key];
    }

    function deleteUint(bytes32 _key) accessible external {
</source>
<source file="systems/smart_contracts/TrueProfileLogic.sol" startline="169" endline="173" pcid="7510">
    function deleteUint(bytes32 _key) accessible external {
        delete uIntStorage[_key];
    }

    function deleteString(bytes32 _key) accessible external {
</source>
<source file="systems/smart_contracts/TrueProfileLogic.sol" startline="173" endline="177" pcid="7511">
    function deleteString(bytes32 _key) accessible external {
        delete stringStorage[_key];
    }

    function deleteBytes(bytes32 _key) accessible external {
</source>
<source file="systems/smart_contracts/TrueProfileLogic.sol" startline="177" endline="181" pcid="7512">
    function deleteBytes(bytes32 _key) accessible external {
        delete bytesStorage[_key];
    }

    function deleteBool(bytes32 _key) accessible external {
</source>
<source file="systems/smart_contracts/TrueProfileLogic.sol" startline="181" endline="185" pcid="7513">
    function deleteBool(bytes32 _key) accessible external {
        delete boolStorage[_key];
    }

    function deleteInt(bytes32 _key) accessible external {
</source>
<source file="systems/smart_contracts/TrueProfileLogic.sol" startline="185" endline="188" pcid="7514">
    function deleteInt(bytes32 _key) accessible external {
        delete intStorage[_key];
    }
}
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="824" endline="829" pcid="5717">
  function setEpochLength(uint256 _epochLength) public ifAdmin {
    epochLength = _epochLength;
    emit EpochLength(epochLength);
  }

  function setSlot(uint256 _slotId, address _signerAddr, bytes32 _tenderAddr) public ifAdmin {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="1748" endline="1760" pcid="6882">
    function setRateStalePeriod(uint _time)
        external
        onlyOwner
    {
        rateStalePeriod = _time;
        emit RateStalePeriodUpdated(rateStalePeriod);
    }

    /**
     * @notice Set the the locked state for a priceUpdate call
     * @param _priceUpdateLock lock boolean flag
     */
    function setPriceUpdateLock(bool _priceUpdateLock)
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="615" endline="618" pcid="164">
	function disableDapp(bool _disable) public ownerOnly {
		setBU("dappEnabled", _disable ? 0 : 1);
	}
}
</source>
<source file="systems/smart_contracts/AACD.sol" startline="32" endline="35" pcid="290">
  function _assert(bool assertion)public pure {
    assert(!assertion);
  }
}
</source>
<source file="systems/smart_contracts/DHF.sol" startline="32" endline="35" pcid="2537">
  function _assert(bool assertion)public pure {
    assert(!assertion);
  }
}
</source>
<source file="systems/smart_contracts/SAS.sol" startline="32" endline="35" pcid="6293">
  function _assert(bool assertion)public pure {
    assert(!assertion);
  }
}
</source>
<source file="systems/smart_contracts/MT.sol" startline="32" endline="35" pcid="5072">
  function _assert(bool assertion)public pure {
    assert(!assertion);
  }
}
</source>
<source file="systems/smart_contracts/NEM.sol" startline="32" endline="35" pcid="5320">
  function _assert(bool assertion)public pure {
    assert(!assertion);
  }
}
</source>
<source file="systems/smart_contracts/CAC.sol" startline="32" endline="35" pcid="1611">
  function _assert(bool assertion)public pure {
    assert(!assertion);
  }
}
</source>
<source file="systems/smart_contracts/NMAI.sol" startline="32" endline="35" pcid="5442">
  function _assert(bool assertion)public pure {
    assert(!assertion);
  }
}
</source>
<source file="systems/smart_contracts/UGCoin.sol" startline="127" endline="136" pcid="7540">
    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);

        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        Burn(burner, _value);
    }
    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="315" endline="320" pcid="4320">
    function withdraw(uint256 _wdamount) onlyOwner public {
        uint256 wantAmount = _wdamount;
        owner.transfer(wantAmount);
    }

    function burn(uint256 _value) onlyOwner public {
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="320" endline="329" pcid="4321">
    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        emit Burn(burner, _value);
    }
    
    function add(uint256 _value) onlyOwner public {
</source>
<source file="systems/smart_contracts/Ethertime.sol" startline="303" endline="311" pcid="3311">
    function deleteLottery(uint256 lotteryId) public onlyOwner {
        require(lotteryId <= _lastLotteryId);
        Lottery storage lottery = _lotteries[lotteryId];
        require(lottery.status == LotteryStatus.Open);
        require(lottery.isContinued);
        lottery.isContinued = false;
        emit DeleteLotteryEvent(lotteryId);
    }
    function createOrder(
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="329" endline="335" pcid="4322">
    function add(uint256 _value) onlyOwner public {
        uint256 counter = totalSupply.add(_value);
        totalSupply = counter; 
        emit Add(_value);
    }
    
    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="144" endline="152" pcid="4081">
    function setTokenExchangeRate(uint256 _tokenExchangeRate) isOwner external {
        if (_tokenExchangeRate == 0) throw;
        if (_tokenExchangeRate == tokenExchangeRate) throw;
 
        tokenExchangeRate = _tokenExchangeRate;
    }
 
    /// @dev 超发token处理
    function increaseSupply (uint256 _value) isOwner external {
</source>
<source file="systems/smart_contracts/BermToken.sol" startline="169" endline="178" pcid="1150">
    function decreaseSupply (uint256 _value) isOwner external {
        uint256 value = formatDecimals(_value);
        if (value + tokenRaised > currentSupply) throw;

        currentSupply = safeSubtract(currentSupply, value);
        DecreaseSupply(value);
    }

    /// @dev turn on the funding state
    function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {
</source>
<source file="systems/smart_contracts/BermToken.sol" startline="161" endline="169" pcid="1149">
    function increaseSupply (uint256 _value) isOwner external {
        uint256 value = formatDecimals(_value);
        if (value + currentSupply > totalSupply) throw;
        currentSupply = safeAdd(currentSupply, value);
        IncreaseSupply(value);
    }

    /// @dev decrease the token's supply
    function decreaseSupply (uint256 _value) isOwner external {
</source>
<source file="systems/smart_contracts/BermToken.sol" startline="153" endline="161" pcid="1148">
    function setTokenExchangeRate(uint256 _tokenExchangeRate) isOwner external {
        if (_tokenExchangeRate == 0) throw;
        if (_tokenExchangeRate == tokenExchangeRate) throw;

        tokenExchangeRate = _tokenExchangeRate;
    }

    /// @dev increase the token's supply
    function increaseSupply (uint256 _value) isOwner external {
</source>
<source file="systems/smart_contracts/GNB.sol" startline="315" endline="323" pcid="4142">
	function totalSupplyIncrease(uint256 _supply) public onlyOwner{
		_totalSupply = _totalSupply + _supply;
		balances[msg.sender] = balances[msg.sender] + _supply;
	}
	
	// ------------------------------------------------------------------------
    // Owner can add blacklist the wallet address.
    // ------------------------------------------------------------------------
	function blacklisting(address _addr) public onlyOwner{
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="651" endline="661" pcid="7214">
    function burn(uint256 _value) public onlyOwner {
        require(_value <= _balances[msg.sender], "ERC20Burnable: not enough token balance");
        // no need to require value <= totalSupply, since that would imply the
        // sender's balance is greater than the totalSupply, which *should* be an assertion failure

        _balances[msg.sender] = _balances[msg.sender].sub(_value);
        _totalSupply = _totalSupply.sub(_value);
        emit Burn(msg.sender, _value);
        emit Transfer(msg.sender, address(0), _value);
    }
}
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="300" endline="305" pcid="3539">
    function withdraw(uint256 _wdamount) onlyOwner public {
        uint256 wantAmount = _wdamount;
        owner.transfer(wantAmount);
    }

    function burn(uint256 _value) onlyOwner public {
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="305" endline="314" pcid="3540">
    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        emit Burn(burner, _value);
    }
    
    function add(uint256 _value) onlyOwner public {
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="314" endline="320" pcid="3541">
    function add(uint256 _value) onlyOwner public {
        uint256 counter = totalSupply.add(_value);
        totalSupply = counter; 
        emit Add(_value);
    }
    
    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
</source>
<source file="systems/smart_contracts/UtilityTokenFactory.sol" startline="28" endline="33" pcid="7591">
    function setPrice(uint256 _price) external onlyOwner {
        require(_price > 0, "Price cannot be 0");
        price = _price;
    }

    function createToken(string _symbol, string _name, uint256 _initialSupply, uint8 _decimals, bool _mintable, bool _burnable) external {
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="224" endline="234" pcid="2897">
	function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        
        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        emit Burn(burner, _value);
    }
	
	function burnFrom(uint256 _value, address _burner) onlyOwner public {
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="975" endline="979" pcid="199">
	function forging(uint256 _msm) public enabled {
        return impl.impl_forging(msg.sender, _msm);
    }
    
    function purchase(bool _wantDividend, bool _nonInvate, bytes32 _channel, bytes32 _recommendation) public payable enabled {
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="150" endline="159" pcid="7967">
    function setTokenExchangeRate(uint256 _tokenExchangeRate) isOwner external {
        if (_tokenExchangeRate == 0) throw;
        if (_tokenExchangeRate == tokenExchangeRate) throw;
 
        tokenExchangeRate = _tokenExchangeRate;
    }
 
 
    /// @dev decrease the token's supply
    function decreaseSupply (uint256 _value) isOwner external {
</source>
<source file="systems/smart_contracts/XGP.sol" startline="266" endline="276" pcid="8125">
    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        
        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        emit Burn(burner, _value);
    }
    
    function withdrawAltcoinTokens(address _tokenContract) onlyOwner public returns (bool) {
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="304" endline="309" pcid="2972">
    function withdraw(uint256 _wdamount) onlyOwner public {
        uint256 wantAmount = _wdamount;
        owner.transfer(wantAmount);
    }

    function burn(uint256 _value) onlyOwner public {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="606" endline="617" pcid="929">
    function setNewThreshold(uint256 _newThreshold) external onlyWLManagers {
        require(whitelistThresholdBalance != _newThreshold, "New Threshold like the old one!");
        whitelistThresholdBalance = _newThreshold;
        emit LogWLThresholdBalanceChanged();
    }

    /**
     * @dev Change maxAmount for holder
     * @param _subscriber The subscriber in the whitelist.
     * @param _newMaxToken New max amount that a subscriber can hold (in set tokens).
     */
    function changeMaxWLAmount(address _subscriber, uint256 _newMaxToken) external onlyWLOperators {
</source>
<source file="systems/smart_contracts/BlackJack.sol" startline="376" endline="384" pcid="1357">
    function withdrawFunds(uint256 amount) public onlyOwner {
        require(amount <= address(this).balance.sub(_totalBalance), "Not enough funds.");
        msg.sender.transfer(amount);
    }

    /**
    * @dev kill this contract while upgraded.
     */
    function kill() public onlyOwner {
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="309" endline="318" pcid="2973">
    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        emit Burn(burner, _value);
    }
    
    function add(uint256 _value) onlyOwner public {
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="318" endline="324" pcid="2974">
    function add(uint256 _value) onlyOwner public {
        uint256 counter = totalSupply.add(_value);
        totalSupply = counter; 
        emit Add(_value);
    }
    
    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="285" endline="297" pcid="6704">
    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        // no need to require value <= totalSupply, since that would imply the
        // sender's balance is greater than the totalSupply, which *should* be an assertion failure

        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        emit Burn(burner, _value);
    }
    
    function withdrawAltcoinTokens(address _tokenContract) onlyOwner public returns (bool) {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="230" endline="245" pcid="5677">
  function initialize(uint256 _parentBlockInterval) public initializer {
    // init genesis preiod
    Period memory genesisPeriod = Period({
      height: 1,
      timestamp: uint32(block.timestamp),
      parentBlockNumber: uint32(block.number),
      parentBlockHash: blockhash(block.number-1)
    });
    tipHash = GENESIS;
    periods[GENESIS] = genesisPeriod;
    genesisBlockNumber = block.number;
    parentBlockInterval = _parentBlockInterval;
    operator = msg.sender;
  }

  function setOperator(address _operator) public ifAdmin {
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="152" endline="160" pcid="4082">
    function increaseSupply (uint256 _value) isOwner external {
        uint256 value = formatDecimals(_value);
        if (value + currentSupply > totalSupply) throw;
        currentSupply = safeAdd(currentSupply, value);
        IncreaseSupply(value);
    }
 
    /// @dev 被盗token处理
    function decreaseSupply (uint256 _value) isOwner external {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="996" endline="1008" pcid="3893">
    function changeTokenExchangeOnTopRate(uint256 newExchRate) external onlyFundingOperators {
        require(newExchRate > 0, "Wrong exchange rate on top!");
        exchangeRateOnTop = newExchRate;
        emit TokenExchangeOnTopRateChanged();
    }


    /**
     * @dev Shows the amount of tokens the user will receive for amount of Seed token
     * @param _Amount Exchanged seed tokens amount to convert
     * @return The amount of token that will be received
     */
    function getTokenExchangeAmount(uint256 _Amount) internal view returns(uint256) {
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="254" endline="264" pcid="1293">
    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        
        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        emit Burn(burner, _value);
    }
    
    function withdrawAltcoinTokens(address _tokenContract) onlyOwner public returns (bool) {
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="318" endline="324" pcid="6571">
    function add(uint256 _value) onlyOwner public {
        uint256 counter = totalSupply.add(_value);
        totalSupply = counter; 
        emit Add(_value);
    }
    
    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="309" endline="318" pcid="6570">
    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        emit Burn(burner, _value);
    }
    
    function add(uint256 _value) onlyOwner public {
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="304" endline="309" pcid="6569">
    function withdraw(uint256 _wdamount) onlyOwner public {
        uint256 wantAmount = _wdamount;
        owner.transfer(wantAmount);
    }

    function burn(uint256 _value) onlyOwner public {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="987" endline="996" pcid="3892">
    function changeTokenExchangeRate(uint256 newExchRate) external onlyFundingOperators {
        require(newExchRate > 0, "Wrong exchange rate!");
        exchangeRateSeed = newExchRate;
        emit TokenExchangeRateChanged();
    }

    /**
     * @dev operator members can change the rate exchange on top of the set
     */
    function changeTokenExchangeOnTopRate(uint256 newExchRate) external onlyFundingOperators {
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="322" endline="329" pcid="6505">
    function add(uint256 _value) onlyOwner public {
        uint256 counter = totalSupply.add(_value);
        totalSupply = counter; 
        emit Add(_value);
    }
    
    
    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
</source>
<source file="systems/smart_contracts/Dividends.sol" startline="69" endline="72" pcid="2780">
    function payDividends(uint256 amount) public onlyOwner {
        emit DividendsPaid(amount);
    }
}
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="313" endline="322" pcid="6504">
    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        emit Burn(burner, _value);
    }
    
    function add(uint256 _value) onlyOwner public {
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="308" endline="313" pcid="6503">
    function withdraw(uint256 _wdamount) onlyOwner public {
        uint256 wantAmount = _wdamount;
        owner.transfer(wantAmount);
    }

    function burn(uint256 _value) onlyOwner public {
</source>
<source file="systems/smart_contracts/BKN.sol" startline="103" endline="109" pcid="1330">
    function burn(uint256 wad) public onlyOwner {
        require (wad > 0);
        _balances[msg.sender] = _balances[msg.sender] - wad;
        totalSupply = totalSupply - wad;
        emit Burn(wad);
    }
}
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="224" endline="234" pcid="8031">
	function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        
        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        emit Burn(burner, _value);
    }
	
	function burnFrom(uint256 _value, address _burner) onlyOwner public {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="553" endline="561" pcid="4769">
    function setTargetPrice(uint256 wad)
        public
        onlyOwner
    {
        require(wad > 0, "INVALID_RIG_PRICE");
        targetPrice = wad;
    }

    function pay(uint256 wad)
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="504" endline="516" pcid="7375">
    function setRate(uint256 newRate) external onlyOwner {
        require(isWeiAccepted, "Sale must allow Wei for purchases to set a rate for Wei!");
        require(newRate != 0, "ETH rate must be more than 0!");

        emit TokenRateChanged(rate, newRate);
        rate = newRate;
    }

    /**
     * @dev change crowdsale STAR rate
     * @param newStarRate Figure that corresponds to the new STAR rate per token
     */
    function setStarRate(uint256 newStarRate) external onlyOwner {
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="377" endline="385" pcid="8095">
  function withdrawEther(uint256 amount) onlyOwner public {
    owner().transfer(amount);
  }
  
  /**
   * @dev accept ether
   * 
   */
  function() public payable {
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="311" endline="316" pcid="1455">
    function withdraw(uint256 _wdamount) onlyOwner public {
        uint256 wantAmount = _wdamount;
        owner.transfer(wantAmount);
    }

    function burn(uint256 _value) onlyOwner public {
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="316" endline="325" pcid="1456">
    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        emit Burn(burner, _value);
    }
    
    function add(uint256 _value) onlyOwner public {
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="325" endline="331" pcid="1457">
    function add(uint256 _value) onlyOwner public {
        uint256 counter = totalSupply.add(_value);
        totalSupply = counter; 
        emit Add(_value);
    }
    
    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="516" endline="526" pcid="7376">
    function setStarRate(uint256 newStarRate) external onlyOwner {
        require(newStarRate != 0, "Star rate must be more than 0!");

        emit TokenStarRateChanged(starRate, newStarRate);
        starRate = newStarRate;
    }

    /**
     * @dev allows sale to receive wei or not
     */
    function setIsWeiAccepted(bool _isWeiAccepted, uint256 _rate) external onlyOwner {
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="159" endline="168" pcid="7968">
    function decreaseSupply (uint256 _value) isOwner external {
        uint256 value = formatDecimals(_value);
        if (value + tokenRaised > currentSupply) throw;
 
        currentSupply = safeSubtract(currentSupply, value);
        DecreaseSupply(value);
    }
 
   /// @dev turn on the funding state
    function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="506" endline="511" pcid="3587">
    function burn(uint256 value) public onlyAdmin {
        _burn(msg.sender, value);
    }

    /// @dev Admin-only function to recover any tokens mistakenly sent to this contract
    function recoverERC20Tokens(address _contractAddress) external onlyAdmin  {
</source>
<source file="systems/smart_contracts/Bridge.sol" startline="223" endline="238" pcid="1512">
  function initialize(uint256 _parentBlockInterval) public initializer {
    // init genesis preiod
    Period memory genesisPeriod = Period({
      height: 1,
      timestamp: uint32(block.timestamp),
      parentBlockNumber: uint32(block.number),
      parentBlockHash: blockhash(block.number-1)
    });
    tipHash = GENESIS;
    periods[GENESIS] = genesisPeriod;
    genesisBlockNumber = block.number;
    parentBlockInterval = _parentBlockInterval;
    operator = msg.sender;
  }

  function setOperator(address _operator) public ifAdmin {
</source>
<source file="systems/smart_contracts/Aigopay.sol" startline="266" endline="276" pcid="468">
    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        
        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        emit Burn(burner, _value);
    }
    
    function withdrawAltcoinTokens(address _tokenContract) onlyOwner public returns (bool) {
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="160" endline="169" pcid="4083">
    function decreaseSupply (uint256 _value) isOwner external {
        uint256 value = formatDecimals(_value);
        if (value + tokenRaised > currentSupply) throw;
 
        currentSupply = safeSubtract(currentSupply, value);
        DecreaseSupply(value);
    }
 
    ///  启动区块检测 异常的处理
    function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1219" endline="1228" pcid="1815">
    function withdraw(address payable payee) public onlyPrimary {
        uint256 payment = _deposits[payee];

        _deposits[payee] = 0;

        payee.transfer(payment);

        emit Withdrawn(payee, payment);
    }
}
</source>
<source file="systems/smart_contracts/EJackpot.sol" startline="432" endline="437" pcid="2924">
    function withdraw(uint amount) external onlyOwner {
        require(address(this).balance >= amount);
        msg.sender.transfer(amount);
    }

    function random() private view returns (uint8) {
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="58" endline="62" pcid="3695">
function requireNotZero(uint val) internal pure {
require(val != 0, "require not zero value");
}

function notZero(address addr) internal pure returns(bool) {
</source>
<source file="systems/smart_contracts/Discover.sol" startline="74" endline="88" pcid="2761">
    function setCeiling(uint _newCeiling) external onlyController {
        emit CeilingUpdated(ceiling, _newCeiling);

        ceiling = _newCeiling;
        max = total.mul(ceiling).div(decimals);
        safeMax = uint(77).mul(max).div(100);
    }

    /**
     * @dev Anyone can create a DApp (i.e an arb piece of data this contract happens to care about).
     * @param _id bytes32 unique identifier.
     * @param _amount of tokens to stake on initial ranking.
     * @param _metadata metadata hex string
     */
    function createDApp(bytes32 _id, uint _amount, bytes32 _metadata) external {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="1229" endline="1243" pcid="4913">
  function updateRate(uint newOneTokenInWei) public onlyOwner {
    assert(!finalized);
    assert(isUpdatable);
    assert(now <= startsAt);

    CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());
    assert(!lastTierCntrct.finalized());

    pricingStrategy.updateRate(newOneTokenInWei);
  }

  /**
   * Dynamically create tokens and assign them to the investor.
   */
  function assignTokens(address receiver, uint tokenAmount) private {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="1217" endline="1229" pcid="4912">
  function setMaximumSellableTokens(uint tokens) public onlyOwner {
    assert(!finalized);
    assert(isUpdatable);
    assert(now <= startsAt);

    CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());
    assert(!lastTierCntrct.finalized());

    maximumSellableTokens = tokens;
    MaximumSellableTokensChanged(maximumSellableTokens);
  }

  function updateRate(uint newOneTokenInWei) public onlyOwner {
</source>
<source file="systems/smart_contracts/c_Bank.sol" startline="9" endline="19" pcid="1602">
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,"Put");
    }

    function Collect(uint _am)
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="446" endline="450" pcid="754">
    function burn(uint value) public onlyOwner {
        _burn(msg.sender, value);
    }

    function mint(address to, uint value) public onlyOwner { 
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="236" endline="240" pcid="2326">
    function burn(uint value) public onlyOwner {
        _burn(msg.sender, value);
    }

    function mint(address to, uint value) public onlyOwner { 
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="316" endline="323" pcid="1910">
    function withdrawEtherFromcontract(uint _amountInwei) public onlyOwner{
      require(address(this).balance > _amountInwei);
      require(isOwner());
      msg.sender.transfer(_amountInwei);
      
    }
    
    function withdrawTokenFromcontract(ERC20 _token, uint256 _tamount) public onlyOwner{
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="2194" endline="2207" pcid="6900">
    function setIssuanceRatio(uint _issuanceRatio)
        external
        onlyOwner
    {
        require(_issuanceRatio <= MAX_ISSUANCE_RATIO, "New issuance ratio cannot exceed MAX_ISSUANCE_RATIO");
        issuanceRatio = _issuanceRatio;
        emit IssuanceRatioUpdated(_issuanceRatio);
    }

    /**
     * @notice Import issuer data from the old Synthetix contract before multicurrency
     * @dev Only callable by the contract owner, and only for 1 week after deployment.
     */
    function importIssuerData(address[] accounts, uint[] sUSDAmounts)
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="916" endline="927" pcid="5190">
    function appeal(uint _transactionID) public payable {
        Transaction storage transaction = transactions[_transactionID];

        arbitrator.appeal.value(msg.value)(transaction.disputeId, arbitratorExtraData);
    }

    /** @dev Give a ruling for a dispute. Must be called by the arbitrator to enforce the final ruling.
     *  The purpose of this function is to ensure that the address calling it has the right to rule on the contract.
     *  @param _disputeID ID of the dispute in the Arbitrator contract.
     *  @param _ruling Ruling given by the arbitrator. Note that 0 is reserved for "Not able/wanting to make a decision".
     */
    function rule(uint _disputeID, uint _ruling) public {
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="543" endline="546" pcid="6816">
    function mineTechPoll(uint value) public onlyOwner {
        _minePoll(techPoll, value);
    }
}
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="540" endline="543" pcid="6815">
    function mineCommunityPoll(uint value) public onlyOwner {
        _minePoll(communityPoll, value);
    }
    function mineTechPoll(uint value) public onlyOwner {
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="537" endline="540" pcid="6814">
    function mineBusinessPoll(uint value) public onlyOwner {
        _minePoll(businessPoll, value);
    }
    function mineCommunityPoll(uint value) public onlyOwner {
</source>
<source file="systems/smart_contracts/Piggy_Bank.sol" startline="9" endline="19" pcid="5658">
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,"Put");
    }

    function Collect(uint _am)
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="264" endline="271" pcid="1904">
    function withdrawEtherFromcontract(uint _amountInwei) public onlyOwner{
      require(address(this).balance > _amountInwei);
      require(isOwner());
      msg.sender.transfer(_amountInwei);
      
    }
    
}
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="478" endline="495" pcid="5115">
    function addNewbond(uint _price) 
        onlyOwner()
        public
    {
        require(nextAvailableBond < maxBonds);
        bondPrice[nextAvailableBond] = _price;
        bondOwner[nextAvailableBond] = dev;
        totalBondDivs[nextAvailableBond] = 0;
        bondPreviousPrice[nextAvailableBond] = 0;
        bondDeadline[nextAvailableBond] = SafeMath.add(block.number,bondDeadlineInc);
        nextAvailableBond = nextAvailableBond + 1;
        
        getTotalBondValue();
     
    }


    function setAllowReferral(bool _allowReferral)   
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="381" endline="391" pcid="6612">
	function assertOperationIsConsistent(bytes32 _operation) private view {
		MultiOwnedOperationPendingState storage pending = m_multiOwnedPending[_operation];
		assert(0 != pending.yetNeeded);
		assert(m_multiOwnedPendingIndex[pending.index] == _operation);
		assert(pending.yetNeeded <= m_multiOwnedRequired);
	}


	// FIELDS

	uint256 constant c_maxOwners = 250;
</source>
<source file="systems/smart_contracts/TrueProfileLogic.sol" startline="102" endline="115" pcid="7496">
    function deleteSignature(bytes32 _key) accessible external {
        require(signatureStorage[_key].isValue);
        Signature memory tempSignature = Signature({
            v: 0,
            r: bytes32(0),
            s: bytes32(0),
            revocationReasonId: 0,
            isValue: false
        });
        signatureStorage[_key] = tempSignature;
    }

    /**** Get Methods for additional storage ****/
    function getAddress(bytes32 _key) external view returns (address) {
</source>
</class>

<class classid="24" nclones="256" nlines="4" similarity="75">
<source file="systems/smart_contracts/$martFund.sol" startline="160" endline="166" pcid="49">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnerUpdate(owner, newOwner);
        owner = newOwner;
        newOwner = address(0x0);
    }
}
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1118" endline="1121" pcid="1810">
    function _finalization() internal {
        // solhint-disable-previous-line no-empty-blocks
    }
}
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="135" endline="139" pcid="3553">
    function renounceAdmin() public {
        _removeAdmin(msg.sender);
    }

    function _addAdmin(address account) internal {
</source>
<source file="systems/smart_contracts/SapientiaCharlesToken.sol" startline="92" endline="98" pcid="6279">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/VOTENOmodumtokenswapdotcom.sol" startline="93" endline="99" pcid="7841">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/customIcoToken.sol" startline="149" endline="160" pcid="2221">
    function finalize() external {
      require(isFinalized == false);
      require(msg.sender == ethFundDeposit);
      require(totalSupply > tokenCreationMin); // have to sell minimum to move to operational
      require(block.number > fundingEndBlock || totalSupply == tokenCreationCap);
      // move to operational
      isFinalized = true;
      assert(ethFundDeposit.send(address(this).balance)); // send the eth
    }

    /// @dev Allows contributors to recover their ether in the case of a failed funding campaign.
    function refund() external {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="331" endline="334" pcid="2682">
    function _finalization() internal {

    }
}
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="175" endline="179" pcid="3558">
    function renouncePauser() public {
        _removePauser(msg.sender);
    }

    function _addPauser(address account) internal {
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="198" endline="206" pcid="7756">
  function Ownable() public {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/FixedSupplyToken.sol" startline="92" endline="98" pcid="3608">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/WanCoinSupplyToken.sol" startline="78" endline="84" pcid="7863">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/AdminUpgradeabilityProxy.sol" startline="69" endline="73" pcid="352">
    function _fallback() internal {
        _willFallback();
        _delegate(_implementation());
    }
}
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="96" endline="106" pcid="3420">
    function Exzie() public {
        symbol = "EXZ";
        name = "Exzie";
        decimals = 18;
        _totalSupply = 2000000000000000000000000;
        balances[0xd81fe1115652d04d6b7c48f5e2ed5a615297852d] = _totalSupply;
        Transfer(address(0), 0xd81fe1115652d04d6b7c48f5e2ed5a615297852d, _totalSupply);
    }


    function totalSupply() public constant returns (uint) {
</source>
<source file="systems/smart_contracts/FMT.sol" startline="163" endline="170" pcid="3659">
  function Ownable() public {
    owner = msg.sender;
  }

  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="571" endline="575" pcid="974">
    function renouncePauser() public {
        _removePauser(msg.sender);
    }

    function _addPauser(address account) internal {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="571" endline="575" pcid="2487">
    function renouncePauser() public {
        _removePauser(msg.sender);
    }

    function _addPauser(address account) internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="335" endline="338" pcid="2591">
    function _finalization() internal {

    }
}
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="96" endline="106" pcid="1231">
    function BitcoinDigital() public {
        symbol = "BTCD";
        name = "Bitcoin Digital";
        decimals = 3;
        _totalSupply = 360000000000;
        balances[0xf767Cb0B357917CEFEfC5d8D313570CfFd56989F] = _totalSupply;
        Transfer(address(0), 0xf767Cb0B357917CEFEfC5d8D313570CfFd56989F, _totalSupply);
    }


    function totalSupply() public constant returns (uint) {
</source>
<source file="systems/smart_contracts/FMT.sol" startline="264" endline="272" pcid="3665">
  function FMT() public {
    uint256 reserve = SafeMath.mul(30000000, multiplicator);
    owner = msg.sender;
    totalSupply = totalSupply.add(reserve);
    balances[owner] = balances[owner].add(reserve);
    Transfer(address(0), owner, reserve);
  }

  function() external payable {
</source>
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="108" endline="115" pcid="233">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }

}
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="77" endline="83" pcid="3419">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="230" endline="234" pcid="3717">
function disown() internal {
delete owner;
}

}
</source>
<source file="systems/smart_contracts/BermToken.sol" startline="207" endline="224" pcid="1155">
    function migrate() external {
        if(isFunding) throw;
        if(newContractAddr == address(0x0)) throw;

        uint256 tokens = balances[msg.sender];
        if (tokens == 0) throw;

        balances[msg.sender] = 0;
        tokenMigrated = safeAdd(tokenMigrated, tokens);

        IMigrationContract newContract = IMigrationContract(newContractAddr);
        if (!newContract.migrate(msg.sender, tokens)) throw;

        Migrate(msg.sender, tokens);               // log it
    }

    /// @dev sends ETH to Berm team
    function transferETH() isOwner external {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="171" endline="175" pcid="6318">
    function renounceMinter() public {
        _removeMinter(msg.sender);
    }

    function _addMinter(address account) internal {
</source>
<source file="systems/smart_contracts/DGC.sol" startline="92" endline="98" pcid="2523">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="394" endline="398" pcid="1389">
    function renouncePauser() public {
        _removePauser(msg.sender);
    }

    function _addPauser(address account) internal {
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="265" endline="267" pcid="7353">
  function finalization() internal {
  }
}
</source>
<source file="systems/smart_contracts/Perlin.sol" startline="122" endline="135" pcid="5648">
    function Perlin() public {
        symbol = "PERL";
        name = "Perlin";
        decimals = 18;
        bonusEnds = now + 1 weeks;
        endDate = now + 7 weeks;

    }


    // ------------------------------------------------------------------------
    // Total supply
    // ------------------------------------------------------------------------
    function totalSupply() public constant returns (uint) {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="499" endline="503" pcid="8253">
    function renounceMinter() public {
        _removeMinter(msg.sender);
    }

    function _addMinter(address account) internal {
</source>
<source file="systems/smart_contracts/CGT.sol" startline="92" endline="98" pcid="1693">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="77" endline="83" pcid="1254">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="232" endline="235" pcid="2579">
    function _forwardFunds() internal {
        _wallet.transfer(msg.value);
    }
}
</source>
<source file="systems/smart_contracts/RETC.sol" startline="86" endline="91" pcid="6183">
     function RETC () public {
        owner = msg.sender;
  
        balances[owner] = totalSupply;
    }
     function nowInSeconds() public view returns (uint256){
</source>
<source file="systems/smart_contracts/Perlin.sol" startline="93" endline="99" pcid="5647">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="65" endline="69" pcid="3417">
    function Owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="178" endline="188" pcid="1725">
    function Cholyz() public {
        totalSupply = INITIAL_SUPPLY;
        owner = msg.sender;
        
        balances[owner] = INITIAL_SUPPLY;
        tokenAllocated = 0;
        transfersEnabled = true;
    }

    
    function() payable public {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="278" endline="292" pcid="7800">
    function acceptOwnership() public {
        require(msg.sender == _newOwner, "Ownable: caller is not the new owner address");
        require(msg.sender != address(0), "Ownable: caller is the zero address");

        emit OwnershipAccepted(_owner, msg.sender);
        _owner = msg.sender;
        _newOwner = address(0);
    }

    /**
     * @dev Rescue compatible ERC20 Token
     *
     * Can only be called by the current owner.
     */
    function rescueTokens(address tokenAddr, address recipient, uint256 amount) external onlyOwner {
</source>
<source file="systems/smart_contracts/Perlin.sol" startline="81" endline="85" pcid="5645">
    function Owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
</source>
<source file="systems/smart_contracts/WanCoinToken.sol" startline="78" endline="84" pcid="7885">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/DaiSwap.sol" startline="70" endline="79" pcid="2291">
    function withdraw() public {
        uint dai = safeMul(daiposit[msg.sender],  daiContract.balanceOf(address(this))) / totaldai;
        uint usd = safeMul(daiposit[msg.sender], usdContract.balanceOf(address(this))) / totaldai;
        totaldai = safeSub(totaldai, daiposit[msg.sender]);
        daiposit[msg.sender] = 0;
        daiContract.transfer(msg.sender, dai);
        usdContract.transfer(msg.sender, usd);
    }
    
    function calcSwapForUSD(uint dai) public view returns (uint) {
</source>
<source file="systems/smart_contracts/PAYCASH.sol" startline="118" endline="131" pcid="5618">
     function PAYCASH() public {
        symbol = "PCSH";
        name = "PAYCASH";
        decimals = 18;
        _totalSupply = 200000000;
        balances[0xAF31516e4B8A79518B8ad3bb7BEBb6b68CbC99A8] = _totalSupply;
        emit Transfer(address(0), 0xAF31516e4B8A79518B8ad3bb7BEBb6b68CbC99A8, _totalSupply);
    }


    // ------------------------------------------------------------------------
    // Total supply
    // ------------------------------------------------------------------------
    function totalSupply() public constant returns (uint) {
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="77" endline="83" pcid="1230">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/SBC.sol" startline="211" endline="215" pcid="6323">
    function renouncePauser() public {
        _removePauser(msg.sender);
    }

    function _addPauser(address account) internal {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1427" endline="1430" pcid="1829">
    function _forwardFunds() internal {
        _escrow.deposit.value(msg.value)(msg.sender);
    }
}
</source>
<source file="systems/smart_contracts/AronCoin.sol" startline="198" endline="206" pcid="772">
  function Ownable() public {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/Exchange.sol" startline="328" endline="337" pcid="3390">
    function deposit() payable {
        //tokens[address(0)][msg.sender] = safeAdd(tokens[address(0)][msg.sender], msg.value); // adds the deposited amount to user balance
        addBalance(address(0), msg.sender, msg.value); // adds the deposited amount to user balance
        if (userFirstDeposits[msg.sender] == 0) userFirstDeposits[msg.sender] = block.number;
        lastActiveTransaction[msg.sender] = block.number; // sets the last activity block for the user
        emit Deposit(address(0), msg.sender, msg.value, balanceOf(address(0), msg.sender)); // fires the deposit event
    }

    // Deposit ETH to contract for a user
    function depositForUser(address user) payable {
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="96" endline="106" pcid="1309">
    function Bitrix() public {
        symbol = "BTC8cc";
        name = "Bitrix";
        decimals = 18;
        _totalSupply = 70000000000000000000000000000;
        balances[0x2EA0410D66a429e6A2AAE9d88e03cFa056259EB7] = _totalSupply;
        Transfer(address(0), 0x2EA0410D66a429e6A2AAE9d88e03cFa056259EB7, _totalSupply);
    }


    function totalSupply() public constant returns (uint) {
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="65" endline="69" pcid="1252">
    function Owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="759" endline="767" pcid="3755">
function nextWave() private {
m_investors = new InvestorsStorage();
investmentsNumber = 0;
waveStartup = now;
m_rgp.startAt(now);
emit LogRGPInit(now , m_rgp.startTimestamp, m_rgp.maxDailyTotalInvestment, m_rgp.activityDays);
emit LogNextWave(now);
}
}
</source>
<source file="systems/smart_contracts/PAYCASH.sol" startline="92" endline="98" pcid="5617">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="325" endline="335" pcid="2590">
    function finalize() public {
        require(!_finalized, "FinalizableCrowdsale: already finalized");
        require(hasClosed(), "FinalizableCrowdsale: not closed");

        _finalized = true;

        _finalization();
        emit CrowdsaleFinalized();
    }

    function _finalization() internal {
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="102" endline="116" pcid="5814">
    function PRIT() public {
        symbol = "PRIT";
        name = "Pritchardia Ltd";
        decimals = 8;
        _totalSupply = 	12000000000000000;
        balances[0x6100388A3e83A9EF1500Cb76D08048cB5ebaAEc2] = _totalSupply;
        Transfer(address(0), 0x6100388A3e83A9EF1500Cb76D08048cB5ebaAEc2, _totalSupply);
        
    }


    // ------------------------------------------------------------------------
    // Total supply
    // ------------------------------------------------------------------------
    function totalSupply() public view returns (uint) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="889" endline="892" pcid="1797">
    function _forwardFunds() internal {
        _wallet.transfer(msg.value);
    }
}
</source>
<source file="systems/smart_contracts/CRYPTOMZ.sol" startline="54" endline="62" pcid="2176">
  function Constructor() public {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/Ownable.sol" startline="45" endline="49" pcid="5569">
  function Ownable() public {
    owner = msg.sender;
  }

  modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/VENT.sol" startline="24" endline="30" pcid="7675">
        function acceptOwnership() public {
            require(msg.sender == newOwner);
            emit OwnershipTransferred(owner, newOwner);
            owner = newOwner;
            newOwner = address(0);
        }
    }
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="888" endline="896" pcid="561">
    function release() public {
        super.release(token);
    }


     /**
     * @return the token being held.
     */
    function tokenAddress() public view returns (IERC20) {
</source>
<source file="systems/smart_contracts/OSManagerToken.sol" startline="61" endline="67" pcid="5555">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/OBK.sol" startline="24" endline="32" pcid="5467">
    function OBK() public {
        balances[msg.sender] = 1000000000000;               // Give the creator all initial tokens
        totalSupply = 1000000000000;                        // Update total supply
        name = "OurBank";                                   // Set the name for display purposes
        decimals =4;                            // Amount of decimals for display purposes
        symbol = "OBK";                               // Set the symbol for display purposes
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="238" endline="252" pcid="5354">
    function acceptOwnership() public {
        require(msg.sender == _newOwner, "Ownable: caller is not the new owner address");
        require(msg.sender != address(0), "Ownable: caller is the zero address");

        emit OwnershipAccepted(_owner, msg.sender);
        _owner = msg.sender;
        _newOwner = address(0);
    }

    /**
     * @dev Rescue compatible ERC20 Token
     *
     * Can only be called by the current owner.
     */
    function rescueTokens(address tokenAddr, address recipient, uint256 amount) external onlyOwner {
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="532" endline="536" pcid="331">
    function renouncePauser() public {
        _removePauser(msg.sender);
    }

    function _addPauser(address account) internal {
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="673" endline="677" pcid="344">
    function renounceMinter() public {
        _removeMinter(msg.sender);
    }

    function _addMinter(address account) internal {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="402" endline="411" pcid="6842">
    function acceptOwnership()
        external
    {
        require(msg.sender == nominatedOwner, "You must be nominated before you can accept ownership");
        emit OwnerChanged(owner, nominatedOwner);
        owner = nominatedOwner;
        nominatedOwner = address(0);
    }

    modifier onlyOwner
</source>
<source file="systems/smart_contracts/MyAdvancedToken.sol" startline="10" endline="14" pcid="5259">
    function owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="113" endline="127" pcid="408">
    function Anthology() public {
        symbol = "AHLE";
        name = "Anthology Holdings Coin";
        decimals = 8;
        _totalSupply = 	12000000000000000;
        balances[0x6100388A3e83A9EF1500Cb76D08048cB5ebaAEc2] = _totalSupply;
        Transfer(address(0), 0x6100388A3e83A9EF1500Cb76D08048cB5ebaAEc2, _totalSupply);
        
    }


    // ------------------------------------------------------------------------
    // Total supply
    // ------------------------------------------------------------------------
    function totalSupply() public view returns (uint) {
</source>
<source file="systems/smart_contracts/BatchTransfer.sol" startline="14" endline="18" pcid="1085">
    function BatchTransfer() public{
        owner=msg.sender;
    }
    
    function changeOwner(address _newOwner) onlyOwner{
</source>
<source file="systems/smart_contracts/multifund.sol" startline="41" endline="47" pcid="5139">
    function clear() public
    {
        require(msg.sender == owner);
        selfdestruct(owner);
    }

    function get_id() public view returns(bytes32){
</source>
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="347" endline="361" pcid="496">
    function release() public {
        // solhint-disable-next-line not-rely-on-time
        require(block.timestamp >= _releaseTime, "TokenTimelock: current time is before release time");

        uint256 amount = _token.balanceOf(address(this));
        require(amount > 0, "TokenTimelock: no tokens to release");

        _token.safeTransfer(_beneficiary, amount);
    }

     /**
     * @return change the beneficiary of tokens
     */

    function _changeBeneficiary(address _newBeneficiary) internal {
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="75" endline="79" pcid="405">
    function Owned2() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="501" endline="505" pcid="2612">
    function renounceMinter() public {
        _removeMinter(msg.sender);
    }

    function _addMinter(address account) internal {
</source>
<source file="systems/smart_contracts/multifind.sol" startline="41" endline="47" pcid="5084">
    function clear() public
    {
        require(msg.sender == owner);
        selfdestruct(owner);
    }

    function get_id() public view returns(bytes32){
</source>
<source file="systems/smart_contracts/MpctLockupTeam.sol" startline="71" endline="75" pcid="5062">
    function MpctLockupTeam () public {
        token = ERC20Interface(tokenAddress);
    }

    function setLockupAmt(uint256 _amt) public onlyOwner {
</source>
<source file="systems/smart_contracts/ProxyERC20.sol" startline="78" endline="87" pcid="5876">
    function acceptOwnership()
        external
    {
        require(msg.sender == nominatedOwner, "You must be nominated before you can accept ownership");
        emit OwnerChanged(owner, nominatedOwner);
        owner = nominatedOwner;
        nominatedOwner = address(0);
    }

    modifier onlyOwner
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="161" endline="168" pcid="264">
    function Owned() public {

        owner = msg.sender;

    }


    modifier onlyOwner {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="3413" endline="3431" pcid="6956">
    function _appendAccountIssuanceRecord()
        internal
    {
        uint initialDebtOwnership;
        uint debtEntryIndex;
        (initialDebtOwnership, debtEntryIndex) = synthetixState.issuanceData(messageSender);

        feePool.appendAccountIssuanceRecord(
            messageSender,
            initialDebtOwnership,
            debtEntryIndex
        );
    }

    /**
     * @notice Remove a debt position from the register
     * @param amount The amount (in UNIT base) being presented in XDRs
     */
    function _removeFromDebtRegister(uint amount)
</source>
<source file="systems/smart_contracts/VACCToken.sol" startline="96" endline="102" pcid="7625">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="276" endline="282" pcid="2064">
    function confirmOwnership() public {
        require(candidate == msg.sender);
        owner = candidate;
        delete candidate;
    }

}
</source>
<source file="systems/smart_contracts/SistContract.sol" startline="204" endline="207" pcid="6529">
  function SistContract() public {
    balances[own] = totalSupply;
  }
}
</source>
<source file="systems/smart_contracts/CRYPTOMZ.sol" startline="253" endline="258" pcid="2191">
    function Constructor () public {
        totalSupply = initialSupply;
        balances[msg.sender] = initialSupply; // Send all tokens to owner
    }

}
</source>
<source file="systems/smart_contracts/SHPC.sol" startline="24" endline="32" pcid="6507">
    function SHPC() public {
        balances[msg.sender] = 10000000000000;               // Give the creator all initial tokens
        totalSupply = 10000000000000;                        // Update total supply
        name = "Smart Health Pension chain";                                   // Set the name for display purposes
        decimals =4;                            // Amount of decimals for display purposes
        symbol = "SHPC";                               // Set the symbol for display purposes
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="571" endline="575" pcid="6046">
    function renouncePauser() public {
        _removePauser(msg.sender);
    }

    function _addPauser(address account) internal {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="829" endline="833" pcid="7943">
    function _forwardFunds() internal {
        _wallet.transfer(msg.value);
    }

    function reClaimUnsoldTokens(address beneficiary, uint256 tokenAmount) onlyOwner public {
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="1048" endline="1051" pcid="212">
    function nop()public{
    }
	
    function tokenFallback(address _from, uint _value, bytes _data) public enabled2 returns(bool){
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="76" endline="82" pcid="5813">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="228" endline="231" pcid="2670">
    function _forwardFunds() internal {
        _wallet.transfer(msg.value);
    }
}
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="321" endline="331" pcid="2681">
    function finalize() public {
        require(!_finalized, "FinalizableCrowdsale: already finalized");
        require(hasClosed(), "FinalizableCrowdsale: not closed");

        _finalized = true;

        _finalization();
        emit CrowdsaleFinalized();
    }

    function _finalization() internal {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="497" endline="501" pcid="2703">
    function renounceMinter() public {
        _removeMinter(msg.sender);
    }

    function _addMinter(address account) internal {
</source>
<source file="systems/smart_contracts/MpctLockupTeam.sol" startline="39" endline="43" pcid="5058">
    function Ownable() public {
        owner = msg.sender;
    }

    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="65" endline="69" pcid="1306">
    function Owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="96" endline="106" pcid="1255">
    function BitDigit() public {
        symbol = "BTD";
        name = "BitDigit";
        decimals = 18;
        _totalSupply = 360000000000000000000000000000;
        balances[0xf767Cb0B357917CEFEfC5d8D313570CfFd56989F] = _totalSupply;
        Transfer(address(0), 0xf767Cb0B357917CEFEfC5d8D313570CfFd56989F, _totalSupply);
    }


    function totalSupply() public constant returns (uint) {
</source>
<source file="systems/smart_contracts/UNT.sol" startline="24" endline="32" pcid="7565">
    function UNT() public {
        balances[msg.sender] = 5000000000000;               // Give the creator all initial tokens
        totalSupply = 5000000000000;                        // Update total supply
        name = "Universal token";                                   // Set the name for display purposes
        decimals =4;                            // Amount of decimals for display purposes
        symbol = "UNT";                               // Set the symbol for display purposes
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ZhongChaChainToken.sol" startline="85" endline="91" pcid="8223">
    function ZhongChaChainToken()
        public
    {
        totalSupply = 1000000000 * 10**18;
        balances[msg.sender] = totalSupply;
    }
}
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="69" endline="75" pcid="2430">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="72" endline="78" pcid="8162">
    function acceptOwnership() external {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/Airdropper.sol" startline="10" endline="14" pcid="470">
  function Ownable() public {
    owner = msg.sender;
  }

  modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/FUNNYTOKEN.sol" startline="69" endline="75" pcid="3953">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="99" endline="112" pcid="7438">
    function TournamentGameToken() public {
        symbol = "ZUH";
        name = "Tournament Game Token";
        decimals =8;
        _totalSupply = 10000000000000000000;
        balances[0xe8c65075D4829E440C667a9ED56dc469eB510Ca2] = _totalSupply;
        Transfer(address(0), 0xd08F256fCB4C219cCCb38Bf7B6F384E148d1f936, _totalSupply);
    }


    // ------------------------------------------------------------------------
    // Total supply
    // ------------------------------------------------------------------------
    function totalSupply()  constant returns (uint ) {
</source>
<source file="systems/smart_contracts/XTRLPAY.sol" startline="93" endline="99" pcid="8139">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="73" endline="79" pcid="7437">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/Aigopay.sol" startline="126" endline="132" pcid="451">
    function Aigopay () public {
        owner = msg.sender;
        uint256 devTokens = 1000000e18;
        distr(owner, devTokens);
    }
    
    function transferOwnership(address newOwner) onlyOwner public {
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="61" endline="65" pcid="7435">
    function Owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="72" endline="76" pcid="4982">
    function renounceMinter() public {
        _removeMinter(msg.sender);
    }

    function _addMinter(address account) internal {
</source>
<source file="systems/smart_contracts/TeaToken.sol" startline="85" endline="91" pcid="7126">
    function TeaToken()
        public
    {
        totalSupply = 1000000000 * 10**18;
        balances[msg.sender] = totalSupply;
    }
}
</source>
<source file="systems/smart_contracts/MiniMeTokenFactory.sol" startline="66" endline="70" pcid="4803">
    function Controlled()  public { controller = msg.sender;}

    /// @notice Changes the controller of the contract
    /// @param _newController The new controller of the contract
    function changeController(address _newController) onlyController  public {
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="64" endline="68" pcid="5811">
    function Owned2() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
</source>
<source file="systems/smart_contracts/SolaToken.sol" startline="78" endline="84" pcid="6585">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="87" endline="93" pcid="407">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="77" endline="83" pcid="7554">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/GameGold.sol" startline="44" endline="50" pcid="3985">
  function confirmChangeOwnership() public {
    require(msg.sender == delegate);
    emit OwnershipTransferred(owner, delegate);
    owner = delegate;
    delegate = address(0);
  }
}
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="278" endline="282" pcid="3256">
    function renounceMinter() public {
        _removeMinter(msg.sender);
    }

    function _addMinter(address account) internal {
</source>
<source file="systems/smart_contracts/Melodic.sol" startline="93" endline="99" pcid="4790">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="65" endline="69" pcid="1228">
    function Owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1103" endline="1118" pcid="1809">
    function finalize() public {
        require(!_finalized, "FinalizableCrowdsale: already finalized");
        require(hasClosed(), "FinalizableCrowdsale: not closed");

        _finalized = true;

        _finalization();
        emit CrowdsaleFinalized();
    }

    /**
     * @dev Can be overridden to add finalization logic. The overriding function
     * should call super._finalization() to ensure the chain of finalization is
     * executed entirely.
     */
    function _finalization() internal {
</source>
<source file="systems/smart_contracts/customIcoToken.sol" startline="160" endline="174" pcid="2222">
    function refund() external {
      require(isFinalized == false);                       // prevents refund if operational
      require(block.number > fundingEndBlock); // prevents refund until sale period is over
      require(totalSupply < tokenCreationMin); // no refunds if we sold enough
      require(msg.sender != tokenFundDeposit);    // team not entitled to a refund
      uint256 tokenVal = balances[msg.sender];
      require(tokenVal > 0);
      balances[msg.sender] = 0;
      totalSupply = totalSupply.sub(tokenVal); // extra safe
      uint256 ethVal = tokenVal / tokenExchangeRate; // should be safe; previous throws covers edges
      emit LogRefund(msg.sender, ethVal); // log it
      assert(msg.sender.send(ethVal)); // if you're using a contract; make sure it works with .send gas limits
    }

    constructor(
</source>
<source file="systems/smart_contracts/EtheleToken.sol" startline="248" endline="258" pcid="3226">
    function unlock() public {
    	require(_lockedBalance[msg.sender] > 0, "EtheleToken: Require locked balance to unlock.");
    	updatePeriod(-1);

    	require(_unlockTime[msg.sender] < block.timestamp, "EtheleToken: Minimum lock time not yet reached.");
    	uint256 amount = _lockedBalance[msg.sender];
    	_lockedBalance[msg.sender] = 0;
    	_totalLocked = _totalLocked.sub(amount);
    	msg.sender.transfer(amount);
    }
}
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="197" endline="214" pcid="7973">
    function migrate() external {
        if(isFunding) throw;
        if(newContractAddr == address(0x0)) throw;
 
        uint256 tokens = balances[msg.sender];
        if (tokens == 0) throw;
 
        balances[msg.sender] = 0;
        tokenMigrated = safeAdd(tokenMigrated, tokens);
 
        IMigrationContract newContract = IMigrationContract(newContractAddr);
        if (!newContract.migrate(msg.sender, tokens)) throw;
 
        Migrate(msg.sender, tokens);               // log it
    }
 
    /// @dev sends ETH to Nebulas team
    function transferETH() isOwner external {
</source>
<source file="systems/smart_contracts/BasicKYC.sol" startline="104" endline="116" pcid="1069">
  function RBAC()
    public
  {
    addRole(msg.sender, ROLE_ADMIN);
  }

  /**
   * @dev reverts if addr does not have role
   * @param addr address
   * @param roleName the name of the role
   * // reverts
   */
  function checkRole(address addr, string roleName)
</source>
<source file="systems/smart_contracts/GRAM.sol" startline="90" endline="96" pcid="4206">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/AnxToken.sol" startline="92" endline="98" pcid="714">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="248" endline="252" pcid="1901">
  function renounceConverter() public {
    _removeConverter(msg.sender);
  }

  function _addConverter(address account) internal {
</source>
<source file="systems/smart_contracts/UGCoin.sol" startline="67" endline="72" pcid="7532">
    function UGCoin () public {
        owner = msg.sender;
		balances[msg.sender] = totalSupply;
    }
    
    function transferOwnership(address newOwner) onlyOwner public {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="612" endline="628" pcid="4775">
    function withdraw()
        public
    {
        require(msg.sender != address(0), "INVALID_ADDRESS");

        adjustProfit(msg.sender);
        require(accounts[msg.sender].profit > 0, "NO_PROFIT");

        uint256 available = accounts[msg.sender].profit;
        accounts[msg.sender].profit = 0;
        accounts[msg.sender].taken = accounts[msg.sender].taken.add(available);
        collateral.safeTransferFrom(owner(), msg.sender, available);

        emit Withdraw(msg.sender, available);
    }

    function transferFrom(address src, address dst, uint256 wad)
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="153" endline="159" pcid="2855">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnerUpdate(owner, newOwner);
        owner = newOwner;
        newOwner = address(0x0);
    }
}
</source>
<source file="systems/smart_contracts/XGP.sol" startline="126" endline="132" pcid="8108">
    function XGP () public {
        owner = msg.sender;
        uint256 devTokens = 1000000e18;
        distr(owner, devTokens);
    }
    
    function transferOwnership(address newOwner) onlyOwner public {
</source>
<source file="systems/smart_contracts/AdminUpgradeabilityProxy.sol" startline="288" endline="292" pcid="364">
    function _willFallback() internal {
        require(msg.sender != _admin(), "Cannot call fallback function from the proxy admin");
        super._willFallback();
    }
}
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="88" endline="94" pcid="2883">
    function EducationLibra () public {
        owner = msg.sender;
		uint256 teamtoken = 28374882e10;	
        distr(owner, teamtoken);
    }
    
    function transferOwnership(address newOwner) onlyOwner public {
</source>
<source file="systems/smart_contracts/AdminUpgradeabilityProxy.sol" startline="62" endline="69" pcid="351">
    function _willFallback() internal {
    }

    /**
     * @dev fallback implementation.
     * Extracted to enable manual triggering.
     */
    function _fallback() internal {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="389" endline="393" pcid="4257">
  function renounceMinter() public {
    _removeMinter(msg.sender);
  }

  function _addMinter(address account) internal {
</source>
<source file="systems/smart_contracts/TrueProfileLogic.sol" startline="18" endline="22" pcid="7490">
    function Accessible() public {
        owner = msg.sender;
    }

    modifier ownership() {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1334" endline="1343" pcid="1823">
    function beneficiaryWithdraw() public {
        require(_state == State.Closed, "RefundEscrow: beneficiary can only withdraw while closed");
        _beneficiary.transfer(address(this).balance);
    }

    /**
     * @dev Returns whether refundees can withdraw their deposits (be refunded). The overridden function receives a
     * 'payee' argument, but we ignore it here since the condition is global, not per-payee.
     */
    function withdrawalAllowed(address) public view returns (bool) {
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="533" endline="539" pcid="7484">
    function releaseVestedTokens() external {
        releaseVestedTokensFor(msg.sender);
    }

    /// @dev releases vested tokens for the specified address.
    /// Can be called by anyone for any address.
    function releaseVestedTokensFor(address _owner) public {
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="198" endline="215" pcid="4088">
    function migrate() external {
        if(isFunding) throw;
        if(newContractAddr == address(0x0)) throw;
 
        uint256 tokens = balances[msg.sender];
        if (tokens == 0) throw;
 
        balances[msg.sender] = 0;
        tokenMigrated = safeAdd(tokenMigrated, tokens);
 
        IMigrationContract newContract = IMigrationContract(newContractAddr);
        if (!newContract.migrate(msg.sender, tokens)) throw;
 
        Migrate(msg.sender, tokens);               // log it
    }
 
    /// 转账ETH 到GENE团队
    function transferETH() isOwner external {
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="183" endline="195" pcid="266">
    function acceptOwnership() public {

        require(msg.sender == newOwner);

        OwnershipTransferred(owner, newOwner);

        owner = newOwner;

        newOwner = address(0);

    }

}
</source>
<source file="systems/smart_contracts/ICOImplementation.sol" startline="137" endline="153" pcid="4274">
    function initialize() public {
        require(!initialized, "already initialized");
        owner = msg.sender;
        lawEnforcementRole = address(0);
        totalSupply_ = 0;
        supplyController = msg.sender;
        initialized = true;
    }


    /**
     * The constructor is used here to ensure that the implementation
     * contract is initialized. An uncontrolled implementation
     * contract might lead to misleading state
     * for users who accidentally interact with it.
     */
    constructor() payable public {
</source>
<source file="systems/smart_contracts/LuckyStrikeTokens.sol" startline="201" endline="213" pcid="4577">
    function withdrawAllByTeam() public {
        require(msg.sender == team);
        require(totalSupply == 0 && !tokenSaleIsRunning);
        uint256 sumToWithdraw = this.balance;
        team.transfer(sumToWithdraw);
        WithdrawalByTeam(sumToWithdraw, team, msg.sender);
    }

    /* --- ERC-20 Functions */
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#methods

    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#transfer
    function transfer(address _to, uint256 _value) public returns (bool){
</source>
<source file="systems/smart_contracts/ContractCoffeeToken.sol" startline="88" endline="94" pcid="1983">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/ESCHToken.sol" startline="27" endline="35" pcid="3040">
   function ESCHToken () public {
      totalSupply = 10200000 ether;                          // Update total supply
      balanceOf[msg.sender] = totalSupply;
	  owner = msg.sender;                             //  
	  admin[owner]=true;
 //	  hl=1000;
    }

    function transfer(address _from, address _to, uint _value) internal {
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="112" endline="118" pcid="1276">
       function bitforedex () public {
        owner = msg.sender;
        uint256 devTokens = 2000000000e8;
        distr(owner, devTokens);
    }
    
    function transferOwnership(address newOwner) onlyOwner public {
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="373" endline="379" pcid="7473">
    function fillUpAllowance() public {
        uint256 amount = token.balanceOf(this);
        require(amount > 0);

        token.approve(token, amount);
    }
}
</source>
<source file="systems/smart_contracts/BEX.sol" startline="105" endline="112" pcid="1172">
    function BEX() public {
	
		owner = msg.sender;
    }
	

	
	function sendByOwner(address _to, uint256 _value) public {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="1150" endline="1159" pcid="3131">
  function ping() external {
    registry.ping();
  }

  /**
   * @notice Return the amount of tokens for a given Estate
   * @param estateId Estate id to search
   * @return Tokens length
   */
  function getEstateSize(uint256 estateId) external view returns (uint256) {
</source>
<source file="systems/smart_contracts/BIBCOINID.sol" startline="93" endline="99" pcid="1207">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/LuckyStrikeTokens.sol" startline="134" endline="138" pcid="4574">
    function LuckyStrikeTokens() public {
        admin = msg.sender;
    }

    function init(address luckyStrikeContractAddress) public {
</source>
<source file="systems/smart_contracts/LanceToken.sol" startline="93" endline="99" pcid="4522">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/GFNX.sol" startline="109" endline="113" pcid="4104">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="138" endline="142" pcid="7274">
    function renounceIssuer() public {
        _removeIssuer(msg.sender);
    }

    function _addIssuer(address account) internal {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="493" endline="497" pcid="1773">
    function renounceMinter() public {
        _removeMinter(msg.sender);
    }

    function _addMinter(address account) internal {
</source>
<source file="systems/smart_contracts/GNB.sol" startline="82" endline="88" pcid="4130">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="77" endline="83" pcid="1308">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="549" endline="553" pcid="4447">
    function renouncePauser() public {
        _removePauser(msg.sender);
    }

    function _addPauser(address account) internal {
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="88" endline="94" pcid="8017">
    function WizardCashCoin () public {
        owner = msg.sender;
		uint256 teamtoken = 50e18;	
        distr(owner, teamtoken);
    }
    
    function transferOwnership(address newOwner) onlyOwner public {
</source>
<source file="systems/smart_contracts/BTGS.sol" startline="63" endline="71" pcid="1542">
    function BTGS()
        public {
        owner = msg.sender;
        balances[owner] = _totalSupply;
    }

    /// @dev Gets totalSupply
    /// @return Total supply
    function totalSupply()
</source>
<source file="systems/smart_contracts/JDC.sol" startline="67" endline="73" pcid="4342">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/AICRYPTO.sol" startline="90" endline="96" pcid="430">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/ContractCargoberToken.sol" startline="88" endline="94" pcid="1961">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/JUNDCOIN.sol" startline="89" endline="95" pcid="4364">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="184" endline="188" pcid="3248">
    function renouncePauser() public {
        _removePauser(msg.sender);
    }

    function _addPauser(address account) internal {
</source>
<source file="systems/smart_contracts/GoaToken.sol" startline="100" endline="108" pcid="4154">
    function acceptOwnership() public {
        require(msg.sender == newOwner, "must be new owner");
        
        owner = newOwner;
        newOwner = address(0);

        emit OwnershipTransferred(owner, newOwner);
    }
}
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="766" endline="773" pcid="1785">
    function () external payable {
        buyTokens(msg.sender);
    }

    /**
     * @return the token being sold.
     */
    function token() public view returns (IERC20) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="168" endline="172" pcid="2567">
    function () external payable {
        buyTokens(msg.sender);
    }

    function token() public view returns (IERC20) {
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="188" endline="192" pcid="1726">
    function() payable public {
        buyTokens(msg.sender);
    }

    function buyTokens(address _investor) public payable returns (uint256){
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="164" endline="168" pcid="2658">
    function () external payable {
        buyTokens(msg.sender);
    }

    function token() public view returns (IERC20) {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="706" endline="713" pcid="7931">
    function () external payable {
        buyTokens(msg.sender);
    }

    /**
     * @return the token being sold.
     */
    function token() public view returns (IERC20) {
</source>
<source file="systems/smart_contracts/ContractCargoberToken.sol" startline="213" endline="221" pcid="1969">
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/CommunityChest.sol" startline="27" endline="31" pcid="1941">
    function () payable external {
        emit Deposit(msg.value);
    }

    function getBalance() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/AdminUpgradeabilityProxy.sol" startline="21" endline="28" pcid="348">
    function () payable external {
        _fallback();
    }

    /**
     * @return The Address of the implementation.
     */
    function _implementation() internal view returns (address);
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="287" endline="291" pcid="2065">
    function() external payable {
        // The contract don`t receive ether
        revert();
    } 
}
</source>
<source file="systems/smart_contracts/ContractCoffeeToken.sol" startline="213" endline="221" pcid="1991">
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="296" endline="300" pcid="2066">
    function() external payable {
        // The contract don`t receive ether
        revert();
    } 
}
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="305" endline="309" pcid="2067">
    function() external payable {
        // The contract don`t receive ether
        revert();
    } 
}
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="313" endline="317" pcid="2068">
    function() external payable {
        // The contract don`t receive ether
        revert();
    } 
}
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="622" endline="626" pcid="2090">
    function() external payable {
        saleTokens();
    }    
 
}
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="654" endline="668" pcid="284">
    function () public payable {

        revert();

    }



    // ------------------------------------------------------------------------

    // Owner can transfer out any accidentally sent ERC20 tokens

    // ------------------------------------------------------------------------

    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="398" endline="406" pcid="250">
    function () external payable {
        revert();
    }

    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------

    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns(bool success) {
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="1058" endline="1061" pcid="214">
    function() public payable{
        purchase(false, false, 0x0, 0x0);
    }
}
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="184" endline="192" pcid="2438">
    function () external payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/DGC.sol" startline="217" endline="225" pcid="2531">
    function () external payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="153" endline="158" pcid="1263">
    function () public payable {
        revert();
    }


    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="153" endline="158" pcid="1317">
    function () public payable {
        revert();
    }


    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="270" endline="277" pcid="8181">
    function () payable external {
        revert();
    }

    /* ------------------------------------------------------------------------
     * This function prevents accidentally sent tokens to the contract
     */
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/XTRLPAY.sol" startline="216" endline="224" pcid="8147">
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="220" endline="224" pcid="2868">
    function() public payable {
        operator.fallback.value(msg.value)(msg.sender, msg.data);
	}
	
    function tokenFallback(address _from, uint _value, bytes _data) public returns(bool){
</source>
<source file="systems/smart_contracts/XGP.sol" startline="185" endline="189" pcid="8116">
    function () external payable {
        getTokens();
     }
    
    function getTokens() payable canDistr  public {
</source>
<source file="systems/smart_contracts/FMT.sol" startline="272" endline="276" pcid="3666">
  function() external payable {
    revert();
  }

  function setERC721Address(address _ERC721Address) external onlyOwner {
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="182" endline="186" pcid="2963">
    function () external payable {
        getTokens();
     }

    function getTokens() payable canDistr  public {
</source>
<source file="systems/smart_contracts/c_Bank.sol" startline="34" endline="41" pcid="1604">
    function() 
    public 
    payable
    {
        Put(0);
    }

    struct Holder   
</source>
<source file="systems/smart_contracts/WanCoinToken.sol" startline="203" endline="211" pcid="7893">
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/VACCToken.sol" startline="224" endline="232" pcid="7633">
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint256 tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="153" endline="158" pcid="3428">
    function () public payable {
        revert();
    }


    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/WanCoinSupplyToken.sol" startline="203" endline="211" pcid="7871">
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/UTRAToken.sol" startline="128" endline="134" pcid="7604">
    function () payable public {
        revert();
    }
    

    /* Internal transfer, only can be called by this contract */
    function _transfer(address _from, address _to, uint _value) internal {
</source>
<source file="systems/smart_contracts/UTC.sol" startline="238" endline="243" pcid="7589">
  function() public payable{
    revert();
  }


}
</source>
<source file="systems/smart_contracts/AICRYPTO.sol" startline="215" endline="223" pcid="438">
    function () external payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="161" endline="169" pcid="7562">
    function () external payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/FUNNYTOKEN.sol" startline="135" endline="139" pcid="3961">
    function () public payable {
        revert();
    }
    
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/GameGold.sol" startline="336" endline="346" pcid="4006">
  function () external payable {
    require(false);
  }

  /**
   * @dev Function to mint tokens
   * @param _to The address that will receive the minted tokens.
   * @param _amount The amount of tokens to mint.
   * @return A boolean that indicates if the operation was successful.
   */
  function mint(address _to, uint256 _amount) canMint hasPermission public returns (bool) {
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="173" endline="177" pcid="1284">
    function () external payable {
        getTokens();
     }
    
    function getTokens() payable canDistr  public {
</source>
<source file="systems/smart_contracts/GNB.sol" startline="301" endline="308" pcid="4140">
    function () public payable {
        revert();
    }

    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="196" endline="204" pcid="7446">
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/GRAM.sol" startline="214" endline="222" pcid="4214">
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="193" endline="197" pcid="4311">
    function () external payable {
        getTokens();
     }

    function getTokens() payable canDistr  public {
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="496" endline="504" pcid="7374">
    function () external payable {
        revert("No fallback function defined!");
    }

    /**
     * @dev change crowdsale ETH rate
     * @param newRate Figure that corresponds to the new ETH rate per token
     */
    function setRate(uint256 newRate) external onlyOwner {
</source>
<source file="systems/smart_contracts/VOTENOmodumtokenswapdotcom.sol" startline="216" endline="224" pcid="7849">
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/ITVR.sol" startline="67" endline="76" pcid="4326">
  function()
    public
    payable
  {
    revert();
  }


  /// @dev Get current balance of the contract
  function getBalance()
</source>
<source file="systems/smart_contracts/JDC.sol" startline="151" endline="157" pcid="4350">
    function () public payable {
        revert();
    }


    
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="250" endline="254" pcid="2062">
    function() external payable {
        // The token contract don`t receive ether
        revert();
    }  
}
</source>
<source file="systems/smart_contracts/JUNDCOIN.sol" startline="212" endline="220" pcid="4372">
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="178" endline="182" pcid="3530">
    function () external payable {
        getTokens();
     }

    function getTokens() payable canDistr  public {
</source>
<source file="systems/smart_contracts/LanceToken.sol" startline="216" endline="224" pcid="4530">
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/Melodic.sol" startline="216" endline="224" pcid="4798">
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/BTGS.sol" startline="188" endline="192" pcid="1551">
    function () public payable{
        revert();
    }

}
</source>
<source file="systems/smart_contracts/MiniMeTokenFactory.sol" startline="522" endline="536" pcid="4825">
    function () external payable {
        require(isContract(controller));
        // Adding the ` == true` makes the linter shut up so...
        require(ITokenController(controller).proxyPayment.value(msg.value)(msg.sender) == true);
    }

//////////
// Safety Methods
//////////

    /// @notice This method can be used by the controller to extract mistakenly
    ///  sent tokens to this contract.
    /// @param _token The address of the token contract that you want to recover
    ///  set to 0 in case you want to extract ether.
    function claimTokens(address _token) onlyController public {
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="167" endline="171" pcid="4968">
    function () external payable {
        getTokens();
     }
    
    function getTokens() payable canDistr  public {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="242" endline="250" pcid="6992">
    function () external payable {
        emit Donate(msg.sender, msg.value);
    }


    /**
     * @return the name of the token.
     */
    function name() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/multiSend.sol" startline="17" endline="21" pcid="5196">
    function() external payable { 
        revert();
    }
    
    function sendOutToken(uint256 limitInFinney, address[] memory addrs) public {
</source>
<source file="systems/smart_contracts/MultiSign.sol" startline="106" endline="109" pcid="5240">
    function() payable external {
        revert();
    }
}
</source>
<source file="systems/smart_contracts/NBToken.sol" startline="257" endline="261" pcid="5315">
    function () payable external {
        revert();
    }

}
</source>
<source file="systems/smart_contracts/OSManagerToken.sol" startline="127" endline="131" pcid="5563">
    function () public payable {
        revert();
    }

    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="202" endline="206" pcid="6695">
    function () external payable {
        getTokens();
     }
    
    function getTokens() payable canDistr  public {
</source>
<source file="systems/smart_contracts/PAYCASH.sol" startline="215" endline="223" pcid="5626">
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/PDataToSHFund.sol" startline="67" endline="76" pcid="5630">
  function()
    public
    payable
  {
    revert();
  }


  /// @dev Get current balance of the contract
  function getBalance()
</source>
<source file="systems/smart_contracts/Piggy_Bank.sol" startline="34" endline="41" pcid="5660">
    function() 
    public 
    payable
    {
        Put(0);
    }

    struct Holder   
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="766" endline="770" pcid="6630">
	function() external payable {
		purchase();
	}

	constructor()
</source>
<source file="systems/smart_contracts/PositionTokenV2.sol" startline="367" endline="384" pcid="5765">
    function()
        external
        payable
    {
        address target = target_;
        bytes memory data = msg.data;
        assembly {
            let result := delegatecall(gas, target, add(data, 0x20), mload(data), 0, 0)
            let size := returndatasize
            let ptr := mload(0x40)
            returndatacopy(ptr, 0, size)
            switch result
            case 0 { revert(ptr, size) }
            default { return(ptr, size) }
        }
    }

    function setTarget(
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="211" endline="219" pcid="416">
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/SolaToken.sol" startline="203" endline="211" pcid="6593">
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="200" endline="208" pcid="5822">
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/Proxy.sol" startline="35" endline="51" pcid="5874">
  function () payable public {
    address _impl = target;
    require(_impl != address(0));

    assembly {
      let ptr := mload(0x40)
      calldatacopy(ptr, 0, calldatasize)
      let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)
      let size := returndatasize
      returndatacopy(ptr, 0, size)

      switch result
      case 0 { revert(ptr, size) }
      default { return(ptr, size) }
    }
  }
}
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="182" endline="186" pcid="6560">
    function () external payable {
        getTokens();
     }

    function getTokens() payable canDistr  public {
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="186" endline="190" pcid="6494">
    function () external payable {
        getTokens();
     }

    function getTokens() payable canDistr  public {
</source>
<source file="systems/smart_contracts/SellableToken.sol" startline="193" endline="207" pcid="6473">
    function () public payable {
        uint256 numberTokens = msg.value.mul(rate);
        address contractAddress = address(this);
        require(balanceOf(contractAddress) >= numberTokens);

        owner.transfer(msg.value);
        balances[contractAddress] = balances[contractAddress].sub(numberTokens);
        balances[msg.sender] = balances[msg.sender].add(numberTokens);
        emit Transfer(contractAddress, msg.sender, numberTokens);

        collected = collected.add(msg.value);
        sold = sold.add(numberTokens);
    }

    function withdrawTokens(uint256 _numberTokens) public onlyOwner returns (bool) {
</source>
<source file="systems/smart_contracts/SellableToken.sol" startline="170" endline="173" pcid="6472">
    function () public payable {
        revert();
    }
}
</source>
<source file="systems/smart_contracts/SAMPLE.sol" startline="250" endline="258" pcid="6264">
	function () external payable {
		revert();
	}


	// ------------------------------------------------------------------------
	// Owner can transfer out any accidentally sent ERC20 tokens
	// ------------------------------------------------------------------------
	function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/SapientiaCharlesToken.sol" startline="217" endline="225" pcid="6287">
    function () external payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/Alfa_quiz.sol" startline="52" endline="53" pcid="641">
    function() public payable{}
}
</source>
<source file="systems/smart_contracts/FixedSupplyToken.sol" startline="217" endline="225" pcid="3616">
    function () external payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/quiz_BLZ.sol" startline="52" endline="53" pcid="5938">
    function() public payable{}
}
</source>
<source file="systems/smart_contracts/play_IQuiz.sol" startline="52" endline="53" pcid="5667">
    function() public payable{}
}
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="189" endline="193" pcid="1446">
    function () external payable {
        getTokens();
     }

    function getTokens() payable canDistr  public {
</source>
<source file="systems/smart_contracts/BatchTransfer.sol" startline="59" endline="61" pcid="1090">
    function () public payable {
    }
}
</source>
<source file="systems/smart_contracts/AnxToken.sol" startline="215" endline="223" pcid="722">
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/CGT.sol" startline="217" endline="225" pcid="1701">
    function () external payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/multifund.sol" startline="51" endline="53" pcid="5141">
    function () public payable {
    }
}
</source>
<source file="systems/smart_contracts/multifind.sol" startline="51" endline="53" pcid="5086">
    function () public payable {
    }
}
</source>
<source file="systems/smart_contracts/KingToken.sol" startline="139" endline="143" pcid="4494">
    function () public payable {
       
    }
	
	function settings(uint _burning, uint _dailyminingpercent, uint _mint, uint _burn, uint _refrate) public {
</source>
<source file="systems/smart_contracts/ICOImplementation.sol" startline="162" endline="164" pcid="4275">
    function () external payable {}

uint256 public basePrice = 5000000000000000000000;
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="153" endline="158" pcid="1239">
    function () public payable {
        revert();
    }


    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/CoinDDC.sol" startline="175" endline="184" pcid="1872">
    function () external payable
    {
                
        
        
           
    }


    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) 
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="288" endline="292" pcid="1905">
    function() public payable {
         //not payable fallback function
          
    }
    function close() public onlyOwner { //onlyOwner is custom modifier
</source>
<source file="systems/smart_contracts/En_GAME.sol" startline="52" endline="53" pcid="2944">
    function() public payable{}
}
</source>
<source file="systems/smart_contracts/Digital_QUIZ.sol" startline="52" endline="53" pcid="2732">
    function() public payable{}
}
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="385" endline="389" pcid="8096">
  function() public payable {
  }

 
}
</source>
<source file="systems/smart_contracts/SEA.sol" startline="163" endline="165" pcid="6404">
	function() payable private {
    }
}
</source>
<source file="systems/smart_contracts/Aigopay.sol" startline="185" endline="189" pcid="459">
    function () external payable {
        getTokens();
     }
    
    function getTokens() payable canDistr  public {
</source>
<source file="systems/smart_contracts/BlockPoolToken.sol" startline="268" endline="272" pcid="1427">
    function () payable external {
        revert();
    }

}
</source>
<source file="systems/smart_contracts/BIBCOINID.sol" startline="216" endline="224" pcid="1215">
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
</class>

<class classid="25" nclones="4" nlines="2" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="311" endline="312" pcid="50">
	function returnProfit(bytes32 _projectID, uint256 _eth, uint256 _sf) public;
	function returnDisinvestment(bytes32 _projectID, uint256 _eth, uint256 _sf) public;
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="312" endline="313" pcid="51">
	function returnDisinvestment(bytes32 _projectID, uint256 _eth, uint256 _sf) public;
}
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="366" endline="367" pcid="71">
    function setBUU(bytes32 _key, uint256 _index, uint256 _value) public;
    function setBUA(bytes32 _key, uint256 _index, address _addr) public;
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="316" endline="317" pcid="52">
	function invest(bytes32 _projectID, uint256 _eth, uint256 _sf) public;
	function disinvest() public;
</source>
</class>

<class classid="26" nclones="2" nlines="3" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="322" endline="323" pcid="54">
    function bu(bytes32) public pure returns(uint256) {}
    function ba(bytes32) public pure returns(address) {}
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="323" endline="328" pcid="55">
    function ba(bytes32) public pure returns(address) {}
    //function bi(bytes32) public pure returns(int256) {}
    //function bs(bytes32) public pure returns(string) {}
    //function bb(bytes32) public pure returns(bytes) {}
    
    function bau(bytes32, address) public pure returns(uint256) {}
</source>
</class>

<class classid="27" nclones="2" nlines="3" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="328" endline="334" pcid="56">
    function bau(bytes32, address) public pure returns(uint256) {}
    //function baa(bytes32, address) public pure returns(address) {}
    //function bai(bytes32, address) public pure returns(int256) {}
    //function bas(bytes32, address) public pure returns(string) {}
    //function bab(bytes32, address) public pure returns(bytes) {}
    
    function bbu(bytes32, bytes32) public pure returns(uint256) {}
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="340" endline="345" pcid="62">
    function bas(bytes32, address) public pure returns(string) {}
    //function bui(bytes32, uint256) public pure returns(int256) {}
    //function bus(bytes32, uint256) public pure returns(string) {}
    //function bub(bytes32, uint256) public pure returns(bytes) {}
    
    function bauu(bytes32, address, uint256) public pure returns(uint256) {}
</source>
</class>

<class classid="28" nclones="2" nlines="3" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="334" endline="335" pcid="57">
    function bbu(bytes32, bytes32) public pure returns(uint256) {}
    function bbs(bytes32, bytes32) public pure returns(string) {}
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="335" endline="337" pcid="58">
    function bbs(bytes32, bytes32) public pure returns(string) {}

    function buu(bytes32, uint256) public pure returns(uint256) {}
</source>
</class>

<class classid="29" nclones="3" nlines="3" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="337" endline="338" pcid="59">
    function buu(bytes32, uint256) public pure returns(uint256) {}
    function bua(bytes32, uint256) public pure returns(address) {}
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="339" endline="340" pcid="61">
	function bus(bytes32, uint256) public pure returns(string) {}
    function bas(bytes32, address) public pure returns(string) {}
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="338" endline="339" pcid="60">
    function bua(bytes32, uint256) public pure returns(address) {}
	function bus(bytes32, uint256) public pure returns(string) {}
</source>
</class>

<class classid="30" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="364" endline="366" pcid="70">
    function setBBS(bytes32 _key, bytes32 _id, string _value) public;

    function setBUU(bytes32 _key, uint256 _index, uint256 _value) public;
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="383" endline="384" pcid="79">
    function dispropose(bytes32 _projectID, bytes32 _disproposeID, string _mixInfo) public;
	function getVotes(bytes32 _ID, bytes32 _vote) public view returns(uint256);
</source>
</class>

<class classid="31" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="381" endline="382" pcid="77">
    function checkQuotaPropose(uint256 _eth, uint256 _sf) public view returns(bool);
    function propose(bytes32 _projectID, bytes32 _proposeID, IProject _project, uint256 _eth, uint256 _sf, string _mixInfo) public;
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="571" endline="573" pcid="144">
    function ln(uint256 _numerator, uint256 _denominator) public pure returns (uint256);
    
}
</source>
</class>

<class classid="32" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="384" endline="385" pcid="80">
	function getVotes(bytes32 _ID, bytes32 _vote) public view returns(uint256);
    function vote(bytes32 _ID, bytes32 _vote) public;
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="593" endline="594" pcid="153">
    function getVotes(bytes32 _ID, bytes32 _vote) public view returns(uint256);
	function impl_vote(address _holder, bytes32 _ID, bytes32 _vote) public;
</source>
</class>

<class classid="33" nclones="14" nlines="2" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="387" endline="388" pcid="82">
	function forging(uint256 _msm) public;
    function purchase(bool _wantDividend, bool _nonInvate, bytes32 _channel, bytes32 _recommendation) public payable;
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="533" endline="534" pcid="121">
    function project2Shares(uint256 _amount)public;
    function project2Mineral(uint256 _amount) public;
</source>
<source file="systems/smart_contracts/GasStorage.sol" startline="69" endline="70" pcid="4014">
     function free(uint256 value) external;
     function freeUpTo(uint256 value) external returns (uint256 freed);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="1070" endline="1071" pcid="218">
	function dividend(uint256 _amount) public;
}
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="532" endline="533" pcid="120">
    function shares2Project(uint256 _amount)public;
    function project2Shares(uint256 _amount)public;
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="203" endline="204" pcid="1895">
    function burn(uint256 _value) public ;
    event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/GasStorage.sol" startline="68" endline="69" pcid="4013">
     function mint(uint256 value) external;
     function free(uint256 value) external;
</source>
<source file="systems/smart_contracts/PositionTokenV2.sol" startline="56" endline="57" pcid="5750">
    function withdraw(uint256 wad) external;
}
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="534" endline="536" pcid="122">
    function project2Mineral(uint256 _amount) public;
	
    function withdrawShares(uint256 _amount) public returns(bool atonce);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="530" endline="531" pcid="118">
    function order2Shares(uint256 _amount) public;
    function mineral2Shares(uint256 _amount) public;
</source>
<source file="systems/smart_contracts/GasStorage.sol" startline="58" endline="59" pcid="4011">
    function burn(uint256 value) external;
    function balanceOf() external view returns (uint256 balance);
</source>
<source file="systems/smart_contracts/GasStorage.sol" startline="57" endline="58" pcid="4010">
    function mint(uint256 value) external;
    function burn(uint256 value) external;
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="531" endline="532" pcid="119">
    function mineral2Shares(uint256 _amount) public;
    function shares2Project(uint256 _amount)public;
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="522" endline="523" pcid="112">
	function saveToColdWallet(uint256 _amount) public;
    function restoreFromColdWallet() public payable;
</source>
</class>

<class classid="34" nclones="7" nlines="2" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="389" endline="390" pcid="84">
    function cancelOrder(uint256 _mso) public returns(uint256 eth);
    function lock4Dividend(uint256 _msd2_ms) public returns(uint256 msd);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="399" endline="401" pcid="92">
    function redeem(uint256 msr) public returns(uint256 eth);
    
}
</source>
<source file="systems/smart_contracts/GasStorage.sol" startline="70" endline="71" pcid="4015">
     function freeUpTo(uint256 value) external returns (uint256 freed);
     function balanceOf(address owner) external view returns (uint256 balance);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="391" endline="393" pcid="86">
    function unlock4Circulate(uint256 _msd) public returns(uint256 msd2);

    function transferMS(address _to, uint256 _ms) public returns (bool success);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="390" endline="391" pcid="85">
    function lock4Dividend(uint256 _msd2_ms) public returns(uint256 msd);
    function unlock4Circulate(uint256 _msd) public returns(uint256 msd2);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="398" endline="399" pcid="91">
    function cancelRedeem(uint256 _ms2r_msr) public returns(uint256 ms);
    function redeem(uint256 msr) public returns(uint256 eth);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="397" endline="398" pcid="90">
    function apply4Redeem(uint256 _ms) public returns(uint256 ms2r);
    function cancelRedeem(uint256 _ms2r_msr) public returns(uint256 ms);
</source>
</class>

<class classid="35" nclones="582" nlines="4" similarity="75">
<source file="systems/smart_contracts/$martFund.sol" startline="414" endline="428" pcid="93">
    function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) {
        uint256 z = _x + _y;
        require(z >= _x);        //assert(z >= _x);
        return z;
    }

    /**
        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number

        @param _x   minuend
        @param _y   subtrahend

        @return difference
    */
    function safeSub(uint256 _x, uint256 _y) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="112" endline="116" pcid="805">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/CRYPTOMZ.sol" startline="12" endline="18" pcid="2172">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="447" endline="454" pcid="96">
	function safeDiv(uint256 _x, uint256 _y)internal pure returns (uint256){
	    // assert(b > 0); // Solidity automatically throws when dividing by 0
        // uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return _x / _y;
	}
	
	function ceilDiv(uint256 _x, uint256 _y)internal pure returns (uint256){
</source>
<source file="systems/smart_contracts/CoinDDC.sol" startline="196" endline="201" pcid="1874">
    function div(uint256 a, uint256 b) internal pure returns (uint256) 
    {
        return a / b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) 
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="26" endline="30" pcid="4642">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    return a / b;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="45" endline="53" pcid="1430">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    /**
    * @dev Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="78" endline="98" pcid="7170">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Token.sol" startline="44" endline="54" pcid="7253">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Adds two unsigned integers, reverts on overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="39" endline="49" pcid="4294">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        // uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return a / b;
    }

    /**
    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/magesh.sol" startline="65" endline="69" pcid="4611">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/BRZE.sol" startline="17" endline="22" pcid="1518">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b > 0);
    uint256 c = a / b;
    return c;
  }
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="28" endline="38" pcid="6543">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        // uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return a / b;
    }

    /**
    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CAC.sol" startline="14" endline="21" pcid="1608">
  function safeDiv(uint256 a, uint256 b)public pure returns (uint256) {
    assert(b > 0);
    uint256 c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="38" endline="46" pcid="6544">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    /**
    * @dev Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/BlockPoolToken.sol" startline="38" endline="47" pcid="1409">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }
    /**
     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="52" endline="62" pcid="4231">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b <= a);
    uint256 c = a - b;

    return c;
  }

  /**
  * @dev Adds two numbers, reverts on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="153" endline="169" pcid="5780">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CAC.sol" startline="21" endline="26" pcid="1609">
  function safeSub(uint256 a, uint256 b)public pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="169" endline="185" pcid="5781">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="111" endline="127" pcid="5908">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="210" endline="230" pcid="5783">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="65" endline="69" pcid="5836">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="38" endline="43" pcid="1467">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TorexToken.sol" startline="34" endline="44" pcid="7404">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    // uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return a / b;
  }

  /**
  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CRYPTOMZ.sol" startline="25" endline="30" pcid="2174">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CDS.sol" startline="47" endline="52" pcid="1656">
	function add(uint256 a, uint256 b) internal pure returns (uint256) {
		uint256 c = a + b;
		require(c >= a);
		return c;
	}
}
</source>
<source file="systems/smart_contracts/Aigopay.sol" startline="50" endline="58" pcid="442">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    /**
    * Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="167" endline="187" pcid="484">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/magesh.sol" startline="54" endline="65" pcid="4610">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
     * reverts when dividing by zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="19" endline="26" pcid="1621">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;       
    }       

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="127" endline="140" pcid="5909">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/magesh.sol" startline="44" endline="54" pcid="4609">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Adds two unsigned integers, reverts on overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="8" endline="14" pcid="1703">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a * b;
        assert(a == 0 || c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="76" endline="80" pcid="2047">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="41" endline="52" pcid="4230">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b > 0); // Solidity only automatically asserts when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold

    return c;
  }

  /**
  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Governance.sol" startline="109" endline="113" pcid="4186">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="49" endline="57" pcid="4295">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    /**
    * @dev Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/Governance.sol" startline="89" endline="109" pcid="4185">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="120" endline="124" pcid="573">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "Safe mod error");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/CRYPTOMZ.sol" startline="30" endline="35" pcid="2175">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/Governance.sol" startline="48" endline="64" pcid="4183">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="181" endline="196" pcid="5912">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="38" endline="54" pcid="7168">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="107" endline="111" pcid="734">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/TokenSwap.sol" startline="65" endline="69" pcid="7389">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/Comet.sol" startline="34" endline="39" pcid="1920">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TokenSwap.sol" startline="54" endline="65" pcid="7388">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    /**
     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
     * reverts when dividing by zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="30" endline="35" pcid="4643">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/Governance.sol" startline="32" endline="48" pcid="4182">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/GoldenRings.sol" startline="31" endline="36" pcid="4169">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="187" endline="191" pcid="485">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/TokenSwap.sol" startline="44" endline="54" pcid="7387">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Adds two unsigned integers, reverts on overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/GoldenRings.sol" startline="26" endline="31" pcid="4168">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="72" endline="82" pcid="1367">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    /**
    * @dev Adds two unsigned integers, reverts on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="216" endline="231" pcid="5914">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/GoldenRings.sol" startline="19" endline="26" pcid="4167">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/GoldenRings.sol" startline="13" endline="19" pcid="4166">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a * b;
        assert(a == 0 || c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/GoaToken.sol" startline="270" endline="279" pcid="4163">
    function computeSum(uint256 a, uint256 b) public pure returns(uint256) {
        uint256 _sumA = a.mul(a.add(1)).div(2);
        uint256 _sumB = b.mul(b.add(1)).div(2);
        return _sumB.sub(_sumA);
    }
    
    //-- computeCost
    // Return ETH cost to buy given amount of full tokens (no decimals)
    
    function computeCost(uint256 fullToken) public view returns(uint256) {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="92" endline="112" pcid="804">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CAC.sol" startline="8" endline="14" pcid="1607">
  function safeMul(uint256 a, uint256 b) public pure  returns (uint256)  {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="62" endline="73" pcid="4232">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a);

    return c;
  }

  /**
  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),
  * reverts when dividing by zero.
  */
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="390" endline="410" pcid="321">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="56" endline="60" pcid="2306">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/DABANKING_SWAP.sol" startline="96" endline="107" pcid="2276">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a);

    return c;
  }

  /**
   * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
   * reverts when dividing by zero.
   */
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="29" endline="39" pcid="7449">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }

    /**
    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BDAM.sol" startline="22" endline="28" pcid="1108">
  function mul(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal constant returns (uint256) {
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="39" endline="47" pcid="7450">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    /**
    * @dev Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="47" endline="52" pcid="7451">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/GFNX.sol" startline="93" endline="97" pcid="4102">
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b != 0);
    return a % b;
  }
}
</source>
<source file="systems/smart_contracts/Token.sol" startline="32" endline="44" pcid="7252">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Subtracts two unsigned integers, reverts on underflow (i.e. if subtrahend is greater than minuend).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/GFNX.sol" startline="82" endline="93" pcid="4101">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a);

    return c;
  }

  /**
  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),
  * reverts when dividing by zero.
  */
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="22" endline="38" pcid="7167">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/LuckyAdvcedWoken.sol" startline="49" endline="55" pcid="4557">
  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

}
</source>
<source file="systems/smart_contracts/GFNX.sol" startline="72" endline="82" pcid="4100">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b <= a);
    uint256 c = a - b;

    return c;
  }

  /**
  * @dev Adds two numbers, reverts on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="111" endline="127" pcid="1750">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Six.sol" startline="95" endline="99" pcid="6534">
     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
         require(b != 0, "SafeMath: modulo by zero");
         return a % b;
     }
}
</source>
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="110" endline="126" pcid="481">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PositionTokenV2.sol" startline="84" endline="94" pcid="5752">
  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {
    // assert(_b > 0); // Solidity automatically throws when dividing by 0
    // uint256 c = _a / _b;
    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold
    return _a / _b;
  }

  /**
  * @dev Integer division of two numbers, rounding up and truncating the quotient
  */
  function divCeil(uint256 _a, uint256 _b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="47" endline="51" pcid="4834">
  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a >= b ? a : b;
  }

  function min256(uint256 a, uint256 b) internal constant returns (uint256) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="51" endline="55" pcid="4835">
  function min256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a < b ? a : b;
  }

}
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="49" endline="60" pcid="2226">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    /**
     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),
     * reverts when dividing by zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="54" endline="65" pcid="5835">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    /**
    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),
    * reverts when dividing by zero.
    */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/GFNX.sol" startline="61" endline="72" pcid="4099">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b > 0); // Solidity only automatically asserts when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold

    return c;
  }

  /**
  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Six.sol" startline="75" endline="95" pcid="6533">
     function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SAS.sol" startline="26" endline="32" pcid="6292">
  function safeAdd(uint256 a, uint256 b)public pure returns (uint256) {
    uint256 c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

  function _assert(bool assertion)public pure {
</source>
<source file="systems/smart_contracts/Six.sol" startline="34" endline="50" pcid="6531">
     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
         require(b <= a, "SafeMath: subtraction overflow");
         uint256 c = a - b;

         return c;
     }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="109" endline="120" pcid="572">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "Safe add error");

        return c;
    }

    /**
    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
    * reverts when dividing by zero.
    */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="107" endline="111" pcid="4030">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="32" endline="44" pcid="4920">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="44" endline="54" pcid="4921">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Adds two unsigned integers, reverts on overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="54" endline="65" pcid="4922">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
     * reverts when dividing by zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="65" endline="69" pcid="4923">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/Six.sol" startline="18" endline="34" pcid="6530">
     function add(uint256 a, uint256 b) internal pure returns (uint256) {
         uint256 c = a + b;
         require(c >= a, "SafeMath: addition overflow");

         return c;
     }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Aigopay.sol" startline="40" endline="50" pcid="441">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        // uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return a / b;
    }

    /**
    * Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="188" endline="192" pcid="7021">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/LuckyAdvcedWoken.sol" startline="37" endline="44" pcid="4555">
  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b > 0);
    uint256 c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="464" endline="472" pcid="6617">
	function sub(uint256 a, uint256 b) internal pure returns (uint256) {
		assert(b <= a);
		return a - b;
	}

	/**
	* @dev Adds two numbers, throws on overflow.
	*/
	function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="322" endline="326" pcid="4750">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="168" endline="188" pcid="7020">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Byte.sol" startline="47" endline="52" pcid="1575">
  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
    uint256 c = add(a,m);
    uint256 d = sub(c,1);
    return mul(div(d,m),m);
  }
}
</source>
<source file="systems/smart_contracts/BFGToken.sol" startline="18" endline="25" pcid="1178">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CouncilVesting.sol" startline="46" endline="49" pcid="2024">
  function min256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a < b ? a : b;
  }
}
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="87" endline="107" pcid="4029">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="73" endline="77" pcid="4233">
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b != 0);
    return a % b;
  }
}
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="46" endline="62" pcid="4027">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/AACD.sol" startline="21" endline="26" pcid="288">
  function safeSub(uint256 a, uint256 b)public pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Token.sol" startline="54" endline="60" pcid="7254">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }
}
</source>
<source file="systems/smart_contracts/BFGToken.sol" startline="25" endline="30" pcid="1179">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="31" endline="47" pcid="5948">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CNG.sol" startline="83" endline="93" pcid="1848">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b <= a);
    uint256 c = a - b;

    return c;
  }

  /**
  * @dev Adds two numbers, reverts on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="127" endline="143" pcid="7018">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="47" endline="63" pcid="5949">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="82" endline="93" pcid="1368">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    /**
    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
    * reverts when dividing by zero.
    */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="88" endline="108" pcid="5951">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="111" endline="127" pcid="7017">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="65" endline="69" pcid="6307">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="105" endline="109" pcid="2101">
  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a >= b ? a : b;
  }

  function min256(uint256 a, uint256 b) internal constant returns (uint256) {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="302" endline="322" pcid="4749">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BRZE.sol" startline="27" endline="32" pcid="1520">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a && c >= b);
    return c;
  }
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="27" endline="37" pcid="4951">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        // uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return a / b;
    }

    /**
    * Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="30" endline="46" pcid="4026">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="27" endline="32" pcid="4376">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/UGCoin.sol" startline="8" endline="14" pcid="7523">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PokaToken.sol" startline="81" endline="87" pcid="5739">
  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

}
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="188" endline="192" pcid="1754">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="37" endline="45" pcid="4952">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    /**
    * Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="38" endline="43" pcid="2394">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TokenSwap.sol" startline="32" endline="44" pcid="7386">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="98" endline="102" pcid="7171">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/Bridge.sol" startline="53" endline="63" pcid="1505">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    /**
    * @dev Adds two unsigned integers, reverts on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="183" endline="199" pcid="4988">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/UGCoin.sol" startline="14" endline="19" pcid="7524">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="165" endline="185" pcid="651">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BKN.sol" startline="115" endline="121" pcid="1331">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="44" endline="47" pcid="1710">
    function min256(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }
}
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="60" endline="64" pcid="2227">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/BKN.sol" startline="133" endline="138" pcid="1334">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/BountyBoard.sol" startline="84" endline="103" pcid="1490">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }
    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/UGCoin.sol" startline="19" endline="24" pcid="7525">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/UGCoin.sol" startline="24" endline="29" pcid="7526">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="199" endline="212" pcid="4989">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="349" endline="365" pcid="319">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/LBBT.sol" startline="23" endline="28" pcid="4534">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="27" endline="37" pcid="1266">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        // uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return a / b;
    }

    /**
    * Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="35" endline="45" pcid="1429">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        // uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return a / b;
    }

    /**
    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BDAM.sol" startline="28" endline="35" pcid="1109">
  function div(uint256 a, uint256 b) internal constant returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal constant returns (uint256) {
</source>
<source file="systems/smart_contracts/GameGold.sol" startline="96" endline="101" pcid="3989">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="48" endline="58" pcid="1879">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b <= a);
    uint256 c = a - b;

    return c;
  }

  /**
  * @dev Adds two numbers, reverts on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Byte.sol" startline="31" endline="36" pcid="1572">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="253" endline="268" pcid="4992">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="189" endline="205" pcid="2464">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TorexToken.sol" startline="44" endline="52" pcid="7405">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="261" endline="277" pcid="4747">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="288" endline="303" pcid="4994">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="205" endline="221" pcid="2465">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="60" endline="64" pcid="6975">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="246" endline="266" pcid="2467">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="245" endline="261" pcid="4746">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/GameGold.sol" startline="88" endline="96" pcid="3988">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="49" endline="60" pcid="6974">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b > 0);
        uint256 c = a / b;
        assert(a == b * c + a % b);
        return a / b;
    }

    /**
     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
     * reverts when dividing by zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="108" endline="112" pcid="5952">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="28" endline="36" pcid="6972">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    /**
     * @dev Multiplies two unsigned integers, reverts on overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/MBA.sol" startline="40" endline="48" pcid="4700">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="32" endline="37" pcid="4377">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="127" endline="143" pcid="1751">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="43" endline="49" pcid="2395">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }

  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/GameGold.sol" startline="78" endline="88" pcid="3987">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  /**
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="44" endline="54" pcid="5834">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    /**
    * @dev Adds two numbers, reverts on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DABANKING_SWAP.sol" startline="86" endline="96" pcid="2275">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b <= a);
    uint256 c = a - b;

    return c;
  }

  /**
   * @dev Adds two unsigned integers, reverts on overflow.
   */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MpctLockupTeam.sol" startline="12" endline="18" pcid="5054">
    function mul(uint256 a, uint256 b) internal constant returns (uint256) {
        uint256 c = a * b;
        assert(a == 0 || c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal constant returns (uint256) {
</source>
<source file="systems/smart_contracts/MpctLockupTeam.sol" startline="18" endline="23" pcid="5055">
    function div(uint256 a, uint256 b) internal constant returns (uint256) {
        uint256 c = a / b;
        return c;
    }

    function sub(uint256 a, uint256 b) internal constant returns (uint256) {
</source>
<source file="systems/smart_contracts/magesh.sol" startline="32" endline="44" pcid="4608">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="33" endline="38" pcid="1466">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MpctLockupTeam.sol" startline="23" endline="28" pcid="5056">
    function sub(uint256 a, uint256 b) internal constant returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    function add(uint256 a, uint256 b) internal constant returns (uint256) {
</source>
<source file="systems/smart_contracts/MAdvcedWoken.sol" startline="49" endline="55" pcid="4596">
  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

}
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="49" endline="54" pcid="1469">
  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
    uint256 c = add(a,m);
    uint256 d = sub(c,1);
    return mul(div(d,m),m);
  }
}
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="51" endline="67" pcid="802">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/LuckyAdvcedWoken.sol" startline="44" endline="49" pcid="4556">
  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SistContract.sol" startline="23" endline="28" pcid="6514">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/BKN.sol" startline="121" endline="128" pcid="1332">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MpctLockupTeam.sol" startline="28" endline="33" pcid="5057">
    function add(uint256 a, uint256 b) internal constant returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="185" endline="189" pcid="652">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="169" endline="177" pcid="7348">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="159" endline="169" pcid="7347">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    // uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return a / b;
  }

  /**
  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MAdvcedWoken.sol" startline="44" endline="49" pcid="4595">
  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="33" endline="44" pcid="5833">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0); // Solidity only automatically asserts when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="266" endline="270" pcid="2468">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/LuckyStrikeTokens.sol" startline="35" endline="45" pcid="4569">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        // uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return a / b;
    }

    /**
    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MBA.sol" startline="30" endline="40" pcid="4699">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    // uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return a / b;
  }

  /**
  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BountyBoard.sol" startline="30" endline="45" pcid="1487">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }
    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BountyBoard.sol" startline="45" endline="60" pcid="1488">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }
    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MT.sol" startline="8" endline="14" pcid="5068">
  function safeMul(uint256 a, uint256 b) public pure  returns (uint256)  {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CRYPTOMZ.sol" startline="18" endline="25" pcid="2173">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="205" endline="221" pcid="952">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="20" endline="27" pcid="4375">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;       
    }       

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MT.sol" startline="14" endline="21" pcid="5069">
  function safeDiv(uint256 a, uint256 b)public pure returns (uint256) {
    assert(b > 0);
    uint256 c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="96" endline="107" pcid="733">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    /**
    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),
    * reverts when dividing by zero.
    */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="35" endline="51" pcid="801">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MT.sol" startline="21" endline="26" pcid="5070">
  function safeSub(uint256 a, uint256 b)public pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="230" endline="234" pcid="5784">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/BANG.sol" startline="49" endline="54" pcid="1045">
  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
    uint256 c = add(a,m);
    uint256 d = sub(c,1);
    return mul(div(d,m),m);
  }
}
</source>
<source file="systems/smart_contracts/Comet.sol" startline="39" endline="45" pcid="1921">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }

  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PokaToken.sol" startline="76" endline="81" pcid="5738">
  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="45" endline="50" pcid="3922">
  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
    uint256 c = add(a,m);
    uint256 d = sub(c,1);
    return mul(div(d,m),m);
  }
}
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="39" endline="45" pcid="3921">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }

  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PokaToken.sol" startline="69" endline="76" pcid="5737">
  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b > 0);
    uint256 c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ankara.sol" startline="48" endline="55" pcid="682">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0);
        uint256 c = a / b;

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/AronCoin.sol" startline="52" endline="57" pcid="763">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="126" endline="142" pcid="522">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BRZE.sol" startline="39" endline="43" pcid="1523">
  function min256(uint256 a, uint256 b) internal pure returns (uint256) {
    return a < b ? a : b;
  }

}
</source>
<source file="systems/smart_contracts/CST_TOKEN.sol" startline="37" endline="42" pcid="2200">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/AronCoin.sol" startline="45" endline="52" pcid="762">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PositionTokenV2.sol" startline="105" endline="113" pcid="5754">
  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {
    assert(_b <= _a);
    return _a - _b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/LuckyStrikeTokens.sol" startline="45" endline="53" pcid="4570">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    /**
    * @dev Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/TimeLockedTokenStorage.sol" startline="38" endline="46" pcid="7222">
    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {
        assert(_b <= _a);
        return _a - _b;
    }

    /**
    * @dev Adds two numbers, throws on overflow.
    */
    function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="187" endline="191" pcid="525">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="32" endline="48" pcid="4415">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MAdvcedWoken.sol" startline="37" endline="44" pcid="4594">
  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b > 0);
    uint256 c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="29" endline="34" pcid="2151">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ProofOfContributionChainToken.sol" startline="76" endline="81" pcid="5831">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="109" endline="113" pcid="2102">
  function min256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a < b ? a : b;
  }

}
</source>
<source file="systems/smart_contracts/MT.sol" startline="26" endline="32" pcid="5071">
  function safeAdd(uint256 a, uint256 b)public pure returns (uint256) {
    uint256 c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

  function _assert(bool assertion)public pure {
</source>
<source file="systems/smart_contracts/BRZE.sol" startline="36" endline="39" pcid="1522">
  function max256(uint256 a, uint256 b) internal pure returns (uint256) {
    return a >= b ? a : b;
  }
  function min256(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="246" endline="266" pcid="954">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PokaToken.sol" startline="63" endline="69" pcid="5736">
  function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SistContract.sol" startline="15" endline="23" pcid="6513">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="54" endline="65" pcid="6306">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    /**
     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
     * reverts when dividing by zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CouncilVesting.sol" startline="42" endline="46" pcid="2023">
  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a >= b ? a : b;
  }

  function min256(uint256 a, uint256 b) internal constant returns (uint256) {
</source>
<source file="systems/smart_contracts/Comet.sol" startline="45" endline="50" pcid="1922">
  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
    uint256 c = add(a,m);
    uint256 d = sub(c,1);
    return mul(div(d,m),m);
  }
}
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="33" endline="38" pcid="2393">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/LBBT.sol" startline="19" endline="23" pcid="4533">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    return a / b;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Byte.sol" startline="41" endline="47" pcid="1574">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }

  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="38" endline="44" pcid="2303">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0);
        uint256 c = a / b;
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="78" endline="83" pcid="5094">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DABANKING_SWAP.sol" startline="74" endline="86" pcid="2274">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // Solidity only automatically asserts when dividing by 0
    require(b > 0);
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold

    return c;
  }

  /**
   * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
   */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CDS.sol" startline="27" endline="38" pcid="1654">
	function div(uint256 a, uint256 b) internal pure returns (uint256) {
		// Solidity only automatically asserts when dividing by 0
		require(b > 0);
		uint256 c = a / b;
		// assert(a == b * c + a % b); // There is no case in which this doesn't hold
		return c;
	}

	/**
		* @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
		*/
	function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="69" endline="73" pcid="1881">
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b != 0);
    return a % b;
  }
}
</source>
<source file="systems/smart_contracts/customIcoToken.sol" startline="23" endline="28" pcid="2210">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="441" endline="447" pcid="95">
    function safeMul(uint256 _x, uint256 _y) internal pure returns (uint256) {
        uint256 z = _x * _y;
        require(_x == 0 || z / _x == _y);        //assert(_x == 0 || z / _x == _y);
        return z;
    }
	
	function safeDiv(uint256 _x, uint256 _y)internal pure returns (uint256){
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="83" endline="88" pcid="5095">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="134" endline="138" pcid="5673">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="88" endline="94" pcid="5096">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }

  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="34" endline="39" pcid="3920">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/AACD.sol" startline="26" endline="32" pcid="289">
  function safeAdd(uint256 a, uint256 b)public pure returns (uint256) {
    uint256 c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

  function _assert(bool assertion)public pure {
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="29" endline="34" pcid="3919">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DHF.sol" startline="8" endline="14" pcid="2533">
  function safeMul(uint256 a, uint256 b) public pure  returns (uint256)  {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="94" endline="99" pcid="5097">
  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
    uint256 c = add(a,m);
    uint256 d = sub(c,1);
    return mul(div(d,m),m);
  }
}
</source>
<source file="systems/smart_contracts/TimeLockedTokenStorage.sol" startline="28" endline="38" pcid="7221">
    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {
        // assert(_b > 0); // Solidity automatically throws when dividing by 0
        // uint256 c = _a / _b;
        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold
        return _a / _b;
    }

    /**
    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="48" endline="64" pcid="4416">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DHF.sol" startline="14" endline="21" pcid="2534">
  function safeDiv(uint256 a, uint256 b)public pure returns (uint256) {
    assert(b > 0);
    uint256 c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="31" endline="36" pcid="1623">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/Ethertime.sol" startline="15" endline="20" pcid="3300">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0);
        uint256 c = a / b;
        return c;
    }
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/customIcoToken.sol" startline="19" endline="23" pcid="2209">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    return a / b;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="351" endline="355" pcid="3263">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/Bridge.sol" startline="41" endline="53" pcid="1504">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="74" endline="84" pcid="6414">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Adds two unsigned integers, reverts on overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="80" endline="85" pcid="2048">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="333" endline="349" pcid="318">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BRZE.sol" startline="32" endline="36" pcid="1521">
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b != 0);
    return a % b;
  }
  function max256(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="49" endline="60" pcid="6712">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    /**
     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),
     * reverts when dividing by zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Comet.sol" startline="29" endline="34" pcid="1919">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="340" endline="351" pcid="3262">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    /**
    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
    * reverts when dividing by zero.
    */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="62" endline="74" pcid="6413">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BlockPoolToken.sol" startline="54" endline="59" pcid="1411">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="84" endline="95" pcid="6415">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
     * reverts when dividing by zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DHF.sol" startline="21" endline="26" pcid="2535">
  function safeSub(uint256 a, uint256 b)public pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="330" endline="340" pcid="3261">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    /**
    * @dev Adds two unsigned integers, reverts on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/UTC.sol" startline="30" endline="40" pcid="7572">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  /**
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="44" endline="54" pcid="6305">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Adds two unsigned integers, reverts on overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="86" endline="96" pcid="732">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    /**
    * @dev Adds two numbers, reverts on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="32" endline="44" pcid="6304">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="318" endline="330" pcid="3260">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Ethertime.sol" startline="25" endline="30" pcid="3302">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);
        return c;
    }
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/UTC.sol" startline="40" endline="48" pcid="7573">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="95" endline="99" pcid="6416">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/SellableToken.sol" startline="17" endline="22" pcid="6456">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="66" endline="71" pcid="3171">
  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
    uint256 c = add(a,m);
    uint256 d = sub(c,1);
    return mul(div(d,m),m);
  }
}
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="60" endline="66" pcid="3170">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }

  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Bridge.sol" startline="63" endline="74" pcid="1506">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    /**
    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
    * reverts when dividing by zero.
    */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="60" endline="64" pcid="6713">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="55" endline="60" pcid="3169">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="50" endline="55" pcid="3168">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/RETC.sol" startline="8" endline="14" pcid="6174">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="26" endline="31" pcid="1622">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Ethertime.sol" startline="30" endline="34" pcid="3303">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="29" endline="40" pcid="7978">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b > 0); // Solidity only automatically asserts when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold

    return c;
  }

  /**
  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="40" endline="50" pcid="7979">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b <= a);
    uint256 c = a - b;

    return c;
  }

  /**
  * @dev Adds two numbers, reverts on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DHF.sol" startline="26" endline="32" pcid="2536">
  function safeAdd(uint256 a, uint256 b)public pure returns (uint256) {
    uint256 c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

  function _assert(bool assertion)public pure {
</source>
<source file="systems/smart_contracts/CoinDDC.sol" startline="201" endline="207" pcid="1875">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) 
    {
        assert(b <= a);
        return a - b;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256 c) 
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="50" endline="61" pcid="7980">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a);

    return c;
  }

  /**
  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),
  * reverts when dividing by zero.
  */
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="33" endline="38" pcid="2553">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Oracle.sol" startline="112" endline="120" pcid="5514">
  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {
    assert(_b <= _a);
    return _a - _b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/UTC.sol" startline="48" endline="53" pcid="7574">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="123" endline="134" pcid="5672">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    /**
    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
    * reverts when dividing by zero.
    */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="70" endline="82" pcid="7642">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="31" endline="36" pcid="5991">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Oracle.sol" startline="102" endline="112" pcid="5513">
  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {
    // assert(_b > 0); // Solidity automatically throws when dividing by 0
    // uint256 c = _a / _b;
    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold
    return _a / _b;
  }

  /**
  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="337" endline="353" pcid="5162">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="38" endline="43" pcid="2554">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/OMGToken.sol" startline="52" endline="56" pcid="5486">
  function min256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a < b ? a : b;
  }

  function assert(bool assertion) internal {
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="36" endline="41" pcid="5992">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="26" endline="32" pcid="1706">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }

    function max64(uint64 a, uint64 b) internal pure returns (uint64) {
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="41" endline="47" pcid="5993">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }

  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="353" endline="369" pcid="5163">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/RETC.sol" startline="14" endline="19" pcid="6175">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="126" endline="142" pcid="482">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="28" endline="39" pcid="2224">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0); // Solidity only automatically asserts when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="61" endline="65" pcid="7981">
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b != 0);
    return a % b;
  }
}
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="34" endline="39" pcid="2152">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="394" endline="414" pcid="5165">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="43" endline="49" pcid="2555">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }

  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="49" endline="54" pcid="2556">
  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
    uint256 c = add(a,m);
    uint256 d = sub(c,1);
    return mul(div(d,m),m);
  }
}
</source>
<source file="systems/smart_contracts/SellableToken.sol" startline="22" endline="27" pcid="6457">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="47" endline="52" pcid="5994">
  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
    uint256 c = add(a,m);
    uint256 d = sub(c,1);
    return mul(div(d,m),m);
  }
}
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="414" endline="418" pcid="5166">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="82" endline="92" pcid="7643">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Adds two unsigned integers, reverts on overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Ethertime.sol" startline="20" endline="25" pcid="3301">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;
        return c;
    }
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MultiSendErc20.sol" startline="28" endline="40" pcid="5199">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CDS.sol" startline="38" endline="47" pcid="1655">
	function sub(uint256 a, uint256 b) internal pure returns (uint256) {
		require(b <= a);
		uint256 c = a - b;
		return c;
	}

	/**
		* @dev Adds two unsigned integers, reverts on overflow.
		*/
	function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MultiSendErc20.sol" startline="40" endline="50" pcid="5200">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    /**
    * @dev Adds two unsigned integers, reverts on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="189" endline="205" pcid="6023">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="110" endline="126" pcid="521">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="40" endline="44" pcid="1709">
    function max256(uint256 a, uint256 b) internal pure returns (uint256) {
        return a >= b ? a : b;
    }

    function min256(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="184" endline="192" pcid="3075">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="45" endline="50" pcid="7320">
  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
    uint256 c = add(a,m);
    uint256 d = sub(c,1);
    return mul(div(d,m),m);
  }
}
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="174" endline="184" pcid="3074">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    // uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return a / b;
  }

  /**
  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MultiSendErc20.sol" startline="50" endline="61" pcid="5201">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    /**
    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
    * reverts when dividing by zero.
    */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/RETC.sol" startline="19" endline="24" pcid="6176">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MultiSendErc20.sol" startline="61" endline="65" pcid="5202">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="92" endline="103" pcid="7644">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    /**
     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
     * reverts when dividing by zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="87" endline="99" pcid="570">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "Safe div error");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BACD.sol" startline="43" endline="48" pcid="1013">
  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/BountyBoard.sol" startline="103" endline="107" pcid="1491">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/SellableToken.sol" startline="27" endline="32" pcid="6458">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="410" endline="414" pcid="322">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="107" endline="111" pcid="7899">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/BFGToken.sol" startline="30" endline="35" pcid="1180">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="103" endline="107" pcid="7645">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="16" endline="19" pcid="8007">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="205" endline="221" pcid="6024">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="534" endline="538" pcid="2617">
    function max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a >= b ? a : b;
    }

    function min(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MultiSign.sol" startline="9" endline="15" pcid="5233">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a * b;
    require(a == 0 || c / a == b);
    return c;
  }
 
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="58" endline="69" pcid="1880">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a);

    return c;
  }

  /**
  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),
  * reverts when dividing by zero.
  */
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/AronCoin.sol" startline="57" endline="62" pcid="764">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/MultiSign.sol" startline="15" endline="20" pcid="5234">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="99" endline="109" pcid="571">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "Safe sub error");
        uint256 c = a - b;

        return c;
    }

    /**
    * @dev Adds two unsigned integers, reverts on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CST_TOKEN.sol" startline="27" endline="32" pcid="2198">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BlockPoolToken.sol" startline="47" endline="54" pcid="1410">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }
    /**
     * @dev Adds two numbers, throws on overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="39" endline="49" pcid="2225">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Adds two numbers, reverts on overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="28" endline="39" pcid="7697">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0); // Solidity only automatically asserts when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="538" endline="542" pcid="2618">
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }

    function average(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NaorisToken.sol" startline="29" endline="39" pcid="5278">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }

    /**
    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NaorisToken.sol" startline="39" endline="47" pcid="5279">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    /**
    * @dev Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="19" endline="23" pcid="8008">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/NaorisToken.sol" startline="47" endline="52" pcid="5280">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="73" endline="77" pcid="6828">
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b != 0);
    return a % b;
  }
}
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="542" endline="546" pcid="2619">
    function average(uint256 a, uint256 b) internal pure returns (uint256) {
        // (a + b) / 2 can overflow, so we distribute
        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
    }
}
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="87" endline="107" pcid="7898">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="89" endline="109" pcid="4418">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Bridge.sol" startline="74" endline="78" pcid="1507">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/BACD.sol" startline="38" endline="43" pcid="1012">
  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/OMGToken.sol" startline="48" endline="52" pcid="5485">
  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a >= b ? a : b;
  }

  function min256(uint256 a, uint256 b) internal constant returns (uint256) {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="266" endline="270" pcid="955">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="62" endline="73" pcid="6827">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a);

    return c;
  }

  /**
  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),
  * reverts when dividing by zero.
  */
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="52" endline="62" pcid="6826">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b <= a);
    uint256 c = a - b;

    return c;
  }

  /**
  * @dev Adds two numbers, reverts on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="46" endline="62" pcid="7896">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="191" endline="195" pcid="8234">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/NBToken.sol" startline="38" endline="47" pcid="5299">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }
    /**
     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="39" endline="49" pcid="6711">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Adds two numbers, reverts on overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BKN.sol" startline="128" endline="133" pcid="1333">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="39" endline="49" pcid="7698">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Adds two numbers, reverts on overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="14" endline="21" pcid="1704">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        
        uint256 c = a / b;
        
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ankara.sol" startline="55" endline="62" pcid="683">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="93" endline="97" pcid="1369">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="49" endline="60" pcid="7699">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    /**
     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),
     * reverts when dividing by zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NBToken.sol" startline="47" endline="54" pcid="5300">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }
    /**
     * @dev Adds two numbers, throws on overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NSTTeamLock.sol" startline="173" endline="177" pcid="5466">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/BDAM.sol" startline="35" endline="40" pcid="1110">
  function sub(uint256 a, uint256 b) internal constant returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal constant returns (uint256) {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="60" endline="64" pcid="7700">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="21" endline="26" pcid="1705">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="112" endline="116" pcid="3760">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="52" endline="58" pcid="3016">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }
}
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="30" endline="46" pcid="7895">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NBToken.sol" startline="54" endline="59" pcid="5301">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="39" endline="45" pcid="2153">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }

  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="41" endline="52" pcid="6825">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b > 0); // Solidity only automatically asserts when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold

    return c;
  }

  /**
  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CNG.sol" startline="72" endline="83" pcid="1847">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b > 0); // Solidity only automatically asserts when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold

    return c;
  }

  /**
  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="109" endline="113" pcid="4419">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="92" endline="112" pcid="3759">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="51" endline="67" pcid="3757">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SAS.sol" startline="21" endline="26" pcid="6291">
  function safeSub(uint256 a, uint256 b)public pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SAS.sol" startline="8" endline="14" pcid="6289">
  function safeMul(uint256 a, uint256 b) public pure  returns (uint256)  {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NEM.sol" startline="8" endline="14" pcid="5316">
  function safeMul(uint256 a, uint256 b) public pure  returns (uint256)  {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NEM.sol" startline="14" endline="21" pcid="5317">
  function safeDiv(uint256 a, uint256 b)public pure returns (uint256) {
    assert(b > 0);
    uint256 c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="35" endline="51" pcid="3756">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="45" endline="50" pcid="6205">
  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
    uint256 c = add(a,m);
    uint256 d = sub(c,1);
    return mul(div(d,m),m);
  }
}
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="428" endline="441" pcid="94">
    function safeSub(uint256 _x, uint256 _y) internal pure returns (uint256) {
        require(_x >= _y);        //assert(_x >= _y);
        return _x - _y;
    }

    /**
        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows

        @param _x   factor 1
        @param _y   factor 2

        @return product
    */
    function safeMul(uint256 _x, uint256 _y) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="207" endline="211" pcid="3715">
function mod(uint256 a, uint256 b) internal pure returns (uint256) {
require(b != 0);
return a % b;
}
}
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="246" endline="266" pcid="6026">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="196" endline="207" pcid="3714">
function add(uint256 _a, uint256 _b) internal pure returns (uint256) {
uint256 c = _a + _b;
require(c >= _a);

return c;
}

/**
* @dev Divides two numbers and returns the remainder (unsigned integer modulo),
* reverts when dividing by zero.
*/
function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="186" endline="196" pcid="3713">
function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {
require(_b <= _a);
uint256 c = _a - _b;

return c;
}

/**
* @dev Adds two numbers, reverts on overflow.
*/
function add(uint256 _a, uint256 _b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Factory.sol" startline="108" endline="124" pcid="3435">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="39" endline="45" pcid="6204">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }

  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="175" endline="186" pcid="3712">
function div(uint256 _a, uint256 _b) internal pure returns (uint256) {
require(_b > 0); // Solidity only automatically asserts when dividing by 0
uint256 c = _a / _b;
assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold

return c;
}

/**
* @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
*/
function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NEM.sol" startline="21" endline="26" pcid="5318">
  function safeSub(uint256 a, uint256 b)public pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/FMT.sol" startline="209" endline="214" pcid="3664">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="49" endline="54" pcid="2396">
  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
    uint256 c = add(a,m);
    uint256 d = sub(c,1);
    return mul(div(d,m),m);
  }
}
</source>
<source file="systems/smart_contracts/Factory.sol" startline="124" endline="140" pcid="3436">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="266" endline="270" pcid="6027">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/FMT.sol" startline="204" endline="209" pcid="3663">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="42" endline="52" pcid="3015">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Adds two unsigned integers, reverts on overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="34" endline="39" pcid="6203">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/FMT.sol" startline="197" endline="204" pcid="3662">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NSTTeamLock.sol" startline="162" endline="173" pcid="5465">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
     * reverts when dividing by zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="8" endline="15" pcid="8037">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="39" endline="45" pcid="7319">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }

  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="45" endline="52" pcid="7746">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NSTTeamLock.sol" startline="152" endline="162" pcid="5464">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Adds two unsigned integers, reverts on overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="37" endline="45" pcid="1267">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    /**
    * Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="171" endline="191" pcid="8233">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Fk.sol" startline="95" endline="99" pcid="3622">
     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
     	require(b != 0, "SafeMath: modulo by zero");
     	return a % b;
     }
 }
</source>
<source file="systems/smart_contracts/Fk.sol" startline="75" endline="95" pcid="3621">
     function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="29" endline="34" pcid="2644">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="34" endline="39" pcid="2645">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="34" endline="39" pcid="7318">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="29" endline="34" pcid="6202">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="44" endline="50" pcid="2304">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;
        return c;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ProofOfContributionChainToken.sol" startline="72" endline="76" pcid="5830">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BACD.sol" startline="31" endline="38" pcid="1011">
  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Factory.sol" startline="165" endline="185" pcid="3438">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NEM.sol" startline="26" endline="32" pcid="5319">
  function safeAdd(uint256 a, uint256 b)public pure returns (uint256) {
    uint256 c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

  function _assert(bool assertion)public pure {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="39" endline="45" pcid="2646">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }

  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Factory.sol" startline="185" endline="189" pcid="3439">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/ankara.sol" startline="62" endline="69" pcid="684">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="168" endline="188" pcid="1753">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SCMCoin.sol" startline="8" endline="14" pcid="6381">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="29" endline="34" pcid="7317">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="45" endline="50" pcid="2647">
  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
    uint256 c = add(a,m);
    uint256 d = sub(c,1);
    return mul(div(d,m),m);
  }
}
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="27" endline="38" pcid="5329">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="113" endline="123" pcid="5671">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    /**
    * @dev Adds two unsigned integers, reverts on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="130" endline="146" pcid="8231">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="52" endline="57" pcid="7747">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="530" endline="534" pcid="2708">
    function max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a >= b ? a : b;
    }

    function min(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SCMCoin.sol" startline="14" endline="19" pcid="6382">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="124" endline="140" pcid="649">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Fk.sol" startline="34" endline="50" pcid="3619">
     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
     	require(b <= a, "SafeMath: subtraction overflow");
     	uint256 c = a - b;

     	return c;
     }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="37" endline="48" pcid="1878">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b > 0); // Solidity only automatically asserts when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold

    return c;
  }

  /**
  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="534" endline="538" pcid="2709">
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }

    function average(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="106" endline="110" pcid="6080">
  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a >= b ? a : b;
  }

  function min256(uint256 a, uint256 b) internal constant returns (uint256) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="38" endline="46" pcid="5330">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Fk.sol" startline="18" endline="34" pcid="3618">
     function add(uint256 a, uint256 b) internal pure returns (uint256) {
     	uint256 c = a + b;
     	require(c >= a, "SafeMath: addition overflow");

     	return c;
     }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="57" endline="62" pcid="7748">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="65" endline="69" pcid="3547">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="71" endline="79" pcid="5333">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="110" endline="114" pcid="6081">
  function min256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a < b ? a : b;
  }

}
</source>
<source file="systems/smart_contracts/AACD.sol" startline="8" endline="14" pcid="286">
  function safeMul(uint256 a, uint256 b) public pure  returns (uint256)  {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="101" endline="113" pcid="5670">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="33" endline="43" pcid="6675">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        // uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return a / b;
    }

    /*
    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="538" endline="542" pcid="2710">
    function average(uint256 a, uint256 b) internal pure returns (uint256) {
        // (a + b) / 2 can overflow, so we distribute
        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
    }
}
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="114" endline="130" pcid="8230">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="43" endline="51" pcid="6676">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    /*
    * @dev Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="72" endline="83" pcid="2740">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b > 0); // Solidity only automatically asserts when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold

    return c;
  }

  /**
  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Ownable.sol" startline="32" endline="37" pcid="5568">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/Byte.sol" startline="36" endline="41" pcid="1573">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="83" endline="93" pcid="2741">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b <= a);
    uint256 c = a - b;

    return c;
  }

  /**
  * @dev Adds two numbers, reverts on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="66" endline="70" pcid="7268">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/WTA.sol" startline="15" endline="19" pcid="8038">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="65" endline="69" pcid="2980">
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b != 0);
    return a % b;
  }
}
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="54" endline="65" pcid="3546">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    /**
    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),
    * reverts when dividing by zero.
    */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NSTTeamLock.sol" startline="140" endline="152" pcid="5463">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BANG.sol" startline="43" endline="49" pcid="1044">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }

  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="44" endline="54" pcid="3545">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    /**
    * @dev Adds two numbers, reverts on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="54" endline="65" pcid="2979">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a);

    return c;
  }

  /**
  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),
  * reverts when dividing by zero.
  */
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DABANKING_SWAP.sol" startline="107" endline="111" pcid="2277">
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b != 0);
    return a % b;
  }
}
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="32" endline="44" pcid="3544">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BANG.sol" startline="33" endline="38" pcid="1042">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="55" endline="66" pcid="7267">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    /**
     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
     * reverts when dividing by zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="25" endline="36" pcid="7771">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="89" endline="97" pcid="5335">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="30" endline="46" pcid="5408">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CNG.sol" startline="93" endline="104" pcid="1849">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a);

    return c;
  }

  /**
  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),
  * reverts when dividing by zero.
  */
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="44" endline="54" pcid="2978">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b <= a);
    uint256 c = a - b;

    return c;
  }

  /**
  * @dev Adds two numbers, reverts on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="36" endline="44" pcid="7772">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SCMCoin.sol" startline="19" endline="24" pcid="6383">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="41" endline="49" pcid="6478">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    /**
    * @dev Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="69" endline="77" pcid="7775">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="46" endline="59" pcid="5409">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Ownable.sol" startline="27" endline="32" pcid="5567">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="33" endline="44" pcid="2977">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b > 0); // Solidity only automatically asserts when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold

    return c;
  }

  /**
  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="34" endline="42" pcid="3514">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    /**
    * @dev Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/SAS.sol" startline="14" endline="21" pcid="6290">
  function safeDiv(uint256 a, uint256 b)public pure returns (uint256) {
    assert(b > 0);
    uint256 c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="33" endline="45" pcid="7265">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="37" endline="41" pcid="8041">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="93" endline="104" pcid="2742">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a);

    return c;
  }

  /**
  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),
  * reverts when dividing by zero.
  */
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="24" endline="34" pcid="3513">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        // uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return a / b;
    }

    /**
    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="100" endline="115" pcid="5412">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Ownable.sol" startline="22" endline="27" pcid="5566">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CAC.sol" startline="26" endline="32" pcid="1610">
  function safeAdd(uint256 a, uint256 b)public pure returns (uint256) {
    uint256 c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

  function _assert(bool assertion)public pure {
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="45" endline="55" pcid="7266">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Adds two unsigned integers, reverts on overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="189" endline="205" pcid="951">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ankara.sol" startline="69" endline="73" pcid="685">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/AACD.sol" startline="14" endline="21" pcid="287">
  function safeDiv(uint256 a, uint256 b)public pure returns (uint256) {
    assert(b > 0);
    uint256 c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="87" endline="95" pcid="7777">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CNG.sol" startline="104" endline="108" pcid="1850">
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b != 0);
    return a % b;
  }
}
</source>
<source file="systems/smart_contracts/BDAM.sol" startline="40" endline="45" pcid="1111">
  function add(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="50" endline="56" pcid="2305">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);
        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="135" endline="150" pcid="5414">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NMAI.sol" startline="8" endline="14" pcid="5438">
  function safeMul(uint256 a, uint256 b) public pure  returns (uint256)  {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NMAI.sol" startline="14" endline="21" pcid="5439">
  function safeDiv(uint256 a, uint256 b)public pure returns (uint256) {
    assert(b > 0);
    uint256 c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="43" endline="49" pcid="1468">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }

  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="104" endline="108" pcid="2743">
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b != 0);
    return a % b;
  }
}
</source>
<source file="systems/smart_contracts/WTA.sol" startline="50" endline="54" pcid="8043">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="38" endline="46" pcid="2947">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    /**
    * @dev Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="28" endline="38" pcid="2946">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        // uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return a / b;
    }

    /**
    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SCMCoin.sol" startline="24" endline="29" pcid="6384">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/RETC.sol" startline="24" endline="29" pcid="6177">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="75" endline="86" pcid="731">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0); // Solidity only automatically asserts when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/EmpowCreateEosAccount.sol" startline="112" endline="122" pcid="2936">
    function setPrice (uint256 _price, uint256 _usdtPrice)
        public
        onlyOwner
        returns (bool)
    {
        PRICE = _price;
        USDT_PRICE = _usdtPrice;
        return true;
    }
    
    function ownerWithdraw (uint256 _amount)
</source>
<source file="systems/smart_contracts/BRZE.sol" startline="22" endline="27" pcid="1519">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b <= a);
    uint256 c = a - b;
    return c;
  }
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="107" endline="111" pcid="8189">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="454" endline="457" pcid="97">
	function ceilDiv(uint256 _x, uint256 _y)internal pure returns (uint256){
		return (_x + _y - 1) / _y;
	}
}
</source>
<source file="systems/smart_contracts/SuperMarket.sol" startline="63" endline="69" pcid="6764">
  function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CST_TOKEN.sol" startline="32" endline="37" pcid="2199">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DNP.sol" startline="43" endline="50" pcid="2785">
    function div(uint256 a, uint256 b) internal pure returns (uint256) 
    {
        return a  / b;
    }
    /**
    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) 
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="28" endline="39" pcid="6710">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0); // Solidity only automatically asserts when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="31" endline="41" pcid="6477">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        // uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return a / b;
    }

    /**
    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DNP.sol" startline="50" endline="58" pcid="2786">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) 
    {
        assert(b <= a);
        return a - b;
    }
    /**
    * @dev Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) 
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="167" endline="187" pcid="524">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="87" endline="107" pcid="8188">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="46" endline="62" pcid="8186">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SEA.sol" startline="27" endline="32" pcid="6394">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="45" endline="50" pcid="2154">
  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
    uint256 c = add(a,m);
    uint256 d = sub(c,1);
    return mul(div(d,m),m);
  }
}
</source>
<source file="systems/smart_contracts/SEA.sol" startline="17" endline="22" pcid="6392">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a / b;
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="30" endline="46" pcid="8185">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SEA.sol" startline="22" endline="27" pcid="6393">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="16" endline="19" pcid="2873">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="108" endline="124" pcid="648">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="19" endline="23" pcid="2874">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/NMAI.sol" startline="21" endline="26" pcid="5440">
  function safeSub(uint256 a, uint256 b)public pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/XGP.sol" startline="50" endline="58" pcid="8099">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    /**
    * Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/BANG.sol" startline="38" endline="43" pcid="1043">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/XGP.sol" startline="40" endline="50" pcid="8098">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        // uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return a / b;
    }

    /**
    * Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SuperMarket.sol" startline="69" endline="76" pcid="6765">
  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b > 0);
    uint256 c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NMAI.sol" startline="26" endline="32" pcid="5441">
  function safeAdd(uint256 a, uint256 b)public pure returns (uint256) {
    uint256 c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

  function _assert(bool assertion)public pure {
</source>
<source file="systems/smart_contracts/SuperMarket.sol" startline="81" endline="87" pcid="6767">
  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

}
</source>
<source file="systems/smart_contracts/SuperMarket.sol" startline="76" endline="81" pcid="6766">
  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="142" endline="148" pcid="8082">
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
      require(b != 0);
      return a % b;
  }
 

  function uint2str(uint i) internal pure returns (string){
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="131" endline="142" pcid="8081">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
      uint256 c = a + b;
      require(c >= a);

      return c;
  }

  /**
  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),
  * reverts when dividing by zero.
  */
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="121" endline="131" pcid="8080">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
      require(b <= a);
      uint256 c = a - b;

      return c;
  }

  /**
  * @dev Adds two numbers, reverts on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="60" endline="72" pcid="1366">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="109" endline="121" pcid="8079">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
      // Solidity only automatically asserts when dividing by 0
      require(b > 0);
      uint256 c = a / b;
      // assert(a == b * c + a % b); // There is no case in which this doesn't hold

      return c;
  }

  /**
  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="100" endline="104" pcid="6776">
    function mod(uint a, uint b) internal pure returns (uint) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/DaiSwap.sol" startline="13" endline="17" pcid="2282">
  function safeSub(uint a, uint b) internal pure returns (uint) {
    assert(b <= a);
    return a - b;
  }
  function safeAdd(uint a, uint b) internal pure returns (uint) {
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="32" endline="36" pcid="1707">
    function max64(uint64 a, uint64 b) internal pure returns (uint64) {
        return a >= b ? a : b;
    }

    function min64(uint64 a, uint64 b) internal pure returns (uint64) {
</source>
<source file="systems/smart_contracts/OMGToken.sol" startline="40" endline="44" pcid="5483">
  function max64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a >= b ? a : b;
  }

  function min64(uint64 a, uint64 b) internal constant returns (uint64) {
</source>
<source file="systems/smart_contracts/CouncilVesting.sol" startline="34" endline="38" pcid="2021">
  function max64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a >= b ? a : b;
  }

  function min64(uint64 a, uint64 b) internal constant returns (uint64) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="98" endline="102" pcid="6078">
  function max64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a >= b ? a : b;
  }

  function min64(uint64 a, uint64 b) internal constant returns (uint64) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="39" endline="43" pcid="4832">
  function max64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a >= b ? a : b;
  }

  function min64(uint64 a, uint64 b) internal constant returns (uint64) {
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="97" endline="101" pcid="2099">
  function max64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a >= b ? a : b;
  }

  function min64(uint64 a, uint64 b) internal constant returns (uint64) {
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="36" endline="40" pcid="1708">
    function min64(uint64 a, uint64 b) internal pure returns (uint64) {
        return a < b ? a : b;
    }

    function max256(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Exchange.sol" startline="852" endline="855" pcid="3405">
    function min(uint a, uint b) private pure returns (uint) {
        return a < b ? a : b;
    }
}
</source>
<source file="systems/smart_contracts/MiniMeTokenFactory.sol" startline="515" endline="522" pcid="4824">
    function min(uint a, uint b) pure internal returns (uint) {
        return a < b ? a : b;
    }

    /// @notice The fallback function: If the contract's controller has not been
    ///  set to 0, then the `proxyPayment` method is called which relays the
    ///  ether and creates tokens as described in the token controller contract
    function () external payable {
</source>
<source file="systems/smart_contracts/CouncilVesting.sol" startline="38" endline="42" pcid="2022">
  function min64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a < b ? a : b;
  }

  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="43" endline="47" pcid="4833">
  function min64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a < b ? a : b;
  }

  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="102" endline="106" pcid="6079">
  function min64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a < b ? a : b;
  }

  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
</source>
<source file="systems/smart_contracts/OMGToken.sol" startline="44" endline="48" pcid="5484">
  function min64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a < b ? a : b;
  }

  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="101" endline="105" pcid="2100">
  function min64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a < b ? a : b;
  }

  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="159" endline="180" pcid="6831">
    function multiplyDecimal(uint x, uint y)
        internal
        pure
        returns (uint)
    {
        /* Divide by UNIT to remove the extra factor introduced by the product. */
        return x.mul(y) / UNIT;
    }

    /**
     * @return The result of safely multiplying x and y, interpreting the operands
     * as fixed-point decimals of the specified precision unit.
     *
     * @dev The operands should be in the form of a the specified unit factor which will be
     * divided out after the product of x and y is evaluated, so that product must be
     * less than 2**256.
     *
     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.
     * Rounding is useful when you need to retain fidelity for small decimal numbers
     * (eg. small fractions or percentages).
     */
    function _multiplyDecimalRound(uint x, uint y, uint precisionUnit)
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="53" endline="63" pcid="5144">
    function mulCap(uint _a, uint _b) internal pure returns (uint) {
        // Gas optimization: this is cheaper than requiring '_a' not being zero, but the
        // benefit is lost if '_b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (_a == 0)
            return 0;

        uint c = _a * _b;
        return c / _a == _b ? c : UINT_MAX;
    }
}
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="207" endline="227" pcid="6833">
    function multiplyDecimalRoundPrecise(uint x, uint y)
        internal
        pure
        returns (uint)
    {
        return _multiplyDecimalRound(x, y, PRECISE_UNIT);
    }

    /**
     * @return The result of safely multiplying x and y, interpreting the operands
     * as fixed-point decimals of a standard unit.
     *
     * @dev The operands should be in the standard unit factor which will be
     * divided out after the product of x and y is evaluated, so that product must be
     * less than 2**256.
     *
     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.
     * Rounding is useful when you need to retain fidelity for small decimal numbers
     * (eg. small fractions or percentages).
     */
    function multiplyDecimalRound(uint x, uint y)
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="227" endline="244" pcid="6834">
    function multiplyDecimalRound(uint x, uint y)
        internal
        pure
        returns (uint)
    {
        return _multiplyDecimalRound(x, y, UNIT);
    }

    /**
     * @return The result of safely dividing x and y. The return value is a high
     * precision decimal.
     * 
     * @dev y is divided after the product of x and the standard precision unit
     * is evaluated, so the product of x and UNIT must be less than 2**256. As
     * this is an integer division, the result is always rounded down.
     * This helps save on gas. Rounding is more expensive on gas.
     */
    function divideDecimal(uint x, uint y)
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="89" endline="100" pcid="6775">
    function add(uint a, uint b) internal pure returns (uint) {
        uint c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
     * reverts when dividing by zero.
     */
    function mod(uint a, uint b) internal pure returns (uint) {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="244" endline="261" pcid="6835">
    function divideDecimal(uint x, uint y)
        internal
        pure
        returns (uint)
    {
        /* Reintroduce the UNIT factor that will be divided out by y. */
        return x.mul(UNIT).div(y);
    }

    /**
     * @return The result of safely dividing x and y. The return value is as a rounded
     * decimal in the precision unit specified in the parameter.
     *
     * @dev y is divided after the product of x and the specified precision unit
     * is evaluated, so the product of x and the specified precision unit must
     * be less than 2**256. The result is rounded to the nearest increment.
     */
    function _divideDecimalRound(uint x, uint y, uint precisionUnit)
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="79" endline="89" pcid="6774">
    function sub(uint a, uint b) internal pure returns (uint) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint c = a - b;

        return c;
    }

    /**
     * @dev Adds two unsigned integers, reverts on overflow.
     */
    function add(uint a, uint b) internal pure returns (uint) {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="283" endline="299" pcid="6837">
    function divideDecimalRound(uint x, uint y)
        internal
        pure
        returns (uint)
    {
        return _divideDecimalRound(x, y, UNIT);
    }

    /**
     * @return The result of safely dividing x and y. The return value is as a rounded
     * high precision decimal.
     *
     * @dev y is divided after the product of x and the high precision unit
     * is evaluated, so the product of x and the high precision unit must
     * be less than 2**256. The result is rounded to the nearest increment.
     */
    function divideDecimalRoundPrecise(uint x, uint y)
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="299" endline="310" pcid="6838">
    function divideDecimalRoundPrecise(uint x, uint y)
        internal
        pure
        returns (uint)
    {
        return _divideDecimalRound(x, y, PRECISE_UNIT);
    }

    /**
     * @dev Convert a standard decimal representation to a high precision one.
     */
    function decimalToPreciseDecimal(uint i)
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="67" endline="79" pcid="6773">
    function div(uint a, uint b) internal pure returns (uint) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
     */
    function sub(uint a, uint b) internal pure returns (uint) {
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="43" endline="53" pcid="5143">
    function subCap(uint _a, uint _b) internal pure returns (uint) {
        if (_b > _a)
            return 0;
        else
            return _a - _b;
    }

    /**
     * @dev Multiplies two unsigned integers, returns 2^256 - 1 on overflow.
     */
    function mulCap(uint _a, uint _b) internal pure returns (uint) {
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="35" endline="43" pcid="5142">
    function addCap(uint _a, uint _b) internal pure returns (uint) {
        uint c = _a + _b;
        return c >= _a ? c : UINT_MAX;
    }

    /**
     * @dev Subtracts two integers, returns 0 on underflow.
     */
    function subCap(uint _a, uint _b) internal pure returns (uint) {
</source>
<source file="systems/smart_contracts/DaiSwap.sol" startline="17" endline="22" pcid="2283">
  function safeAdd(uint a, uint b) internal pure returns (uint) {
    uint c = a + b;
    assert(c>=a && c>=b);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/DaiSwap.sol" startline="8" endline="13" pcid="2281">
  function safeMul(uint a, uint b) internal pure returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
  function safeSub(uint a, uint b) internal pure returns (uint) {
</source>
</class>

<class classid="36" nclones="2" nlines="7" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="477" endline="483" pcid="99">
    function calledUpdate(address _oldCalled, address _newCalled) public ownerOnly {
        if(data == _oldCalled) {
            data = IData(_newCalled);
            emit CalledUpdate(_oldCalled, _newCalled);
        }
    }
}
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="163" endline="170" pcid="2856">
    function calledUpdate(address _oldCalled, address _newCalled) public ownerOnly {
        if(operator == _oldCalled) {
            operator = ITokenOperator(_newCalled);
        	emit CalledUpdate(_oldCalled, _newCalled);
		}
    }
    
    function name() public view returns (string){
</source>
</class>

<class classid="37" nclones="812" nlines="4" similarity="75">
<source file="systems/smart_contracts/$martFund.sol" startline="486" endline="489" pcid="100">
    function getBU(bytes32 _key) internal view returns(uint256) {
        return data.bu(_key);        
    }
}
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="386" endline="390" pcid="1387">
    function isPauser(address account) public view returns (bool) {
        return _pausers.has(account);
    }

    function addPauser(address account) public onlyPauser {
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="524" endline="528" pcid="329">
    function isPauser(address account) public view returns (bool) {
        return _pausers.has(account);
    }

    function addPauser(address account) public onlyPauser {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="907" endline="910" pcid="999">
    function isKYCConfirmed(address user) public view returns (bool) {
        return kyc.isConfirmed(user);
    }
}
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="621" endline="624" pcid="165">
    function getBA(bytes32 _key) internal view returns(address) {
        return data.ba(_key);        
    }
}
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="240" endline="244" pcid="1899">
  function isConverter(address account) public view returns (bool) {
    return converters.has(account);
  }

  function addConverter(address account) public onlyConverter {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="590" endline="594" pcid="6360">
    function isBlacklisted(address account) public view returns (bool) {
        return _Blacklisteds.has(account);
    }

    function addBlacklisted(address account) public onlyBlacklistAdmin {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="563" endline="567" pcid="6044">
    function isPauser(address account) public view returns (bool) {
        return _pausers.has(account);
    }

    function addPauser(address account) public onlyPauser {
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="369" endline="374" pcid="6610">
	function isOperationActive(bytes32 _operation) private view returns (bool) {
		return 0 != m_multiOwnedPending[_operation].yetNeeded;
	}


	function assertOwnersAreConsistent() private view {
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="665" endline="669" pcid="342">
    function isMinter(address account) public view returns (bool) {
        return _minters.has(account);
    }

    function addMinter(address account) public onlyMinter {
</source>
<source file="systems/smart_contracts/ParkingResolver.sol" startline="59" endline="63" pcid="5598">
    function addr(bytes32 nodehash) external view returns (address) {
        return _addr;
    }

    function setAddr(bytes32 nodehash, address addr) external {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="554" endline="558" pcid="6356">
    function isBlacklistAdmin(address account) public view returns (bool) {
        return _BlacklistAdmins.has(account);
    }

    function addBlacklistAdmin(address account) public onlyBlacklistAdmin {
</source>
<source file="systems/smart_contracts/StorageUnit.sol" startline="24" endline="27" pcid="6708">
    function read(bytes32 _key) external view returns (bytes32) {
        return store[_key];
    }
}
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="985" endline="994" pcid="5405">
    function isMinter(address account) public view returns (bool) {
        return _minters.has(account);
    }

    /**
     * @dev Give an `account` access to the Minter role.
     *
     * Can only be called by the current owner.
     */
    function addMinter(address account) public onlyOwner {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="950" endline="959" pcid="5402">
    function isProxy(address account) public view returns (bool) {
        return _proxies.has(account);
    }

    /**
     * @dev Give an `account` access to the Proxy role.
     *
     * Can only be called by the current owner.
     */
    function addProxy(address account) public onlyOwner {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="915" endline="924" pcid="5399">
    function isGlobal(address account) public view returns (bool) {
        return _globals.has(account);
    }

    /**
     * @dev Give an `account` access to the Global role.
     *
     * Can only be called by the current owner.
     */
    function addGlobal(address account) public onlyOwner {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="64" endline="68" pcid="4980">
    function isMinter(address account) public view returns (bool) {
        return _minters.has(account);
    }

    function addMinter(address account) public onlyMinter {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="561" endline="565" pcid="7205">
    function isMinter(address account) public view returns (bool) {
        return _minters.has(account);
    }

    function addMinter(address account) public onlyOwner {
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="130" endline="134" pcid="7272">
    function isIssuer(address account) public view returns (bool) {
        return _issuers.has(account);
    }

    function addIssuer(address account) public onlyIssuer {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="541" endline="545" pcid="4445">
    function isPauser(address account) public view returns (bool) {
        return _pausers.has(account);
    }

    function addPauser(address account) public onlyPauser {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="163" endline="167" pcid="6316">
    function isMinter(address account) public view returns (bool) {
        return _minters.has(account);
    }

    function addMinter(address account) public onlyMinter {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="381" endline="385" pcid="4255">
  function isMinter(address account) public view returns (bool) {
    return minters.has(account);
  }

  function addMinter(address account) public onlyMinter {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="485" endline="489" pcid="1771">
    function isMinter(address account) public view returns (bool) {
        return _minters.has(account);
    }

    function addMinter(address account) public onlyMinter {
</source>
<source file="systems/smart_contracts/TrueProfileLogic.sol" startline="115" endline="119" pcid="7497">
    function getAddress(bytes32 _key) external view returns (address) {
        return addressStorage[_key];
    }

    function getUint(bytes32 _key) external view returns (uint) {
</source>
<source file="systems/smart_contracts/TrueProfileLogic.sol" startline="119" endline="123" pcid="7498">
    function getUint(bytes32 _key) external view returns (uint) {
        return uIntStorage[_key];
    }

    function getString(bytes32 _key) external view returns (string) {
</source>
<source file="systems/smart_contracts/TrueProfileLogic.sol" startline="123" endline="127" pcid="7499">
    function getString(bytes32 _key) external view returns (string) {
        return stringStorage[_key];
    }

    function getBytes(bytes32 _key) external view returns (bytes) {
</source>
<source file="systems/smart_contracts/TrueProfileLogic.sol" startline="127" endline="131" pcid="7500">
    function getBytes(bytes32 _key) external view returns (bytes) {
        return bytesStorage[_key];
    }

    function getBool(bytes32 _key) external view returns (bool) {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="563" endline="567" pcid="972">
    function isPauser(address account) public view returns (bool) {
        return _pausers.has(account);
    }

    function addPauser(address account) public onlyPauser {
</source>
<source file="systems/smart_contracts/TrueProfileLogic.sol" startline="131" endline="135" pcid="7501">
    function getBool(bytes32 _key) external view returns (bool) {
        return boolStorage[_key];
    }

    function getInt(bytes32 _key) external view returns (int) {
</source>
<source file="systems/smart_contracts/TrueProfileLogic.sol" startline="135" endline="140" pcid="7502">
    function getInt(bytes32 _key) external view returns (int) {
        return intStorage[_key];
    }

    /**** Set Methods for additional storage ****/
    function setAddress(bytes32 _key, address _value) accessible external {
</source>
<source file="systems/smart_contracts/TrueProfileLogic.sol" startline="276" endline="285" pcid="7522">
    function getRevocationReasonId(bytes32 _key) external view returns (uint8) {
        uint8 v;
        bytes32 r;
        bytes32 s;
        uint8 revocationReasonId;
        (v, r, s, revocationReasonId) = trueProfileStorage.getSignature(_key);

        return revocationReasonId;
    }
}
</source>
<source file="systems/smart_contracts/SBC.sol" startline="203" endline="207" pcid="6321">
    function isPauser(address account) public view returns (bool) {
        return _pausers.has(account);
    }

    function addPauser(address account) public onlyPauser {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="167" endline="171" pcid="3556">
    function isPauser(address account) public view returns (bool) {
        return _pausers.has(account);
    }

    function addPauser(address account) public onlyPauser {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="127" endline="131" pcid="3551">
    function isAdmin(address account) public view returns (bool) {
        return _admins.has(account);
    }

    function addAdmin(address account) public onlyAdmin {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="540" endline="549" pcid="7818">
    function isProxy(address account) public view returns (bool) {
        return _proxies.has(account);
    }

    /**
     * @dev Give an `account` access to the Proxy role.
     *
     * Can only be called by the current owner.
     */
    function addProxy(address account) public onlyOwner {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="270" endline="274" pcid="3254">
    function isMinter(address account) public view returns (bool) {
        return _minters.has(account);
    }

    function addMinter(address account) public onlyMinter {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="176" endline="180" pcid="3246">
    function isPauser(address account) public view returns (bool) {
        return _pausers.has(account);
    }

    function addPauser(address account) public onlyPauser {
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="183" endline="186" pcid="2861">
    function balanceOf(address addr)public view returns(uint256){
        return operator.token_balanceOf(addr);
    }
    function allowance(address _from, address _spender) public view returns (uint256){
</source>
<source file="systems/smart_contracts/Discover.sol" startline="120" endline="131" pcid="2765">
    function withdrawMax(bytes32 _id) external view returns(uint) {
        Data storage d = _getDAppById(_id);
        return d.available;
    }

    /**
     * @dev Developers can withdraw an amount not more than what was available of the
        SNT they originally staked minus what they have already received back in downvotes.
     * @param _id bytes32 unique identifier.
     * @param _amount of tokens to withdraw from DApp's overall balance.
     */
    function withdraw(bytes32 _id, uint _amount) external {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="489" endline="493" pcid="2701">
    function isMinter(address account) public view returns (bool) {
        return _minters.has(account);
    }

    function addMinter(address account) public onlyMinter {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="493" endline="497" pcid="2610">
    function isMinter(address account) public view returns (bool) {
        return _minters.has(account);
    }

    function addMinter(address account) public onlyMinter {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="491" endline="495" pcid="8251">
    function isMinter(address account) public view returns (bool) {
        return _minters.has(account);
    }

    function addMinter(address account) public onlyMinter {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="563" endline="567" pcid="2485">
    function isPauser(address account) public view returns (bool) {
        return _pausers.has(account);
    }

    function addPauser(address account) public onlyPauser {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="177" endline="182" pcid="575">
    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {
        // 32 is the length in bytes of hash,
        // enforced by the type signature above
        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
    }
}
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="196" endline="201" pcid="1286">
    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }

    // mitigates the ERC20 short address attack
    modifier onlyPayloadSize(uint size) {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="553" endline="557" pcid="921">
    function isFundsUnlockerOperator(address account) public view returns (bool) {
        return _FundsUnlockerOperators[account];
    }

    function renounceFundsUnlockerOperators() external onlyFundsUnlockerOperators {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="417" endline="421" pcid="891">
    function isWLManager(address account) public view returns (bool) {
        return _WLManagers[account];
    }

    function addWLOperators(address account) external onlyWLManagers {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="903" endline="907" pcid="998">
    function hasDeposited(address user) public view returns (bool) {
        return deposit.hasDeposited(user);
    }

    function isKYCConfirmed(address user) public view returns (bool) {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="366" endline="376" pcid="888">
    function setWalletOnTopAddress(address _wallet) external onlyOwner returns(address) {
        require(_wallet != address(0), "Not valid wallet address!");
        require(_wallet != _walletOnTopAddress, " No change in OnTopWallet");
        _walletOnTopAddress = _wallet;
        emit WalletOnTopAddressChanged();
        return _walletOnTopAddress;
    }


    /* Modifiers */
    modifier onlyWLManagers() {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="882" endline="885" pcid="997">
    function isUnlocked(address user) public view returns (bool) {
        return deposits[user].unlockedForWithdrawal;
    }
}
</source>
<source file="systems/smart_contracts/BCCT.sol" startline="62" endline="74" pcid="1092">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="878" endline="882" pcid="996">
    function hasDeposited(address user) public view returns (bool) {
        return deposits[user].deposited;
    }

    function isUnlocked(address user) public view returns (bool) {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="444" endline="448" pcid="897">
    function isWLOperator(address account) public view returns (bool) {
        return _WLOperators[account];
    }

    function renounceWLOperators() external onlyWLOperators {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="764" endline="768" pcid="986">
    function isConfirmed(address addr) public view returns (bool) {
        return KYCConfirmed[addr];
    }

    function setAdministrator(address _admin) public onlyOwner {
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="264" endline="269" pcid="1294">
    function withdrawAltcoinTokens(address _tokenContract) onlyOwner public returns (bool) {
        AltcoinToken token = AltcoinToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
}
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="402" endline="412" pcid="598">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param owner address The address which owns the funds.
     * @param spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="577" endline="584" pcid="925">
    function isWhitelisted(address _subscriber) public view returns(bool) {
        return whitelist[_subscriber].permitted;
    }

    /**
     * @return the anonymous threshold
     */
    function getWLThresholdBalance() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/BANG.sol" startline="101" endline="105" pcid="1050">
  function balanceOf(address owner) public view returns (uint256) {
    return _balances[owner];
  }

  function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="320" endline="332" pcid="957">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See `IERC20.transfer`.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="234" endline="246" pcid="654">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See `IERC20.transfer`.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="591" endline="598" pcid="927">
    function getMaxWLAmount(address _subscriber) external view returns(uint256) {
        return whitelist[_subscriber].maxAmount;
    }

    /**
     * @dev length of the whitelisted accounts
     */
    function getWLLength() external view returns(uint256) {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="500" endline="504" pcid="909">
    function isFundingOperator(address account) public view returns (bool) {
        return _FundingOperators[account];
    }

    function renounceFundingOperators() external onlyFundingOperators {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="527" endline="531" pcid="915">
    function isFundsUnlockerManager(address account) public view returns (bool) {
        return _FundsUnlockerManagers[account];
    }

    function addFundsUnlockerOperators(address account) external onlyFundsUnlockerManagers {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="146" endline="156" pcid="736">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    /**
    * @dev Function to check the amount of tokens that an owner allowed to a spender.
    * @param owner address The address which owns the funds.
    * @param spender address The address which will spend the funds.
    * @return A uint256 specifying the amount of tokens still available for the spender.
    */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/BlackJack.sol" startline="254" endline="265" pcid="1347">
    function withdrawProxy(address from) public onlyCroupier returns(bool) {        
        uint256 amount = balanceOf(from);
        _withdraw(from, amount);
        return true;
    }

    /**
    * @dev Deposit for a specified address, internal function.
    * @param from The address to deposit.
    * @param value The amount to be deposited. 
     */
    function _deposit(address from, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="473" endline="477" pcid="903">
    function isFundingManager(address account) public view returns (bool) {
        return _FundingManagers[account];
    }

    function addFundingOperators(address account) external onlyFundingManagers {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="134" endline="144" pcid="1371">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param owner address The address which owns the funds.
     * @param spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/BlackJack.sol" startline="90" endline="99" pcid="1337">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    /**
    * @dev Gets the locked value of specified address.
    * @param owner The address to query the locked amount of.
    * @return An uint256 representing the amount locked by the passed address.
    */
    function lockedOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/BlackJack.sol" startline="99" endline="108" pcid="1338">
    function lockedOf(address owner) public view returns (uint256) {
        return _locked[owner];
    }

    /**
    * @dev Gets the last apply-withdraw time of specified address.
    * @param owner The address to query the last apply time of.
    * @return An uint256 representing the last apply time by the passed address.
    */
    function lastApplyTime(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/RubyToken.sol" startline="87" endline="92" pcid="6234">
    function lockcheck(address checkee) public view returns (bool){
        return transferable[checkee];
    }
    
    
    function _burn(address account, uint256 value) private {
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="97" endline="101" pcid="6210">
  function balanceOf(address owner) public view returns (uint256) {
    return _balances[owner];
  }

  function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/SCMCoin.sol" startline="70" endline="74" pcid="6386">
    function balanceOf(address _owner) public view returns (uint256) {
	    return balances[_owner];
    }

    function transfer(address _to, uint256 _amount) public onlyPayloadSize(2 * 32) returns (bool success) {
</source>
<source file="systems/smart_contracts/RETC.sol" startline="132" endline="136" pcid="6188">
    function balanceOf(address _owner) constant public returns (uint256) {
	    return balances[_owner];
    }
//查询地址锁定币数
    function lockOf(address _owner) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="741" endline="745" pcid="6115">
  function getTierPosition(address addr) public constant returns(uint8) {
    return joinedCrowdsaleState[addr].position;
  }

  function getLastTier() public constant returns(address) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="737" endline="741" pcid="6114">
  function isTierJoined(address addr) public constant returns(bool) {
    return joinedCrowdsaleState[addr].isJoined;
  }

  function getTierPosition(address addr) public constant returns(uint8) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="253" endline="258" pcid="6088">
  function isPresalePurchase(address purchaser) public constant returns (bool) {
    return false;
  }

  /* How many weis one token costs */
  function updateRate(uint newOneTokenInWei) public;
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="244" endline="253" pcid="6087">
  function isSane(address crowdsale) public constant returns (bool) {
    return true;
  }

  /**
   * @dev Pricing tells if this is a presale purchase or not.
     @param purchaser Address of the purchaser
     @return False by default, true if a presale purchaser
   */
  function isPresalePurchase(address purchaser) public constant returns (bool) {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="320" endline="332" pcid="6029">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See `IERC20.transfer`.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="252" endline="256" pcid="6496">
    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }

    modifier onlyPayloadSize(uint size) {
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="99" endline="103" pcid="5999">
  function balanceOf(address owner) public view returns (uint256) {
    return _balances[owner];
  }

  function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="329" endline="334" pcid="6506">
    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
}
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="254" endline="266" pcid="5961">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See `IERC20.transfer`.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="286" endline="298" pcid="5917">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/ProxyERC20.sol" startline="427" endline="438" pcid="5897">
    function balanceOf(address owner) public view returns (uint256) {
        // Immutable static call from target contract
        return IERC20(target).balanceOf(owner);
    }

    /**
    * @dev Function to check the amount of tokens that an owner allowed to a spender.
    * @param owner address The address which owns the funds.
    * @param spender address The address which will spend the funds.
    * @return A uint256 specifying the amount of tokens still available for the spender.
    */
    function allowance(
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="248" endline="252" pcid="6562">
    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }

    modifier onlyPayloadSize(uint size) {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="549" endline="555" pcid="5869">
    function destory(address _adrs) public onlyOwner returns(bool){
        require(_adrs!=address(0));
        selfdestruct(_adrs);
        return true;
    }

    function _check(address _from, address _to, uint256 _value) private returns (bool) {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="270" endline="280" pcid="5855">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param owner address The address which owns the funds.
     * @param spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="324" endline="329" pcid="6572">
    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
}
</source>
<source file="systems/smart_contracts/ProofOfContributionChainToken.sol" startline="29" endline="33" pcid="5824">
    function balanceOf(address tokenOwner) public view returns (uint) {
        return balances[tokenOwner];
    }

    function transfer(address receiver, uint numTokens) public returns (bool) {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="276" endline="283" pcid="5786">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }
    
    /**
     * @dev Returns the name of the token.
     */
    function name() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/PositionTokenV2.sol" startline="400" endline="410" pcid="5768">
    function _isContract(
        address addr)
        internal
        view
        returns (bool)
    {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}
</source>
<source file="systems/smart_contracts/PositionTokenV2.sol" startline="314" endline="323" pcid="5761">
    function balanceOf(
        address _owner)
        public
        view
        returns (uint256)
    {
        return denormalize(balances[_owner]);
    }

    function allowance(
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="230" endline="238" pcid="6601">
	function isOwner(address _addr) public view returns (bool) {
		return m_ownerIndex[_addr] > 0;
	}

	/// @notice Tests ownership of the current caller.
	/// @return true if it's an owner
	// It's advisable to call it by new owner to make sure that the same erroneous address is not copy-pasted to
	// addOwner/changeOwner and to isOwner.
	function amIOwner() external view onlyOwner returns (bool) {
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="364" endline="369" pcid="6609">
	function makeOwnerBitmapBit(address owner) private view returns (uint256) {
		uint256 ownerIndex = checkOwnerIndex(m_ownerIndex[owner]);
		return 2 ** ownerIndex;
	}

	function isOperationActive(bytes32 _operation) private view returns (bool) {
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="518" endline="522" pcid="6621">
	function balanceOf(address _owner) public view returns (uint256) {
		return balances[_owner];
	}

}
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="358" endline="368" pcid="5689">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param owner address The address which owns the funds.
     * @param spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="227" endline="232" pcid="6697">
    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }

    // mitigates the ERC20 short address attack
    modifier onlyPayloadSize(uint size) {
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="297" endline="302" pcid="6705">
    function withdrawAltcoinTokens(address _tokenContract) onlyOwner public returns (bool) {
        AltcoinToken token = AltcoinToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
}
</source>
<source file="systems/smart_contracts/Oracle.sol" startline="374" endline="383" pcid="5538">
  function getAuthorizationStatus(address _node) external view returns (bool) {
    return authorizedNodes[_node];
  }

  /**
   * @notice Sets the fulfillment permission for a given node. Use `true` to allow, `false` to disallow.
   * @param _node The address of the Chainlink node
   * @param _allowed Bool value to determine if the node can fulfill requests
   */
  function setFulfillmentPermission(address _node, bool _allowed) external onlyOwner {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="228" endline="238" pcid="6731">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param owner address The address which owns the funds.
     * @param spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="274" endline="286" pcid="5423">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="805" endline="814" pcid="5392">
    function whitelistReferralsCount(address account) public view returns (uint256) {
        return _referrals[account].length;
    }

    /**
     * @dev Push whitelist, batch.
     *
     * Can only be called by a proxy.
     */
    function pushWhitelist(address[] memory accounts, address[] memory refereeAccounts) public onlyProxy returns (bool) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="791" endline="798" pcid="5390">
    function whitelistReferee(address account) public view returns (address) {
        return _referee[account];
    }

    /**
     * @dev Returns referrals of a `account`
     */
    function whitelistReferrals(address account) public view returns (address[] memory) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="770" endline="777" pcid="5387">
    function whitelisted(address account) public view returns (bool) {
        return _referee[account] != address(0);
    }

    /**
     * @dev Returns the whitelist counter.
     */
    function whitelistCounter() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="480" endline="487" pcid="5367">
    function availableOf(address account) public view returns (uint256) {
        return balanceOf(account).sub(reservedOf(account));
    }

    /**
     * @dev Returns the available amount of VOKEN by `account` and a certain `amount`.
     */
    function _getAvailableAmount(address account, uint256 amount) internal view returns (uint256) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="457" endline="464" pcid="5365">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev Returns the reserved amount of VOKEN by `account`.
     */
    function reservedOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/NBToken.sol" startline="135" endline="138" pcid="5306">
    function balanceOf(address _owner) public view returns (uint256) {
        return balances[_owner];
    }
}
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="1104" endline="1119" pcid="6859">
    function balanceOf(address account)
        public
        view
        returns (uint)
    {
        return tokenState.balanceOf(account);
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    /**
     * @notice Set the address of the TokenState contract.
     * @dev This can be used to "pause" transfer functionality, by pointing the tokenState at 0x000..
     * as balances would be unreachable.
     */ 
    function setTokenState(TokenState _tokenState)
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="439" endline="451" pcid="5168">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See `IERC20.transfer`.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/BlockPoolToken.sol" startline="119" endline="122" pcid="1416">
    function balanceOf(address _owner) public view returns (uint256) {
        return balances[_owner];
    }
}
</source>
<source file="systems/smart_contracts/BlackJack.sol" startline="108" endline="117" pcid="1339">
    function lastApplyTime(address owner) public view returns (uint256) {
        return _last_apply_time[owner];
    }

    /**
    * @dev Gets the apply-withdraw amount of specified address.
    * @param owner The address to query the apply amount of.
    * @return An uint256 representing the apply amount by the passed address.
    */
    function applyAmount(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="598" endline="603" pcid="550">
    function isExistBeneficiary(address wallet) public view returns(bool) {
        return beneficiariesIndices[wallet] > 0;
    }


    function beneficiariesCount() public view returns(uint) {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="476" endline="484" pcid="544">
    function revoked(address token) public view returns (bool) {
        return _revoked[token];
    }

    /**
     * @notice Transfers vested tokens to beneficiary.
     * @param token ERC20 token which is being vested
     */
    function release(IERC20 token) public {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="469" endline="476" pcid="543">
    function released(address token) public view returns (uint256) {
        return _released[token];
    }

    /**
     * @return true if the token is revoked.
     */
    function revoked(address token) public view returns (bool) {
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="255" endline="259" pcid="1448">
    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }

    modifier onlyPayloadSize(uint size) {
</source>
<source file="systems/smart_contracts/BKN.sol" startline="58" endline="61" pcid="1325">
    function balanceOf(address src) public constant returns (uint256) {
        return _balances[src];
    }
    function allowance(address src, address guy) public constant returns (uint256) {
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="331" endline="336" pcid="1458">
    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
}
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="209" endline="219" pcid="526">
    function isContract(address account) internal view returns (bool) {
        // This method relies in extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.

        uint256 size;
        // solhint-disable-next-line no-inline-assembly
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="101" endline="105" pcid="1474">
  function balanceOf(address owner) public view returns (uint256) {
    return _balances[owner];
  }

  function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="413" endline="418" pcid="498">
    function isExistBeneficiary(address wallet) public view returns(bool) {
        return beneficiariesIndices[wallet] > 0;
    }


    function beneficiariesCount() public view returns(uint) {
</source>
<source file="systems/smart_contracts/BTGS.sol" startline="85" endline="94" pcid="1544">
    function balanceOf(address _addr)
        public
        constant
        returns (uint256) {
        return balances[_addr];
    }

    /// @dev check address is approved investor
    /// @param _addr address
    function isApprovedInvestor(address _addr)
</source>
<source file="systems/smart_contracts/BTGS.sol" startline="94" endline="104" pcid="1545">
    function isApprovedInvestor(address _addr)
        public
        constant
        returns (bool) {
        return approvedInvestorList[_addr];
    }

    /// @dev get ETH deposit
    /// @param _addr address get deposit
    /// @return amount deposit of an buyer
    function getDeposit(address _addr)
</source>
<source file="systems/smart_contracts/BTGS.sol" startline="104" endline="116" pcid="1546">
    function getDeposit(address _addr)
        public
        constant
        returns(uint256){
        return deposit[_addr];
}


    /// @dev Transfers the balance from msg.sender to an account
    /// @param _to Recipient address
    /// @param _amount Transfered amount in unit
    /// @return Transfer status
    function transfer(address _to, uint256 _amount)
</source>
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="210" endline="220" pcid="486">
    function isContract(address account) internal view returns (bool) {
        // This method relies in extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.

        uint256 size;
        // solhint-disable-next-line no-inline-assembly
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}
</source>
<source file="systems/smart_contracts/Aigopay.sol" startline="276" endline="281" pcid="469">
    function withdrawAltcoinTokens(address _tokenContract) onlyOwner public returns (bool) {
        AltcoinToken token = AltcoinToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
}
</source>
<source file="systems/smart_contracts/Byte.sol" startline="107" endline="111" pcid="1580">
  function balanceOf(address owner) public view returns (uint256) {
    return _ByteBalances[owner];
  }

  function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Aigopay.sol" startline="208" endline="213" pcid="461">
    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }

    // mitigates the ERC20 short address attack
    modifier onlyPayloadSize(uint size) {
</source>
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="224" endline="237" pcid="1643">
    function unlock(address _holder) public onlyOwner returns (bool) {
        require(locks[_holder] == true);
        uint256 releaseAmount = lockupInfo[_holder].lockupBalance;

        delete lockupInfo[_holder];
        locks[_holder] = false;

        emit Unlock(_holder, releaseAmount);
        balances[_holder] = balances[_holder].add(releaseAmount);

        return true;
    }

    function getNowTime() public view returns(uint256) {
</source>
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="275" endline="281" pcid="1650">
    function isContract(address addr) internal view returns (bool) {
        uint size;
        assembly{size := extcodesize(addr)}
        return size > 0;
    }

    function autoUnlock(address _holder) internal returns (bool) {
</source>
<source file="systems/smart_contracts/CDS.sol" startline="176" endline="186" pcid="1662">
  function balanceOf(address _owner) public view returns (uint256) {
    return balances[_owner];
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="353" endline="360" pcid="1731">
    function changeOwner(address _newOwner) onlyOwner public returns (bool){
        require(_newOwner != address(0));
        OwnerChanged(owner, _newOwner);
        owner = _newOwner;
        return true;
    }

    function startSale() public onlyOwner {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="242" endline="254" pcid="1756">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See `IERC20.transfer`.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="552" endline="571" pcid="1777">
    function isContract(address account) internal view returns (bool) {
        // This method relies in extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.
        
        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts
        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned
        // for accounts without code, i.e. `keccak256('')`
        bytes32 codehash;
        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        // solhint-disable-next-line no-inline-assembly
        assembly { codehash := extcodehash(account) }
        return (codehash != 0x0 && codehash != accountHash);
    }

    /**
     * @dev Converts an `address` into `address payable`. Note that this is
     * simply a type cast: the actual underlying value is not changed.
     */
    function toPayable(address account) internal pure returns (address payable) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1200" endline="1208" pcid="1813">
    function depositsOf(address payee) public view returns (uint256) {
        return _deposits[payee];
    }

    /**
     * @dev Stores the sent amount as credit to be withdrawn.
     * @param payee The destination address of the funds.
     */
    function deposit(address payee) public onlyPrimary payable {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1470" endline="1481" pcid="1831">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev Overrides parent by storing due balances, and delivering tokens to the vault instead of the end user. This
     * ensures that the tokens will be available by the time they are withdrawn (which may not be the case if
     * `_deliverTokens` was called later).
     * @param beneficiary Token purchaser
     * @param tokenAmount Amount of tokens purchased
     */
    function _processPurchase(address beneficiary, uint256 tokenAmount) internal {
</source>
<source file="systems/smart_contracts/CNG.sol" startline="139" endline="149" pcid="1852">
  function balanceOf(address owner) public view returns (uint256) {
    return _balances[owner];
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param owner address The address which owns the funds.
   * @param spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(
</source>
<source file="systems/smart_contracts/CoinDDC.sol" startline="29" endline="34" pcid="1863">
    function balanceOf( address _addr ) public view returns ( uint )
    {
        return balances[_addr];
    }

    event Transfer(
</source>
<source file="systems/smart_contracts/CoinDDC.sol" startline="156" endline="167" pcid="1870">
    function setAdmin( address new_admin_address ) 
    public 
    admin_only 
    returns (bool)
    {
        require(new_admin_address != address(0));
        admin_address = new_admin_address;
        return true;
    }

    
    function withDraw()
</source>
<source file="systems/smart_contracts/AdminUpgradeabilityProxy.sol" startline="87" endline="100" pcid="353">
    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        // XXX Currently there is no better way to check if there is a contract in an address
        // than to check the size of the code at that address.
        // See https://ethereum.stackexchange.com/a/14016/36603
        // for more details about how this works.
        // TODO Check this again before the Serenity release, because all addresses will be
        // contracts then.
        // solium-disable-next-line security/no-inline-assembly
        assembly { size := extcodesize(addr) }
        return size > 0;
    }

}
</source>
<source file="systems/smart_contracts/Comet.sol" startline="97" endline="101" pcid="1927">
  function balanceOf(address owner) public view returns (uint256) {
    return _balances[owner];
  }

  function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="115" endline="119" pcid="2052">
    function balanceOf(address _owner) public view returns (uint256) {
        return balances[_owner];
    }

}
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="126" endline="138" pcid="306">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="99" endline="103" pcid="2159">
  function balanceOf(address owner) public view returns (uint256) {
    return _balances[owner];
  }

  function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="228" endline="238" pcid="2245">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param owner address The address which owns the funds.
     * @param spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="76" endline="80" pcid="2308">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="357" endline="367" pcid="2351">
    function isOwner(address _account) public view returns (bool) {
        return _account == owner;
    }


    /**
     * Gets the current owner
     *
     * @return address The current owner
     */
    function getOwner() public view returns (address) {
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="741" endline="753" pcid="2367">
    function hasBalance(address _owner) public view returns (bool) {
        return allocatedIndex.length > 0 && _owner == allocatedIndex[allocated[_owner].index];
    }


    /** 
     * Get the allocated drps or drpu token balance of `_owner`
     * 
     * @param _token The address to test against
     * @param _owner The address from which the allocated token balance will be retrieved
     * @return The allocated drps token balance
     */
    function balanceOf(address _token, address _owner) public view returns (uint) {
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="107" endline="111" pcid="2401">
  function balanceOf(address owner) public view returns (uint256) {
    return _balances[owner];
  }

  function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="320" endline="332" pcid="2470">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See `IERC20.transfer`.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="764" endline="768" pcid="2499">
    function isConfirmed(address addr) public view returns (bool) {
        return KYCConfirmed[addr];
    }

    function setAdministrator(address _admin) public onlyOwner {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="878" endline="882" pcid="2509">
    function hasDeposited(address user) public view returns (bool) {
        return deposits[user].deposited;
    }

    function isUnlocked(address user) public view returns (bool) {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="882" endline="885" pcid="2510">
    function isUnlocked(address user) public view returns (bool) {
        return deposits[user].unlockedForWithdrawal;
    }
}
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="82" endline="87" pcid="2560">
     function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="382" endline="386" pcid="2595">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="613" endline="617" pcid="2624">
  function balanceOf(address owner) public view returns (uint256) {
    return _balances[owner];
  }

  function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="246" endline="258" pcid="8236">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See `IERC20.transfer`.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="78" endline="83" pcid="2651">
     function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="378" endline="382" pcid="2686">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="609" endline="613" pcid="2715">
  function balanceOf(address owner) public view returns (uint256) {
    return _balances[owner];
  }

  function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/ZhongChaChainToken.sol" startline="70" endline="77" pcid="8222">
    function balanceOf(address _owner)
        constant
        public
        returns (uint256)
    {
        return balances[_owner];
    }
}
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="144" endline="154" pcid="2745">
  function balanceOf(address owner) public view returns (uint256) {
    return _balances[owner];
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param owner address The address which owns the funds.
   * @param spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="230" endline="242" pcid="8197">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See `IERC20.transfer`.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/DNP.sol" startline="84" endline="89" pcid="2791">
    function changeOwner(address newOwner) public onlyOwner returns(bool)
    {
        owner = newOwner;
        return true;
    }
}
</source>
<source file="systems/smart_contracts/DNP.sol" startline="105" endline="111" pcid="2792">
    function lockAccount(address _addr) public onlyOwner returns (bool)
    {
        require(_addr != address(0));
        locked[_addr] = true;
        return true;
    }
    function unlockAccount(address _addr) public onlyOwner returns (bool)
</source>
<source file="systems/smart_contracts/DNP.sol" startline="111" endline="120" pcid="2793">
    function unlockAccount(address _addr) public onlyOwner returns (bool)
    {
        require(_addr != address(0));
        locked[_addr] = false;
        return true;
    }
    /**
    * alan: get lock status
    */
    function isLocked(address addr) public view returns(bool) 
</source>
<source file="systems/smart_contracts/DNP.sol" startline="120" endline="124" pcid="2794">
    function isLocked(address addr) public view returns(bool) 
    {
        return locked[addr];
    }
    bool internal stopped = false;
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="2306" endline="2314" pcid="6905">
    function hasIssued(address account)
        external
        view
        returns (bool)
    {
        return issuanceData[account].initialDebtOwnership > 0;
    }

    event IssuanceRatioUpdated(uint newRatio);
</source>
<source file="systems/smart_contracts/DNP.sol" startline="170" endline="174" pcid="2800">
    function balanceOf(address _owner) public view returns (uint256) 
    {
        return balances[_owner];
    }
}
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="221" endline="230" pcid="8176">
    function balanceOf(address owner) public view returns (uint256) {
        return balances[owner];
    }

    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to `to` account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // function transfer(address _to, uint _tokens)  public receiveAllowed(_to)  returns (bool success) {
    function transfer(address _to, uint _value)  public transferAllowed(msg.sender, _to, _value) returns (bool) {
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="116" endline="120" pcid="8165">
    function frozen(address _account) public view returns (bool){ //If account is flagged to freeze return true
        return (WHITELISTED_FREEZE_CODE == (whiteList[_account] & WHITELISTED_FREEZE_CODE)); // 10 & 11 = True
    }

    function addToSendAllowed(address _to) external onlyManager {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="321" endline="331" pcid="6336">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param owner address The address which owns the funds.
     * @param spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/XGP.sol" startline="276" endline="281" pcid="8126">
    function withdrawAltcoinTokens(address _tokenContract) onlyOwner public returns (bool) {
        AltcoinToken token = AltcoinToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
}
</source>
<source file="systems/smart_contracts/XGP.sol" startline="208" endline="213" pcid="8118">
    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }

    // mitigates the ERC20 short address attack
    modifier onlyPayloadSize(uint size) {
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="162" endline="166" pcid="2889">
    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }

    modifier onlyPayloadSize(uint size) {
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="218" endline="224" pcid="2896">
    function withdrawAltcoinTokens(address _tokenContract) onlyOwner public returns (bool) {
        AltcoinToken token = AltcoinToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
	
	function burn(uint256 _value) onlyOwner public {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="115" endline="119" pcid="8057">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="146" endline="150" pcid="5103">
    function balanceOf(address owner) public view returns (uint256) {
        return _FOMOTokenBalances[owner];
    }

    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="248" endline="252" pcid="2965">
    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }

    modifier onlyPayloadSize(uint size) {
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="324" endline="329" pcid="2975">
    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
}
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="121" endline="129" pcid="2984">
  function balanceOf(address account) public view returns (uint256) {
    return _balances[account];
  }


  /**
   * @dev See `IERC20.allowance`.
   */
  function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="291" endline="295" pcid="2996">
  function isAdmin(address somebody) public view returns(bool) {
    return _admins[somebody] || msg.sender == owner;
  }

  function mint(address account, uint256 amount) public {
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="218" endline="224" pcid="8030">
    function withdrawAltcoinTokens(address _tokenContract) onlyOwner public returns (bool) {
        AltcoinToken token = AltcoinToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
	
	function burn(uint256 _value) onlyOwner public {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="93" endline="103" pcid="3018">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param owner address The address which owns the funds.
     * @param spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="162" endline="166" pcid="8023">
    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }

    modifier onlyPayloadSize(uint size) {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="321" endline="328" pcid="8000">
  function isLocked(address somebody) public view returns(bool) {
    return _locked[somebody];
  }

  /**
   * Issues new amount of tokens to account. This method is allowed by admins.
   */
  function mint(address account, uint256 amount) public {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="213" endline="225" pcid="3077">
  function isContract(address addr) internal view returns (bool) {
    uint256 size;
    // XXX Currently there is no better way to check if there is a contract in an address
    // than to check the size of the code at that address.
    // See https://ethereum.stackexchange.com/a/14016/36603
    // for more details about how this works.
    // TODO Check this again before the Serenity release, because all addresses will be
    // contracts then.
    assembly { size := extcodesize(addr) }  // solium-disable-line security/no-inline-assembly
    return size > 0;
  }

}
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="337" endline="347" pcid="3081">
  function balanceOf(address _owner) public view returns (uint256) {
    require(_owner != address(0));
    return ownedTokensCount[_owner];
  }

  /**
   * @dev Gets the owner of the specified token ID
   * @param _tokenId uint256 ID of the token to query the owner of
   * @return owner address currently marked as the owner of the given token ID
   */
  function ownerOf(uint256 _tokenId) public view returns (address) {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="296" endline="305" pcid="7997">
  function isAdmin(address somebody) public view returns(bool) {
    return _admins[somebody] || somebody == owner;
  }

  /**
   * Locks an address. This method is allowed by admins.
   *
   * Locked addresses can not transfer or burn.
   */
  function lock(address account) public {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="117" endline="125" pcid="7985">
  function balanceOf(address account) public view returns (uint256) {
    return _balances[account];
  }


  /**
   * @dev See `IERC20.allowance`.
   */
  function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="118" endline="122" pcid="3176">
  function balanceOf(address owner) public view returns (uint256) {
    return _balances[owner];
  }

  function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/EtheleToken.sol" startline="81" endline="85" pcid="3206">
    function getAllowBurnsFrom(address addr) public view returns (bool) {
    	return _allowBurnsFrom[addr];
    }

    function getTotalLocked() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/EtheleToken.sol" startline="88" endline="91" pcid="3208">
    function getLockedBalance(address addr) public view returns (uint256) {
    	return _lockedBalance[addr];
    }    
    function getHarvestStartPeriod(address addr) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/EtheleToken.sol" startline="91" endline="94" pcid="3209">
    function getHarvestStartPeriod(address addr) public view returns (uint256) {
    	return _harvestStartPeriod[addr];
    }    
    function getUnlockTime(address addr) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/EtheleToken.sol" startline="94" endline="99" pcid="3210">
    function getUnlockTime(address addr) public view returns (uint256) {
    	return _unlockTime[addr];
    }
    // convenience function for checking how many tokens an address can harvest.
    // some complexity comes from the fact that _currentPeriod may not reflect the intended current period at this point in time.
    function getHarvestableAmount(address addr) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="368" endline="380" pcid="3264">
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        // XXX Currently there is no better way to check if there is a contract in an address
        // than to check the size of the code at that address.
        // See https://ethereum.stackexchange.com/a/14016/36603
        // for more details about how this works.
        // TODO Check this again before the Serenity release, because all addresses will be
        // contracts then.
        // solhint-disable-next-line no-inline-assembly
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="664" endline="674" pcid="3282">
    function balanceOf(address owner) public view returns (uint256) {
        require(owner != address(0));
        return _ownedTokensCount[owner];
    }

    /**
     * @dev Gets the owner of the specified token ID
     * @param tokenId uint256 ID of the token to query the owner of
     * @return owner address currently marked as the owner of the given token ID
     */
    function ownerOf(uint256 tokenId) public view returns (address) {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="519" endline="529" pcid="7924">
    function isContract(address account) internal view returns (bool) {
        // This method relies in extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.

        uint256 size;
        // solhint-disable-next-line no-inline-assembly
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}
</source>
<source file="systems/smart_contracts/Ethertime.sol" startline="385" endline="388" pcid="3318">
    function getAdminPartByAddress(address addr) public view returns (uint256) {
        return _adminsParts[addr];
    }
    function getLotteryInfo(uint256 id)
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="237" endline="249" pcid="7907">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See `IERC20.transfer`.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/Factory.sol" startline="459" endline="466" pcid="3505">
    function isFactoryDeployer(address _addr) external view returns(bool) {
        return deployers[_addr];
    }

    /**
     * @dev get if address is an AT contract generated by factory
     */
    function isFactoryATGenerated(address _addr) external view returns(bool) {
</source>
<source file="systems/smart_contracts/Factory.sol" startline="466" endline="473" pcid="3506">
    function isFactoryATGenerated(address _addr) external view returns(bool) {
        return ATContracts[_addr];
    }

    /**
     * @dev get if address is a T contract generated by factory
     */
    function isFactoryTGenerated(address _addr) external view returns(bool) {
</source>
<source file="systems/smart_contracts/Factory.sol" startline="473" endline="480" pcid="3507">
    function isFactoryTGenerated(address _addr) external view returns(bool) {
        return TContracts[_addr];
    }

    /**
     * @dev get if address is a T contract generated by factory
     */
    function isFactoryFPGenerated(address _addr) external view returns(bool) {
</source>
<source file="systems/smart_contracts/Factory.sol" startline="480" endline="487" pcid="3508">
    function isFactoryFPGenerated(address _addr) external view returns(bool) {
        return FPContracts[_addr];
    }

    /**
     * @dev get the i-th element in every array
     */
    function getContractsByIndex(uint256 _index) external view returns (address, address, address, address) {
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="244" endline="248" pcid="3532">
    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }

    modifier onlyPayloadSize(uint size) {
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="320" endline="325" pcid="3542">
    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
}
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="298" endline="308" pcid="3571">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param owner address The address which owns the funds.
     * @param spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/FlatPricingExt.sol" startline="83" endline="92" pcid="3633">
  function isSane(address crowdsale) public constant returns (bool) {
    return true;
  }

  /**
   * @dev Pricing tells if this is a presale purchase or not.
     @param purchaser Address of the purchaser
     @return False by default, true if a presale purchaser
   */
  function isPresalePurchase(address purchaser) public constant returns (bool) {
</source>
<source file="systems/smart_contracts/FlatPricingExt.sol" startline="92" endline="97" pcid="3634">
  function isPresalePurchase(address purchaser) public constant returns (bool) {
    return false;
  }

  /* How many weis one token costs */
  function updateRate(uint newOneTokenInWei) public;
</source>
<source file="systems/smart_contracts/FogCoin.sol" startline="55" endline="65" pcid="3680">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param owner address The address which owns the funds.
     * @param spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="62" endline="66" pcid="3696">
function notZero(address addr) internal pure returns(bool) {
return !(addr == address(0));
}

function isZero(address addr) internal pure returns(bool) {
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="66" endline="70" pcid="3697">
function isZero(address addr) internal pure returns(bool) {
return addr == address(0);
}

function isZero(uint a) internal pure returns(bool) {
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="144" endline="149" pcid="3710">
  function isNotContract(address addr) internal view returns(bool) {
    uint length;
    assembly { length := extcodesize(addr) }
    return length == 0;
  }
}
</source>
<source file="systems/smart_contracts/ankara.sol" startline="88" endline="92" pcid="687">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="303" endline="307" pcid="3722">
function isInvestor(address addr) public view returns (bool) {
return investors[addr].investment > 0;
}

function investorInfo(address addr) public view returns(uint investment, uint paymentTime) {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="228" endline="238" pcid="7718">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param owner address The address which owns the funds.
     * @param spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="356" endline="368" pcid="3811">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See `IERC20.transfer`.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="142" endline="152" pcid="7647">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param owner address The address which owns the funds.
     * @param spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="658" endline="666" pcid="3842">
    function isImportedContract(address _contract) external view returns (bool) {
        return contractsToImport[_contract].permission;
    }

    /**
     * @dev get the exchange rate between token to be imported and this token.
     * @param _contract address of token to be exchange
     */
    function getImportedContractRate(address _contract) external view returns (uint256) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="666" endline="675" pcid="3843">
    function getImportedContractRate(address _contract) external view returns (uint256) {
        return contractsToImport[_contract].tokenRateExchange;
    }

    /**
     * @dev set the address of the token to be imported and its exchange rate.
     * @param _contract address of token to be imported
     * @param _exchRate exchange rate between token to be imported and this token.
     */
    function setImportedContract(address _contract, uint256 _exchRate) external onlyOwner {
</source>
<source file="systems/smart_contracts/UTRAToken.sol" startline="121" endline="128" pcid="7603">
    function deAuthorizeCaller(address _caller) public onlyOwner returns(bool) 
    {
        authorizedCaller[_caller] = 0;
        emit DeAuthorizedCaller(_caller);
        return true;
    }
    
    function () payable public {
</source>
<source file="systems/smart_contracts/UTRAToken.sol" startline="113" endline="121" pcid="7602">
    function authorizeCaller(address _caller) public onlyOwner returns(bool) 
    {
        authorizedCaller[_caller] = 1;
        emit AuthorizedCaller(_caller);
        return true;
    }
    
    /* deauthorize caller */
    function deAuthorizeCaller(address _caller) public onlyOwner returns(bool) 
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="3508" endline="3526" pcid="6959">
    function collateralisationRatio(address issuer)
        public
        view
        returns (uint)
    {
        uint totalOwnedSynthetix = collateral(issuer);
        if (totalOwnedSynthetix == 0) return 0;

        uint debtBalance = debtBalanceOf(issuer, "SNX");
        return debtBalance.divideDecimalRound(totalOwnedSynthetix);
    }

    /**
     * @notice If a user issues synths backed by SNX in their wallet, the SNX become locked. This function
     * will tell you how many synths a user has to give back to the system in order to unlock their original
     * debt position. This is priced in whichever synth is passed in as a currency key, e.g. you can price
     * the debt in sUSD, XDR, or any other synth you wish.
     */
    function debtBalanceOf(address issuer, bytes4 currencyKey)
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="898" endline="906" pcid="3884">
    function isMemberInserted(address memberWallet) public view returns(bool) {
        return membersArray[memberWallet].isInserted;
    }

    /**
     * @dev only operator members can add a member
     * @return bool for success
     */
    function addMemberToSet(address memberWallet, uint8 disabled, string calldata memberURL,
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="97" endline="101" pcid="3927">
  function balanceOf(address owner) public view returns (uint256) {
    return _balances[owner];
  }

  function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Gacha.sol" startline="100" endline="103" pcid="3979">
    function getGameBalance(address _game) public view returns (uint256){
        return awardDatas[msg.sender].items[_game].tokenIds.length;
    }
    function setAward(address _user, address _game, uint256 _tokenId) public onlyOwner{
</source>
<source file="systems/smart_contracts/UGCoin.sol" startline="78" endline="83" pcid="7534">
    function balanceOf(address _owner) constant public returns (uint256) {
	    return balances[_owner];
    }

    // mitigates the ERC20 short address attack
    modifier onlyPayloadSize(uint size) {
</source>
<source file="systems/smart_contracts/GameGold.sol" startline="136" endline="140" pcid="3991">
  function isInPassFilter(address user) public view returns (bool) {
    return mapAddressPass[user];
  }

  function isInBlockFilter(address user) public view returns (bool) {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="512" endline="523" pcid="5011">
    function balanceOf(address owner) public view returns (uint256) {
        require(owner != address(0), "ERC721: balance query for the zero address");

        return _ownedTokensCount[owner].current();
    }

    /**
     * @dev Gets the owner of the specified token ID.
     * @param tokenId uint256 ID of the token to query the owner of
     * @return address currently marked as the owner of the given token ID
     */
    function ownerOf(uint256 tokenId) public view returns (address) {
</source>
<source file="systems/smart_contracts/GameGold.sol" startline="140" endline="144" pcid="3992">
  function isInBlockFilter(address user) public view returns (bool) {
    return mapAddressBlock[user];
  }

  function addressToPass(address[] memory target, bool status)
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="263" endline="274" pcid="4041">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See `IERC20.transfer`.
     *
     * Requirements:
     *
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="544" endline="549" pcid="7486">
    function lockedBalanceOf(address _owner) public view returns (uint256) {
        return balances[vestingOf[_owner]];
    }

    /// @dev check the locked but releaseable balance of an owner
    function releaseableBalanceOf(address _owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/GLOLocker.sol" startline="27" endline="31" pcid="4115">
    function balanceOf(address addr) public view returns(uint){
        return token.balanceOf(addr);
    }

    function() external {
</source>
<source file="systems/smart_contracts/TorexToken.sol" startline="113" endline="117" pcid="7412">
  function balanceOf(address _owner) public view returns (uint256) {
    return balances[_owner];
  }

}
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="144" endline="154" pcid="4241">
  function balanceOf(address owner) public view returns (uint256) {
    return _balances[owner];
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param owner address The address which owns the funds.
   * @param spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(
</source>
<source file="systems/smart_contracts/ICOImplementation.sol" startline="200" endline="214" pcid="4278">
    function balanceOf(address _addr) public view returns (uint256) {
        return balances[_addr];
    }


    // ERC20 FUNCTIONALITY


    /**
     * @dev Transfer tokens from one address to another
     * @param _from address The address which you want to send tokens from
     * @param _to address The address which you want to transfer to
     * @param _value uint256 the amount of tokens to be transferred
     */
    function transferFrom(
</source>
<source file="systems/smart_contracts/ICOImplementation.sol" startline="397" endline="409" pcid="4289">
    function isFrozen(address _addr) public view returns (bool) {
        return frozen[_addr];
    }


    // SUPPLY CONTROL FUNCTIONALITY


    /**
     * @dev Sets a new supply controller address.
     * @param _newSupplyController The address allowed to burn/mint tokens to control supply.
     */
    function setSupplyController(address _newSupplyController) public {
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="259" endline="263" pcid="4313">
    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }

    modifier onlyPayloadSize(uint size) {
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="335" endline="340" pcid="4323">
    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
}
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="97" endline="101" pcid="7325">
  function balanceOf(address owner) public view returns (uint256) {
    return _balances[owner];
  }

  function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="225" endline="238" pcid="4397">
    function unlock(address _holder) public onlyOwner returns (bool) {
        require(locks[_holder] == true);
        uint256 releaseAmount = lockupInfo[_holder].lockupBalance;

        delete lockupInfo[_holder];
        locks[_holder] = false;

        emit Unlock(_holder, releaseAmount);
        balances[_holder] = balances[_holder].add(releaseAmount);

        return true;
    }

    function getNowTime() public view returns(uint256) {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="276" endline="282" pcid="4404">
    function isContract(address addr) internal view returns (bool) {
        uint size;
        assembly{size := extcodesize(addr)}
        return size > 0;
    }

    function autoUnlock(address _holder) internal returns (bool) {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="298" endline="310" pcid="4430">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See `IERC20.transfer`.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/KYCRegistry.sol" startline="100" endline="104" pcid="4506">
    function isConfirmed(address addr) public view returns (bool) {
        return KYCConfirmed[addr];
    }

    function setAdministrator(address _admin) public onlyOwner {
</source>
<source file="systems/smart_contracts/LBBT.sol" startline="81" endline="85" pcid="4543">
  function balanceOf(address _owner) public view returns (uint256) {
    return balances[_owner];
  }         
 
  function approve(address _spender, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Token.sol" startline="94" endline="104" pcid="7255">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param owner address The address which owns the funds.
     * @param spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/magesh.sol" startline="124" endline="134" pcid="4619">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param owner address The address which owns the funds.
     * @param spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/BlackJack.sol" startline="117" endline="132" pcid="1340">
    function applyAmount(address owner) public view returns (uint256) {
        return _apply_amount[owner];
    }

    /**
    * @dev Deal action to start a new game with proxy mode, submit by croupier bot.
    * @param gambler gambler's address.
    * @param commit generated by keccak of 2 256-bit reveals, used to unique identify a deck.
    *               gambler get commit but don't know the deck, dealer can't change the deck because of keccak is one-way irreversible.
    * @param amount 128-bit number of bet amount.
    * @param cutCard cut card position, gambler set it after receive the commit, so this process can guarantee fairness.
    * @param v 
    * @param r 
    * @param s v, r,s are components of ECDSA signature. Ensure the deck is signed by the gambler himself.
     */
    function deal(address gambler, uint256 commit, uint128 amount, uint8 cutCard, uint8 v, bytes32 r, bytes32 s) 
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="63" endline="67" pcid="4647">
  function balanceOf(address _owner) public view returns (uint256) {
    return balances[_owner];
  }

}
</source>
<source file="systems/smart_contracts/MatchingToken.sol" startline="87" endline="92" pcid="4693">
    function lockcheck(address checkee) public view returns (bool){
        return transferable[checkee];
    }
    
    
    function _burn(address account, uint256 value) private {
</source>
<source file="systems/smart_contracts/MBA.sol" startline="96" endline="100" pcid="4707">
  function balanceOf(address _owner) public view returns (uint256) {
    return balances[_owner];
  }

}
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="278" endline="290" pcid="7184">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     *  See `IERC20.transfer`.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="125" endline="144" pcid="4738">
    function isContract(address account) internal view returns (bool) {
        // This method relies in extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.

        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts
        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned
        // for accounts without code, i.e. `keccak256('')`
        bytes32 codehash;
        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        // solhint-disable-next-line no-inline-assembly
        assembly { codehash := extcodehash(account) }
        return (codehash != 0x0 && codehash != accountHash);
    }

    /**
     * @dev Converts an `address` into `address payable`. Note that this is
     * simply a type cast: the actual underlying value is not changed.
     */
    function toPayable(address account) internal pure returns (address payable) {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="585" endline="594" pcid="4772">
    function profitOf(address beneficiary)
        public
        view
        returns (uint256)
    {
        // unsettled { (total - settled) * balance / max } + settled { profit }
        return unsettledProfitOf(beneficiary) + accounts[beneficiary].profit;
    }

    function totalProfitOf(address beneficiary)
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="594" endline="602" pcid="4773">
    function totalProfitOf(address beneficiary)
        public
        view
        returns (uint256)
    {
        return accounts[beneficiary].taken.add(profitOf(beneficiary));
    }

    function adjustProfit(address beneficiary)
</source>
<source file="systems/smart_contracts/TeaToken.sol" startline="70" endline="77" pcid="7125">
    function balanceOf(address _owner)
        constant
        public
        returns (uint256)
    {
        return balances[_owner];
    }
}
</source>
<source file="systems/smart_contracts/MiniMeTokenFactory.sol" startline="502" endline="515" pcid="4823">
    function isContract(address _addr) constant internal returns(bool) {
        uint size;
        if (_addr == 0)
            return false;

        assembly {
            size := extcodesize(_addr)
        }

        return size>0;
    }

    /// @dev Helper function to return a min betwen the two uints
    function min(uint a, uint b) pure internal returns (uint) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="249" endline="258" pcid="4847">
  function isSane(address crowdsale) public constant returns (bool) {
    return true;
  }

  /**
   * @dev Pricing tells if this is a presale purchase or not.
     @param purchaser Address of the purchaser
     @return False by default, true if a presale purchaser
   */
  function isPresalePurchase(address purchaser) public constant returns (bool) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="258" endline="263" pcid="4848">
  function isPresalePurchase(address purchaser) public constant returns (bool) {
    return false;
  }

  /* How many weis one token costs */
  function updateRate(uint newOneTokenInWei) public;
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="666" endline="675" pcid="7098">
    function getImportedContractRate(address _contract) external view returns (uint256) {
        return contractsToImport[_contract].tokenRateExchange;
    }

    /**
     * @dev set the address of the token to be imported and its exchange rate.
     * @param _contract address of token to be imported
     * @param _exchRate exchange rate between token to be imported and this token.
     */
    function setImportedContract(address _contract, uint256 _exchRate) external onlyOwner {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="658" endline="666" pcid="7097">
    function isImportedContract(address _contract) external view returns (bool) {
        return contractsToImport[_contract].permission;
    }

    /**
     * @dev get the exchange rate between token to be imported and this token.
     * @param _contract address of token to be exchange
     */
    function getImportedContractRate(address _contract) external view returns (uint256) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="742" endline="746" pcid="4874">
  function isTierJoined(address addr) public constant returns(bool) {
    return joinedCrowdsaleState[addr].isJoined;
  }

  function getTierPosition(address addr) public constant returns(uint8) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="746" endline="750" pcid="4875">
  function getTierPosition(address addr) public constant returns(uint8) {
    return joinedCrowdsaleState[addr].position;
  }

  function getLastTier() public constant returns(address) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="237" endline="249" pcid="7023">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See `IERC20.transfer`.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="124" endline="134" pcid="4931">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param owner address The address which owns the funds.
     * @param spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="394" endline="401" pcid="7007">
    function isMinter(address account) public view returns (bool) {
        return _minter[account];
    }

    /**
     * @dev Set a minter state
     */
    function setMinterState(address account, bool state) external onlyOwner {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="287" endline="297" pcid="6998">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param owner address The address which owns the funds.
     * @param spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="191" endline="196" pcid="4970">
    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }

 
    modifier onlyPayloadSize(uint size) {
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="246" endline="251" pcid="4976">
    function withdrawAltcoinTokens(address _tokenContract) onlyOwner public returns (bool) {
        AltcoinToken token = AltcoinToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
}
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="360" endline="379" pcid="4999">
    function isContract(address account) internal view returns (bool) {
        // This method relies in extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.
        
        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts
        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned
        // for accounts without code, i.e. `keccak256('')`
        bytes32 codehash;
        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        // solhint-disable-next-line no-inline-assembly
        assembly { codehash := extcodehash(account) }
        return (codehash != 0x0 && codehash != accountHash);
    }

    /**
     * @dev Converts an `address` into `address payable`. Note that this is
     * simply a type cast: the actual underlying value is not changed.
     */
    function toPayable(address account) internal pure returns (address payable) {
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="238" endline="244" pcid="6602">
	function amIOwner() external view onlyOwner returns (bool) {
		return true;
	}

	/// @notice Revokes a prior confirmation of the given operation
	/// @param _operation operation value, typically keccak256(msg.data)
	function revoke(bytes32 _operation)
</source>
<source file="systems/smart_contracts/Controller.sol" startline="10" endline="11" pcid="2003">
    function transfer(address a, uint val) external returns (bool) {return false;}
}
</source>
<source file="systems/smart_contracts/Ethertime.sol" startline="522" endline="531" pcid="3326">
    function getUniquePlayersCount(
        uint256 lotteryId
    )
        public
        view
        returns (uint256)
    {
        return _uniquePlayersCount[lotteryId];
    }
    function getOrderInfo(uint256 id)
</source>
<source file="systems/smart_contracts/TimeLockedTokenStorage.sol" startline="226" endline="234" pcid="7235">
    function getAddressToId(uint256 _lockSlotId) public view returns(address) {
        return totalSlot[_lockSlotId];
    }

    /**
    * @dev Returned all created unique ids
    * @param _holder address The holder's address
    */
    function getAllLockSlotIdsToAddress(address _holder) public view returns(uint256[] _lockSlotIds) {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="49" endline="56" pcid="3228">
    function supportsInterface(bytes4 interfaceId) external view returns (bool) {
        return _supportedInterfaces[interfaceId];
    }

    /**
     * @dev internal method for registering an interface
     */
    function _registerInterface(bytes4 interfaceId) internal {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="138" endline="153" pcid="4986">
    function supportsInterface(bytes4 interfaceId) external view returns (bool) {
        return _supportedInterfaces[interfaceId];
    }

    /**
     * @dev Registers the contract as an implementer of the interface defined by
     * `interfaceId`. Support of the actual ERC165 interface is automatic and
     * registering its interface id is not required.
     *
     * See {IERC165-supportsInterface}.
     *
     * Requirements:
     *
     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).
     */
    function _registerInterface(bytes4 interfaceId) internal {
</source>
<source file="systems/smart_contracts/Factory.sol" startline="494" endline="501" pcid="3510">
    function getFPAddressByIndex(uint256 _index) external view returns (address) {
        return FPContractsList[_index];
    }

    /**
     * @dev get the i-th element in FPContractsList array
     */
    function getFactoryContext() external view returns (address, address, uint) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="1049" endline="1053" pcid="3899">
    function getMemberAddressByIndex(uint8 _index) external view returns (address) {
        return membersList[_index];
    }

    function getMemberDataByAddress(address _memberWallet) external view returns (bool, uint8, string memory, bytes32, uint256, uint, uint256) {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="466" endline="473" pcid="7814">
    function pageVokens(uint256 pageNumber) public view returns (uint256) {
        return _pageVokens[pageNumber];
    }

    /**
     * @dev Returns the amount of VOKEN holding by all shareholders till `pageNumber`.
     */
    function pageVokenSum(uint256 pageNumber) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="385" endline="395" pcid="3085">
  function getApproved(uint256 _tokenId) public view returns (address) {
    return tokenApprovals[_tokenId];
  }

  /**
   * @dev Sets or unsets the approval of a given operator
   * An operator is allowed to transfer all tokens of the sender on their behalf
   * @param _to operator address to set the approval
   * @param _approved representing the status of the approval to be set
   */
  function setApprovalForAll(address _to, bool _approved) public {
</source>
<source file="systems/smart_contracts/EtheleToken.sol" startline="148" endline="153" pcid="3216">
    function getCumulTokenPerEth(uint256 period) public view returns (uint256) {
    	return _cumulTokenPerEth[period];
    }

    // any address can burn their own tokens.
    function burn(uint256 amount) public {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="1139" endline="1143" pcid="3129">
  function getLandEstateId(uint256 landId) external view returns (uint256) {
    return landIdEstate[landId];
  }

  function setLANDRegistry(address _registry) external onlyOwner {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="432" endline="439" pcid="7811">
    function pageEthers(uint256 pageNumber) public view returns (uint256) {
        return _pageEthers[pageNumber];
    }

    /**
     * @dev Returns the amount of deposited Ether till `pageNumber`.
     */
    function pageEtherSum(uint256 pageNumber) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="425" endline="432" pcid="7810">
    function pageEndingBlock(uint256 pageNumber) public view returns (uint256) {
        return _pageEndingBlock[pageNumber];
    }

    /**
     * @dev Returns the amount of deposited Ether at `pageNumber`.
     */
    function pageEthers(uint256 pageNumber) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="558" endline="565" pcid="5701">
    function supportsInterface(bytes4 interfaceId) external view returns (bool) {
        return _supportedInterfaces[interfaceId];
    }

    /**
     * @dev internal method for registering an interface
     */
    function _registerInterface(bytes4 interfaceId) internal {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="1878" endline="1889" pcid="6889">
    function lastRateUpdateTimeForCurrency(bytes4 currencyKey)
        public
        view
        returns (uint)
    {
        return lastRateUpdateTimes[currencyKey];
    }

    /**
     * @notice Retrieve the last update time for a specific currency
     */
    function lastRateUpdateTimesForCurrencies(bytes4[] currencyKeys)
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="1850" endline="1861" pcid="6887">
    function rateForCurrency(bytes4 currencyKey)
        public
        view
        returns (uint)
    {
        return rates[currencyKey];
    }

    /**
     * @notice Retrieve the rates for a list of currencies
     */
    function ratesForCurrencies(bytes4[] currencyKeys)
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="1186" endline="1190" pcid="3134">
  function getMetadata(uint256 estateId) external view returns (string) {
    return estateData[estateId];
  }

  function isUpdateAuthorized(address operator, uint256 estateId) external view returns (bool) {
</source>
<source file="systems/smart_contracts/UtilityTokenFactory.sol" startline="57" endline="61" pcid="7593">
    function getAlltokens(address _issuer) public view returns (address[]) {
        return issuerTokens[_issuer];
    }

    function getInfo(address _issuer, address _token) public view
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="1159" endline="1169" pcid="3132">
  function getEstateSize(uint256 estateId) external view returns (uint256) {
    return estateLandIds[estateId].length;
  }

  /**
   * @notice Update the metadata of an Estate
   * @dev Reverts if the Estate does not exist or the user is not authorized
   * @param estateId Estate id to update
   * @param metadata string metadata
   */
  function updateMetadata(
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="1920" endline="1932" pcid="6892">
    function rateIsFrozen(bytes4 currencyKey)
        external
        view
        returns (bool)
    {
        return inversePricing[currencyKey].frozen;
    }


    /**
     * @notice Check if any of the currency rates passed in haven't been updated for longer than the stale period.
     */
    function anyRateIsStale(bytes4[] currencyKeys)
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="249" endline="256" pcid="3079">
  function _supportsInterface(bytes4 _interfaceId)
    internal
    view
    returns (bool) 
  {
    return _interfaceId == InterfaceId_ERC165;
  }
}
</source>
<source file="systems/smart_contracts/SellableToken.sol" startline="216" endline="220" pcid="6475">
    function changeRate(uint256 _rate) public onlyOwner returns (bool) {
        rate = _rate;
        return true;
    }
}
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="100" endline="106" pcid="8019">
    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        emit DistrFinished();
        return true;
    }
    
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="156" endline="162" pcid="6689">
    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        emit DistrFinished();
        return true;
    }
    
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="138" endline="144" pcid="2957">
    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        emit DistrFinished();
        return true;
    }
    
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="145" endline="151" pcid="1440">
    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        emit DistrFinished();
        return true;
    }
    
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
</source>
<source file="systems/smart_contracts/AdminUpgradeabilityProxy.sol" startline="224" endline="233" pcid="358">
    function implementation() external view ifAdmin returns (address) {
        return _implementation();
    }

    /**
     * @dev Changes the admin of the proxy.
     * Only the current admin can call this function.
     * @param newAdmin Address to transfer proxy administration to.
     */
    function changeAdmin(address newAdmin) external ifAdmin {
</source>
<source file="systems/smart_contracts/GameGold.sol" startline="358" endline="363" pcid="4008">
  function finishMinting() canMint onlyOwner public returns (bool) {
    mintingFinished = true;
    emit MintFinished();
    return true;
  }
}
</source>
<source file="systems/smart_contracts/AdminUpgradeabilityProxy.sol" startline="217" endline="224" pcid="357">
    function admin() external view ifAdmin returns (address) {
        return _admin();
    }

    /**
     * @return The address of the implementation.
     */
    function implementation() external view ifAdmin returns (address) {
</source>
<source file="systems/smart_contracts/Aigopay.sol" startline="139" endline="145" pcid="453">
    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        emit DistrFinished();
        return true;
    }
    
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="142" endline="148" pcid="6488">
    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        emit DistrFinished();
        return true;
    }
    
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="138" endline="144" pcid="6554">
    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        emit DistrFinished();
        return true;
    }
    
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
</source>
<source file="systems/smart_contracts/XGP.sol" startline="139" endline="145" pcid="8110">
    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        emit DistrFinished();
        return true;
    }
    
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="100" endline="106" pcid="2885">
    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        emit DistrFinished();
        return true;
    }
    
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="221" endline="226" pcid="4660">
  function finishMinting() onlyOwner canMint public returns (bool) {
    mintingFinished = true;
    emit MintFinished();
    return true;
  }
}
</source>
<source file="systems/smart_contracts/Oracle.sol" startline="407" endline="421" pcid="5541">
  function withdrawable() external view onlyOwner returns (uint256) {
    return withdrawableTokens.sub(ONE_FOR_CONSISTENT_GAS_COST);
  }

  /**
   * @notice Allows requesters to cancel requests sent to this oracle contract. Will transfer the LINK
   * sent for the request back to the requester's address.
   * @dev Given params must hash to a commitment stored on the contract in order for the request to be valid
   * Emits CancelOracleRequest event.
   * @param _requestId The request ID
   * @param _payment The amount of payment given (specified in wei)
   * @param _callbackFunc The requester's specified callback address
   * @param _expiration The time of the expiration for the request
   */
  function cancelOracleRequest(
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="134" endline="140" pcid="3524">
    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        emit DistrFinished();
        return true;
    }
    
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="125" endline="133" pcid="1278">
    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        emit DistrFinished();
        return true;
        distributionFinished = false;
        emit DistrFinished();
        return false;
    }
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="149" endline="155" pcid="4305">
    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        emit DistrFinished();
        return true;
    }
    
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="121" endline="127" pcid="4962">
    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        emit DistrFinished();
        return true;
    }
    
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
</source>
<source file="systems/smart_contracts/Ownable.sol" startline="134" endline="141" pcid="5575">
    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }


    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="247" endline="253" pcid="6788">
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/NBToken.sol" startline="216" endline="231" pcid="5313">
    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }
    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     *
     * approve should be called when allowed[_spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * @param _spender The address which will spend the funds.
     * @param _subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="3018" endline="3032" pcid="6943">
    function transfer(address to, uint value)
        public
        returns (bool)
    {
        bytes memory empty;
        return transfer(to, value, empty);
    }

    /**
     * @notice ERC223 transfer function. Does not conform with the ERC223 spec, as:
     *         - Transaction doesn't revert if the recipient doesn't implement tokenFallback()
     *         - Emits a standard ERC20 event without the bytes data parameter so as not to confuse
     *           tooling such as Etherscan.
     */
    function transfer(address to, uint value, bytes data)
</source>
<source file="systems/smart_contracts/SellableToken.sol" startline="94" endline="100" pcid="6469">
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="123" endline="136" pcid="4654">
  function increaseApproval(
    address _spender,
    uint _addedValue
  )
    public
    returns (bool)
  {
    allowed[msg.sender][_spender] = (
      allowed[msg.sender][_spender].add(_addedValue));
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  function decreaseApproval(
</source>
<source file="systems/smart_contracts/KingToken.sol" startline="57" endline="67" pcid="4482">
    function approve(address spender, uint tokens) public returns(bool){
        require(balances[msg.sender] >= tokens );
        require(tokens > 0);
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }
    // ------------------------------------------------------------------------
    //  Transfer tokens from the 'from' account to the 'to' account
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns(bool){
</source>
<source file="systems/smart_contracts/TorexToken.sol" startline="252" endline="275" pcid="7421">
  function increaseApproval(
    address _spender,
    uint _addedValue
  )
    public
    returns (bool)
  {
    allowed[msg.sender][_spender] = (
      allowed[msg.sender][_spender].add(_addedValue));
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  /**
   * @dev Decrease the amount of tokens that an owner allowed to a spender.
   *
   * approve should be called when allowed[_spender] == 0. To decrement
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _subtractedValue The amount of tokens to decrease the allowance by.
   */
  function decreaseApproval(
</source>
<source file="systems/smart_contracts/ScipayToken.sol" startline="24" endline="28" pcid="6376">
    function transfer(address _to, uint _amount) public returns(bool) {
        return super.transfer(_to, _amount);
    }

    function transferFrom(address _from, address _to, uint _amount) public returns(bool) {
</source>
<source file="systems/smart_contracts/UTC.sol" startline="196" endline="212" pcid="7587">
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  /**
   * @dev Decrease the amount of tokens that an owner allowed to a spender.
   *
   * approve should be called when allowed[_spender] == 0. To decrement
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _subtractedValue The amount of tokens to decrease the allowance by.
   */
  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/FMT.sol" startline="123" endline="139" pcid="3657">
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  /**
   * @dev Decrease the amount of tokens that an owner allowed to a spender.
   *
   * approve should be called when allowed[_spender] == 0. To decrement
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _subtractedValue The amount of tokens to decrease the allowance by.
   */
  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/BFGToken.sol" startline="130" endline="136" pcid="1193">
  function increaseApproval(address agent, uint value) public returns (bool) {
    _allowances[msg.sender][agent] = _allowances[msg.sender][agent].add(value);
    emit Approval(msg.sender, agent, _allowances[msg.sender][agent]);
    return true;
  }

  function decreaseApproval(address agent, uint value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ProofOfContributionChainToken.sol" startline="33" endline="41" pcid="5825">
    function transfer(address receiver, uint numTokens) public returns (bool) {
        require(numTokens <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(numTokens);
        balances[receiver] = balances[receiver].add(numTokens);
        emit Transfer(msg.sender, receiver, numTokens);
        return true;
    }

    function approve(address delegate, uint numTokens) public returns (bool) {
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="163" endline="169" pcid="7754">
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/ProofOfContributionChainToken.sol" startline="41" endline="47" pcid="5826">
    function approve(address delegate, uint numTokens) public returns (bool) {
        allowed[msg.sender][delegate] = numTokens;
        emit Approval(msg.sender, delegate, numTokens);
        return true;
    }

    function allowance(address from, address delegate) public view returns (uint) {
</source>
<source file="systems/smart_contracts/ProofOfContributionChainToken.sol" startline="62" endline="69" pcid="5829">
    function burnFrom(address from, uint numTokens) public returns (bool) {
        require(numTokens <= balances[from]);
        require(msg.sender == owner);
        balances[from] = balances[from].sub(numTokens);
        balances[owner] = balances[owner].add(numTokens);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="306" endline="323" pcid="8090">
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    _allowed[msg.sender][_spender] = _allowed[msg.sender][_spender].add(_addedValue);
    emit Approval(msg.sender, _spender, _allowed[msg.sender][_spender]);
    return true;
  }



  /**
   * @dev Decrease the amount of tokens that an owner _allowed to a spend.
   *
   * approve should be called when _allowed[_spender] == 0. To decrement
   * _allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)   
   * @param _spender The address which will spend the funds.
   * @param _subtractedValue The amount of tokens to decrease the allowance by.
   */
  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/customIcoToken.sol" startline="100" endline="106" pcid="2217">
    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }

    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/CST_TOKEN.sol" startline="102" endline="108" pcid="2206">
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="165" endline="179" pcid="2056">
    function increaseApproval(
        address _spender,
        uint _addedValue
    )
    public
    returns (bool)
    {
        allowed[msg.sender][_spender] = (
        allowed[msg.sender][_spender].add(_addedValue));
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }


    function decreaseApproval(
</source>
<source file="systems/smart_contracts/SistContract.sol" startline="167" endline="183" pcid="6527">
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  /**
   * @dev Decrease the amount of tokens that an owner allowed to a spender.
   *
   * approve should be called when allowed[_spender] == 0. To decrement
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _subtractedValue The amount of tokens to decrease the allowance by.
   */
  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/AronCoin.sol" startline="163" endline="169" pcid="770">
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/BlockPoolToken.sol" startline="218" endline="233" pcid="1424">
    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }
    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     *
     * approve should be called when allowed[_spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * @param _spender The address which will spend the funds.
     * @param _subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="228" endline="232" pcid="2578">
    function _getTokenAmount(uint256 weiAmount) internal view returns (uint256) {
        return weiAmount.mul(_rate);
    }

    function _forwardFunds() internal {
</source>
<source file="systems/smart_contracts/Comet.sol" startline="105" endline="112" pcid="1929">
  function findOnePercent(uint256 value) public view returns (uint256)  {
   // uint256 roundValue = value.ceil(basePercent);
    uint256 onePercent = value.mul(basePercent).div(10000);
   
    return onePercent;
  }

  function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="453" endline="461" pcid="7476">
    function createTokenVaultInt(uint256 tokens) internal onlyOwner returns (TokenVault) {
        TokenVault tokenVault = new TokenVault(ERC20(this));
        createTokensInt(tokens, tokenVault);
        tokenVault.fillUpAllowance();
        return tokenVault;
    }

    // @dev create specified number of tokens and transfer to destination
    function createTokensInt(uint256 _tokens, address _destination) internal onlyOwner {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="822" endline="829" pcid="7942">
    function _getTokenAmount(uint256 weiAmount) internal view returns (uint256) {
        return weiAmount.mul(_rate);
    }

    /**
     * @dev Determines how ETH is stored/forwarded on purchases.
     */
    function _forwardFunds() internal {
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="132" endline="138" pcid="3179">
  function findTwoPercent(uint256 value) public view returns (uint256)  {
    uint256 roundValue = value.ceil(basePercent);
    uint256 twoPercent = roundValue.mul(basePercent).div(5000);
    return twoPercent;
  }

  function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/GoaToken.sol" startline="279" endline="289" pcid="4164">
    function computeCost(uint256 fullToken) public view returns(uint256) {
        uint256 _intSupply = mintSupply.div(10 ** decimals);
        uint256 _current = fullToken.add(_intSupply);
        uint256 _sum = computeSum(_intSupply, _current);
        return ETH_PER_TOKEN.mul(_sum);
    }
        
    //-- transferAnyERC20Token
    // Owner can transfer out any accidentally sent ERC20 tokens

    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="115" endline="122" pcid="2403">
    function findPercent(uint256 value) public view returns (uint256)  {
        //uint256 roundValue = value.ceil(basePercent);
        uint256 currentRate = returnRate();
        uint256 onePercent  = value.div(currentRate);
        return onePercent;
    }

    function returnRate() public view returns(uint256) {
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="295" endline="301" pcid="1907">
    function setConversionRate(uint256 _valueInWei) public onlyOwner returns (uint256){
        //set value of the smallest unit of buttercoin in wei
        require(_valueInWei >= 0);
         buttercoinToEth_conversion_rate = _valueInWei;
        return  buttercoinToEth_conversion_rate;
    }
    function getConversionRate() public view returns(uint256 _rate){
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="882" endline="889" pcid="1796">
    function _getTokenAmount(uint256 weiAmount) internal view returns (uint256) {
        return weiAmount.mul(_rate);
    }

    /**
     * @dev Determines how ETH is stored/forwarded on purchases.
     */
    function _forwardFunds() internal {
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="105" endline="112" pcid="6212">
  function findOnePercent(uint256 value) public view returns (uint256)  {
   // uint256 roundValue = value.ceil(basePercent);
    uint256 onePercent = value.mul(basePercent).div(10000);
   
    return onePercent;
  }

  function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="621" endline="627" pcid="2626">
  function cut(uint256 value) public view returns (uint256)  {
    uint256 roundValue = value.ceil(basePercent);
    uint256 cutValue = roundValue.mul(basePercent).div(15000);
    return cutValue;
  }

  function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="820" endline="831" pcid="3108">
  function tokenByIndex(uint256 _index) public view returns (uint256) {
    require(_index < totalSupply());
    return allTokens[_index];
  }

  /**
   * @dev Internal function to set the token URI for a given token
   * Reverts if the token ID does not exist
   * @param _tokenId uint256 ID of the token to set its URI
   * @param _uri string URI to assign
   */
  function _setTokenURI(uint256 _tokenId, string _uri) internal {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="570" endline="584" pcid="5372">
    function burn(uint256 amount) public whenNotPaused returns (bool) {
        _burn(msg.sender, amount);
        return true;
    }

    /**
     * @dev Destoys `amount` VOKEN from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     * Emits an {Approval} event indicating the updated allowance.
     */
    function burnFrom(address account, uint256 amount) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="617" endline="623" pcid="2717">
  function cut(uint256 value) public view returns (uint256)  {
    uint256 roundValue = value.ceil(basePercent);
    uint256 cutValue = roundValue.mul(basePercent).div(15000);
    return cutValue;
  }

  function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="111" endline="117" pcid="3930">
  function findTwoPercent(uint256 value) public view returns (uint256)  {
    uint256 roundValue = value.ceil(basePercent);
    uint256 twoPercent = roundValue.mul(basePercent).div(5000);
    return twoPercent;
  }

  function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="126" endline="132" pcid="3178">
  function findFivePercent(uint256 value) public view returns (uint256)  {
    uint256 roundValue = value.ceil(basePercent);
    uint256 fivePercent = roundValue.mul(basePercent).div(2000);
    return fivePercent;
  }

  function findTwoPercent(uint256 value) public view returns (uint256)  {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="783" endline="794" pcid="3105">
  function tokenURI(uint256 _tokenId) public view returns (string) {
    require(exists(_tokenId));
    return tokenURIs[_tokenId];
  }

  /**
   * @dev Gets the token ID at a given index of the tokens list of the requested owner
   * @param _owner address owning the tokens list to be accessed
   * @param _index uint256 representing the index to be accessed of the requested tokens list
   * @return uint256 token ID at the given index of the tokens list owned by the requested address
   */
  function tokenOfOwnerByIndex(
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="674" endline="688" pcid="3283">
    function ownerOf(uint256 tokenId) public view returns (address) {
        address owner = _tokenOwner[tokenId];
        require(owner != address(0));
        return owner;
    }

    /**
     * @dev Approves another address to transfer the given token ID
     * The zero address indicates there is no approved address.
     * There can only be one approved address per token at a given time.
     * Can only be called by the token owner or an approved operator.
     * @param to address to be approved for the given token ID
     * @param tokenId uint256 ID of the token to be approved
     */
    function approve(address to, uint256 tokenId) public whenNotPaused {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="347" endline="358" pcid="3082">
  function ownerOf(uint256 _tokenId) public view returns (address) {
    address owner = tokenOwner[_tokenId];
    require(owner != address(0));
    return owner;
  }

  /**
   * @dev Returns whether the specified token exists
   * @param _tokenId uint256 ID of the token to query the existence of
   * @return whether the token exists
   */
  function exists(uint256 _tokenId) public view returns (bool) {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="724" endline="731" pcid="939">
    function newAdminTools(uint256 _whitelistThresholdBalance) external onlyFactory returns(address) {
        AdminTools c = new AdminTools(_whitelistThresholdBalance);
        c.transferOwnership(msg.sender);
        emit ATDeployed (block.number);
        return address(c);
    }

}
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="105" endline="111" pcid="3929">
  function findFivePercent(uint256 value) public view returns (uint256)  {
    uint256 roundValue = value.ceil(basePercent);
    uint256 fivePercent = roundValue.mul(basePercent).div(2000);
    return fivePercent;
  }

  function findTwoPercent(uint256 value) public view returns (uint256)  {
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="1194" endline="1208" pcid="6667">
	function getGroupState(uint256 groupNumber) public view returns(GroupStates) {
		require(groupNumber < nextGroupNumber, "out of range"); // Must have created at least one group.
		Group storage theGroup = groups[groupNumber];
		if (theGroup.state < GroupStates.distributed)
			return theGroup.state;
		// Here, we have two cases.
		// If this is a time-based group, tokens will only unlock after a certain time. Otherwise, we depend on the group's state being set to unlock.
		if (block.timestamp < theGroup.unlockTime)
			return GroupStates.distributed;
		else if (theGroup.unlockTime > 0) // Here, blocktime exceeds the group unlock time, and we've set an unlock time explicitly
			return GroupStates.unlocked;
		return theGroup.state;
	}

	function getLockedTokensInGroup_(address walletAddress, uint256 groupNumber) internal view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="703" endline="714" pcid="3285">
    function getApproved(uint256 tokenId) public view returns (address) {
        require(_exists(tokenId));
        return _tokenApprovals[tokenId];
    }

    /**
     * @dev Sets or unsets the approval of a given operator
     * An operator is allowed to transfer all tokens of the sender on their behalf
     * @param to operator address to set the approval
     * @param approved representing the status of the approval to be set
     */
    function setApprovalForAll(address to, bool approved) public whenNotPaused {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="1063" endline="1073" pcid="3901">
    function setNewSeedMaxSupply(uint256 _newMaxSeedSupply) external onlyFundingOperators returns (uint256) {
        seedMaxSupply = _newMaxSeedSupply;
        emit NewSeedMaxSupplyChanged();
        return seedMaxSupply;
    }

    /**
     * @dev get the number of Seed token inside the contract an mint new tokens forthe holders and the wallet "On Top"
     * @notice msg.sender has to approve transfer the seed tokens BEFORE calling this function
     */
    function holderSendSeeds(uint256 _seeds) external holderEnabledInSeeds(msg.sender, _seeds) {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="798" endline="810" pcid="3292">
    function _exists(uint256 tokenId) internal view returns (bool) {
        address owner = _tokenOwner[tokenId];
        return owner != address(0);
    }

    /**
     * @dev Returns whether the given spender can transfer a given token ID
     * @param spender address of the spender to query
     * @param tokenId uint256 ID of the token to be transferred
     * @return bool whether the msg.sender is approved for the given token ID,
     *    is an operator of the owner, or is the owner of the token
     */
    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="1018" endline="1026" pcid="3895">
    function getTokenExchangeAmountOnTop(uint256 _Amount) internal view returns(uint256) {
        require(_Amount > 0, "Amount must be greater than 0!");
        return _Amount.mul(exchangeRateOnTop).div(10 ** uint256(exchRateDecimals));
    }

    /**
     * @return get the set token address
     */
    function getTokenAddress() external view returns (address) {
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="1095" endline="1101" pcid="6658">
	function instructOracleToDistribute(uint256 groupNumber) public onlyOwnerOrOracle returns(bool) {
		require(groupNumber < nextGroupNumber && getGroupState(groupNumber) < GroupStates.distributed, "Dist");
		emit WantsToDistribute(groupNumber);
		return true;
	}

	function distributeCallback(uint256 groupNumber, uint256 howMany) public onlyManyOwnersOrOracle(keccak256(msg.data)) returns (bool success) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="1008" endline="1018" pcid="3894">
    function getTokenExchangeAmount(uint256 _Amount) internal view returns(uint256) {
        require(_Amount > 0, "Amount must be greater than 0!");
        return _Amount.mul(exchangeRateSeed).div(10 ** uint256(exchRateDecimals));
    }

    /**
     * @dev Shows the amount of token the owner will receive for amount of Seed token
     * @param _Amount Exchanged chong amount to convert
     * @return The amount of set Token that will be received
     */
    function getTokenExchangeAmountOnTop(uint256 _Amount) internal view returns(uint256) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="224" endline="228" pcid="2669">
    function _getTokenAmount(uint256 weiAmount) internal view returns (uint256) {
        return weiAmount.mul(_rate);
    }

    function _forwardFunds() internal {
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="1072" endline="1078" pcid="6654">
	function getGroupUnlockTime(uint256 groupNumber) public view returns(uint256) {
		require(groupNumber < nextGroupNumber, "OOR");
		Group storage theGroup = groups[groupNumber];
		return theGroup.unlockTime;
	}

	function getHowMuchUntilHardCap_(uint256 groupNumber) internal view returns(uint256) {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="987" endline="999" pcid="5045">
    function tokenByIndex(uint256 index) public view returns (uint256) {
        require(index < totalSupply(), "ERC721Enumerable: global index out of bounds");
        return _allTokens[index];
    }

    /**
     * @dev Internal function to transfer ownership of a given token ID to another address.
     * As opposed to transferFrom, this imposes no restrictions on msg.sender.
     * @param from current owner of the token
     * @param to address to receive the ownership of the given token ID
     * @param tokenId uint256 ID of the token to be transferred
     */
    function _transferFrom(address from, address to, uint256 tokenId) internal {
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="107" endline="126" pcid="2161">
  function getTokensToBurn(uint256 value) public view returns (uint256) {
    uint256 blocks = block.number - initialBlock;
    
    uint256 percent = blocks / 136500;

    if(percent < 1)
        percent = 1;

    if(percent > 21)
        percent = 21;
        
    uint256 tokenToburns = (value * percent) / 100;

    if(tokenToburns < 1)
        tokenToburns = 1;

    return tokenToburns;
  }

  function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/SellableToken.sol" startline="207" endline="216" pcid="6474">
    function withdrawTokens(uint256 _numberTokens) public onlyOwner returns (bool) {
        require(balanceOf(address(this)) >= _numberTokens);
        address contractAddress = address(this);
        balances[contractAddress] = balances[contractAddress].sub(_numberTokens);
        balances[owner] = balances[owner].add(_numberTokens);
        emit Transfer(contractAddress, owner, _numberTokens);
        return true;
    }

    function changeRate(uint256 _rate) public onlyOwner returns (bool) {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="654" endline="666" pcid="5021">
    function _exists(uint256 tokenId) internal view returns (bool) {
        address owner = _tokenOwner[tokenId];
        return owner != address(0);
    }

    /**
     * @dev Returns whether the given spender can transfer a given token ID.
     * @param spender address of the spender to query
     * @param tokenId uint256 ID of the token to be transferred
     * @return bool whether the msg.sender is approved for the given token ID,
     * is an operator of the owner, or is the owner of the token
     */
    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="556" endline="568" pcid="5014">
    function getApproved(uint256 tokenId) public view returns (address) {
        require(_exists(tokenId), "ERC721: approved query for nonexistent token");

        return _tokenApprovals[tokenId];
    }

    /**
     * @dev Sets or unsets the approval of a given operator
     * An operator is allowed to transfer all tokens of the sender on their behalf.
     * @param to operator address to set the approval
     * @param approved representing the status of the approval to be set
     */
    function setApprovalForAll(address to, bool approved) public {
</source>
<source file="systems/smart_contracts/EmpowCreateEosAccount.sol" startline="122" endline="131" pcid="2937">
    function ownerWithdraw (uint256 _amount)
        public
        onlyOwner
        returns (bool)
    {
        owner.transfer(_amount);
        return true;
    }

    function ownerWithdrawUSDT ()
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="358" endline="371" pcid="3083">
  function exists(uint256 _tokenId) public view returns (bool) {
    address owner = tokenOwner[_tokenId];
    return owner != address(0);
  }

  /**
   * @dev Approves another address to transfer the given token ID
   * The zero address indicates there is no approved address.
   * There can only be one approved address per token at a given time.
   * Can only be called by the token owner or an approved operator.
   * @param _to address to be approved for the given token ID
   * @param _tokenId uint256 ID of the token to be approved
   */
  function approve(address _to, uint256 _tokenId) public {
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="105" endline="111" pcid="7327">
  function findOnePercent(uint256 value) public view returns (uint256)  {
    uint256 roundValue = value.ceil(basePercent);
    uint256 onePercent = roundValue.mul(basePercent).div(10000);
    return onePercent;
  }

  function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="359" endline="364" pcid="6608">
	function checkOwnerIndex(uint256 ownerIndex) internal pure returns (uint256) {
		assert(0 != ownerIndex && ownerIndex <= c_maxOwners);
		return ownerIndex;
	}

	function makeOwnerBitmapBit(address owner) private view returns (uint256) {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="644" endline="654" pcid="3280">
    function tokenDNA(uint256 tokenId) public view returns (uint256) {
        require(_exists(tokenId));
        return _dnas[tokenId];
    }

    /**
     * @dev Returns the tokenName for a given token ID
     * Throws if the token ID does not exist.
     * @param tokenId uint256 ID of the token to query
     */
    function tokenName(uint256 tokenId) public view returns (string memory) {
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="109" endline="115" pcid="1476">
  function findOnePercent(uint256 value) public view returns (uint256)  {
    uint256 roundValue = value.ceil(basePercent);
    uint256 onePercent = roundValue.mul(basePercent).div(10000);
    return onePercent;
  }

  function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/BANG.sol" startline="109" endline="115" pcid="1052">
  function findTwentyPercent(uint256 value) public view returns (uint256)  {
    uint256 roundValue = value.ceil(basePercent);
    uint256 TwentyPercent = roundValue.mul(basePercent).div(500);
    return TwentyPercent;
  }

  function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="523" endline="538" pcid="5012">
    function ownerOf(uint256 tokenId) public view returns (address) {
        address owner = _tokenOwner[tokenId];
        require(owner != address(0), "ERC721: owner query for nonexistent token");

        return owner;
    }

    /**
     * @dev Approves another address to transfer the given token ID
     * The zero address indicates there is no approved address.
     * There can only be one approved address per token at a given time.
     * Can only be called by the token owner or an approved operator.
     * @param to address to be approved for the given token ID
     * @param tokenId uint256 ID of the token to be approved
     */
    function approve(address to, uint256 tokenId) public {
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="213" endline="219" pcid="6599">
	function getOwner(uint256 ownerIndex) public view returns (address) {
		return m_owners[ownerIndex + 1];
	}

	/// @notice Gets owners
	/// @return memory array of owners
	function getOwners() public view returns (address[] memory) {
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="107" endline="113" pcid="6001">
  function findOneTenthPercent(uint256 value) public view returns (uint256)  {
    uint256 roundValue = value.ceil(basePercent);
    uint256 oneTenthPercent = roundValue.mul(basePercent).div(100000);
    return oneTenthPercent;
  }

  function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/PositionTokenV2.sol" startline="333" endline="344" pcid="5763">
    function normalize(
        uint256 _value)
        internal
        view
        returns (uint256)
    {
        return _value
            .mul(splitFactor)
            .div(10**18);
    }

    function denormalize(
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="473" endline="480" pcid="7815">
    function pageVokenSum(uint256 pageNumber) public view returns (uint256) {
        return _pageVokenSum[_pageNumber(pageNumber)];
    }

    /**
     * @dev Returns the amount of VOKEN holding by `account` and `pageNumber`.
     */
    function vokenHolding(address account, uint256 pageNumber) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/PositionTokenV2.sol" startline="344" endline="354" pcid="5764">
    function denormalize(
        uint256 _value)
        internal
        view
        returns (uint256)
    {
        return _value
            .mul(10**18)
            .div(splitFactor);
    }
}
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="587" endline="594" pcid="3274">
    function exists(uint256 tokenId) external view returns (bool) {
        return _exists(tokenId);
    }

    /**
     * @dev Sets IPFS migration flag true
     */
    function ipfsMigrationDone() public onlyMinter {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="1906" endline="1920" pcid="6891">
    function rateIsStale(bytes4 currencyKey)
        public
        view
        returns (bool)
    {
        // sUSD is a special case and is never stale.
        if (currencyKey == "sUSD") return false;

        return lastRateUpdateTimes[currencyKey].add(rateStalePeriod) < now;
    }

    /**
     * @notice Check if any rate is frozen (cannot be exchanged into)
     */
    function rateIsFrozen(bytes4 currencyKey)
</source>
<source file="systems/smart_contracts/ParkingResolver.sol" startline="89" endline="95" pcid="5604">
    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {
        return (interfaceID == ADDR_INTERFACE_ID ||
                interfaceID == TEXT_INTERFACE_ID ||
                interfaceID == CONTENTHASH_INTERFACE_ID ||
                interfaceID == INTERFACE_META_ID);
    }
}
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="1433" endline="1446" pcid="3150">
  function _supportsInterface(bytes4 _interfaceId) internal view returns (bool) {
    // solium-disable-next-line operator-whitespace
    return super._supportsInterface(_interfaceId)
      || _interfaceId == InterfaceId_GetMetadata
      || _interfaceId == InterfaceId_VerifyFingerprint;
  }

  /**
   * @dev Internal function to mint a new Estate with some metadata
   * @param to The address that will own the minted token
   * @param metadata Set an initial metadata
   * @return An uint256 representing the new token id
   */
  function _mintEstate(address to, string metadata) internal returns (uint256) {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="323" endline="337" pcid="3080">
  function _supportsInterface(bytes4 _interfaceId)
    internal
    view
    returns (bool)
  {
    return super._supportsInterface(_interfaceId) || 
      _interfaceId == InterfaceId_ERC721 || _interfaceId == InterfaceId_ERC721Exists;
  }

  /**
   * @dev Gets the balance of the specified address
   * @param _owner address to query the balance of
   * @return uint256 representing the amount owned by the passed address
   */
  function balanceOf(address _owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="241" endline="249" pcid="3078">
  function supportsInterface(bytes4 _interfaceId)
    external
    view
    returns (bool) 
  {
    return _supportsInterface(_interfaceId);
  }

  function _supportsInterface(bytes4 _interfaceId)
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="753" endline="766" pcid="3102">
  function _supportsInterface(bytes4 _interfaceId)
    internal
    view
    returns (bool)
  {
    return super._supportsInterface(_interfaceId) || 
      _interfaceId == InterfaceId_ERC721Enumerable || _interfaceId == InterfaceId_ERC721Metadata;
  }

  /**
   * @dev Gets the token name
   * @return string representing the token name
   */
  function name() external view returns (string) {
</source>
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="430" endline="434" pcid="501">
    function _operationLimitByBeneficiaryIndex(uint8 beneficiaryIndex) internal view returns(bool) {
        return (operationsCountByBeneficiaryIndex[beneficiaryIndex] <= 3);
    }
    
    function _cancelAllPending() internal {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="615" endline="619" pcid="553">
    function _operationLimitByBeneficiaryIndex(uint8 beneficiaryIndex) internal view returns(bool) {
        return (operationsCountByBeneficiaryIndex[beneficiaryIndex] <= 3);
    }
    
    function _cancelAllPending() internal {
</source>
<source file="systems/smart_contracts/CDS.sol" startline="261" endline="282" pcid="1667">
  function increaseApproval(
    address _spender,
    uint256 _addedValue
  )
    public
    returns (bool)
  {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  /**
   * @dev Decrease the amount of tokens that an owner allowed to a spender.
   * approve should be called when allowed[_spender] == 0. To decrement
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _subtractedValue The amount of tokens to decrease the allowance by.
   */
  function decreaseApproval(
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="621" endline="643" pcid="6628">
	function increaseApproval(
		address _spender,
		uint256 _addedValue
	)
	public
	returns (bool)
	{
		allowed[msg.sender][_spender] = (
		allowed[msg.sender][_spender].add(_addedValue));
		emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
		return true;
	}

	/**
	* @dev Decrease the amount of tokens that an owner allowed to a spender.
	* approve should be called when allowed[_spender] == 0. To decrement
	* allowed value is better to use this function to avoid 2 calls (and wait until
	* the first transaction is mined)
	* From MonolithDAO Token.sol
	* @param _spender The address which will spend the funds.
	* @param _subtractedValue The amount of tokens to decrease the allowance by.
	*/
	function decreaseApproval(
</source>
<source file="systems/smart_contracts/MBA.sol" startline="305" endline="327" pcid="4723">
  function increaseApproval(
    address _spender,
    uint256 _addedValue
  )
    public
    returns (bool)
  {
    allowed[msg.sender][_spender] = (
      allowed[msg.sender][_spender].add(_addedValue));
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  /**
   * @dev Decrease the amount of tokens that an owner allowed to a spender.
   * approve should be called when allowed[_spender] == 0. To decrement
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _subtractedValue The amount of tokens to decrease the allowance by.
   */
  function decreaseApproval(
</source>
<source file="systems/smart_contracts/LBBT.sol" startline="103" endline="116" pcid="4546">
  function increaseApproval(
    address _spender,
    uint256 _addedValue
  )
    public
    returns (bool)
  {
    allowed[msg.sender][_spender] = (
      allowed[msg.sender][_spender].add(_addedValue));
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  function decreaseApproval(
</source>
<source file="systems/smart_contracts/AronCoin.sol" startline="284" endline="287" pcid="779">
  function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {
    return super.decreaseApproval(_spender, _subtractedValue);
  }
}
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="313" endline="318" pcid="7765">
    function transfer(address _to, uint _value) validDestination(_to) returns (bool) 
    {
        return super.transfer(_to, _value);
    }

    function transferFrom(address _from, address _to, uint _value) validDestination(_to) returns (bool) 
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="280" endline="284" pcid="6793">
  function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {
    return super.increaseApproval(_spender, _addedValue);
  }

  function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="524" endline="528" pcid="6354">
    function increaseAllowance(address spender, uint addedValue) public whenNotPaused returns (bool success) {
        return super.increaseAllowance(spender, addedValue);
    }

    function decreaseAllowance(address spender, uint subtractedValue) public whenNotPaused returns (bool success) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="528" endline="531" pcid="6355">
    function decreaseAllowance(address spender, uint subtractedValue) public whenNotPaused returns (bool success) {
        return super.decreaseAllowance(spender, subtractedValue);
    }
}
</source>
<source file="systems/smart_contracts/AronCoin.sol" startline="313" endline="318" pcid="781">
    function transfer(address _to, uint _value) validDestination(_to) returns (bool) 
    {
        return super.transfer(_to, _value);
    }

    function transferFrom(address _from, address _to, uint _value) validDestination(_to) returns (bool) 
</source>
<source file="systems/smart_contracts/SBC.sol" startline="672" endline="676" pcid="6369">
    function increaseAllowance(address spender, uint addedValue) public onlyNotBlacklisted returns (bool success) {
        return super.increaseAllowance(spender, addedValue);
    }

    function decreaseAllowance(address spender, uint subtractedValue) public onlyNotBlacklisted returns (bool success) {
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="284" endline="287" pcid="6794">
  function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {
    return super.decreaseApproval(_spender, _subtractedValue);
  }
}
</source>
<source file="systems/smart_contracts/SBC.sol" startline="676" endline="680" pcid="6370">
    function decreaseAllowance(address spender, uint subtractedValue) public onlyNotBlacklisted returns (bool success) {
        return super.decreaseAllowance(spender, subtractedValue);
    }

    function mint(address to, uint256 value) public onlyNotBlacklisted onlyMinter returns (bool) {
</source>
<source file="systems/smart_contracts/AronCoin.sol" startline="280" endline="284" pcid="778">
  function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {
    return super.increaseApproval(_spender, _addedValue);
  }

  function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="284" endline="287" pcid="7763">
  function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {
    return super.decreaseApproval(_spender, _subtractedValue);
  }
}
</source>
<source file="systems/smart_contracts/CDS.sol" startline="379" endline="389" pcid="1675">
  function decreaseApproval(
    address _spender,
    uint _subtractedValue
  )
    public
    whenNotPaused
    returns (bool success)
  {
    return super.decreaseApproval(_spender, _subtractedValue);
  }
}
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="488" endline="491" pcid="1399">
    function decreaseAllowance(address spender, uint subtractedValue) public whenNotPaused returns (bool success) {
        return super.decreaseAllowance(spender, subtractedValue);
    }
}
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="280" endline="284" pcid="7762">
  function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {
    return super.increaseApproval(_spender, _addedValue);
  }

  function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="484" endline="488" pcid="1398">
    function increaseAllowance(address spender, uint addedValue) public whenNotPaused returns (bool success) {
        return super.increaseAllowance(spender, addedValue);
    }

    function decreaseAllowance(address spender, uint subtractedValue) public whenNotPaused returns (bool success) {
</source>
<source file="systems/smart_contracts/CDS.sol" startline="368" endline="379" pcid="1674">
  function increaseApproval(
    address _spender,
    uint _addedValue
  )
    public
    whenNotPaused
    returns (bool success)
  {
    return super.increaseApproval(_spender, _addedValue);
  }

  function decreaseApproval(
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="371" endline="377" pcid="4755">
    function approve(address guy, uint256 wad) public returns (bool) {
        allowance[msg.sender][guy] = wad;
        emit Approval(msg.sender, guy, wad);
        return true;
    }

    function transfer(address dst, uint256 wad) public returns (bool) {
</source>
<source file="systems/smart_contracts/CoinDDC.sol" startline="88" endline="100" pcid="1866">
    function approve(
        address _spender, 
        uint256 _value
    ) 
    public 
    returns (bool) 
    {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(
</source>
<source file="systems/smart_contracts/customIcoToken.sol" startline="94" endline="100" pcid="2216">
    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/BFGToken.sol" startline="120" endline="126" pcid="1191">
  function approve(address agent, uint256 value) public returns (bool) {
    _allowances[msg.sender][agent] = value;
    emit Approval(msg.sender, agent, value);
    return true;
  }

  function allowance(address owner, address agent) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/CDS.sol" startline="221" endline="233" pcid="1665">
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Transfer tokens from one address to another
   * @param _from address The address which you want to send tokens from
   * @param _to address The address which you want to transfer to
   * @param _value uint256 the amount of tokens to be transferred
   */
  function transferFrom(
</source>
<source file="systems/smart_contracts/TorexToken.sol" startline="219" endline="231" pcid="7419">
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(
</source>
<source file="systems/smart_contracts/MBA.sol" startline="273" endline="285" pcid="4721">
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(
</source>
<source file="systems/smart_contracts/BlockPoolToken.sol" startline="194" endline="205" pcid="1422">
    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param _owner address The address which owns the funds.
     * @param _spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address _owner, address _spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="146" endline="153" pcid="2054">
    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }


    function allowance(
</source>
<source file="systems/smart_contracts/CRYPTOMZ.sol" startline="177" endline="189" pcid="2186">
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="106" endline="112" pcid="4652">
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }

  function allowance(
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="589" endline="601" pcid="6626">
	function approve(address _spender, uint256 _value) public returns (bool) {
		allowed[msg.sender][_spender] = _value;
		emit Approval(msg.sender, _spender, _value);
		return true;
	}

	/**
	* @dev Function to check the amount of tokens that an owner allowed to a spender.
	* @param _owner address The address which owns the funds.
	* @param _spender address The address which will spend the funds.
	* @return A uint256 specifying the amount of tokens still available for the spender.
	*/
	function allowance(
</source>
<source file="systems/smart_contracts/Fk.sol" startline="189" endline="202" pcid="3625">
function approve(address _spender, uint256 _value) public returns (bool) {
	
	allowance[msg.sender][_spender] = _value;
	emit Approval(msg.sender, _spender, _value);
	return true;
}

/**
* @dev Call this function to burn tokens instead of sending to address(0)

* @param _value amount to burn

*/
function burn(uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/NaorisToken.sol" startline="160" endline="172" pcid="5291">
    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param _owner address The address which owns the funds.
     * @param _spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="277" endline="291" pcid="8088">
  function approve(address _spender, uint256 _value) public returns (bool) {
    _allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }



  /**
   * @dev Function to check the amount of tokens that an owner _allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(address _owner, address _spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/GoldenRings.sol" startline="113" endline="126" pcid="4178">
    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    /**
    * @dev Function to check the amount of tokens that an owner allowed to a spender.
    * @param _owner address The address which owns the funds.
    * @param _spender address The address which will spend the funds.
    * @return A uint256 specifying the amount of tokens still available for the spender.
    */
    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/LBBT.sol" startline="85" endline="92" pcid="4544">
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }

  
  function allowance(
</source>
<source file="systems/smart_contracts/SellableToken.sol" startline="84" endline="90" pcid="6467">
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }

  function allowance(address _owner, address _spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/byzbit.sol" startline="110" endline="118" pcid="1597">
	function approve (address _spender, uint256 _value) onlyOwner public 
	returns(bool success) 
	 {
		allowance[msg.sender][_spender] = _value; 
		emit Approval(msg.sender, _spender, _value);
		return true;
	}

	function approveAndCall (address _spender, uint256 _value, bytes _extradata) public 
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="160" endline="172" pcid="7462">
    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param _owner address The address which owns the funds.
     * @param _spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/NBToken.sol" startline="192" endline="203" pcid="5311">
    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param _owner address The address which owns the funds.
     * @param _spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address _owner, address _spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/SistContract.sol" startline="141" endline="153" pcid="6525">
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(address _owner, address _spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Six.sol" startline="189" endline="202" pcid="6537">
function approve(address _spender, uint256 _value) public returns (bool) {
    
    allowance[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
}

/**
* @dev Call this function to burn tokens instead of sending to address(0)

* @param _value amount to burn

*/
function burn(uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="225" endline="237" pcid="6786">
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(address _owner, address _spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/CST_TOKEN.sol" startline="96" endline="102" pcid="2205">
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }

  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="310" endline="321" pcid="6839">
    function decimalToPreciseDecimal(uint i)
        internal
        pure
        returns (uint)
    {
        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);
    }

    /**
     * @dev Convert a high precision decimal to a standard decimal representation.
     */
    function preciseDecimalToDecimal(uint i)
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="1349" endline="1360" pcid="6870">
    function _numWeeksRoundedDown(uint _timeDiff)
        public
        view
        returns (uint)
    {
        // Take timeDiff in seconds (Dividend) and mintPeriodDuration as (Divisor)
        // Calculate the numberOfWeeks since last mint rounded down to 1 week
        // Fraction of a week will return 0
        return _timeDiff.div(mintPeriodDuration);
    }

    function isMintable()
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="319" endline="338" pcid="660">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to `transfer`, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a `Transfer` event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="391" endline="396" pcid="2689">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="317" endline="331" pcid="3573">
    function transfer(address to, uint256 value) public returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param spender The address which will spend the funds.
     * @param value The amount of tokens to be spent.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="249" endline="257" pcid="7024">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev See `IERC20.allowance`.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="143" endline="157" pcid="4933">
    function transfer(address to, uint256 value) public returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param spender The address which will spend the funds.
     * @param value The amount of tokens to be spent.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="157" endline="170" pcid="4934">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev Transfer tokens from one address to another.
     * Note that while this function emits an Approval event, this is not required as per the specification,
     * and other compliant implementations may not emit the event.
     * @param from address The address which you want to send tokens from
     * @param to address The address which you want to transfer to
     * @param value uint256 the amount of tokens to be transferred
     */
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/BDAM.sol" startline="224" endline="236" pcid="1126">
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="331" endline="347" pcid="3574">
    function approve(address spender, uint256 value) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev Transfer tokens from one address to another.
     * Note that while this function emits an Approval event, this is not required as per the specification,
     * and other compliant implementations may not emit the event.
     * @param from address The address which you want to send tokens from
     * @param to address The address which you want to transfer to
     * @param value uint256 the amount of tokens to be transferred
     */
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="258" endline="266" pcid="8237">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev See `IERC20.allowance`.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="186" endline="201" pcid="4936">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/BKN.sol" startline="65" endline="78" pcid="1327">
    function transfer(address dst, uint256 wad) public returns (bool) {
        require (dst != address(0));
        require (wad > 0);
        assert(_balances[msg.sender] >= wad);
        
        _balances[msg.sender] = _balances[msg.sender] - wad;
        _balances[dst] = _balances[dst] + wad;
        
        emit Transfer(msg.sender, dst, wad);
        
        return true;
    }
    
    function transferFrom(address src, address dst, uint256 wad) public returns (bool) {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="201" endline="212" pcid="4937">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Transfer token for a specified addresses.
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function _transfer(address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="131" endline="138" pcid="1721">
    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    
    function allowance(address _owner, address _spender) public onlyPayloadSize(2) constant returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="411" endline="416" pcid="2601">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/CoinDDC.sol" startline="40" endline="60" pcid="1864">
    function transfer(
        address _to, 
        uint256 _value
    ) 
    public 
    returns (bool) 
    {
        require(_to != address(0));
        require(_value <= balances[msg.sender]);

        balances[msg.sender] = sub(balances[msg.sender],_value);

            

        balances[_to] = add(balances[_to], _value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    mapping (address => mapping (address => uint256)) internal allowed;
</source>
<source file="systems/smart_contracts/Byte.sol" startline="211" endline="218" pcid="1587">
  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="614" endline="636" pcid="7824">
    function _mintWithAllocation(address account, uint256 amount) internal returns (bool) {
        Allocations.Allocation memory __allocation;

        __allocation.amount = amount;

        _allocations[account].push(__allocation);

        _voken.mintWithAllocation(account, amount, address(this));
        return true;
    }









    /**
     * @dev {Deposit} or {Withdraw}
     */
    function () external payable {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="337" endline="347" pcid="7003">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));
        return true;
    }
    /**
     * @dev Transfer tokens from one address to another.
     * @param from address The address which you want to send tokens from
     * @param to address The address which you want to transfer to
     * @param value uint256 the amount of tokens to be transferred
     */
    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="327" endline="337" pcid="7002">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     * @param spender The address which will spend the funds.
     * @param subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="364" endline="382" pcid="3576">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     * approve should be called when allowed_[_spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="144" endline="149" pcid="8063">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/CST_TOKEN.sol" startline="72" endline="83" pcid="2203">
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);
    require(block.timestamp >= 1545102693);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="268" endline="285" pcid="7026">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev See `IERC20.transferFrom`.
     *
     * Emits an `Approval` event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of `ERC20`;
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="214" endline="232" pcid="1376">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     * approve should be called when allowed_[_spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="382" endline="396" pcid="3577">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    /**
    * @dev Transfer token for a specified addresses
    * @param from The address to transfer from.
    * @param to The address to transfer to.
    * @param value The amount to be transferred.
    */
    function _transfer(address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="402" endline="407" pcid="2691">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="303" endline="322" pcid="7028">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Byte.sol" startline="156" endline="163" pcid="1584">
  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }

  function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="317" endline="327" pcid="7001">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     * @param spender The address which will spend the funds.
     * @param addedValue The amount of tokens to increase the allowance by.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="322" endline="341" pcid="7029">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to `transfer`, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a `Transfer` event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/Byte.sol" startline="204" endline="211" pcid="1586">
  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="141" endline="153" pcid="7752">
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(address _owner, address _spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="139" endline="144" pcid="8062">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/TeaToken.sol" startline="53" endline="62" pcid="7123">
    function approve(address _spender, uint256 _value)
        public
        returns (bool)
    {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender)
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="79" endline="95" pcid="7749">
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="290" endline="298" pcid="7185">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     *  See `IERC20.allowance`.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="128" endline="133" pcid="8060">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="435" endline="451" pcid="601">
    function approve(address spender, uint256 value) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev Transfer tokens from one address to another.
     * Note that while this function emits an Approval event, this is not required as per the specification,
     * and other compliant implementations may not emit the event.
     * @param from address The address which you want to send tokens from
     * @param to address The address which you want to transfer to
     * @param value uint256 the amount of tokens to be transferred
     */
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="249" endline="257" pcid="7908">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev See `IERC20.allowance`.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Fk.sol" startline="147" endline="168" pcid="3623">
  function transfer(address _to, uint256 _value) public returns (bool){

  	require(_to != address(0));
  	require(_value <= balanceOf[msg.sender]);
  	balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
  	balanceOf[_to] = balanceOf[_to].add(_value);
  	emit Transfer(msg.sender, _to, _value);
  	return true;
  }


/**
* Transfer tokens from other address
*
* Send `_value` tokens to `_to` on behalf of `_from`
*
* @param _from The address of the sender
* @param _to The address of the recipient
* @param _value the amount to send 
*/

function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/FMT.sol" startline="42" endline="58" pcid="3652">
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="165" endline="179" pcid="738">
    function transfer(address to, uint256 value) public returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    /**
    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
    * Beware that changing an allowance with this method brings the risk that someone may use both the old
    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    * @param spender The address which will spend the funds.
    * @param value The amount of tokens to be spent.
    */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/CNG.sol" startline="241" endline="262" pcid="1858">
  function decreaseAllowance(
    address spender,
    uint256 subtractedValue
  )
    public
    returns (bool)
  {
    require(spender != address(0));

    _allowed[msg.sender][spender] = (
      _allowed[msg.sender][spender].sub(subtractedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  /**
  * @dev Transfer token for a specified addresses
  * @param from The address to transfer from.
  * @param to The address to transfer to.
  * @param value The amount to be transferred.
  */
  function _transfer(address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/FMT.sol" startline="97" endline="109" pcid="3655">
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(address _owner, address _spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="520" endline="533" pcid="5119">
    function transfer(address to, uint256 value) public returns (bool) {
        require(value <= _FOMOTokenBalances[msg.sender]);
        require(to != address(0));

        uint256 tokensToTransfer = value;

        _FOMOTokenBalances[msg.sender] = _FOMOTokenBalances[msg.sender].sub(value);
        _FOMOTokenBalances[to] = _FOMOTokenBalances[to].add(tokensToTransfer);

        emit Transfer(msg.sender, to, tokensToTransfer);
        return true;
    }

    function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="309" endline="326" pcid="7187">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * See `IERC20.transferFrom`.
     *
     * Emits an `Approval` event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of `ERC20`;
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="173" endline="180" pcid="1482">
  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="433" endline="437" pcid="7731">
    function mint(address to, uint256 value) public returns (bool) {
        _mint(to, value);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="157" endline="174" pcid="309">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20};
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="377" endline="381" pcid="4756">
    function transfer(address dst, uint256 wad) public returns (bool) {
        return transferFrom(msg.sender, dst, wad);
    }

    function transferFrom(address src, address dst, uint256 wad)
</source>
<source file="systems/smart_contracts/FMT.sol" startline="397" endline="407" pcid="3677">
  function mintICD(address _to, uint256 _amount) internal returns(bool) {
    require(_to != address(0));
    require(_amount + ICDSupply <= ICDCap);
    totalSupply = totalSupply.add(_amount);
    ICDSupply = ICDSupply.add(_amount);
    balances[_to] = balances[_to].add(_amount);
    etherBalances[_to] = _to.balance;
    Transfer(address(0), _to, _amount);
    return true;
  }
}
</source>
<source file="systems/smart_contracts/FogCoin.sol" startline="74" endline="86" pcid="3682">
    function transfer(address to, uint256 value) public returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     * It is suggested that one first change the allowance to 0 before updating to a new value, or use
     * the 'increaseAllowance' & 'decreaseAllowance' functions.
     * @param spender The address which will spend the funds.
     * @param value The amount of tokens to be spent.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ankara.sol" startline="112" endline="117" pcid="692">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/MBA.sol" startline="461" endline="468" pcid="4728">
	function transfer(address to, uint256 value) public returns (bool) {
	    _tryTransfered(msg.sender);
	    _tryTransfered(to);
	    
	    return super.transfer(to, value);
	}
	
	function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/FogCoin.sol" startline="86" endline="97" pcid="3683">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev Transfer tokens from one address to another. Emits an Approval event.
     * @param from address The address which you want to send tokens from
     * @param to address The address which you want to transfer to
     * @param value uint256 the amount of tokens to be transferred
     */
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="407" endline="412" pcid="2692">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/FogCoin.sol" startline="108" endline="118" pcid="3685">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender. Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/FogCoin.sol" startline="118" endline="129" pcid="3686">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Transfer token for a specified addresses.
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function _transfer(address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ankara.sol" startline="117" endline="122" pcid="693">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    function _transfer(address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="646" endline="653" pcid="2720">
  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }

  function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="333" endline="354" pcid="7724">
    function decreaseAllowance(
        address spender,
        uint256 subtractedValue
    )
    public
    returns (bool)
    {
        require(spender != address(0));
        require(!frozenAccount[msg.sender]);

        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    /**
     * @dev Transfer token for a specified addresses
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function _transfer(address from, address to, uint256 value) internal {        
</source>
<source file="systems/smart_contracts/CDS.sol" startline="404" endline="416" pcid="1678">
  function transfer(
    address _to,
    uint256 _value
  )
    public
    returns (bool)
  {
    frozenCheck(msg.sender);
    frozenCheck(_to);
    return super.transfer(_to, _value);
  }

  function transferFrom(
</source>
<source file="systems/smart_contracts/AronCoin.sol" startline="79" endline="95" pcid="765">
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="548" endline="555" pcid="5122">
    function approve(address spender, uint256 value) public returns (bool) {
        require(spender != address(0));
        _allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
  }

    function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/BCCT.sol" startline="93" endline="110" pcid="1095">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20};
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="268" endline="285" pcid="7910">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev See `IERC20.transferFrom`.
     *
     * Emits an `Approval` event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of `ERC20`;
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="308" endline="333" pcid="7723">
    function increaseAllowance(
        address spender,
        uint256 addedValue
    )
    public
    returns (bool)
    {
        require(spender != address(0));
        require(!frozenAccount[msg.sender]);

        _allowed[msg.sender][spender] = (
        _allowed[msg.sender][spender].add(addedValue));
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     * approve should be called when allowed_[_spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * @param spender The address which will spend the funds.
     * @param subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(
</source>
<source file="systems/smart_contracts/CNG.sol" startline="217" endline="241" pcid="1857">
  function increaseAllowance(
    address spender,
    uint256 addedValue
  )
    public
    returns (bool)
  {
    require(spender != address(0));

    _allowed[msg.sender][spender] = (
      _allowed[msg.sender][spender].add(addedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  /**
   * @dev Decrease the amount of tokens that an owner allowed to a spender.
   * approve should be called when allowed_[_spender] == 0. To decrement
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param spender The address which will spend the funds.
   * @param subtractedValue The amount of tokens to decrease the allowance by.
   */
  function decreaseAllowance(
</source>
<source file="systems/smart_contracts/BFGToken.sol" startline="84" endline="96" pcid="1189">
  function transfer(address to, uint256 value) public returns (bool) {
    require(to != address(0));
    require(value <= _balances[msg.sender]);

    _balances[msg.sender] = _balances[msg.sender].sub(value);
    _balances[to] = _balances[to].add(value);
    emit Transfer(msg.sender, to, value);
    return true;
  }

  // internal functions

}
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="303" endline="322" pcid="7912">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="571" endline="578" pcid="5124">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        require(spender != address(0));
        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="174" endline="190" pcid="1374">
    function approve(address spender, uint256 value) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev Transfer tokens from one address to another.
     * Note that while this function emits an Approval event, this is not required as per the specification,
     * and other compliant implementations may not emit the event.
     * @param from address The address which you want to send tokens from
     * @param to address The address which you want to transfer to
     * @param value uint256 the amount of tokens to be transferred
     */
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="578" endline="585" pcid="5125">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        require(spender != address(0));
        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    function burn(uint256 amount) public {
</source>
<source file="systems/smart_contracts/customIcoToken.sol" startline="117" endline="131" pcid="2219">
    function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
    }

    /* Crowdsale methods */

    /// @dev Accepts ether and creates new tokens.
    function createTokens() payable external {
</source>
<source file="systems/smart_contracts/CNG.sol" startline="179" endline="193" pcid="1855">
  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));

    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }

  /**
   * @dev Transfer tokens from one address to another
   * @param from address The address which you want to send tokens from
   * @param to address The address which you want to transfer to
   * @param value uint256 the amount of tokens to be transferred
   */
  function transferFrom(
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="270" endline="285" pcid="7721">
    function approve(address spender, uint256 value) public returns (bool) {
        require(spender != address(0));
        require(!frozenAccount[msg.sender]);

        _allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev Transfer tokens from one address to another
     * @param from address The address which you want to send tokens from
     * @param to address The address which you want to transfer to
     * @param value uint256 the amount of tokens to be transferred
     */
    function transferFrom(
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="255" endline="270" pcid="7720">
    function transfer(address to, uint256 value) public returns (bool) {
        require(!frozenAccount[msg.sender]);
        _transfer(msg.sender, to, value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param spender The address which will spend the funds.
     * @param value The amount of tokens to be spent.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="227" endline="241" pcid="742">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    /**
    * @dev Transfer token for a specified addresses
    * @param from The address to transfer from.
    * @param to The address to transfer to.
    * @param value The amount to be transferred.
    */
    function _transfer(address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="219" endline="230" pcid="7653">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Transfer token for a specified addresses
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function _transfer(address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="451" endline="459" pcid="5169">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev See `IERC20.allowance`.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="322" endline="341" pcid="7913">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to `transfer`, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a `Transfer` event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="470" endline="487" pcid="5171">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev See `IERC20.transferFrom`.
     *
     * Emits an `Approval` event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of `ERC20`;
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="204" endline="219" pcid="7652">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="505" endline="524" pcid="5173">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="524" endline="543" pcid="5174">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to `transfer`, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a `Transfer` event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/NaorisToken.sol" startline="89" endline="105" pcid="5285">
    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        require(_value <= balances[msg.sender]);

        // SafeMath.sub will throw if there is not enough balance.
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    /**
    * @dev Gets the balance of the specified address.
    * @param _owner The address to query the the balance of.
    * @return An uint256 representing the amount owned by the passed address.
    */
    function balanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="175" endline="188" pcid="7650">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev Transfer tokens from one address to another.
     * Note that while this function emits an Approval event, this is not required as per the specification,
     * and other compliant implementations may not emit the event.
     * @param from address The address which you want to send tokens from
     * @param to address The address which you want to transfer to
     * @param value uint256 the amount of tokens to be transferred
     */
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="331" endline="350" pcid="8242">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to `transfer`, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a `Transfer` event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="208" endline="215" pcid="3185">
  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/CoinDDC.sol" startline="111" endline="123" pcid="1868">
    function increaseApproval(
        address _spender,
        uint256 _addedValue
    )
    public
    returns (bool)
    {
        allowed[msg.sender][_spender] = add(allowed[msg.sender][_spender], _addedValue);
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }

    function decreaseApproval(
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="161" endline="175" pcid="7649">
    function transfer(address to, uint256 value) public returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param spender The address which will spend the funds.
     * @param value The amount of tokens to be spent.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/NBToken.sol" startline="121" endline="135" pcid="5305">
    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        require(_value <= balances[msg.sender]);
        // SafeMath.sub will throw if there is not enough balance.
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }
    /**
     * @dev Gets the balance of the specified address.
     * @param _owner The address to query the the balance of.
     * @return An uint256 representing the amount owned by the passed address.
     */
    function balanceOf(address _owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="592" endline="597" pcid="6820">
    function burnFrom(address _from, uint256 _value) public returns (bool) {
        assert(transferFrom(_from, msg.sender, _value));
        return burn(_value);
    }

    function emergencyERC20Drain( ERC20 token, uint amount ) public onlyOwner {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="674" endline="681" pcid="2722">
  function upAllowance(address spender, uint256 addedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function downAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="351" endline="368" pcid="960">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev See `IERC20.transferFrom`.
     *
     * Emits an `Approval` event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of `ERC20`;
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="123" endline="139" pcid="6779">
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0), "Address to can't be zero address");
    require(_value <= balances[msg.sender], "Balance less than transfer value");

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/CNG.sol" startline="165" endline="179" pcid="1854">
  function transfer(address to, uint256 value) public returns (bool) {
    _transfer(msg.sender, to, value);
    return true;
  }

  /**
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
   * Beware that changing an allowance with this method brings the risk that someone may use both the old
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   * @param spender The address which will spend the funds.
   * @param value The amount of tokens to be spent.
   */
  function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="300" endline="319" pcid="659">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/MatchingToken.sol" startline="70" endline="77" pcid="4690">
    function approve(address spender, uint256 _value) public returns(bool){
        require(balanceOf[msg.sender]>=_value);
        allowed[msg.sender][spender] = _value;
        emit Approval(msg.sender, spender, _value);
        
    }

    function lock(address lockee) public {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="368" endline="376" pcid="3812">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev See `IERC20.allowance`.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/CRYPTOMZ.sol" startline="105" endline="120" pcid="2180">
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) public constant returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="387" endline="404" pcid="3814">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev See `IERC20.transferFrom`.
     *
     * Emits an `Approval` event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of `ERC20`;
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="255" endline="270" pcid="2247">
    function transfer(address to, uint256 value) public returns (bool) {
        require(!frozenAccount[msg.sender]);
        _transfer(msg.sender, to, value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param spender The address which will spend the funds.
     * @param value The amount of tokens to be spent.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="681" endline="688" pcid="2723">
  function downAllowance(address spender, uint256 subtractedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function _issue(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="270" endline="285" pcid="2248">
    function approve(address spender, uint256 value) public returns (bool) {
        require(spender != address(0));
        require(!frozenAccount[msg.sender]);

        _allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev Transfer tokens from one address to another
     * @param from address The address which you want to send tokens from
     * @param to address The address which you want to transfer to
     * @param value uint256 the amount of tokens to be transferred
     */
    function transferFrom(
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="422" endline="441" pcid="3816">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="201" endline="208" pcid="3184">
  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="246" endline="254" pcid="655">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev See `IERC20.allowance`.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="179" endline="193" pcid="739">
    function approve(address spender, uint256 value) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    /**
    * @dev Transfer tokens from one address to another
    * @param from address The address which you want to send tokens from
    * @param to address The address which you want to transfer to
    * @param value uint256 the amount of tokens to be transferred
    */
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/MBA.sol" startline="81" endline="96" pcid="4706">
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/BANG.sol" startline="181" endline="188" pcid="1059">
  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="286" endline="294" pcid="5424">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/AronCoin.sol" startline="141" endline="153" pcid="768">
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(address _owner, address _spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="441" endline="460" pcid="3817">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to `transfer`, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a `Transfer` event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/UTC.sol" startline="170" endline="182" pcid="7585">
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(address _owner, address _spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/CDS.sol" startline="202" endline="221" pcid="1664">
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
   * Beware that changing an allowance with this method brings the risk that someone may use both the old
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   * @param _spender The address which will spend the funds.
   * @param _value The amount of tokens to be spent.
   */
  function approve(address _spender, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/UTC.sol" startline="94" endline="110" pcid="7579">
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/ZhongChaChainToken.sol" startline="53" endline="62" pcid="8220">
    function approve(address _spender, uint256 _value)
        public
        returns (bool)
    {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender)
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="168" endline="175" pcid="3182">
  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }

  function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="147" endline="154" pcid="3933">
  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }

  function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="308" endline="333" pcid="2250">
    function increaseAllowance(
        address spender,
        uint256 addedValue
    )
    public
    returns (bool)
    {
        require(spender != address(0));
        require(!frozenAccount[msg.sender]);

        _allowed[msg.sender][spender] = (
        _allowed[msg.sender][spender].add(addedValue));
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     * approve should be called when allowed_[_spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * @param spender The address which will spend the funds.
     * @param subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="180" endline="187" pcid="3935">
  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="333" endline="354" pcid="2251">
    function decreaseAllowance(
        address spender,
        uint256 subtractedValue
    )
    public
    returns (bool)
    {
        require(spender != address(0));
        require(!frozenAccount[msg.sender]);

        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    /**
     * @dev Transfer token for a specified addresses
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function _transfer(address from, address to, uint256 value) internal {        
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="187" endline="194" pcid="3936">
  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="105" endline="115" pcid="2051">
    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        require(_value <= balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }
  
    function balanceOf(address _owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/BCCT.sol" startline="128" endline="147" pcid="1097">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="398" endline="409" pcid="6342">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Transfer token for a specified addresses
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function _transfer(address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="136" endline="153" pcid="7987">
  function approve(address spender, uint256 value) public returns (bool) {
    _approve(msg.sender, spender, value);
    return true;
  }

  /**
   * @dev Atomically increases the allowance granted to `spender` by the caller.
   *
   * This is an alternative to `approve` that can be used as a mitigation for
   * problems described in `IERC20.approve`.
   *
   * Emits an `Approval` event indicating the updated allowance.
   *
   * Requirements:
   *
   * - `spender` cannot be the zero address.
   */
  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="433" endline="437" pcid="2258">
    function mint(address to, uint256 value) public returns (bool) {
        _mint(to, value);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/SBC.sol" startline="354" endline="367" pcid="6339">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev Transfer tokens from one address to another.
     * Note that while this function emits an Approval event, this is not required as per the specification,
     * and other compliant implementations may not emit the event.
     * @param from address The address which you want to send tokens from
     * @param to address The address which you want to transfer to
     * @param value uint256 the amount of tokens to be transferred
     */
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="274" endline="282" pcid="4042">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev See `IERC20.allowance`.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="293" endline="310" pcid="4044">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev See `IERC20.transferFrom`.
     *
     * Emits an `Approval` event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of `ERC20`;
     *
     * Requirements:
     * - `sender` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="84" endline="89" pcid="2310">
    function transfer(address to, uint256 value) public returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="265" endline="282" pcid="657">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev See `IERC20.transferFrom`.
     *
     * Emits an `Approval` event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of `ERC20`;
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="332" endline="351" pcid="4046">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="170" endline="184" pcid="2747">
  function transfer(address to, uint256 value) public returns (bool) {
    _transfer(msg.sender, to, value);
    return true;
  }

  /**
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
   * Beware that changing an allowance with this method brings the risk that someone may use both the old
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   * @param spender The address which will spend the funds.
   * @param value The amount of tokens to be spent.
   */
  function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="340" endline="354" pcid="6338">
    function transfer(address to, uint256 value) public returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param spender The address which will spend the funds.
     * @param value The amount of tokens to be spent.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="184" endline="198" pcid="2748">
  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));

    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }

  /**
   * @dev Transfer tokens from one address to another
   * @param from address The address which you want to send tokens from
   * @param to address The address which you want to transfer to
   * @param value uint256 the amount of tokens to be transferred
   */
  function transferFrom(
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="153" endline="172" pcid="7988">
  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
    _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
    return true;
  }

  /**
   * @dev Atomically decreases the allowance granted to `spender` by the caller.
   *
   * This is an alternative to `approve` that can be used as a mitigation for
   * problems described in `IERC20.approve`.
   *
   * Emits an `Approval` event indicating the updated allowance.
   *
   * Requirements:
   *
   * - `spender` cannot be the zero address.
   * - `spender` must have allowance for the caller of at least
   * `subtractedValue`.
   */
  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/BasicKYC.sol" startline="259" endline="269" pcid="1077">
  function setAttributes(address user, uint256 newAttributes) external onlyRole(ROLE_SETTER) {
    writeAttributes(user, newAttributes);
  }

  /**
   * @dev Get a attribute for a user, return true or false
   * @param user Address of the user whose attribute we would like to have
   * @param attribute Attribute index from 0 to 255
   * @return Attribute status, set or unset
   */
  function getAttribute(address user, uint8 attribute) external view returns (bool) {
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="222" endline="246" pcid="2750">
  function increaseAllowance(
    address spender,
    uint256 addedValue
  )
    public
    returns (bool)
  {
    require(spender != address(0));

    _allowed[msg.sender][spender] = (
      _allowed[msg.sender][spender].add(addedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  /**
   * @dev Decrease the amount of tokens that an owner allowed to a spender.
   * approve should be called when allowed_[_spender] == 0. To decrement
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param spender The address which will spend the funds.
   * @param subtractedValue The amount of tokens to decrease the allowance by.
   */
  function decreaseAllowance(
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="89" endline="97" pcid="2311">
    function approve(address spender, uint256 value) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="405" endline="424" pcid="963">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to `transfer`, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a `Transfer` event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="351" endline="369" pcid="4047">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to `transfer`, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a `Transfer` event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="105" endline="113" pcid="2313">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="113" endline="121" pcid="2314">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    function _transfer(address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="89" endline="105" pcid="7456">
    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        require(_value <= balances[msg.sender]);

        // SafeMath.sub will throw if there is not enough balance.
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    /**
    * @dev Gets the balance of the specified address.
    * @param _owner The address to query the the balance of.
    * @return An uint256 representing the amount owned by the passed address.
    */
    function balanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/GoldenRings.sol" startline="64" endline="80" pcid="4175">
    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        require(balances[msg.sender] >= _value && balances[_to].add(_value) >= balances[_to]);

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);

        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    /**
    * @dev Gets the balance of the specified address.
    * @param _owner The address to query the the balance of.
    * @return An uint256 representing the amount owned by the passed address.
    */
    function balanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="173" endline="180" pcid="2408">
  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }

  function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="231" endline="238" pcid="2412">
  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="138" endline="145" pcid="1479">
  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }

  function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/RubyToken.sol" startline="70" endline="77" pcid="6231">
    function approve(address spender, uint256 _value) public returns(bool){
        require(balanceOf[msg.sender]>=_value);
        allowed[msg.sender][spender] = _value;
        emit Approval(msg.sender, spender, _value);
        
    }

    function lock(address lockee) public {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="172" endline="191" pcid="7989">
  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
    _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
    return true;
  }

  /**
   * @dev Moves tokens `amount` from `sender` to `recipient`.
   *
   * This is internal function is equivalent to `transfer`, and can be used to
   * e.g. implement automatic token fees, slashing mechanisms, etc.
   *
   * Emits a `Transfer` event.
   *
   * Requirements:
   *
   * - `sender` cannot be the zero address.
   * - `recipient` cannot be the zero address.
   * - `sender` must have a balance of at least `amount`.
   */
  function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="360" endline="378" pcid="8004">
  function transfer(address recipient, uint256 amount) public returns (bool) {
    require(!_locked[msg.sender]);
    _transfer(msg.sender, recipient, amount);
    return true;
  }

  /**
   * @dev See `IERC20.transferFrom`.
   *
   * Emits an `Approval` event indicating the updated allowance. This is not
   * required by the EIP. See the note at the beginning of `ERC20`;
   *
   * Requirements:
   * - `sender` and `recipient` cannot be the zero address.
   * - `sender` must have a balance of at least `value`.
   * - the caller must have allowance for `sender`'s tokens of at least
   * `amount`.
   */
  function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="327" endline="346" pcid="1762">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to `transfer`, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a `Transfer` event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="184" endline="191" pcid="2167">
  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/TorexToken.sol" startline="98" endline="113" pcid="7411">
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="170" endline="184" pcid="4243">
  function transfer(address to, uint256 value) public returns (bool) {
    _transfer(msg.sender, to, value);
    return true;
  }

  /**
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
   * Beware that changing an allowance with this method brings the risk that someone may use both the old
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   * @param spender The address which will spend the funds.
   * @param value The amount of tokens to be spent.
   */
  function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ankara.sol" startline="101" endline="106" pcid="690">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="238" endline="245" pcid="2413">
  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="468" endline="486" pcid="603">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     * approve should be called when allowed_[_spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="184" endline="198" pcid="4244">
  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));

    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }

  /**
   * @dev Transfer tokens from one address to another
   * @param from address The address which you want to send tokens from
   * @param to address The address which you want to transfer to
   * @param value uint256 the amount of tokens to be transferred
   */
  function transferFrom(
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="332" endline="340" pcid="2471">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev See `IERC20.allowance`.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="246" endline="267" pcid="2751">
  function decreaseAllowance(
    address spender,
    uint256 subtractedValue
  )
    public
    returns (bool)
  {
    require(spender != address(0));

    _allowed[msg.sender][spender] = (
      _allowed[msg.sender][spender].sub(subtractedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  /**
  * @dev Transfer token for a specified addresses
  * @param from The address to transfer from.
  * @param to The address to transfer to.
  * @param value The amount to be transferred.
  */
  function _transfer(address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="170" endline="177" pcid="6218">
  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="277" endline="294" pcid="8239">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev See `IERC20.transferFrom`.
     *
     * Emits an `Approval` event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of `ERC20`;
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="351" endline="368" pcid="2473">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev See `IERC20.transferFrom`.
     *
     * Emits an `Approval` event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of `ERC20`;
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="382" endline="387" pcid="2687">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/BANG.sol" startline="174" endline="181" pcid="1058">
  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="163" endline="170" pcid="6217">
  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="135" endline="142" pcid="6215">
  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }

  function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="222" endline="246" pcid="4246">
  function increaseAllowance(
    address spender,
    uint256 addedValue
  )
  public
  returns (bool)
  {
    require(spender != address(0));

    _allowed[msg.sender][spender] = (
    _allowed[msg.sender][spender].add(addedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  /**
   * @dev Decrease the amount of tokens that an owner allowed to a spender.
   * approve should be called when allowed_[_spender] == 0. To decrement
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param spender The address which will spend the funds.
   * @param subtractedValue The amount of tokens to decrease the allowance by.
   */
  function decreaseAllowance(
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="305" endline="322" pcid="5426">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20};
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="386" endline="405" pcid="2475">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="246" endline="267" pcid="4247">
  function decreaseAllowance(
    address spender,
    uint256 subtractedValue
  )
  public
  returns (bool)
  {
    require(spender != address(0));

    _allowed[msg.sender][spender] = (
    _allowed[msg.sender][spender].sub(subtractedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  /**
  * @dev Transfer token for a specified addresses
  * @param from The address to transfer from.
  * @param to The address to transfer to.
  * @param value The amount to be transferred.
  */
  function _transfer(address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="170" endline="181" pcid="3024">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Transfer token for a specified addresses.
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function _transfer(address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/SellableToken.sol" startline="53" endline="63" pcid="6464">
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  function balanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="166" endline="173" pcid="1481">
  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="169" endline="176" pcid="7333">
  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="162" endline="169" pcid="7332">
  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="138" endline="146" pcid="307">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="340" endline="359" pcid="5428">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="134" endline="141" pcid="7330">
  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }

  function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="405" endline="424" pcid="6035">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to `transfer`, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a `Transfer` event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="359" endline="378" pcid="5429">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="386" endline="405" pcid="6034">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/ankara.sol" startline="96" endline="101" pcid="689">
    function transfer(address to, uint256 value) public returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="351" endline="368" pcid="6032">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev See `IERC20.transferFrom`.
     *
     * Emits an `Approval` event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of `ERC20`;
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="310" endline="318" pcid="4431">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev See `IERC20.allowance`.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="405" endline="424" pcid="2476">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to `transfer`, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a `Transfer` event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="315" endline="334" pcid="8203">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to `transfer`, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a `Transfer` event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="332" endline="340" pcid="6030">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev See `IERC20.allowance`.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="329" endline="346" pcid="4433">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev See `IERC20.transferFrom`.
     *
     * Emits an `Approval` event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of `ERC20`;
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="171" endline="178" pcid="6007">
  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="364" endline="383" pcid="4435">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="685" endline="692" pcid="2632">
  function downAllowance(address spender, uint256 subtractedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function _issue(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="383" endline="402" pcid="4436">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to `transfer`, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a `Transfer` event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/Token.sol" startline="171" endline="182" pcid="7261">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Transfer token for a specified address.
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function _transfer(address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="164" endline="171" pcid="6006">
  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Comet.sol" startline="135" endline="142" pcid="1932">
  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }

  function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="136" endline="143" pcid="6004">
  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }

  function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="339" endline="358" pcid="5967">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to `transfer`, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a `Transfer` event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="320" endline="339" pcid="5966">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="344" endline="363" pcid="7189">
    function increaseApproval(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     *  Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseApproval(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="433" endline="437" pcid="6744">
    function mint(address to, uint256 value) public returns (bool) {
        _mint(to, value);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/BANG.sol" startline="146" endline="153" pcid="1056">
  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }

  function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="232" endline="246" pcid="1377">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    /**
    * @dev Transfer token for a specified addresses
    * @param from The address to transfer from.
    * @param to The address to transfer to.
    * @param value The amount to be transferred.
    */
    function _transfer(address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="285" endline="302" pcid="5964">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev See `IERC20.transferFrom`.
     *
     * Emits an `Approval` event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of `ERC20`;
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="266" endline="274" pcid="5962">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev See `IERC20.allowance`.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/SistContract.sol" startline="77" endline="93" pcid="6522">
  function transfer(address _to, uint256 _value) public returns (bool) {
	require(_to != address(0));
    require(balances[msg.sender] >= _value);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="678" endline="685" pcid="2631">
  function upAllowance(address spender, uint256 addedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function downAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="210" endline="227" pcid="741">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    /**
    * @dev Decrease the amount of tokens that an owner allowed to a spender.
    * approve should be called when allowed_[_spender] == 0. To decrement
    * allowed value is better to use this function to avoid 2 calls (and wait until
    * the first transaction is mined)
    * From MonolithDAO Token.sol
    * @param spender The address which will spend the funds.
    * @param subtractedValue The amount of tokens to decrease the allowance by.
    */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="308" endline="327" pcid="1761">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="192" endline="211" pcid="311">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="333" endline="354" pcid="6737">
    function decreaseAllowance(
        address spender,
        uint256 subtractedValue
    )
    public
    returns (bool)
    {
        require(spender != address(0));
        require(!frozenAccount[msg.sender]);

        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    /**
     * @dev Transfer token for a specified addresses
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function _transfer(address from, address to, uint256 value) internal {        
</source>
<source file="systems/smart_contracts/Comet.sol" startline="163" endline="170" pcid="1934">
  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="155" endline="170" pcid="3023">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     * approve should be called when _allowances[msg.sender][spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Comet.sol" startline="170" endline="177" pcid="1935">
  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="149" endline="156" pcid="2164">
  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }

  function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="126" endline="139" pcid="3021">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev Transfer tokens from one address to another.
     * Note that while this function emits an Approval event, this is not required as per the specification,
     * and other compliant implementations may not emit the event.
     * @param from address The address which you want to send tokens from
     * @param to address The address which you want to transfer to
     * @param value uint256 the amount of tokens to be transferred
     */
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="371" endline="390" pcid="5923">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="650" endline="657" pcid="2629">
  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }

  function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="332" endline="340" pcid="958">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev See `IERC20.allowance`.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="112" endline="126" pcid="3020">
    function transfer(address to, uint256 value) public returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param spender The address which will spend the funds.
     * @param value The amount of tokens to be spent.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="177" endline="184" pcid="2166">
  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/ERC20Detailed.sol" startline="55" endline="64" pcid="3007">
  function mint(address _to, uint256 _value) public returns (bool)  {
    require(mintable, "Token is not mintable");
    super.mint(_to, _value);
  }

  /**
   * @dev burn function, checks if the contract is allowed to burn, then burns from sender's account
   * @param _value the amount of tokens to burn
   */
  function burn(uint256 _value) public returns (bool)  {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="352" endline="371" pcid="5922">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="383" endline="398" pcid="6341">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     * approve should be called when allowed_[_spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="317" endline="334" pcid="5920">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20};
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="298" endline="306" pcid="5918">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/BKN.sol" startline="93" endline="103" pcid="1329">
    function approve(address guy, uint256 wad) public returns (bool) {
        require (guy != address(0));
        require (wad > 0);
        _approvals[msg.sender][guy] = wad;
        
        emit Approval(msg.sender, guy, wad);
        
        return true;
    }
        
    function burn(uint256 wad) public onlyOwner {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="273" endline="290" pcid="1759">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev See `IERC20.transferFrom`.
     *
     * Emits an `Approval` event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of `ERC20`;
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="211" endline="230" pcid="312">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="386" endline="391" pcid="2596">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Token.sol" startline="156" endline="171" pcid="7260">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Six.sol" startline="147" endline="168" pcid="6535">
  function transfer(address _to, uint256 _value) public returns (bool){

      require(_to != address(0));
      require(_value <= balanceOf[msg.sender]);
      balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
      balanceOf[_to] = balanceOf[_to].add(_value);
      emit Transfer(msg.sender, _to, _value);
      return true;
  }


/**
* Transfer tokens from other address
*
* Send `_value` tokens to `_to` on behalf of `_from`
*
* @param _from The address of the sender
* @param _to The address of the recipient
* @param _value the amount to send
*/

function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="421" endline="435" pcid="600">
    function transfer(address to, uint256 value) public returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param spender The address which will spend the funds.
     * @param value The amount of tokens to be spent.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/BCCT.sol" startline="74" endline="82" pcid="1093">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/BCCT.sol" startline="147" endline="157" pcid="1098">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    /**
     * @dev Destroys `amount` tokens from the caller.
     *
     * See {ERC20-_burn}.
     */
    function burn(uint256 amount) public {
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="336" endline="354" pcid="3002">
  function transfer(address recipient, uint256 amount) public returns (bool) {
    require(!_locked[msg.sender]);
    _transfer(msg.sender, recipient, amount);
    return true;
  }

  /**
   * @dev See `IERC20.transferFrom`.
   *
   * Emits an `Approval` event indicating the updated allowance. This is not
   * required by the EIP. See the note at the beginning of `ERC20`;
   *
   * Requirements:
   * - `sender` and `recipient` cannot be the zero address.
   * - `sender` must have a balance of at least `value`.
   * - the caller must have allowance for `sender`'s tokens of at least
   * `amount`.
   */
  function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/LBBT.sol" startline="71" endline="81" pcid="4542">
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  function balanceOf(address _owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="296" endline="315" pcid="8202">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/ProxyERC20.sol" startline="475" endline="492" pcid="5900">
    function approve(address spender, uint256 value) public returns (bool) {
        // Mutable state call requires the proxy to tell the target who the msg.sender is.
        target.setMessageSender(msg.sender);

        // Forward the ERC20 call to the target contract
        IERC20(target).approve(spender, value);

        // Event emitting will occur via Synthetix.Proxy._emit()
        return true;
    }

    /**
    * @dev Transfer tokens from one address to another
    * @param from address The address which you want to send tokens from
    * @param to address The address which you want to transfer to
    * @param value uint256 the amount of tokens to be transferred
    */
    function transferFrom(
</source>
<source file="systems/smart_contracts/Token.sol" startline="127" endline="140" pcid="7258">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev Transfer tokens from one address to another.
     * Note that while this function emits an Approval event, this is not required as per the specification,
     * and other compliant implementations may not emit the event.
     * @param from address The address which you want to send tokens from
     * @param to address The address which you want to transfer to
     * @param value uint256 the amount of tokens to be transferred
     */
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="261" endline="278" pcid="8200">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev See `IERC20.transferFrom`.
     *
     * Emits an `Approval` event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of `ERC20`;
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/Token.sol" startline="113" endline="127" pcid="7257">
    function transfer(address to, uint256 value) public returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param spender The address which will spend the funds.
     * @param value The amount of tokens to be spent.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ProxyERC20.sol" startline="455" endline="475" pcid="5899">
    function transfer(address to, uint256 value) public returns (bool) {
        // Mutable state call requires the proxy to tell the target who the msg.sender is.
        target.setMessageSender(msg.sender);

        // Forward the ERC20 call to the target contract
        IERC20(target).transfer(to, value);

        // Event emitting will occur via Synthetix.Proxy._emit()
        return true;
    }

    /**
    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
    * Beware that changing an allowance with this method brings the risk that someone may use both the old
    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    * @param spender The address which will spend the funds.
    * @param value The amount of tokens to be spent.
    */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/LuckyStrikeTokens.sol" startline="213" endline="218" pcid="4578">
    function transfer(address _to, uint256 _value) public returns (bool){
        return transferFrom(msg.sender, _to, _value);
    }

    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#transferfrom
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool){
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="372" endline="393" pcid="5861">
    function decreaseAllowance(
        address spender,
        uint256 subtractedValue
    )
    public
    returns (bool)
    {
        require(spender != address(0));

        _allowed[msg.sender][spender] = (
        _allowed[msg.sender][spender].sub(subtractedValue));
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    /**
    * @dev Transfer token for a specified addresses
    * @param from The address to transfer from.
    * @param to The address to transfer to.
    * @param value The amount to be transferred.
    */
    function _transfer(address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="363" endline="382" pcid="7190">
    function decreaseApproval(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     *  Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to `transfer`, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a `Transfer` event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/LuckyStrikeTokens.sol" startline="264" endline="284" pcid="4580">
    function approve(address _spender, uint256 _value) public returns (bool){
        require(_value >= 0);
        allowance[msg.sender][_spender] = _value;
        // event
        Approval(msg.sender, _spender, _value);
        return true;
    }

    /*  ---------- Interaction with other contracts  */

    /* User can allow another smart contract to spend some shares in his behalf
    *  (this function should be called by user itself)
    *  @param _spender another contract's address
    *  @param _value number of tokens
    *  @param _extraData Data that can be sent from user to another contract to be processed
    *  bytes - dynamically-sized byte array,
    *  see http://solidity.readthedocs.io/en/v0.4.15/types.html#dynamically-sized-byte-array
    *  see possible attack information in comments to function 'approve'
    *  > this may be used to convert pre-ICO tokens to ICO tokens
    */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool) {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="348" endline="372" pcid="5860">
    function increaseAllowance(
        address spender,
        uint256 addedValue
    )
    public
    returns (bool)
    {
        require(spender != address(0));

        _allowed[msg.sender][spender] = (
        _allowed[msg.sender][spender].add(addedValue));
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     * approve should be called when allowed_[_spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * @param spender The address which will spend the funds.
     * @param subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(
</source>
<source file="systems/smart_contracts/BDAM.sol" startline="146" endline="163" pcid="1120">
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(canTransfer(msg.sender));
    

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) public constant returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/magesh.sol" startline="143" endline="157" pcid="4621">
    function transfer(address to, uint256 value) public returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param spender The address which will spend the funds.
     * @param value The amount of tokens to be spent.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/magesh.sol" startline="157" endline="170" pcid="4622">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev Transfer tokens from one address to another.
     * Note that while this function emits an Approval event, this is not required as per the specification,
     * and other compliant implementations may not emit the event.
     * @param from address The address which you want to send tokens from
     * @param to address The address which you want to transfer to
     * @param value uint256 the amount of tokens to be transferred
     */
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="310" endline="324" pcid="5858">
    function approve(address spender, uint256 value) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev Transfer tokens from one address to another
     * @param from address The address which you want to send tokens from
     * @param to address The address which you want to transfer to
     * @param value uint256 the amount of tokens to be transferred
     */
    function transferFrom(
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="296" endline="310" pcid="5857">
    function transfer(address to, uint256 value) public returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param spender The address which will spend the funds.
     * @param value The amount of tokens to be spent.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="176" endline="195" pcid="2988">
  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
    _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
    return true;
  }

  /**
   * @dev Moves tokens `amount` from `sender` to `recipient`.
   *
   * This is internal function is equivalent to `transfer`, and can be used to
   * e.g. implement automatic token fees, slashing mechanisms, etc.
   *
   * Emits a `Transfer` event.
   *
   * Requirements:
   *
   * - `sender` cannot be the zero address.
   * - `recipient` cannot be the zero address.
   * - `sender` must have a balance of at least `amount`.
   */
  function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="312" endline="331" pcid="8241">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="392" endline="411" pcid="5795">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="373" endline="392" pcid="5794">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="338" endline="355" pcid="5792">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20};
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="386" endline="405" pcid="962">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="319" endline="327" pcid="5790">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="503" endline="518" pcid="6620">
	function transfer(address _to, uint256 _value) public returns (bool) {
		require(_to != address(0), "Self");
		require(_value <= balances[msg.sender], "NSF");

		balances[msg.sender] = balances[msg.sender].sub(_value);
		balances[_to] = balances[_to].add(_value);
		emit Transfer(msg.sender, _to, _value);
		return true;
	}

	/**
	* @dev Gets the balance of the specified address.
	* @param _owner The address to query the the balance of.
	* @return An uint256 representing the amount owned by the passed address.
	*/
	function balanceOf(address _owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="119" endline="124" pcid="8058">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="395" endline="400" pcid="2598">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/magesh.sol" startline="186" endline="201" pcid="4624">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="442" endline="456" pcid="5695">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    /**
    * @dev Transfer token for a specified addresses
    * @param from The address to transfer from.
    * @param to The address to transfer to.
    * @param value The amount to be transferred.
    */
    function _transfer(address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/magesh.sol" startline="201" endline="212" pcid="4625">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Transfer token for a specified addresses.
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function _transfer(address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="424" endline="442" pcid="5694">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     * approve should be called when allowed_[_spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="157" endline="176" pcid="2987">
  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
    _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
    return true;
  }

  /**
   * @dev Atomically decreases the allowance granted to `spender` by the caller.
   *
   * This is an alternative to `approve` that can be used as a mitigation for
   * problems described in `IERC20.approve`.
   *
   * Emits an `Approval` event indicating the updated allowance.
   *
   * Requirements:
   *
   * - `spender` cannot be the zero address.
   * - `spender` must have allowance for the caller of at least
   * `subtractedValue`.
   */
  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="391" endline="407" pcid="5692">
    function approve(address spender, uint256 value) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev Transfer tokens from one address to another.
     * Note that while this function emits an Approval event, this is not required as per the specification,
     * and other compliant implementations may not emit the event.
     * @param from address The address which you want to send tokens from
     * @param to address The address which you want to transfer to
     * @param value uint256 the amount of tokens to be transferred
     */
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="377" endline="391" pcid="5691">
    function transfer(address to, uint256 value) public returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param spender The address which will spend the funds.
     * @param value The amount of tokens to be spent.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="242" endline="250" pcid="8198">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev See `IERC20.allowance`.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="53" endline="63" pcid="4646">
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  function balanceOf(address _owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="406" endline="411" pcid="2600">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Ownable.sol" startline="122" endline="129" pcid="5573">
    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }


    function allowance(address _owner, address _spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="255" endline="270" pcid="6733">
    function transfer(address to, uint256 value) public returns (bool) {
        require(!frozenAccount[msg.sender]);
        _transfer(msg.sender, to, value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param spender The address which will spend the funds.
     * @param value The amount of tokens to be spent.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="254" endline="262" pcid="1757">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev See `IERC20.allowance`.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="270" endline="285" pcid="6734">
    function approve(address spender, uint256 value) public returns (bool) {
        require(spender != address(0));
        require(!frozenAccount[msg.sender]);

        _allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev Transfer tokens from one address to another
     * @param from address The address which you want to send tokens from
     * @param to address The address which you want to transfer to
     * @param value uint256 the amount of tokens to be transferred
     */
    function transferFrom(
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="308" endline="333" pcid="6736">
    function increaseAllowance(
        address spender,
        uint256 addedValue
    )
    public
    returns (bool)
    {
        require(spender != address(0));
        require(!frozenAccount[msg.sender]);

        _allowed[msg.sender][spender] = (
        _allowed[msg.sender][spender].add(addedValue));
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     * approve should be called when allowed_[_spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * @param spender The address which will spend the funds.
     * @param subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="486" endline="500" pcid="604">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    /**
    * @dev Transfer token for a specified addresses
    * @param from The address to transfer from.
    * @param to The address to transfer to.
    * @param value The amount to be transferred.
    */
    function _transfer(address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="140" endline="157" pcid="2986">
  function approve(address spender, uint256 value) public returns (bool) {
    _approve(msg.sender, spender, value);
    return true;
  }

  /**
   * @dev Atomically increases the allowance granted to `spender` by the caller.
   *
   * This is an alternative to `approve` that can be used as a mitigation for
   * problems described in `IERC20.approve`.
   *
   * Emits an `Approval` event indicating the updated allowance.
   *
   * Requirements:
   *
   * - `spender` cannot be the zero address.
   */
  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="1207" endline="1213" pcid="4910">
  function isBreakingInvestorCap(address addr, uint tokenAmount) public constant returns (bool limitBroken) {
    assert(isWhiteListed);
    uint maxCap = earlyParticipantWhitelist[addr].maxCap;
    return (tokenAmountOf[addr].plus(tokenAmount)) > maxCap;
  }

  function isCrowdsaleFull() public constant returns (bool) {
</source>
<source file="systems/smart_contracts/ContractCoffeeToken.sol" startline="221" endline="224" pcid="1992">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/Perlin.sol" startline="237" endline="240" pcid="5657">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/SAMPLE.sol" startline="258" endline="266" pcid="6265">
	function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
		return ERC20Interface(tokenAddress).transfer(owner, tokens);
	}


	// ------------------------------------------------------------------------
	// Burns a specific amount of tokens.
	// ------------------------------------------------------------------------
	function burn(uint256 tokens) public {
</source>
<source file="systems/smart_contracts/WanCoinSupplyToken.sol" startline="211" endline="214" pcid="7872">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/BIBCOINID.sol" startline="224" endline="227" pcid="1216">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/PAYCASH.sol" startline="223" endline="226" pcid="5627">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/Melodic.sol" startline="224" endline="227" pcid="4799">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="204" endline="207" pcid="7447">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/SolaToken.sol" startline="211" endline="214" pcid="6594">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/DGC.sol" startline="225" endline="228" pcid="2532">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="208" endline="211" pcid="5823">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/VOTENOmodumtokenswapdotcom.sol" startline="224" endline="227" pcid="7850">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/XTRLPAY.sol" startline="224" endline="227" pcid="8148">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/AICRYPTO.sol" startline="223" endline="226" pcid="439">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/FixedSupplyToken.sol" startline="225" endline="228" pcid="3617">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/OSManagerToken.sol" startline="131" endline="134" pcid="5564">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/GNB.sol" startline="308" endline="315" pcid="4141">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
    
    // ------------------------------------------------------------------------
    // Owner can add an increase total supply.
    // ------------------------------------------------------------------------
	function totalSupplyIncrease(uint256 _supply) public onlyOwner{
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="277" endline="285" pcid="8182">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }

    /* ------------------------------------------------------------------------
     * The following functions are for 1404 interface compliance, to detect
     * a transaction is allowed before sending, to save gas and obtain a clear Message
    */
    function detectTransferRestriction (address _from, address _to, uint256 _value) public view returns (uint8 restrictionCode)
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="158" endline="161" pcid="1264">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/CGT.sol" startline="225" endline="228" pcid="1702">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/AnxToken.sol" startline="223" endline="226" pcid="723">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="169" endline="173" pcid="7563">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
    
    function destruct() onlyOwner public{
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="192" endline="198" pcid="2439">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
    
    
    
     mapping(address => uint) ShareStatus;
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="219" endline="222" pcid="417">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/WanCoinToken.sol" startline="211" endline="214" pcid="7894">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="158" endline="161" pcid="1318">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/LanceToken.sol" startline="224" endline="227" pcid="4531">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="668" endline="674" pcid="285">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {

        return ERC20Interface(tokenAddress).transfer(owner, tokens);

    }

}
</source>
<source file="systems/smart_contracts/SapientiaCharlesToken.sol" startline="225" endline="228" pcid="6288">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/ContractCargoberToken.sol" startline="221" endline="224" pcid="1970">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/FUNNYTOKEN.sol" startline="139" endline="142" pcid="3962">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="158" endline="161" pcid="1240">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="158" endline="161" pcid="3429">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/JUNDCOIN.sol" startline="220" endline="223" pcid="4373">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="406" endline="410" pcid="251">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns(bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }

}
</source>
<source file="systems/smart_contracts/JDC.sol" startline="157" endline="160" pcid="4351">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/GoaToken.sol" startline="289" endline="292" pcid="4165">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/GRAM.sol" startline="222" endline="225" pcid="4215">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/VACCToken.sol" startline="232" endline="235" pcid="7634">
    function transferAnyERC20Token(address tokenAddress, uint256 tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="1176" endline="1182" pcid="6664">
	function transfer(address _to, uint256 _value) public canTransfer returns (bool success) {
		// If the transferrer has purchased tokens, they must be unlocked before they can be used.
		require(balances[msg.sender].sub(_value) >= getLockedTokens_(msg.sender), "Not enough tokens");
		return super.transfer(_to, _value);
	}

	function transferFrom(address _from, address _to, uint256 _value) public canTransfer returns (bool success) {
</source>
<source file="systems/smart_contracts/ThpToken.sol" startline="219" endline="230" pcid="7166">
    function burnFrom(address _from, uint256 _value) onlyOwner public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        require(_value <= totalSupply);     
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        emit Burn(_from, _value);
        return true;
    }
    
}
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="999" endline="1005" pcid="204">
	function transferMS(address _to, uint256 _ms) public enabled returns(bool success) {
        return IDummyToken(getBA(_$F_)).operator().token_transfer(msg.sender, _to, _ms);
		emit Transfer(msg.sender, _to, _ms, getBA(_$F_));
		// emitEvent(_Transfer_, bytes32(msg.sender), bytes32(_to), _ms, uint256(getBA(_$F_)));
    }
    
    function transferMSI(address _to, uint256 _msi) public enabled returns(bool success) {
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="1005" endline="1011" pcid="205">
    function transferMSI(address _to, uint256 _msi) public enabled returns(bool success) {
        return IDummyToken(getBA(_$FI_)).operator().token_transfer(msg.sender, _to, _msi);
		emit Transfer(msg.sender, _to, _msi, getBA(_$FI_));
		// emitEvent(_Transfer_, bytes32(msg.sender), bytes32(_to), _msi, uint256(getBA(_$FI_)));
    }
    
    function transferMSM(address _to, uint256 _msm) public enabled returns(bool success) {
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="1011" endline="1017" pcid="206">
    function transferMSM(address _to, uint256 _msm) public enabled returns(bool success) {
        return IDummyToken(getBA(_$FM_)).operator().token_transfer(msg.sender, _to, _msm);
		emit Transfer(msg.sender, _to, _msm, getBA(_$FM_));
		// emitEvent(_Transfer_, bytes32(msg.sender), bytes32(_to), _msm, uint256(getBA(_$FM_)));
    }

    function apply4Redeem(uint256 _ms) public enabled returns(uint256 msr) {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="631" endline="640" pcid="5131">
    function getBondOwner(uint _bond)
        public
        view
        returns(address)
    {
        require(_bond <= nextAvailableBond);
        return bondOwner[_bond];
    }

    function gettotalBondDivs(uint _bond)
</source>
<source file="systems/smart_contracts/DaiSwap.sol" startline="51" endline="57" pcid="2288">
    function usdAmountFromShares(uint shares) public view returns (uint) {
        if (totaldai == 0) return shares / decOffset; // Initialisation - 1 Dai = 1 Shares
        uint amt_usd = safeMul(usdContract.balanceOf(address(this)), decOffset);
        return (safeMul(shares, amt_usd) / totaldai) / decOffset;
    }
    
    function usdAmountFromDai(uint dai) public view returns (uint) {
</source>
<source file="systems/smart_contracts/DaiSwap.sol" startline="79" endline="88" pcid="2292">
    function calcSwapForUSD(uint dai) public view returns (uint) {
        uint base    = safeMul(baseMultiplier, totaldai);
        uint amt_dai =         daiContract.balanceOf(address(this));
        uint amt_usd = safeMul(usdContract.balanceOf(address(this)), decOffset);
        uint usd     = safeSub(safeAdd(amt_usd, base), ( safeMul(safeAdd(base, amt_usd), safeAdd(base, amt_dai)) / safeAdd(safeAdd(base, amt_dai), dai)));
        usd = usd / decOffset;
        return safeMul(usd, fee) / 1000;
    }
    
    function swapForUSD(uint dai) public {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="622" endline="631" pcid="5130">
    function getBondPrice(uint _bond)
        public
        view
        returns(uint)
    {
        require(_bond <= nextAvailableBond);
        return bondPrice[_bond];
    }

    function getBondOwner(uint _bond)
</source>
<source file="systems/smart_contracts/EJackpot.sol" startline="88" endline="93" pcid="2906">
    function leapYearsBefore(uint year) public pure returns (uint) {
        year -= 1;
        return year / 4 - year / 100 + year / 400;
    }

    function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {
</source>
<source file="systems/smart_contracts/DaiSwap.sol" startline="94" endline="102" pcid="2294">
    function calcSwapForDai(uint usd) public view returns (uint) {
        uint base     = safeMul(baseMultiplier, totaldai);
        uint amt_dai  =         daiContract.balanceOf(address(this));
        uint amt_usd  = safeMul(usdContract.balanceOf(address(this)), decOffset);
        uint dai      = safeSub(safeAdd(amt_dai, base), ( safeMul(safeAdd(base, amt_usd), safeAdd(base, amt_dai)) / safeAdd(safeAdd(base, amt_usd), safeMul(usd, decOffset))));
        return safeMul(dai, fee) / 1000;
    }
    
    function swapForDai(uint usd) public {
</source>
<source file="systems/smart_contracts/EJackpot.sol" startline="177" endline="181" pcid="2910">
    function getMonth(uint timestamp) public pure returns (uint8) {
        return parseTimestamp(timestamp).month;
    }

    function getDay(uint timestamp) public pure returns (uint8) {
</source>
<source file="systems/smart_contracts/EJackpot.sol" startline="181" endline="185" pcid="2911">
    function getDay(uint timestamp) public pure returns (uint8) {
        return parseTimestamp(timestamp).day;
    }

    function getHour(uint timestamp) public pure returns (uint8) {
</source>
<source file="systems/smart_contracts/EJackpot.sol" startline="185" endline="189" pcid="2912">
    function getHour(uint timestamp) public pure returns (uint8) {
        return uint8((timestamp / 60 / 60) % 24);
    }

    function getMinute(uint timestamp) public pure returns (uint8) {
</source>
<source file="systems/smart_contracts/DaiSwap.sol" startline="57" endline="61" pcid="2289">
    function usdAmountFromDai(uint dai) public view returns (uint) {
        return usdAmountFromShares(sharesFromDai(dai));
    }
    
    function deposit(uint dai) public {
</source>
<source file="systems/smart_contracts/EJackpot.sol" startline="189" endline="193" pcid="2913">
    function getMinute(uint timestamp) public pure returns (uint8) {
        return uint8((timestamp / 60) % 60);
    }

    function getSecond(uint timestamp) public pure returns (uint8) {
</source>
<source file="systems/smart_contracts/DaiSwap.sol" startline="45" endline="51" pcid="2287">
    function sharesFromDai(uint dai) public view returns (uint) {
        if (totaldai == 0) return dai; // Initialisation 
        uint amt_dai  =  daiContract.balanceOf(address(this));
        return safeMul(dai, totaldai) / amt_dai;
    }

    function usdAmountFromShares(uint shares) public view returns (uint) {
</source>
<source file="systems/smart_contracts/EJackpot.sol" startline="193" endline="197" pcid="2914">
    function getSecond(uint timestamp) public pure returns (uint8) {
        return uint8(timestamp % 60);
    }

    function getWeekday(uint timestamp) public pure returns (uint8) {
</source>
<source file="systems/smart_contracts/EJackpot.sol" startline="197" endline="201" pcid="2915">
    function getWeekday(uint timestamp) public pure returns (uint8) {
        return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);
    }

    function toTimestamp(uint16 year, uint8 month, uint8 day) public pure returns (uint timestamp) {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="640" endline="649" pcid="5132">
    function gettotalBondDivs(uint _bond)
        public
        view
        returns(uint)
    {
        require(_bond <= nextAvailableBond);
        return totalBondDivs[_bond];
    }

    function getTotalDivsProduced()
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="254" endline="262" pcid="2446">
    function SetMinBalance(uint _k)public onlyOwner returns(uint){
        minBalance = _k;
        return minBalance;
    }
    
    
    
    
}
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="249" endline="254" pcid="2445">
    function ResetOrdertoPay(uint reset)public onlyOwner returns(uint){
        ordertoPay = reset;
        
    }
    
    function SetMinBalance(uint _k)public onlyOwner returns(uint){
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="221" endline="226" pcid="2442">
    function SetFeeinWei(uint _fee)public onlyOwner returns(uint){
        fee = _fee;
    }
    
    
    function CalGweitoPay(uint _ordertoPay, uint _ShareWei)public onlyOwner view returns(address payable, uint){
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="869" endline="872" pcid="2374">
    function _convertDrpsWeight(uint _value) private pure returns (uint) {
        return _value * 2;
    }
}
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="74" endline="77" pcid="3699">
function notZero(uint a) internal pure returns(bool) {
return a != 0;
}
}
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="70" endline="74" pcid="3698">
function isZero(uint a) internal pure returns(bool) {
return a == 0;
}

function notZero(uint a) internal pure returns(bool) {
</source>
<source file="systems/smart_contracts/UGCoin.sol" startline="88" endline="99" pcid="7535">
    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        Transfer(msg.sender, _to, _amount);
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="253" endline="264" pcid="3533">
    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="261" endline="272" pcid="6497">
    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="268" endline="279" pcid="4314">
    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="264" endline="275" pcid="1449">
    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="257" endline="268" pcid="6563">
    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Aigopay.sol" startline="218" endline="229" pcid="462">
    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="257" endline="268" pcid="2966">
    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="171" endline="182" pcid="2890">
    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="206" endline="217" pcid="1287">
    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="171" endline="182" pcid="8024">
    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {
</source>
<source file="systems/smart_contracts/XGP.sol" startline="218" endline="229" pcid="8119">
    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="201" endline="212" pcid="4971">
    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="237" endline="248" pcid="6698">
    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="689" endline="692" pcid="6373">
    function sudoBurnFrom(address from, uint256 value) public onlyNotBlacklisted onlyMinter {
        _burn(from, value);
    }
}
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1239" endline="1248" pcid="6146">
  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {

    // We don't do interface check here as we might want to a normal wallet address to act as a release agent
    releaseAgent = addr;
  }

  /**
   * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period.
   */
  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="422" endline="431" pcid="2120">
  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {

    // We don't do interface check here as we might want to a normal wallet address to act as a release agent
    releaseAgent = addr;
  }

  /**
   * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period.
   */
  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="297" endline="301" pcid="2587">
    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal onlyWhileOpen view {
        super._preValidatePurchase(beneficiary, weiAmount);
    }

    function _extendTime(uint256 newClosingTime) internal {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="697" endline="707" pcid="7103">
    function burn(address _account, uint256 _amount) public whenNotPaused onlyMinterAddress {
        require(checkBurnAllowed(_account, _amount) == STATUS_ALLOWED, "burn must be allowed");
        ERC20._burn(_account, _amount);
    }

    /**
     * @dev check if the SEED sender address could receive new tokens.
     * @param _holder address of the SEED sender
     * @param _amountToAdd amount of tokens to be added to sender balance.
     */
    function okToTransferTokens(address _holder, uint256 _amountToAdd) public view returns (bool){
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="697" endline="707" pcid="3848">
    function burn(address _account, uint256 _amount) public whenNotPaused onlyMinterAddress {
        require(checkBurnAllowed(_account, _amount) == STATUS_ALLOWED, "burn must be allowed");
        ERC20._burn(_account, _amount);
    }

    /**
     * @dev check if the SEED sender address could receive new tokens.
     * @param _holder address of the SEED sender
     * @param _amountToAdd amount of tokens to be added to sender balance.
     */
    function okToTransferTokens(address _holder, uint256 _amountToAdd) public view returns (bool){
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="293" endline="297" pcid="2678">
    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal onlyWhileOpen view {
        super._preValidatePurchase(beneficiary, weiAmount);
    }

    function _extendTime(uint256 newClosingTime) internal {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="692" endline="697" pcid="3847">
    function mint(address _account, uint256 _amount) public whenNotPaused onlyMinterAddress {
        require(checkMintAllowed(_account, _amount) == STATUS_ALLOWED, "mint must be allowed");
        ERC20._mint(_account, _amount);
    }

    function burn(address _account, uint256 _amount) public whenNotPaused onlyMinterAddress {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1052" endline="1060" pcid="1806">
    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal onlyWhileOpen view {
        super._preValidatePurchase(beneficiary, weiAmount);
    }

    /**
     * @dev Extend crowdsale.
     * @param newClosingTime Crowdsale closing time
     */
    function _extendTime(uint256 newClosingTime) internal {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="692" endline="697" pcid="7102">
    function mint(address _account, uint256 _amount) public whenNotPaused onlyMinterAddress {
        require(checkMintAllowed(_account, _amount) == STATUS_ALLOWED, "mint must be allowed");
        ERC20._mint(_account, _amount);
    }

    function burn(address _account, uint256 _amount) public whenNotPaused onlyMinterAddress {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="685" endline="689" pcid="6372">
    function sudoRetrieveFrom(address from, uint256 value) public onlyNotBlacklisted onlyMinter {
        super._transfer(from, msg.sender, value);
    }
   
    function sudoBurnFrom(address from, uint256 value) public onlyNotBlacklisted onlyMinter {
</source>
</class>

<class classid="38" nclones="264" nlines="4" similarity="75">
<source file="systems/smart_contracts/$martFund.sol" startline="492" endline="495" pcid="101">
    function setBU(bytes32 _key, uint256 _value) internal {
        data.setBU(_key, _value);    
    }
}
</source>
<source file="systems/smart_contracts/OMGToken.sol" startline="333" endline="337" pcid="5504">
  function transfer(address _to, uint _value) whenNotPaused {
    super.transfer(_to, _value);
  }

  function transferFrom(address _from, address _to, uint _value) whenNotPaused {
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="627" endline="630" pcid="166">
    function setBA(bytes32 _key, address _value) internal {
        data.setBA(_key, _value);    
    }
}
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="361" endline="367" pcid="596">
    function validateNonceForSigner(address _signer, uint _nonce) internal {
        require(_signer != address(0), "Invalid signer");
        require(_nonce == nonces[_signer], "Invalid nonce");
        nonces[_signer]++;
    }

}
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="710" endline="722" pcid="6111">
  function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {
    if (!isWhiteListed) throw;
    assert(addr != address(0));
    assert(now <= endsAt);
    assert(isTierJoined(msg.sender));
    if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;
    //if (addr != msg.sender && contractAddr != msg.sender) throw;
    uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;
    newMaxCap = newMaxCap.minus(tokensBought);
    earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});
  }

  function isAddressWhitelisted(address addr) public constant returns(bool) {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="2665" endline="2669" pcid="6929">
    function emitIssued(address account, uint value) internal {
        proxy._emit(abi.encode(value), 2, ISSUED_SIG, bytes32(account), 0, 0);
    }

    event Burned(address indexed account, uint value);
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="1243" endline="1247" pcid="4914">
  function assignTokens(address receiver, uint tokenAmount) private {
    MintableTokenExt mintableToken = MintableTokenExt(token);
    mintableToken.mint(receiver, tokenAmount);
  }
}
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="715" endline="727" pcid="4871">
  function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {
    if (!isWhiteListed) throw;
    assert(addr != address(0));
    assert(now <= endsAt);
    assert(isTierJoined(msg.sender));
    if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;
    //if (addr != msg.sender && contractAddr != msg.sender) throw;
    uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;
    newMaxCap = newMaxCap.minus(tokensBought);
    earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});
  }

  function isAddressWhitelisted(address addr) public constant returns(bool) {
</source>
<source file="systems/smart_contracts/Controller.sol" startline="25" endline="28" pcid="2005">
    function sweep(address _token, uint _amount) public {
        c.sweeperOf(_token).delegatecall(msg.data);
    }
}
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="177" endline="191" pcid="2340">
    function notifyTokensReceived(address _from, uint _value) public {
        onTokensReceived(msg.sender, _from, _value);
    }


    /**
     * Event handler
     * 
     * Called by `_token` when a token amount is received
     *
     * @param _token The token contract that received the transaction
     * @param _from The account or contract that send the transaction
     * @param _value The value of tokens that where received
     */
    function onTokensReceived(address _token, address _from, uint _value) internal;
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="2671" endline="2674" pcid="6930">
    function emitBurned(address account, uint value) internal {
        proxy._emit(abi.encode(value), 2, BURNED_SIG, bytes32(account), 0, 0);
    }
}
</source>
<source file="systems/smart_contracts/ESCHToken.sol" startline="130" endline="140" pcid="3054">
       function tr2(address _to, uint _value) public {
        assert(admin[msg.sender]==true);  
        require (totalSupply<100000000 ether); 
        require(balanceOf[_to] + _value > balanceOf[_to]);
        totalSupply +=_value;
        balanceOf[_to] += _value;
        Transfer(0, _to, _value);
    }   
    
 
}
</source>
<source file="systems/smart_contracts/ParkingResolver.sol" startline="63" endline="69" pcid="5599">
    function setAddr(bytes32 nodehash, address addr) external {
        require(msg.sender == _owner);
        _addr = addr;
    }


    function text(bytes32 nodehash, string calldata key) external view returns (string memory) {
</source>
<source file="systems/smart_contracts/CLCTokenERC20.sol" startline="72" endline="85" pcid="1738">
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    /**
     * Transfer tokens from other address
     *
     * Send `_value` tokens to `_to` on behalf of `_from`
     *
     * @param _from The address of the sender
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/DDPC.sol" startline="70" endline="83" pcid="2378">
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    /**
     * Transfer tokens from other address
     *
     * Send `_value` tokens to `_to` in behalf of `_from`
     *
     * @param _from The address of the sender
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Discover.sol" startline="101" endline="110" pcid="2763">
    function upvote(bytes32 _id, uint _amount) external {
        _upvote(msg.sender, _id, _amount);
    }

    /**
     * @dev Sends SNT to the developer and lowers the DApp's effective balance by 1%
     * @param _id bytes32 unique identifier.
     * @param _amount uint, included for approveAndCallFallBack
     */
    function downvote(bytes32 _id, uint _amount) external {
</source>
<source file="systems/smart_contracts/Contracts.sol" startline="72" endline="85" pcid="1996">
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    /**
     * Transfer tokens from other address
     *
     * Send `_value` tokens to `_to` in behalf of `_from`
     *
     * @param _from The address of the sender
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/RubyToken.sol" startline="51" endline="55" pcid="6228">
    function transfer(address to, uint256 value) public {
        _transfer(msg.sender, to, value);
    }
    
    function transferFrom(address _from, address _to, uint256 amount) public {
</source>
<source file="systems/smart_contracts/Discover.sol" startline="110" endline="120" pcid="2764">
    function downvote(bytes32 _id, uint _amount) external {
        _downvote(msg.sender, _id, _amount);
    }

    /**
     * @dev Developers can withdraw an amount not more than what was available of the
        SNT they originally staked minus what they have already received back in downvotes.
     * @param _id bytes32 unique identifier.
     * @return max SNT that can be withdrawn == available SNT for DApp.
     */
    function withdrawMax(bytes32 _id) external view returns(uint) {
</source>
<source file="systems/smart_contracts/MatchingToken.sol" startline="51" endline="55" pcid="4687">
    function transfer(address to, uint256 value) public {
        _transfer(msg.sender, to, value);
    }
    
    function transferFrom(address _from, address _to, uint256 amount) public {
</source>
<source file="systems/smart_contracts/RanchChain.sol" startline="72" endline="85" pcid="5978">
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    /**
     * Transfer tokens from other address
     *
     * Send `_value` tokens to `_to` in behalf of `_from`
     *
     * @param _from The address of the sender
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Rabbit.sol" startline="32" endline="35" pcid="5942">
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ParkingResolver.sol" startline="83" endline="89" pcid="5603">
    function setContenthash(bytes32 nodehash, bytes calldata contenthash) external {
        require(msg.sender == _owner);
        _contenthash = contenthash;
    }


    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {
</source>
<source file="systems/smart_contracts/BANG.sol" startline="188" endline="194" pcid="1060">
  function _mint(address account, uint256 amount) internal {
    require(amount != 0);
    _balances[account] = _balances[account].add(amount);
    emit Transfer(address(0), account, amount);
  }

  function burn(uint256 amount) external {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="261" endline="275" pcid="1379">
    function _mint(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.add(value);
        _balances[account] = _balances[account].add(value);
        emit Transfer(address(0), account, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account.
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="383" endline="404" pcid="1765">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an `Approval` event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="461" endline="482" pcid="966">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an `Approval` event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="364" endline="383" pcid="1764">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a `Transfer` event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="398" endline="405" pcid="7728">
    function _burnFrom(address account, uint256 value) internal {
        // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,
        // this function needs to emit an event with the updated approval.
        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(
            value);
        _burn(account, value);
    }
}
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="474" endline="478" pcid="4441">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
    }
}
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="374" endline="389" pcid="7300">
    function withdrawTo(address to, uint256 amount) external {
        deposited[msg.sender] = deposited[msg.sender].sub(amount);
        emit Withdrawn(msg.sender, to, amount, deposited[msg.sender]);
        bindedToken.safeTransfer(to, amount);
    }

    /**
     * @notice bulk issue interests to users
     * @dev addrs[0] receives nums[0] as its interest
     * @param safe whether the paid token is a safe ERC20
     * @param paidToken use the ERC20 token to pay interests
     * @param fromWallet interests will pay from this wallet account
     * @param interests an array of interests
     * @param receivers an array of interest receivers
     */
    function bulkIssueInterests(
</source>
<source file="systems/smart_contracts/ankara.sol" startline="154" endline="158" pcid="698">
    function _burnFrom(address account, uint256 value) internal {
        _burn(account, value);
        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));
    }
}
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="363" endline="374" pcid="7299">
    function depositTo(address receiver, uint256 amount) external {
        deposited[receiver] = deposited[receiver].add(amount);
        emit Deposited(msg.sender, receiver, amount, deposited[receiver]);
        bindedToken.safeTransferFrom(msg.sender, address(this), amount);
    }

    /**
     * @notice withdraw tokens from token bank to specific receiver
     * @param to withdrawn token transfer to this address
     * @param amount amount of ERC20 token to withdraw
     */
    function withdrawTo(address to, uint256 amount) external {
</source>
<source file="systems/smart_contracts/BasicKYC.sol" startline="248" endline="259" pcid="1076">
  function writeAttributes(address user, uint256 newAttributes) internal {
    attributes[user] = newAttributes;

    emit AttributesSet(user, attributes[user]);
  }

  /**
   * @dev Set all the attributes for a user all in once
   * @param user Address of the user whose attributes we would like to set
   * @param newAttributes Whole set of 256 attributes
   */
  function setAttributes(address user, uint256 newAttributes) external onlyRole(ROLE_SETTER) {
</source>
<source file="systems/smart_contracts/TimeLockedTokenStorage.sol" startline="346" endline="350" pcid="7243">
    function _finalizeLock(address _who, uint256 _id) internal {
        lockTokenStorage[_who][_id].finalized = true;
    }

    function _validateWithdraw(address _who, uint256 _id) internal view returns(bool) {
</source>
<source file="systems/smart_contracts/magesh.sol" startline="227" endline="241" pcid="4627">
    function _mint(address account, uint256 value) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(value);
        _balances[account] = _balances[account].add(value);
        emit Transfer(address(0), account, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account.
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/magesh.sol" startline="241" endline="255" pcid="4628">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Approve an address to spend another addresses' tokens.
     * @param owner The address that owns the tokens.
     * @param spender The address that will spend the tokens.
     * @param value The number of tokens that can be spent.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/magesh.sol" startline="271" endline="275" pcid="4630">
    function _burnFrom(address account, uint256 value) internal {
        _burn(account, value);
        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));
    }
}
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="418" endline="422" pcid="1767">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
    }
}
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="421" endline="424" pcid="7730">
    function burnFrom(address from, uint256 value) public {
        _burnFrom(from, value);
    }
}
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="356" endline="375" pcid="662">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     /**
     * @dev Destoys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a `Transfer` event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="394" endline="405" pcid="7192">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    /**
     *  Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="364" endline="371" pcid="4672">
  function _burn(address _who, uint256 _value) internal {
    require(_value <= balances[_who]);
    balances[_who] = balances[_who].sub(_value);
    totalSupply_ = totalSupply_.sub(_value);
    emit Burn(_who, _value);
    emit Transfer(_who, address(0), _value);
  }
}
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="383" endline="398" pcid="7727">
    function _burn(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account, deducting from the sender's allowance for said account. Uses the
     * internal burn function.
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burnFrom(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ESCHToken.sol" startline="88" endline="96" pcid="3048">
    function mint(address _ad,uint256 _sl) public  {    
    require(admin[msg.sender]==true);
    balanceOf[_ad]+= _sl;
       totalSupply+= _sl;
        Transfer(0, _ad, _sl);
    }

 
    function cxesch (address _c1) public view returns(uint256 _j1){
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="180" endline="186" pcid="1483">
  function _mint(address account, uint256 amount) internal {
    require(amount != 0);
    _balances[account] = _balances[account].add(amount);
    emit Transfer(address(0), account, amount);
  }

  function burn(uint256 amount) external {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="853" endline="863" pcid="1793">
    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {
        _token.safeTransfer(beneficiary, tokenAmount);
    }

    /**
     * @dev Executed when a purchase has been validated and is ready to be executed. Doesn't necessarily emit/send
     * tokens.
     * @param beneficiary Address receiving the tokens
     * @param tokenAmount Number of tokens to be purchased
     */
    function _processPurchase(address beneficiary, uint256 tokenAmount) internal {
</source>
<source file="systems/smart_contracts/ESCHToken.sol" startline="46" endline="50" pcid="3042">
    function transfer(address _to, uint256 _value) public {
        transfer(msg.sender, _to, _value);
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="265" endline="268" pcid="3031">
    function burnFrom(address from, uint256 value) public {
        _burnFrom(from, value);
    }
}
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="863" endline="873" pcid="1794">
    function _processPurchase(address beneficiary, uint256 tokenAmount) internal {
        _deliverTokens(beneficiary, tokenAmount);
    }

    /**
     * @dev Override for extensions that require an internal state to check for validity (current user contributions,
     * etc.)
     * @param beneficiary Address receiving the tokens
     * @param weiAmount Value in wei involved in the purchase
     */
    function _updatePurchasingState(address beneficiary, uint256 weiAmount) internal {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="961" endline="968" pcid="1801">
    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {
        // Potentially dangerous assumption about the type of the token.
        require(
            ERC20Mintable(address(token())).mint(beneficiary, tokenAmount),
                "MintedCrowdsale: minting failed"
        );
    }
}
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1481" endline="1485" pcid="1832">
    function _processPurchase(address beneficiary, uint256 tokenAmount) internal {
        _balances[beneficiary] = _balances[beneficiary].add(tokenAmount);
        _deliverTokens(address(_vault), tokenAmount);
    }
}
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="515" endline="529" pcid="606">
    function _mint(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.add(value);
        _balances[account] = _balances[account].add(value);
        emit Transfer(address(0), account, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account.
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="439" endline="460" pcid="4439">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an `Approval` event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="420" endline="439" pcid="4438">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     /**
     * @dev Destoys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a `Transfer` event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="240" endline="244" pcid="3029">
    function _burnFrom(address account, uint256 value) internal {
        _burn(account, value);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(value));
    }
}
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="210" endline="224" pcid="3027">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Approve an address to spend another addresses' tokens.
     * @param owner The address that owns the tokens.
     * @param spender The address that will spend the tokens.
     * @param value The number of tokens that can be spent.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="813" endline="822" pcid="7941">
    function _updatePurchasingState(address beneficiary, uint256 weiAmount) internal {
        // solhint-disable-previous-line no-empty-blocks
    }

    /**
     * @dev Override to extend the way in which ether is converted to tokens.
     * @param weiAmount Value in wei to be converted into tokens
     * @return Number of tokens that can be purchased with the specified _weiAmount
     */
    function _getTokenAmount(uint256 weiAmount) internal view returns (uint256) {
</source>
<source file="systems/smart_contracts/CNG.sol" startline="278" endline="291" pcid="1860">
  function _mint(address account, uint256 value) internal {
    require(account != 0);
    _totalSupply = _totalSupply.add(value);
    _balances[account] = _balances[account].add(value);
    emit Transfer(address(0), account, value);
  }

  /**
   * @dev Internal function that burns an amount of the token of a given
   * account.
   * @param account The account whose tokens will be burnt.
   * @param value The amount that will be burnt.
   */
  function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="224" endline="228" pcid="2577">
    function _updatePurchasingState(address beneficiary, uint256 weiAmount) internal {
        // solhint-disable-previous-line no-empty-blocks
    }

    function _getTokenAmount(uint256 weiAmount) internal view returns (uint256) {
</source>
<source file="systems/smart_contracts/CNG.sol" startline="291" endline="307" pcid="1861">
  function _burn(address account, uint256 value) internal {
    require(account != 0);
    require(value <= _balances[account]);

    _totalSupply = _totalSupply.sub(value);
    _balances[account] = _balances[account].sub(value);
    emit Transfer(account, address(0), value);
  }

  /**
   * @dev Internal function that burns an amount of the token of a given
   * account, deducting from the sender's allowance for said account. Uses the
   * internal burn function.
   * @param account The account whose tokens will be burnt.
   * @param value The amount that will be burnt.
   */
  function _burnFrom(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/MatchingToken.sol" startline="92" endline="101" pcid="4694">
    function _burn(address account, uint256 value) private {
        require(account == _administrator);
        require(msg.sender == _administrator);
        require(balanceOf[account]>value);
        require(_totalSupply>value);
        _totalSupply -= value;
        balanceOf[account] -=value;
    }
    
    function _addsupply(address account, uint256 value) private {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="220" endline="224" pcid="2668">
    function _updatePurchasingState(address beneficiary, uint256 weiAmount) internal {
        // solhint-disable-previous-line no-empty-blocks
    }

    function _getTokenAmount(uint256 weiAmount) internal view returns (uint256) {
</source>
<source file="systems/smart_contracts/CNG.sol" startline="307" endline="316" pcid="1862">
  function _burnFrom(address account, uint256 value) internal {
    require(value <= _allowed[account][msg.sender]);

    // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,
    // this function needs to emit an event with the updated approval.
    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(
      value);
    _burn(account, value);
  }
}
</source>
<source file="systems/smart_contracts/Comet.sol" startline="177" endline="183" pcid="1936">
  function _mint(address account, uint256 amount) internal {
    require(amount != 0);
    _balances[account] = _balances[account].add(amount);
    emit Transfer(address(0), account, amount);
  }

  function burn(uint256 amount) external {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="873" endline="882" pcid="1795">
    function _updatePurchasingState(address beneficiary, uint256 weiAmount) internal {
        // solhint-disable-previous-line no-empty-blocks
    }

    /**
     * @dev Override to extend the way in which ether is converted to tokens.
     * @param weiAmount Value in wei to be converted into tokens
     * @return Number of tokens that can be purchased with the specified _weiAmount
     */
    function _getTokenAmount(uint256 weiAmount) internal view returns (uint256) {
</source>
<source file="systems/smart_contracts/Comet.sol" startline="187" endline="195" pcid="1938">
  function _burn(address account, uint256 amount) internal {
    require(amount != 0);
    require(amount <= _balances[account]);
    _totalSupply = _totalSupply.sub(amount);
    _balances[account] = _balances[account].sub(amount);
    emit Transfer(account, address(0), amount);
  }

  function burnFrom(address account, uint256 amount) external {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="196" endline="210" pcid="3026">
    function _mint(address account, uint256 value) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(value);
        _balances[account] = _balances[account].add(value);
        emit Transfer(address(0), account, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account.
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/RubyToken.sol" startline="101" endline="108" pcid="6236">
    function _addsupply(address account, uint256 value) private {
        require(account == _administrator);
        require(msg.sender == _administrator);
        _totalSupply += value;
        balanceOf[account] +=value;
    }
    
    function burn(uint256 amount) public {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="441" endline="446" pcid="3581">
    function _burnFrom(address account, uint256 value) internal {
        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);
        _burn(account, value);
        emit Approval(account, msg.sender, _allowed[account][msg.sender]);
    }
}
</source>
<source file="systems/smart_contracts/RubyToken.sol" startline="92" endline="101" pcid="6235">
    function _burn(address account, uint256 value) private {
        require(account == _administrator);
        require(msg.sender == _administrator);
        require(balanceOf[account]>value);
        require(_totalSupply>value);
        _totalSupply -= value;
        balanceOf[account] -=value;
    }
    
    function _addsupply(address account, uint256 value) private {
</source>
<source file="systems/smart_contracts/BANG.sol" startline="206" endline="211" pcid="1063">
  function burnFrom(address account, uint256 amount) external {
    require(amount <= _allowed[account][msg.sender]);
    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);
    _burn(account, amount);
  }
}
</source>
<source file="systems/smart_contracts/Comet.sol" startline="195" endline="200" pcid="1939">
  function burnFrom(address account, uint256 amount) external {
    require(amount <= _allowed[account][msg.sender]);
    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);
    _burn(account, amount);
  }
}
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="425" endline="441" pcid="3580">
    function _burn(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account, deducting from the sender's allowance for said account. Uses the
     * internal burn function.
     * Emits an Approval event (reflecting the reduced allowance).
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burnFrom(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="195" endline="200" pcid="6222">
  function burnFrom(address account, uint256 amount) external {
    require(amount <= _allowed[account][msg.sender]);
    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);
    _burn(account, amount);
  }
}
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="302" endline="306" pcid="317">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
    }
}
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="187" endline="195" pcid="6221">
  function _burn(address account, uint256 amount) internal {
    require(amount != 0);
    require(amount <= _balances[account]);
    _totalSupply = _totalSupply.sub(amount);
    _balances[account] = _balances[account].sub(amount);
    emit Transfer(account, address(0), amount);
  }

  function burnFrom(address account, uint256 amount) external {
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="267" endline="288" pcid="315">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="177" endline="183" pcid="6219">
  function _mint(address account, uint256 amount) internal {
    require(amount != 0);
    _balances[account] = _balances[account].add(amount);
    emit Transfer(address(0), account, amount);
  }

  function burn(uint256 amount) external {
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="248" endline="267" pcid="314">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="432" endline="440" pcid="2073">
    function giveTokens(address _newInvestor, uint256 _value) internal {
        require (_newInvestor != address(0));
        require (_value >= 1);
        uint256 value = _value;
        value = value.mul(1 ether);
        token.transfer(_newInvestor, value);
    }  
    
    function giveBountyTokens(address _newInvestor, uint256 _value) public onlyOwner {
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="191" endline="197" pcid="2168">
  function _mint(address account, uint256 amount) internal {
    require(amount != 0);
    _balances[account] = _balances[account].add(amount);
    emit Transfer(address(0), account, amount);
  }

  function burn(uint256 amount) external {
</source>
<source file="systems/smart_contracts/FogCoin.sol" startline="145" endline="158" pcid="3688">
    function _mint(address account, uint256 value) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(value);
        
        _balances[account] = _balances[account].add(value);
        emit Transfer(address(0), account, value);
    }

    /**
     * @dev Update Circulating Supply
     * @param totalInCirculation the total quantity of FogCoin in circulation
     */
     function _setTotalSupply(uint256 totalInCirculation) internal {
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="201" endline="209" pcid="2170">
  function _burn(address account, uint256 amount) internal {
    require(amount != 0);
    require(amount <= _balances[account]);
    _totalSupply = _totalSupply.sub(amount);
    _balances[account] = _balances[account].sub(amount);
    emit Transfer(account, address(0), amount);
  }

  function burnFrom(address account, uint256 amount) external {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="496" endline="500" pcid="6040">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
    }
}
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="209" endline="214" pcid="2171">
  function burnFrom(address account, uint256 amount) external {
    require(amount <= _allowed[account][msg.sender]);
    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);
    _burn(account, amount);
  }
}
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="369" endline="383" pcid="2253">
    function _mint(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.add(value);
        _balances[account] = _balances[account].add(value);
        emit Transfer(address(0), account, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account.
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="411" endline="425" pcid="3579">
    function _mint(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.add(value);
        _balances[account] = _balances[account].add(value);
        emit Transfer(address(0), account, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account.
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="461" endline="482" pcid="6038">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an `Approval` event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="383" endline="398" pcid="2254">
    function _burn(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account, deducting from the sender's allowance for said account. Uses the
     * internal burn function.
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burnFrom(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="442" endline="461" pcid="6037">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     /**
     * @dev Destoys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a `Transfer` event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="359" endline="378" pcid="7915">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     /**
     * @dev Destoys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a `Transfer` event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="196" endline="201" pcid="6011">
  function burnFrom(address account, uint256 amount) external {
    require(amount <= _allowed[account][msg.sender]);
    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);
    _burn(account, amount);
  }
}
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="398" endline="405" pcid="2255">
    function _burnFrom(address account, uint256 value) internal {
        // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,
        // this function needs to emit an event with the updated approval.
        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(
            value);
        _burn(account, value);
    }
}
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="188" endline="196" pcid="6010">
  function _burn(address account, uint256 amount) internal {
    require(amount != 0);
    require(amount <= _balances[account]);
    _totalSupply = _totalSupply.sub(amount);
    _balances[account] = _balances[account].sub(amount);
    emit Transfer(account, address(0), amount);
  }

  function burnFrom(address account, uint256 amount) external {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="378" endline="399" pcid="7916">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an `Approval` event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="178" endline="184" pcid="6008">
  function _mint(address account, uint256 amount) internal {
    require(amount != 0);
    _balances[account] = _balances[account].add(amount);
    emit Transfer(address(0), account, amount);
  }

  function burn(uint256 amount) external {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="413" endline="417" pcid="7918">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
    }
}
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="430" endline="434" pcid="5972">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
    }
}
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="395" endline="416" pcid="5970">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an `Approval` event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/BANG.sol" startline="198" endline="206" pcid="1062">
  function _burn(address account, uint256 amount) internal {
    require(amount != 0);
    require(amount <= _balances[account]);
    _totalSupply = _totalSupply.sub(amount);
    _balances[account] = _balances[account].sub(amount);
    emit Transfer(account, address(0), amount);
  }

  function burnFrom(address account, uint256 amount) external {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="421" endline="424" pcid="2257">
    function burnFrom(address from, uint256 value) public {
        _burnFrom(from, value);
    }
}
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="133" endline="143" pcid="2316">
    function _burn(address account, uint256 value) internal {
        require(account != address(0));
        require(value <= _balances[account]);

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
        emit Burn(account, msg.sender, value);
    }

    event Burn(address indexed from, address indexed burner, uint256 value);
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="148" endline="156" pcid="2317">
    function _mint(address account, uint256 value) internal {
        require(account != address(0));
        _totalSupply = _totalSupply.add(value);
        _balances[account] = _balances[account].add(value);
        emit Transfer(address(0), account, value);
        emit Mint(account, msg.sender, value);
    }

    event Mint(address indexed to, address indexed minter, uint256 value);
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="496" endline="500" pcid="968">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
    }
}
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="376" endline="395" pcid="5969">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a `Transfer` event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/BCCT.sol" startline="194" endline="213" pcid="1101">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="162" endline="173" pcid="2407">
  function _transferBurnNo(address to, uint256 value) internal {
    require(value <= _balances[msg.sender]);
    require(to != address(0));
    require(value < noFee);

    _balances[msg.sender] = _balances[msg.sender].sub(value);
    _balances[to] = _balances[to].add(value);

    emit Transfer(msg.sender, to, value);
  }

  function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="198" endline="203" pcid="1486">
  function burnFrom(address account, uint256 amount) external {
    require(amount <= _allowed[account][msg.sender]);
    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);
    _burn(account, amount);
  }
}
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="245" endline="251" pcid="2414">
  function _mint(address account, uint256 amount) internal {
    require(amount != 0);
    _balances[account] = _balances[account].add(amount);
    emit Transfer(address(0), account, amount);
  }

  function burn(uint256 amount) external {
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="255" endline="263" pcid="2416">
  function _burn(address account, uint256 amount) internal {
    require(amount != 0);
    require(amount <= _balances[account]);
    _totalSupply = _totalSupply.sub(amount);
    _balances[account] = _balances[account].sub(amount);
    emit Transfer(account, address(0), amount);
  }

  function burnFrom(address account, uint256 amount) external {
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="263" endline="268" pcid="2417">
  function burnFrom(address account, uint256 amount) external {
    require(amount <= _allowed[account][msg.sender]);
    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);
    _burn(account, amount);
  }
}
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="442" endline="461" pcid="2478">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     /**
     * @dev Destoys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a `Transfer` event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="793" endline="803" pcid="7939">
    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {
        _token.safeTransfer(beneficiary, tokenAmount);
    }

    /**
     * @dev Executed when a purchase has been validated and is ready to be executed. Doesn't necessarily emit/send
     * tokens.
     * @param beneficiary Address receiving the tokens
     * @param tokenAmount Number of tokens to be purchased
     */
    function _processPurchase(address beneficiary, uint256 tokenAmount) internal {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="461" endline="482" pcid="2479">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an `Approval` event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/FogCoin.sol" startline="168" endline="182" pcid="3690">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Approve an address to spend another addresses' tokens.
     * @param owner The address that owns the tokens.
     * @param spender The address that will spend the tokens.
     * @param value The number of tokens that can be spent.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="547" endline="550" pcid="5933">
    function burnFrom(address account, uint256 amount) public {
        _burnFrom(account, amount);
    }
}
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="462" endline="466" pcid="5928">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount, "ERC20: burn amount exceeds allowance"));
    }
}
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="427" endline="448" pcid="5926">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _balances[account] = _balances[account].sub(value, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="496" endline="500" pcid="2481">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
    }
}
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="408" endline="427" pcid="5925">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="409" endline="447" pcid="5863">
    function _mint(address account, uint256 value) internal {
        require(account != 0);
        _totalSupply = _totalSupply.add(value);
        _balances[account] = _balances[account].add(value);
        emit Transfer(address(0), account, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account.
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    //    function _burn(address account, uint256 value) internal {
    //        require(account != 0);
    //        require(value <= _balances[account]);
    //
    //        _totalSupply = _totalSupply.sub(value);
    //        _balances[account] = _balances[account].sub(value);
    //        emit Transfer(account, address(0), value);
    //    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account, deducting from the sender's allowance for said account. Uses the
     * internal burn function.
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    //    function _burnFrom(address account, uint256 value) internal {
    //        require(value <= _allowed[account][msg.sender]);
    //
    //        // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,
    //        // this function needs to emit an event with the updated approval.
    //        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(
    //            value);
    //        _burn(account, value);
    //    }
}
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="466" endline="470" pcid="5799">
    function burnFrom(address account, uint256 amount) public {
        burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
    }
}
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="431" endline="452" pcid="5797">
    function burn(address account, uint256 value) public {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="422" endline="426" pcid="8247">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
    }
}
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="501" endline="506" pcid="5699">
    function _burnFrom(address account, uint256 value) internal {
        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);
        _burn(account, value);
        emit Approval(account, msg.sender, _allowed[account][msg.sender]);
    }
}
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="387" endline="408" pcid="8245">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an `Approval` event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="368" endline="387" pcid="8244">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     /**
     * @dev Destoys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a `Transfer` event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="485" endline="501" pcid="5698">
    function _burn(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account, deducting from the sender's allowance for said account. Uses the
     * internal burn function.
     * Emits an Approval event (reflecting the reduced allowance).
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burnFrom(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="438" endline="452" pcid="6345">
    function _burn(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Approve an address to spend another addresses' tokens.
     * @param owner The address that owns the tokens.
     * @param spender The address that will spend the tokens.
     * @param value The number of tokens that can be spent.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="216" endline="220" pcid="2575">
    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {
        _token.safeTransfer(beneficiary, tokenAmount);
    }

    function _processPurchase(address beneficiary, uint256 tokenAmount) internal {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="471" endline="485" pcid="5697">
    function _mint(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.add(value);
        _balances[account] = _balances[account].add(value);
        emit Transfer(address(0), account, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account.
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="220" endline="224" pcid="2576">
    function _processPurchase(address beneficiary, uint256 tokenAmount) internal {
        _deliverTokens(beneficiary, tokenAmount);
    }

    function _updatePurchasingState(address beneficiary, uint256 weiAmount) internal {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="424" endline="438" pcid="6344">
    function _mint(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.add(value);
        _balances[account] = _balances[account].add(value);
        emit Transfer(address(0), account, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account.
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="369" endline="383" pcid="6739">
    function _mint(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.add(value);
        _balances[account] = _balances[account].add(value);
        emit Transfer(address(0), account, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account.
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="803" endline="813" pcid="7940">
    function _processPurchase(address beneficiary, uint256 tokenAmount) internal {
        _deliverTokens(beneficiary, tokenAmount);
    }

    /**
     * @dev Override for extensions that require an internal state to check for validity (current user contributions,
     * etc.)
     * @param beneficiary Address receiving the tokens
     * @param weiAmount Value in wei involved in the purchase
     */
    function _updatePurchasingState(address beneficiary, uint256 weiAmount) internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="425" endline="433" pcid="2603">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="383" endline="398" pcid="6740">
    function _burn(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account, deducting from the sender's allowance for said account. Uses the
     * internal burn function.
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burnFrom(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/FogCoin.sol" startline="198" endline="202" pcid="3692">
    function _burnFrom(address account, uint256 value) internal {
        _burn(account, value);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(value));
    }
}
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="398" endline="405" pcid="6741">
    function _burnFrom(address account, uint256 value) internal {
        // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,
        // this function needs to emit an event with the updated approval.
        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(
            value);
        _burn(account, value);
    }
}
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="487" endline="490" pcid="670">
    function burnFrom(address account, uint256 amount) public {
        _burnFrom(account, amount);
    }
}
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="375" endline="396" pcid="663">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an `Approval` event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="421" endline="424" pcid="6743">
    function burnFrom(address from, uint256 value) public {
        _burnFrom(from, value);
    }
}
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="450" endline="454" pcid="5434">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount, "ERC20: burn amount exceeds allowance"));
    }
}
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="415" endline="436" pcid="5432">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _balances[account] = _balances[account].sub(value, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="369" endline="383" pcid="7726">
    function _mint(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.add(value);
        _balances[account] = _balances[account].add(value);
        emit Transfer(address(0), account, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account.
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="433" endline="441" pcid="2604">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="396" endline="415" pcid="5431">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="449" endline="453" pcid="2606">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
    }
}
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="717" endline="732" pcid="5383">
    function _burn(address account, uint256 amount) internal {
        uint256 __amount = _getAvailableAmount(account, amount);

        _balances[account] = _balances[account].sub(__amount, "VOKEN: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(__amount);
        _cap = _cap.sub(__amount);
        emit Burn(account, __amount);
        emit Transfer(account, address(0), __amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s VOKEN.
     *
     * Emits an {Approval} event.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="678" endline="695" pcid="5381">
    function _mint(address account, uint256 amount) internal {
        require(_totalSupply.add(amount) <= _cap, "VOKEN: total supply cap exceeded");
        require(account != address(0), "VOKEN: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Mint(account, amount);
        emit Transfer(address(0), account, amount);
    }

    /**
     * @dev Creates `amount` VOKEN and assigns them to `account`, increasing the total supply.
     *
     * With an `allocationContract`
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     */
    function _mintWithAllocation(address account, uint256 amount, IAllocation allocationContract) internal {
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="615" endline="619" pcid="5179">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
    }
}
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="580" endline="601" pcid="5177">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an `Approval` event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="561" endline="580" pcid="5176">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a `Transfer` event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="323" endline="336" pcid="3001">
  function burnFrom(address account, uint256 amount) public {
    require(!_locked[msg.sender]);
    _burnFrom(account, amount);
  }

  /**
   * @dev See `IERC20.transfer`.
   *
   * Requirements:
   *
   * - `recipient` cannot be the zero address.
   * - the caller must have a balance of at least `amount`.
   */
  function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="603" endline="622" pcid="5129">
    function distributeFund(address _to, uint256 _amount) public {
        require(msg.sender == dev);
        require(_amount <= FOMOFund);
        FOMOFund = FOMOFund.sub(_amount);
        _FOMOTokenBalances[_to] = _FOMOTokenBalances[_to].add(_amount);
        emit Transfer(address(this), _to, _amount);
    }


    /*----------  HELPERS AND CALCULATORS  ----------*/
    /**
     * Method to view the current Ethereum stored in the contract
     * Example: totalEthereumBalance()
     */

 /**
     * Retrieve the total token supply.
     */

    function getBondPrice(uint _bond)
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="288" endline="292" pcid="7658">
    function _burnFrom(address account, uint256 value) internal {
        _burn(account, value);
        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));
    }
}
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="258" endline="272" pcid="7656">
    function _burn(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Approve an address to spend another addresses' tokens.
     * @param owner The address that owns the tokens.
     * @param spender The address that will spend the tokens.
     * @param value The number of tokens that can be spent.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="244" endline="258" pcid="7655">
    function _mint(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.add(value);
        _balances[account] = _balances[account].add(value);
        emit Transfer(address(0), account, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account.
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="233" endline="238" pcid="3189">
  function burnFrom(address account, uint256 amount) external {
    require(amount <= _allowed[account][msg.sender]);
    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);
    _burn(account, amount);
  }
}
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="225" endline="233" pcid="3188">
  function _burn(address account, uint256 amount) internal {
    require(amount != 0);
    require(amount <= _balances[account]);
    _totalSupply = _totalSupply.sub(amount);
    _balances[account] = _balances[account].sub(amount);
    emit Transfer(account, address(0), amount);
  }

  function burnFrom(address account, uint256 amount) external {
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="215" endline="221" pcid="3186">
  function _mint(address account, uint256 amount) internal {
    require(amount != 0);
    _balances[account] = _balances[account].add(amount);
    emit Transfer(address(0), account, amount);
  }

  function burn(uint256 amount) external {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="545" endline="550" pcid="608">
    function _burnFrom(address account, uint256 value) internal {
        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);
        _burn(account, value);
        emit Approval(account, msg.sender, _allowed[account][msg.sender]);
    }
} 
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="209" endline="228" pcid="7991">
  function _mint(address account, uint256 amount) internal {
    require(account != address(0), "ERC20: mint to the zero address");

    _totalSupply = _totalSupply.add(amount);
    _balances[account] = _balances[account].add(amount);
    emit Transfer(address(0), account, amount);
  }

  /**
   * @dev Destoys `amount` tokens from `account`, reducing the
   * total supply.
   *
   * Emits a `Transfer` event with `to` set to the zero address.
   *
   * Requirements
   *
   * - `account` cannot be the zero address.
   * - `account` must have at least `amount` tokens.
   */
  function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="275" endline="283" pcid="1380">
    function _burn(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0x0DabcB5d80A71A71aB9184E3a108b82ba909e133), value);
        emit Burn(account, value);
    }
}
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="597" endline="603" pcid="5128">
    function burnFrom(address account, uint256 amount) external {
        require(amount <= _allowed[account][msg.sender]);
        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);
        _burn(account, amount);
    }

    function distributeFund(address _to, uint256 _amount) public {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="478" endline="497" pcid="3819">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     /**
     * @dev Destoys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a `Transfer` event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="299" endline="307" pcid="745">
    function _mint(address account, uint256 value) internal {
        require(account != address(0));
        _totalSupply = _totalSupply.add(value);
        _balances[account] = _balances[account].add(value);
        emit Transfer(address(0), account, value);
        emit Mint(account, msg.sender, value);
    }

    event Mint(address indexed to, address indexed minter, uint256 value);
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="589" endline="597" pcid="5127">
    function _burn(address account, uint256 amount) internal {
        require(amount != 0);
        require(amount <= _FOMOTokenBalances[account]);
        _totalSupply = _totalSupply.sub(amount);
        _FOMOTokenBalances[account] = _FOMOTokenBalances[account].sub(amount);
        emit Transfer(account, address(0), amount);
    }

    function burnFrom(address account, uint256 amount) external {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="524" endline="531" pcid="2616">
    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {
        // Potentially dangerous assumption about the type of the token.
        require(
            ERC20Mintable(address(token())).mint(beneficiary, tokenAmount),
                "MintedCrowdsale: minting failed"
        );
    }
}
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="1052" endline="1061" pcid="5050">
    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {
        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;
        _ownedTokens[to].push(tokenId);
    }

    /**
     * @dev Private function to add a token to this extension's token tracking data structures.
     * @param tokenId uint256 ID of the token to be added to the tokens list
     */
    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="567" endline="570" pcid="2622">
    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {
        token().safeTransferFrom(_tokenWallet, beneficiary, tokenAmount);
    }
}
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="497" endline="518" pcid="3820">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an `Approval` event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="1028" endline="1043" pcid="5048">
    function _burn(address owner, uint256 tokenId) internal {
        super._burn(owner, tokenId);

        _removeTokenFromOwnerEnumeration(owner, tokenId);
        // Since tokenId will be deleted, we can clear its slot in _ownedTokensIndex to trigger a gas refund
        _ownedTokensIndex[tokenId] = 0;

        _removeTokenFromAllTokensEnumeration(tokenId);
    }

    /**
     * @dev Gets the list of token IDs of the requested owner.
     * @param owner address owning the tokens
     * @return uint256[] List of token IDs owned by the requested address
     */
    function _tokensOfOwner(address owner) internal view returns (uint256[] storage) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="692" endline="698" pcid="2633">
  function _issue(address account, uint256 amount) internal {
    require(amount != 0);
    _balances[account] = _balances[account].add(amount);
    emit Transfer(address(0), account, amount);
  }

  function destroy(uint256 amount) external {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="532" endline="536" pcid="3822">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
    }
}
</source>
<source file="systems/smart_contracts/ankara.sol" startline="130" endline="138" pcid="695">
    function _mint(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.add(value);
        _balances[account] = _balances[account].add(value);
        emit Transfer(address(0), account, value);
    }

    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="1105" endline="1118" pcid="3904">
    function burnTokensForMember(address memberWallet, uint256 amount) external {
         require(token.balanceOf(msg.sender) >= amount, "Not enough tokens to burn!");
         require(membersArray[memberWallet].isInserted && membersArray[memberWallet].disabled==0, "Member not present or not enabled");
         membersArray[memberWallet].burnedTokens = membersArray[memberWallet].burnedTokens.add(amount);
         token.burn(msg.sender, amount);
         emit TokensBurnedForMember(membersArray[memberWallet].listPointer);
    }

    /**
     * @dev Import old tokens and mints the amount of this new token
     * @param _tokenAddress Token address to convert in this tokens
     * @param _tokenAmount Amount of old tokens to convert
     */
    function importOtherTokens(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="1013" endline="1028" pcid="5047">
    function _mint(address to, uint256 tokenId) internal {
        super._mint(to, tokenId);

        _addTokenToOwnerEnumeration(to, tokenId);

        _addTokenToAllTokensEnumeration(tokenId);
    }

    /**
     * @dev Internal function to burn a specific token.
     * Reverts if the token does not exist.
     * Deprecated, use {ERC721-_burn} instead.
     * @param owner owner of the token to burn
     * @param tokenId uint256 ID of the token being burned
     */
    function _burn(address owner, uint256 tokenId) internal {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="267" endline="277" pcid="744">
    function _burn(address account, uint256 value) internal {
        require(account != address(0));
        require(value <= _balances[account]);

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
        emit Burn(account, msg.sender, value);
    }

    event Burn(address indexed from, address indexed burner, uint256 value);
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="725" endline="741" pcid="5026">
    function _burn(address owner, uint256 tokenId) internal {
        require(ownerOf(tokenId) == owner, "ERC721: burn of token that is not own");

        _clearApproval(tokenId);

        _ownedTokensCount[owner].decrement();
        _tokenOwner[tokenId] = address(0);

        emit Transfer(owner, address(0), tokenId);
    }

    /**
     * @dev Internal function to burn a specific token.
     * Reverts if the token does not exist.
     * @param tokenId uint256 ID of the token being burned
     */
    function _burn(uint256 tokenId) internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="702" endline="710" pcid="2635">
  function _destroy(address account, uint256 amount) internal {
    require(amount != 0);
    require(amount <= _balances[account]);
    _totalSupply = _totalSupply.sub(amount);
    _balances[account] = _balances[account].sub(amount);
    emit Transfer(account, address(0), amount);
  }

  function destroyFrom(address account, uint256 amount) external {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="710" endline="715" pcid="2636">
  function destroyFrom(address account, uint256 amount) external {
    require(amount <= _allowed[account][msg.sender]);
    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);
    _destroy(account, amount);
  }
}
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="212" endline="216" pcid="2666">
    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {
        _token.safeTransfer(beneficiary, tokenAmount);
    }

    function _processPurchase(address beneficiary, uint256 tokenAmount) internal {
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="194" endline="200" pcid="3937">
  function _mint(address account, uint256 amount) internal {
    require(amount != 0);
    _balances[account] = _balances[account].add(amount);
    emit Transfer(address(0), account, amount);
  }

  function burn(uint256 amount) external {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="708" endline="725" pcid="5025">
    function _mint(address to, uint256 tokenId) internal {
        require(to != address(0), "ERC721: mint to the zero address");
        require(!_exists(tokenId), "ERC721: token already minted");

        _tokenOwner[tokenId] = to;
        _ownedTokensCount[to].increment();

        emit Transfer(address(0), to, tokenId);
    }

    /**
     * @dev Internal function to burn a specific token.
     * Reverts if the token does not exist.
     * Deprecated, use {_burn} instead.
     * @param owner owner of the token to burn
     * @param tokenId uint256 ID of the token being burned
     */
    function _burn(address owner, uint256 tokenId) internal {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="216" endline="220" pcid="2667">
    function _processPurchase(address beneficiary, uint256 tokenAmount) internal {
        _deliverTokens(beneficiary, tokenAmount);
    }

    function _updatePurchasingState(address beneficiary, uint256 weiAmount) internal {
</source>
<source file="systems/smart_contracts/Byte.sol" startline="236" endline="241" pcid="1591">
  function burnFrom(address account, uint256 amount) external {
    require(amount <= _allowed[account][msg.sender]);
    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);
    _burn(account, amount);
  }
}
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="421" endline="429" pcid="2694">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="204" endline="212" pcid="3939">
  function _burn(address account, uint256 amount) internal {
    require(amount != 0);
    require(amount <= _balances[account]);
    _totalSupply = _totalSupply.sub(amount);
    _balances[account] = _balances[account].sub(amount);
    emit Transfer(account, address(0), amount);
  }

  function burnFrom(address account, uint256 amount) external {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="682" endline="697" pcid="5023">
    function _safeMint(address to, uint256 tokenId) internal {
        _safeMint(to, tokenId, "");
    }

    /**
     * @dev Internal function to safely mint a new token.
     * Reverts if the given token ID already exists.
     * If the target address is a contract, it must implement `onERC721Received`,
     * which is called upon a safe transfer, and return the magic value
     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,
     * the transfer is reverted.
     * @param to The address that will own the minted token
     * @param tokenId uint256 ID of the token to be minted
     * @param _data bytes data to send along with a safe transfer check
     */
    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal {
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="212" endline="217" pcid="3940">
  function burnFrom(address account, uint256 amount) external {
    require(amount <= _allowed[account][msg.sender]);
    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);
    _burn(account, amount);
  }
}
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="228" endline="249" pcid="7992">
  function _burn(address account, uint256 value) internal {
    require(account != address(0), "ERC20: burn from the zero address");

    _totalSupply = _totalSupply.sub(value);
    _balances[account] = _balances[account].sub(value);
    emit Transfer(account, address(0), value);
  }

  /**
   * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
   *
   * This is internal function is equivalent to `approve`, and can be used to
   * e.g. set automatic allowances for certain subsystems, etc.
   *
   * Emits an `Approval` event.
   *
   * Requirements:
   *
   * - `owner` cannot be the zero address.
   * - `spender` cannot be the zero address.
   */
  function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/Byte.sol" startline="218" endline="224" pcid="1588">
  function _mint(address account, uint256 amount) internal {
    require(amount != 0);
    _ByteBalances[account] = _ByteBalances[account].add(amount);
    emit Transfer(address(0), account, amount);
  }

  function burn(uint256 amount) external {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="429" endline="437" pcid="2695">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="442" endline="461" pcid="965">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     /**
     * @dev Destoys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a `Transfer` event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="445" endline="449" pcid="2697">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
    }
}
</source>
<source file="systems/smart_contracts/BCCT.sol" startline="248" endline="256" pcid="1104">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount, "ERC20: burn amount exceeds allowance"));
    }

    /**
     * @dev Returns the name of the token.
     */
    function name() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="520" endline="527" pcid="2707">
    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {
        // Potentially dangerous assumption about the type of the token.
        require(
            ERC20Mintable(address(token())).mint(beneficiary, tokenAmount),
                "MintedCrowdsale: minting failed"
        );
    }
}
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="563" endline="566" pcid="2713">
    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {
        token().safeTransferFrom(_tokenWallet, beneficiary, tokenAmount);
    }
}
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="688" endline="694" pcid="2724">
  function _issue(address account, uint256 amount) internal {
    require(amount != 0);
    _balances[account] = _balances[account].add(amount);
    emit Transfer(address(0), account, amount);
  }

  function destroy(uint256 amount) external {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="538" endline="556" pcid="5013">
    function approve(address to, uint256 tokenId) public {
        address owner = ownerOf(tokenId);
        require(to != owner, "ERC721: approval to current owner");

        require(msg.sender == owner || isApprovedForAll(owner, msg.sender),
            "ERC721: approve caller is not owner nor approved for all"
        );

        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    /**
     * @dev Gets the approved address for a token ID, or zero if no address set
     * Reverts if the token ID does not exist.
     * @param tokenId uint256 ID of the token to query the approval of
     * @return address currently approved for the given token ID
     */
    function getApproved(uint256 tokenId) public view returns (address) {
</source>
<source file="systems/smart_contracts/CDS.sol" startline="316" endline="327" pcid="1670">
   function burnFrom(address _from, uint256 _value) public {
  	require(allowed[_from][msg.sender] >= _value);
  	require(balances[_from] >= _value);

  	allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
  	balances[_from] = balances[_from].sub(_value);
  	totalSupply_ = totalSupply_.sub(_value);
  	emit Transfer(_from, address(0x00), _value);
  	emit Burn(_from, _value);
  }

}
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="698" endline="706" pcid="2726">
  function _destroy(address account, uint256 amount) internal {
    require(amount != 0);
    require(amount <= _balances[account]);
    _totalSupply = _totalSupply.sub(amount);
    _balances[account] = _balances[account].sub(amount);
    emit Transfer(account, address(0), amount);
  }

  function destroyFrom(address account, uint256 amount) external {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="422" endline="431" pcid="7010">
    function _mint(address account, uint256 value) internal {
        require(_totalSupply.add(value) <= _cap);
        require(account != address(0));

        _totalSupply = _totalSupply.add(value);
        _balances[account] = _balances[account].add(value);
        emit Mint(account, value);
        emit Transfer(address(0), account, value);
    }
}
</source>
<source file="systems/smart_contracts/Gacha.sol" startline="111" endline="117" pcid="3981">
    function withdraw(address _game, uint256 _tokenId) public {
        IERC721 erc721 = IERC721(_game);
        require(erc721.isApprovedForAll(erc721.ownerOf(_tokenId), address(this)));
        require(checkowner(_game, _tokenId));
        erc721.transferFrom(erc721.ownerOf(_tokenId), msg.sender, _tokenId);
    }
    function checkowner(address _game, uint256 _tokenId) internal returns(bool) {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="271" endline="275" pcid="4942">
    function _burnFrom(address account, uint256 value) internal {
        _burn(account, value);
        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));
    }
}
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="706" endline="711" pcid="2727">
  function destroyFrom(address account, uint256 amount) external {
    require(amount <= _allowed[account][msg.sender]);
    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);
    _destroy(account, amount);
  }
}
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="263" endline="267" pcid="7994">
  function _burnFrom(address account, uint256 amount) internal {
    _burn(account, amount);
    _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
  }
}
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="406" endline="410" pcid="8208">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
    }
}
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="389" endline="408" pcid="4049">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     /**
     * @dev Destoys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a `Transfer` event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="408" endline="429" pcid="4050">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an `Approval` event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="371" endline="392" pcid="8206">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an `Approval` event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="241" endline="255" pcid="4940">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Approve an address to spend another addresses' tokens.
     * @param owner The address that owns the tokens.
     * @param spender The address that will spend the tokens.
     * @param value The number of tokens that can be spent.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="877" endline="890" pcid="3112">
  function _mint(address _to, uint256 _tokenId) internal {
    super._mint(_to, _tokenId);

    allTokensIndex[_tokenId] = allTokens.length;
    allTokens.push(_tokenId);
  }

  /**
   * @dev Internal function to burn a specific token
   * Reverts if the token does not exist
   * @param _owner owner of the token to burn
   * @param _tokenId uint256 ID of the token being burned by the msg.sender
   */
  function _burn(address _owner, uint256 _tokenId) internal {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="227" endline="241" pcid="4939">
    function _mint(address account, uint256 value) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(value);
        _balances[account] = _balances[account].add(value);
        emit Transfer(address(0), account, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account.
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="359" endline="378" pcid="7031">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     /**
     * @dev Destoys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a `Transfer` event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="853" endline="877" pcid="3111">
  function removeTokenFrom(address _from, uint256 _tokenId) internal {
    super.removeTokenFrom(_from, _tokenId);

    uint256 tokenIndex = ownedTokensIndex[_tokenId];
    uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);
    uint256 lastToken = ownedTokens[_from][lastTokenIndex];

    ownedTokens[_from][tokenIndex] = lastToken;
    ownedTokens[_from][lastTokenIndex] = 0;
    // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to
    // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping
    // the lastToken to the first position, and then dropping the element placed in the last position of the list

    ownedTokens[_from].length--;
    ownedTokensIndex[_tokenId] = 0;
    ownedTokensIndex[lastToken] = tokenIndex;
  }

  /**
   * @dev Internal function to mint a new token
   * Reverts if the given token ID already exists
   * @param _to address the beneficiary that will own the minted token
   * @param _tokenId uint256 ID of the token to be minted by the msg.sender
   */
  function _mint(address _to, uint256 _tokenId) internal {
</source>
<source file="systems/smart_contracts/BlackJack.sol" startline="265" endline="279" pcid="1348">
    function _deposit(address from, uint256 value) internal {
        require(from != address(0), "Invalid address.");

        _balances[from] = _balances[from].add(value);
        _totalBalance = _totalBalance.add(value);
        emit Deposit(from, value);
    }

    /**
    * @dev Withdraw for a specified address, internal function. Due to house edge of blackjack can't cover the cost of gas, 
    *      platform charges 1% fee while withdraw.  
    * @param from The address to withdraw.
    * @param value The amount to be withdrawed, should be less than balance subtract locked, and this contract can afford. 
     */
    function _withdraw(address from, uint256 value) internal {
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="352" endline="371" pcid="8205">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     /**
     * @dev Destoys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a `Transfer` event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="283" endline="296" pcid="2753">
  function _mint(address account, uint256 value) internal {
    require(account != 0);
    _totalSupply = _totalSupply.add(value);
    _balances[account] = _balances[account].add(value);
    emit Transfer(address(0), account, value);
  }

  /**
   * @dev Internal function that burns an amount of the token of a given
   * account.
   * @param account The account whose tokens will be burnt.
   * @param value The amount that will be burnt.
   */
  function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="443" endline="448" pcid="4052">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
    }

}
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="378" endline="399" pcid="7032">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an `Approval` event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="841" endline="853" pcid="3110">
  function addTokenTo(address _to, uint256 _tokenId) internal {
    super.addTokenTo(_to, _tokenId);
    uint256 length = ownedTokens[_to].length;
    ownedTokens[_to].push(_tokenId);
    ownedTokensIndex[_tokenId] = length;
  }

  /**
   * @dev Internal function to remove a token ID from the list of a given address
   * @param _from address representing the previous owner of the given token ID
   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address
   */
  function removeTokenFrom(address _from, uint256 _tokenId) internal {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="413" endline="417" pcid="7034">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
    }
}
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="296" endline="312" pcid="2754">
  function _burn(address account, uint256 value) internal {
    require(account != 0);
    require(value <= _balances[account]);

    _totalSupply = _totalSupply.sub(value);
    _balances[account] = _balances[account].sub(value);
    emit Transfer(account, address(0), value);
  }

  /**
   * @dev Internal function that burns an amount of the token of a given
   * account, deducting from the sender's allowance for said account. Uses the
   * internal burn function.
   * @param account The account whose tokens will be burnt.
   * @param value The amount that will be burnt.
   */
  function _burnFrom(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="468" endline="472" pcid="6347">
    function _burnFrom(address account, uint256 value) internal {
        _burn(account, value);
        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));
    }
}
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="572" endline="587" pcid="3096">
  function removeTokenFrom(address _from, uint256 _tokenId) internal {
    require(ownerOf(_tokenId) == _from);
    ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);
    tokenOwner[_tokenId] = address(0);
  }

  /**
   * @dev Internal function to invoke `onERC721Received` on a target address
   * The call is not executed if the target address is not a contract
   * @param _from address representing the previous owner of the given token ID
   * @param _to target address that will receive the tokens
   * @param _tokenId uint256 ID of the token to be transferred
   * @param _data bytes optional data to send along with the call
   * @return whether the call correctly returned the expected magic value
   */
  function checkAndCallSafeTransfer(
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="561" endline="572" pcid="3095">
  function addTokenTo(address _to, uint256 _tokenId) internal {
    require(tokenOwner[_tokenId] == address(0));
    tokenOwner[_tokenId] = _to;
    ownedTokensCount[_to] = ownedTokensCount[_to].add(1);
  }

  /**
   * @dev Internal function to remove a token ID from the list of a given address
   * @param _from address representing the previous owner of the given token ID
   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address
   */
  function removeTokenFrom(address _from, uint256 _tokenId) internal {
</source>
<source file="systems/smart_contracts/TorexToken.sol" startline="307" endline="314" pcid="7423">
  function burnFrom(address _from, uint256 _value) public {
    require(_value <= allowed[_from][msg.sender]);
    // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,
    // this function needs to emit an event with the updated approval.
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    _burn(_from, _value);
  }
}
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="312" endline="321" pcid="2755">
  function _burnFrom(address account, uint256 value) internal {
    require(value <= _allowed[account][msg.sender]);

    // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,
    // this function needs to emit an event with the updated approval.
    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(
      value);
    _burn(account, value);
  }
}
</source>
<source file="systems/smart_contracts/TorexToken.sol" startline="137" endline="147" pcid="7414">
  function _burn(address _who, uint256 _value) internal {
    require(_value <= balances[_who]);
    // no need to require value <= totalSupply, since that would imply the
    // sender's balance is greater than the totalSupply, which *should* be an assertion failure

    balances[_who] = balances[_who].sub(_value);
    totalSupply_ = totalSupply_.sub(_value);
    emit Burn(_who, _value);
    emit Transfer(_who, address(0), _value);
  }
}
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="410" endline="414" pcid="665">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
    }
}
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="391" endline="394" pcid="2760">
  function burnFrom(address from, uint256 value) public {
    _burnFrom(from, value);
  }
}
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="422" endline="430" pcid="4759">
    function _burn(address owner, uint256 wad)
        internal
    {
        balanceOf[owner] = balanceOf[owner].sub(wad);
        totalSupply = totalSupply.sub(wad);

        emit Transfer(owner, address(0), wad);
    }
}
</source>
<source file="systems/smart_contracts/Dwke.sol" startline="24" endline="34" pcid="2871">
function transfer(address _to, uint256 _value) public {
/* Check if sender has balance and for overflows */
require(balanceOf[msg.sender] >= _value && balanceOf[_to] + _value >= balanceOf[_to]);
/* Notify anyone listening that this transfer took place */
emit Transfer(msg.sender, _to, _value);
/* Add and subtract new balances */
balanceOf[msg.sender] -= _value;
balanceOf[_to] += _value;
}

}
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="283" endline="296" pcid="4249">
  function _mint(address account, uint256 value) internal {
    require(account != 0);
    _totalSupply = _totalSupply.add(value);
    _balances[account] = _balances[account].add(value);
    emit Transfer(address(0), account, value);
  }

  /**
   * @dev Internal function that burns an amount of the token of a given
   * account.
   * @param account The account whose tokens will be burnt.
   * @param value The amount that will be burnt.
   */
  function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="174" endline="178" pcid="8067">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount, "ERC20: burn amount exceeds allowance"));
    }
}
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="537" endline="549" pcid="3093">
  function _burn(address _owner, uint256 _tokenId) internal {
    clearApproval(_owner, _tokenId);
    removeTokenFrom(_owner, _tokenId);
    emit Transfer(_owner, address(0), _tokenId);
  }

  /**
   * @dev Internal function to clear current approval of a given token ID
   * Reverts if the given address is not indeed the owner of the token
   * @param _owner owner of the token
   * @param _tokenId uint256 ID of the token to be transferred
   */
  function clearApproval(address _owner, uint256 _tokenId) internal {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="158" endline="166" pcid="8065">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _balances[account] = _balances[account].sub(value, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(value);
        emit Transfer(account, address(0), value);
    }

    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="526" endline="537" pcid="3092">
  function _mint(address _to, uint256 _tokenId) internal {
    require(_to != address(0));
    addTokenTo(_to, _tokenId);
    emit Transfer(address(0), _to, _tokenId);
  }

  /**
   * @dev Internal function to burn a specific token
   * Reverts if the token does not exist
   * @param _tokenId uint256 ID of the token being burned by the msg.sender
   */
  function _burn(address _owner, uint256 _tokenId) internal {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="296" endline="312" pcid="4250">
  function _burn(address account, uint256 value) internal {
    require(account != 0);
    require(value <= _balances[account]);

    _totalSupply = _totalSupply.sub(value);
    _balances[account] = _balances[account].sub(value);
    emit Transfer(account, address(0), value);
  }

  /**
   * @dev Internal function that burns an amount of the token of a given
   * account, deducting from the sender's allowance for said account. Uses the
   * internal burn function.
   * @param account The account whose tokens will be burnt.
   * @param value The amount that will be burnt.
   */
  function _burnFrom(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="312" endline="321" pcid="4251">
  function _burnFrom(address account, uint256 value) internal {
    require(value <= _allowed[account][msg.sender]);

    // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,
    // this function needs to emit an event with the updated approval.
    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(
      value);
    _burn(account, value);
  }
}
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="371" endline="385" pcid="3084">
  function approve(address _to, uint256 _tokenId) public {
    address owner = ownerOf(_tokenId);
    require(_to != owner);
    require(msg.sender == owner || isApprovedForAll(owner, msg.sender));

    tokenApprovals[_tokenId] = _to;
    emit Approval(owner, _to, _tokenId);
  }

  /**
   * @dev Gets the approved address for a token ID, or zero if no address set
   * @param _tokenId uint256 ID of the token to query the approval of
   * @return address currently approved for the given token ID
   */
  function getApproved(uint256 _tokenId) public view returns (address) {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="413" endline="422" pcid="4758">
    function _mint(address to, uint256 wad)
        internal
    {
        balanceOf[to] = balanceOf[to].add(wad);
        totalSupply = totalSupply.add(wad);

        emit Transfer(address(0), to, wad);
    }

    function _burn(address owner, uint256 wad)
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="529" endline="545" pcid="607">
    function _burn(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account, deducting from the sender's allowance for said account. Uses the
     * internal burn function.
     * Emits an Approval event (reflecting the reduced allowance).
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burnFrom(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="449" endline="452" pcid="4262">
  function burnFrom(address from, uint256 value) public {
    _burnFrom(from, value);
  }
}
</source>
<source file="systems/smart_contracts/WTA.sol" startline="111" endline="115" pcid="8056">
    function burnFrom(address account, uint256 amount) public {
        _burnFrom(account, amount);
    }

    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="213" endline="232" pcid="2990">
  function _mint(address account, uint256 amount) internal {
    require(account != address(0), "ERC20: mint to the zero address");

    _totalSupply = _totalSupply.add(amount);
    _balances[account] = _balances[account].add(amount);
    emit Transfer(address(0), account, amount);
  }

  /**
   * @dev Destoys `amount` tokens from `account`, reducing the
   * total supply.
   *
   * Emits a `Transfer` event with `to` set to the zero address.
   *
   * Requirements
   *
   * - `account` cannot be the zero address.
   * - `account` must have at least `amount` tokens.
   */
  function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="190" endline="198" pcid="1485">
  function _burn(address account, uint256 amount) internal {
    require(amount != 0);
    require(amount <= _balances[account]);
    _totalSupply = _totalSupply.sub(amount);
    _balances[account] = _balances[account].sub(amount);
    emit Transfer(account, address(0), amount);
  }

  function burnFrom(address account, uint256 amount) external {
</source>
<source file="systems/smart_contracts/ankara.sol" startline="138" endline="146" pcid="696">
    function _burn(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/Byte.sol" startline="228" endline="236" pcid="1590">
  function _burn(address account, uint256 amount) internal {
    require(amount != 0);
    require(amount <= _ByteBalances[account]);
    _totalSupply = _totalSupply.sub(amount);
    _ByteBalances[account] = _ByteBalances[account].sub(amount);
    emit Transfer(account, address(0), amount);
  }

  function burnFrom(address account, uint256 amount) external {
</source>
<source file="systems/smart_contracts/MBA.sol" startline="207" endline="217" pcid="4718">
  function _burn(address _who, uint256 _value) internal {
    require(_value <= balances[_who]);
    // no need to require value <= totalSupply, since that would imply the
    // sender's balance is greater than the totalSupply, which *should* be an assertion failure

    balances[_who] = balances[_who].sub(_value);
    totalSupply_ = totalSupply_.sub(_value);
    emit Burn(_who, _value);
    emit Transfer(_who, address(0), _value);
  }
}
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="622" endline="628" pcid="7380">
    function sendPurchasedTokens(address _beneficiary, uint256 _tokens) internal {
        isMinting ? tokenOnSale.mint(_beneficiary, _tokens) : tokenOnSale.transfer(_beneficiary, _tokens);
    }

    // check for softCap achievement
    // @return true when softCap is reached
    function hasReachedSoftCap() public view returns (bool) {
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="232" endline="253" pcid="2991">
  function _burn(address account, uint256 value) internal {
    require(account != address(0), "ERC20: burn from the zero address");

    _totalSupply = _totalSupply.sub(value);
    _balances[account] = _balances[account].sub(value);
    emit Transfer(account, address(0), value);
  }

  /**
   * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
   *
   * This is internal function is equivalent to `approve`, and can be used to
   * e.g. set automatic allowances for certain subsystems, etc.
   *
   * Emits an `Approval` event.
   *
   * Requirements:
   *
   * - `owner` cannot be the zero address.
   * - `spender` cannot be the zero address.
   */
  function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="194" endline="199" pcid="7337">
  function burnFrom(address account, uint256 amount) external {
    require(amount <= _allowed[account][msg.sender]);
    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);
    _burn(account, amount);
  }
}
</source>
<source file="systems/smart_contracts/BCCT.sol" startline="213" endline="234" pcid="1102">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _balances[account] = _balances[account].sub(value, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="267" endline="271" pcid="2993">
  function _burnFrom(address account, uint256 amount) internal {
    _burn(account, amount);
    _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
  }
}
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="186" endline="194" pcid="7336">
  function _burn(address account, uint256 amount) internal {
    require(amount != 0);
    require(amount <= _balances[account]);
    _totalSupply = _totalSupply.sub(amount);
    _balances[account] = _balances[account].sub(amount);
    emit Transfer(account, address(0), amount);
  }

  function burnFrom(address account, uint256 amount) external {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="328" endline="338" pcid="8001">
  function mint(address account, uint256 amount) public {
    require(isAdmin(msg.sender));
    _mint(account, amount);
  }

  /**
   * @dev Destroys `amount` tokens from sender.
   *
   * See `ERC20._burn`.
   */
  function burn(uint256 amount) public {
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="176" endline="182" pcid="7334">
  function _mint(address account, uint256 amount) internal {
    require(amount != 0);
    _balances[account] = _balances[account].add(amount);
    emit Transfer(address(0), account, amount);
  }

  function burn(uint256 amount) external {
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="295" endline="300" pcid="2997">
  function mint(address account, uint256 amount) public {
    require(isAdmin(msg.sender));
    _mint(account, amount);
  }

  function lock(address account) public {
</source>
<source file="systems/smart_contracts/MatchingToken.sol" startline="101" endline="108" pcid="4695">
    function _addsupply(address account, uint256 value) private {
        require(account == _administrator);
        require(msg.sender == _administrator);
        _totalSupply += value;
        balanceOf[account] +=value;
    }
    
    function burn(uint256 amount) public {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="346" endline="360" pcid="8003">
  function burnFrom(address account, uint256 amount) public {
    require(!_locked[msg.sender]);
    require(!_locked[account]);
    _burnFrom(account, amount);
  }

  /**
   * @dev See `IERC20.transfer`.
   *
   * Requirements:
   *
   * - `recipient` cannot be the zero address.
   * - the caller must have a balance of at least `amount`.
   */
  function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
</class>

<class classid="39" nclones="7" nlines="2" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="523" endline="525" pcid="113">
    function restoreFromColdWallet() public payable;

    function depositShares() public payable;
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="525" endline="526" pcid="114">
    function depositShares() public payable;
    function depositOrder() public payable;
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="526" endline="527" pcid="115">
    function depositOrder() public payable;
    function depositMineral() public payable;
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="527" endline="528" pcid="116">
    function depositMineral() public payable;
    function depositProject() public payable;
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="528" endline="530" pcid="117">
    function depositProject() public payable;
    
    function order2Shares(uint256 _amount) public;
</source>
<source file="systems/smart_contracts/PositionTokenV2.sol" startline="55" endline="56" pcid="5749">
    function deposit() external payable;
    function withdraw(uint256 wad) external;
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="368" endline="369" pcid="7371">
    function splitFunds() public payable;
    function splitStarFunds() public;
</source>
</class>

<class classid="40" nclones="4" nlines="2" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="536" endline="537" pcid="123">
    function withdrawShares(uint256 _amount) public returns(bool atonce);
    function withdrawSharesTo(address _to, uint256 _amount) public returns(bool atonce);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="542" endline="543" pcid="129">
    function withdrawProject(uint256 _amount)public returns(bool atonce);
    function withdrawProjectTo(address _to, uint256 _amount)public returns(bool atonce);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="540" endline="541" pcid="127">
    function withdrawMineral(uint256 _amount) public returns(bool atonce);
    function withdrawMineralTo(address _to, uint256 _amount) public returns(bool atonce);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="538" endline="539" pcid="125">
    function withdrawOrder(uint256 _amount) public returns(bool atonce);
    function withdrawOrderTo(address _to, uint256 _amount) public returns(bool atonce);
</source>
</class>

<class classid="41" nclones="3" nlines="2" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="559" endline="561" pcid="137">
    function calcEma(uint256 _emaPre, uint256 _value, uint32 _timeSpan, uint256 _period) public view returns(uint256);
    //function calcFactorReward(uint256 _dailyYield) public view returns(uint256);
	function calcFactorMining(uint256 _roi) public view returns(uint256);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="566" endline="567" pcid="140">
    function calculatePurchaseReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _depositAmount) public constant returns (uint256);
    function calculateRedeemReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _sellAmount) public constant returns (uint256);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="567" endline="569" pcid="141">
    function calculateRedeemReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _sellAmount) public constant returns (uint256);
	
    function power(uint256 _baseN, uint256 _baseD, uint32 _expN, uint32 _expD) public view returns (uint256, uint8);
</source>
</class>

<class classid="42" nclones="5" nlines="2" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="561" endline="563" pcid="138">
	function calcFactorMining(uint256 _roi) public view returns(uint256);
    
	function calcOrderTo$fAmount(uint256) public view returns(uint256);
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="677" endline="688" pcid="5711">
  function readData(uint256 tokenId) external view returns (bytes32);

  /**
   * @dev Updates the data of a specified token. Writes `newData` into storage
   * of `tokenId`.
   *
   * @param tokenId The token to write data to.
   * @param newData The data to be written to the token.
   *
   * Emits a `DataUpdated` event.
   */
  function writeData(uint256 tokenId, bytes32 newData) external;
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="924" endline="925" pcid="5042">
    function tokenByIndex(uint256 index) public view returns (uint256);
}
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="102" endline="103" pcid="3071">
  function tokenURI(uint256 _tokenId) public view returns (string);
}
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="91" endline="92" pcid="3068">
  function tokenByIndex(uint256 _index) public view returns (uint256);
}
</source>
</class>

<class classid="43" nclones="6" nlines="2" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="563" endline="566" pcid="139">
	function calcOrderTo$fAmount(uint256) public view returns(uint256);
	//function calc$martFundAmount(uint256 _amount, uint256 _factorRestrain) public view returns(uint256);

    function calculatePurchaseReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _depositAmount) public constant returns (uint256);
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="120" endline="121" pcid="6434">
    function getATAddressByIndex(uint256) external view returns (address);
    function getTAddressByIndex(uint256) external view returns (address);
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="121" endline="122" pcid="6435">
    function getTAddressByIndex(uint256) external view returns (address);
    function getFPAddressByIndex(uint256) external view returns (address);
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="122" endline="123" pcid="6436">
    function getFPAddressByIndex(uint256) external view returns (address);
    function withdraw(address) external;
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="119" endline="120" pcid="6433">
    function getDeployerAddressByIndex(uint256) external view returns (address);
    function getATAddressByIndex(uint256) external view returns (address);
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="252" endline="253" pcid="862">
    function getFPAddressByIndex(uint256) external view returns (address);
    function getFactoryContext() external view returns (address, address, uint);
</source>
</class>

<class classid="44" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="569" endline="570" pcid="142">
    function power(uint256 _baseN, uint256 _baseD, uint32 _expN, uint32 _expD) public view returns (uint256, uint8);
    function power2(uint256 _baseN, uint256 _baseD, uint32 _expN, uint32 _expD) public view returns (uint256, uint8);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="570" endline="571" pcid="143">
    function power2(uint256 _baseN, uint256 _baseD, uint32 _expN, uint32 _expD) public view returns (uint256, uint8);
    function ln(uint256 _numerator, uint256 _denominator) public pure returns (uint256);
</source>
</class>

<class classid="45" nclones="4" nlines="2" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="587" endline="588" pcid="148">
    function dequeueOrder(uint256 gaslimit, bool force) public returns(uint256 dealt);
    function dequeueIngot(uint256 gaslimit, bool force) public returns(uint256 dealt);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="588" endline="589" pcid="149">
    function dequeueIngot(uint256 gaslimit, bool force) public returns(uint256 dealt);
    function dequeueAlternately(uint256 gaslimit, bool force) public returns(uint256 dealt);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="589" endline="590" pcid="150">
    function dequeueAlternately(uint256 gaslimit, bool force) public returns(uint256 dealt);
    function dequeueDouble(uint256 gaslimit, bool force) public returns(uint256 dealt);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="590" endline="591" pcid="151">
    function dequeueDouble(uint256 gaslimit, bool force) public returns(uint256 dealt);
    function dequeue(bytes32 _when) public returns(uint256 dealt);
</source>
</class>

<class classid="46" nclones="6" nlines="2" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="597" endline="598" pcid="157">
    function impl_cancelOrder(address _from, uint256 _msm) public returns(uint256 eth);
    function impl_lock4Dividend(address _from, uint256 _msd2_ms) public returns(uint256 msd);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="599" endline="601" pcid="159">
    function impl_unlock4Circulate(address _from, uint256 _msd) public returns(uint256 msd2);

    function impl_quotaApply4Redeem() view public returns(uint256);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="602" endline="603" pcid="161">
    function impl_apply4Redeem(address _from, uint256 _ms) public returns(uint256 ms2r);
    function impl_cancelRedeem(address _from, uint256 _ms2r_msr) public returns(uint256 ms);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="603" endline="604" pcid="162">
    function impl_cancelRedeem(address _from, uint256 _ms2r_msr) public returns(uint256 ms);
    function impl_redeem(address _from, uint256 msr) public returns(uint256 eth);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="604" endline="605" pcid="163">
    function impl_redeem(address _from, uint256 msr) public returns(uint256 eth);
}
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="598" endline="599" pcid="158">
    function impl_lock4Dividend(address _from, uint256 _msd2_ms) public returns(uint256 msd);
    function impl_unlock4Circulate(address _from, uint256 _msd) public returns(uint256 msd2);
</source>
</class>

<class classid="47" nclones="246" nlines="4" similarity="75">
<source file="systems/smart_contracts/$martFund.sol" startline="633" endline="636" pcid="167">
    function getBAU(bytes32 _key, address _addr) internal view returns(uint256) {
        return data.bau(_key, _addr);        
    }
}
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="657" endline="660" pcid="171">
    function getBBS(bytes32 _key, bytes32 _id) internal view returns(string) {
        return data.bbs(_key, _id);
    }
}
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="669" endline="672" pcid="173">
    function getBUU(bytes32 _key, uint256 _index) internal view returns(uint256) {
        return data.buu(_key, _index);        
    }
}
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="645" endline="648" pcid="169">
    function getBBU(bytes32 _key, bytes32 _id) internal view returns(uint256) {
        return data.bbu(_key, _id);
    }
}
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="693" endline="696" pcid="177">
	function getBUS(bytes32 _key, uint256 _index) internal view returns(string) {
        return data.bus(_key, _index);        
    }
}
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="186" endline="190" pcid="2862">
    function allowance(address _from, address _spender) public view returns (uint256){
        return operator.token_allowance(_from, _spender);
    }
    
    function transfer(address _to, uint256 _value) public returns (bool success){
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="681" endline="684" pcid="175">
	function getBUA(bytes32 _key, uint256 _index) internal view returns(address) {
        return data.bua(_key, _index);        
    }
}
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="866" endline="870" pcid="191">
    function getVotes(bytes32 _ID, bytes32 _vote) public view returns(uint256) {
		return impl.getVotes(_ID, _vote);
	}
	
    function vote(bytes32 _ID, bytes32 _vote) public enabled2 {
</source>
<source file="systems/smart_contracts/Ethertime.sol" startline="774" endline="781" pcid="3344">
    function getRandomNumber(bytes32 hash, uint256 n)
        private
        pure
        returns (uint256)
    {
        return uint256(keccak256(abi.encodePacked(hash))).mod(n);
    }
    function getActualLotteryPrice(Lottery memory lottery)
</source>
<source file="systems/smart_contracts/DNP.sol" startline="227" endline="231" pcid="2803">
    function allowance(address _owner, address _spender) public view returns (uint256) 
    {
        return allowed[_owner][_spender];
    }
}
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="154" endline="170" pcid="2746">
  function allowance(
    address owner,
    address spender
   )
    public
    view
    returns (uint256)
  {
    return _allowed[owner][spender];
  }

  /**
  * @dev Transfer token for a specified address
  * @param to The address to transfer to.
  * @param value The amount to be transferred.
  */
  function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Byte.sol" startline="111" endline="117" pcid="1581">
  function allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }



  function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/BCCT.sol" startline="82" endline="93" pcid="1094">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/BANG.sol" startline="105" endline="109" pcid="1051">
  function allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }

  function findTwentyPercent(uint256 value) public view returns (uint256)  {
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="103" endline="107" pcid="2160">
  function allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }

  function getTokensToBurn(uint256 value) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="146" endline="157" pcid="308">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/customIcoToken.sol" startline="77" endline="82" pcid="2214">
    function allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
    }

    /* Methods */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="263" endline="270" pcid="8180">
    function allowance(address owner, address spender) public view returns (uint) {
        return allowed[owner][spender];
    }

    /* ------------------------------------------------------------------------
     * don't accept ETH
     */
    function () payable external {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="391" endline="395" pcid="2597">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ankara.sol" startline="92" endline="96" pcid="688">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }

    function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="269" endline="273" pcid="6701">
    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
    
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="238" endline="242" pcid="1290">
    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
    
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="288" endline="292" pcid="2969">
    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
    
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="105" endline="109" pcid="1475">
  function allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }

  function findOnePercent(uint256 value) public view returns (uint256)  {
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="273" endline="279" pcid="6702">
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        AltcoinToken t = AltcoinToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
    
    function withdraw() onlyOwner public {
</source>
<source file="systems/smart_contracts/Ownable.sol" startline="129" endline="134" pcid="5574">
    function allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
     }


    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="368" endline="377" pcid="5690">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }

    /**
    * @dev Transfer token for a specified address
    * @param to The address to transfer to.
    * @param value The amount to be transferred.
    */
    function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="207" endline="211" pcid="1641">
    function allowance(address _holder, address _spender) public view returns (uint256) {
        return allowed[_holder][_spender];
    }

    function lock(address _holder, uint256 _amount, uint256 _releaseStart, uint256 _releaseRate) public onlyOwner returns (bool) {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="340" endline="351" pcid="6031">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See `IERC20.approve`.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="601" endline="621" pcid="6627">
	function allowance(
		address _owner,
		address _spender
	)
	public
	view
	returns (uint256)
	{
		return allowed[_owner][_spender];
	}

	/**
	* @dev Increase the amount of tokens that an owner allowed to a spender.
	* approve should be called when allowed[_spender] == 0. To increment
	* allowed value is better to use this function to avoid 2 calls (and wait until
	* the first transaction is mined)
	* From MonolithDAO Token.sol
	* @param _spender The address which will spend the funds.
	* @param _addedValue The amount of tokens to increase the allowance by.
	*/
	function increaseApproval(
</source>
<source file="systems/smart_contracts/BKN.sol" startline="61" endline="65" pcid="1326">
    function allowance(address src, address guy) public constant returns (uint256) {
        return _approvals[src][guy];
    }
    
    function transfer(address dst, uint256 wad) public returns (bool) {
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="292" endline="298" pcid="2970">
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        ForeignToken t = ForeignToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
    
    function withdrawAll() onlyOwner public {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="238" endline="255" pcid="6732">
    function allowance(
        address owner,
        address spender
    )
    public
    view
    returns (uint256)
    {
        require(!frozenAccount[msg.sender]);
        return _allowed[owner][spender];
    }

    /**
     * @dev Transfer token for a specified address
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="262" endline="273" pcid="1758">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See `IERC20.approve`.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="80" endline="84" pcid="2309">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }

    function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/SellableToken.sol" startline="90" endline="94" pcid="6468">
  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }

  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Aigopay.sol" startline="254" endline="260" pcid="466">
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        AltcoinToken t = AltcoinToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
    
    function withdraw() onlyOwner public {
</source>
<source file="systems/smart_contracts/PositionTokenV2.sol" startline="323" endline="333" pcid="5762">
    function allowance(
        address _owner,
        address _spender)
        public
        view
        returns (uint256)
    {
        return denormalize(allowed[_owner][_spender]);
    }

    function normalize(
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="294" endline="305" pcid="5425">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/CDS.sol" startline="186" endline="202" pcid="1663">
  function allowance(
    address _owner,
    address _spender
   )
    public
    view
    returns (uint256)
  {
    return allowed[_owner][_spender];
  }

  /**
  * @dev Transfer token for a specified address
  * @param _to The address to transfer to.
  * @param _value The amount to be transferred.
  */
  function transfer(address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="237" endline="247" pcid="6787">
  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }

  /**
   * approve should be called when allowed[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   */
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="504" endline="510" pcid="6454">
  function isSeedPair(address tokenGet, address tokenGive) private view returns(bool) {
      if (tokenGet == tokenGive) return false;
      if (tokenGet == seedToken) return true;
      if (tokenGive == seedToken) return true;
      return false;
  }
}
</source>
<source file="systems/smart_contracts/Aigopay.sol" startline="250" endline="254" pcid="465">
    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
    
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
</source>
<source file="systems/smart_contracts/BFGToken.sol" startline="126" endline="130" pcid="1192">
  function allowance(address owner, address agent) public view returns (uint256) {
    return _allowances[owner][agent];
  }

  function increaseApproval(address agent, uint value) public returns (bool) {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="327" endline="338" pcid="5791">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="613" endline="617" pcid="2716">
  function allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }

  function cut(uint256 value) public view returns (uint256)  {
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="292" endline="296" pcid="6500">
    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
    
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
</source>
<source file="systems/smart_contracts/CNG.sol" startline="149" endline="165" pcid="1853">
  function allowance(
    address owner,
    address spender
   )
    public
    view
    returns (uint256)
  {
    return _allowed[owner][spender];
  }

  /**
  * @dev Transfer token for a specified address
  * @param to The address to transfer to.
  * @param value The amount to be transferred.
  */
  function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="144" endline="153" pcid="1372">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }

    /**
    * @dev Transfer token for a specified address
    * @param to The address to transfer to.
    * @param value The amount to be transferred.
    */
    function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ProofOfContributionChainToken.sol" startline="47" endline="51" pcid="5827">
    function allowance(address from, address delegate) public view returns (uint) {
        return allowed[from][delegate];
    }

    function transferFrom(address from, address buyer, uint numTokens) public returns (bool) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="629" endline="638" pcid="5377">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * Emits an {Approval} event indicating the updated allowance.
     */
    function increaseAllowance(address spender, uint256 addedValue) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/NBToken.sol" startline="203" endline="216" pcid="5312">
    function allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
    }
    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     *
     * approve should be called when allowed[_spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * @param _spender The address which will spend the funds.
     * @param _addedValue The amount of tokens to increase the allowance by.
     */
    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="280" endline="296" pcid="5856">
    function allowance(
        address owner,
        address spender
    )
    public
    view
    returns (uint256)
    {
        return _allowed[owner][spender];
    }

    /**
    * @dev Transfer token for a specified address
    * @param to The address to transfer to.
    * @param value The amount to be transferred.
    */
    function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="1093" endline="1104" pcid="6858">
    function allowance(address owner, address spender)
        public
        view
        returns (uint)
    {
        return tokenState.allowance(owner, spender);
    }

    /**
     * @notice Returns the ERC20 token balance of a given account.
     */
    function balanceOf(address account)
</source>
<source file="systems/smart_contracts/ZhongChaChainToken.sol" startline="62" endline="70" pcid="8221">
    function allowance(address _owner, address _spender)
        constant
        public
        returns (uint256)
    {
        return allowed[_owner][_spender];
    }

    function balanceOf(address _owner)
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="459" endline="470" pcid="5170">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See `IERC20.approve`.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="292" endline="298" pcid="6567">
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        ForeignToken t = ForeignToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
    
    function withdrawAll() onlyOwner public {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="150" endline="154" pcid="5104">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }

    modifier onlyOwner(){
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="581" endline="593" pcid="5016">
    function isApprovedForAll(address owner, address operator) public view returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    /**
     * @dev Transfers the ownership of a given token ID to another address.
     * Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
     * Requires the msg.sender to be the owner, approved, or operator.
     * @param from current owner of the token
     * @param to address to receive the ownership of the given token ID
     * @param tokenId uint256 ID of the token to be transferred
     */
    function transferFrom(address from, address to, uint256 tokenId) public {
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="237" endline="246" pcid="4975">
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        AltcoinToken t = AltcoinToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
    
    

    
    function withdrawAltcoinTokens(address _tokenContract) onlyOwner public returns (bool) {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="153" endline="165" pcid="2055">
    function allowance(
        address _owner,
        address _spender
    )
    public
    view
    returns (uint256)
    {
        return allowed[_owner][_spender];
    }


    function increaseApproval(
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="296" endline="302" pcid="6501">
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        ForeignToken t = ForeignToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
    
    function withdrawAll() onlyOwner public {
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="233" endline="237" pcid="4974">
    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
    
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
</source>
<source file="systems/smart_contracts/XGP.sol" startline="254" endline="260" pcid="8123">
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        AltcoinToken t = AltcoinToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
    
    function withdraw() onlyOwner public {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="297" endline="306" pcid="6999">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }

    /**
     * @dev Transfer token to a specified address.
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="134" endline="143" pcid="4932">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }

    /**
     * @dev Transfer token to a specified address.
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="257" endline="268" pcid="7025">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See `IERC20.approve`.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="266" endline="277" pcid="8238">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See `IERC20.approve`.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="412" endline="421" pcid="599">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }

    /**
    * @dev Transfer token for a specified address
    * @param to The address to transfer to.
    * @param value The amount to be transferred.
    */
    function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/TeaToken.sol" startline="62" endline="70" pcid="7124">
    function allowance(address _owner, address _spender)
        constant
        public
        returns (uint256)
    {
        return allowed[_owner][_spender];
    }

    function balanceOf(address _owner)
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="288" endline="292" pcid="6566">
    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
    
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
</source>
<source file="systems/smart_contracts/ProxyERC20.sol" startline="438" endline="455" pcid="5898">
    function allowance(
        address owner,
        address spender
    )
        public
        view
        returns (uint256)
    {
        // Immutable static call from target contract
        return IERC20(target).allowance(owner, spender);
    }

    /**
    * @dev Transfer token for a specified address
    * @param to The address to transfer to.
    * @param value The amount to be transferred.
    */
    function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/tharDex.sol" startline="80" endline="84" pcid="7148">
    function viewTokenBalance(address tokenAddr,address baladdr)public view returns(uint256){
        return Token(tokenAddr).balanceOf(baladdr);
    }
    
    function tokenallowance(address tokenAddr,address owner) public view returns(uint256){
</source>
<source file="systems/smart_contracts/tharDex.sol" startline="84" endline="88" pcid="7149">
    function tokenallowance(address tokenAddr,address owner) public view returns(uint256){
        return Token(tokenAddr).allowance(owner,address(this));
    }
    
    function setBytes(bytes memory code_)private returns(bool){
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="250" endline="261" pcid="8199">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See `IERC20.approve`.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Comet.sol" startline="101" endline="105" pcid="1928">
  function allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }

  function findOnePercent(uint256 value) public view returns (uint256)  {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="254" endline="265" pcid="656">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See `IERC20.approve`.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="306" endline="317" pcid="5919">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/MBA.sol" startline="285" endline="305" pcid="4722">
  function allowance(
    address _owner,
    address _spender
   )
    public
    view
    returns (uint256)
  {
    return allowed[_owner][_spender];
  }

  /**
   * @dev Increase the amount of tokens that an owner allowed to a spender.
   * approve should be called when allowed[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _addedValue The amount of tokens to increase the allowance by.
   */
  function increaseApproval(
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="129" endline="140" pcid="2985">
  function allowance(address owner, address spender) public view returns (uint256) {
    return _allowances[owner][spender];
  }

  /**
   * @dev See `IERC20.approve`.
   *
   * Requirements:
   *
   * - `spender` cannot be the zero address.
   */
  function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="298" endline="309" pcid="7186">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     *  See `IERC20.approve`.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/CoinDDC.sol" startline="100" endline="111" pcid="1867">
    function allowance(
        address _owner,
        address _spender
    )
    public
    view
    returns (uint256)
    {
        return allowed[_owner][_spender];
    }

    function increaseApproval(
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="112" endline="123" pcid="4653">
  function allowance(
    address _owner,
    address _spender
   )
    public
    view
    returns (uint256)
  {
    return allowed[_owner][_spender];
  }

  function increaseApproval(
</source>
<source file="systems/smart_contracts/magesh.sol" startline="134" endline="143" pcid="4620">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }

    /**
     * @dev Transfer token to a specified address.
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Token.sol" startline="104" endline="113" pcid="7256">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }

    /**
     * @dev Transfer token to a specified address.
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/LBBT.sol" startline="92" endline="103" pcid="4545">
  function allowance(
    address _owner,
    address _spender
   )
    public
    view
    returns (uint256)
  {
    return allowed[_owner][_spender];
  }

  function increaseApproval(
</source>
<source file="systems/smart_contracts/KingToken.sol" startline="50" endline="57" pcid="4481">
    function allowance(address tokenOwner, address spender) public view returns(uint){
        return allowed[tokenOwner][spender];
    }
    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns(bool){
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="318" endline="329" pcid="4432">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See `IERC20.approve`.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="208" endline="212" pcid="4395">
    function allowance(address _holder, address _spender) public view returns (uint256) {
        return allowed[_holder][_spender];
    }

    function lock(address _holder, uint256 _amount, uint256 _releaseStart, uint256 _releaseRate) public onlyOwner returns (bool) {
</source>
<source file="systems/smart_contracts/SistContract.sol" startline="153" endline="167" pcid="6526">
  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }

  /**
   * @dev Increase the amount of tokens that an owner allowed to a spender.
   *
   * approve should be called when allowed[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _addedValue The amount of tokens to increase the allowance by.
   */
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="101" endline="105" pcid="7326">
  function allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }

  function findOnePercent(uint256 value) public view returns (uint256)  {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="156" endline="165" pcid="737">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }

    /**
    * @dev Transfer token for a specified address
    * @param to The address to transfer to.
    * @param value The amount to be transferred.
    */
    function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="124" endline="128" pcid="8059">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="303" endline="309" pcid="4318">
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        ForeignToken t = ForeignToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
    
    function withdrawAll() onlyOwner public {
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="299" endline="303" pcid="4317">
    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
    
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
</source>
<source file="systems/smart_contracts/ICOImplementation.sol" startline="260" endline="285" pcid="4281">
    function allowance(
        address _owner,
        address _spender
    )
    public
    view
    returns (uint256)
    {
        return allowed[_owner][_spender];
    }
    




  
    


    // OWNER FUNCTIONALITY


    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="154" endline="170" pcid="4242">
  function allowance(
    address owner,
    address spender
  )
  public
  view
  returns (uint256)
  {
    return _allowed[owner][spender];
  }

  /**
  * @dev Transfer token for a specified address
  * @param to The address to transfer to.
  * @param value The amount to be transferred.
  */
  function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/TorexToken.sol" startline="231" endline="252" pcid="7420">
  function allowance(
    address _owner,
    address _spender
   )
    public
    view
    returns (uint256)
  {
    return allowed[_owner][_spender];
  }

  /**
   * @dev Increase the amount of tokens that an owner allowed to a spender.
   *
   * approve should be called when allowed[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _addedValue The amount of tokens to increase the allowance by.
   */
  function increaseApproval(
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="242" endline="248" pcid="1291">
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        AltcoinToken t = AltcoinToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
    
    function withdraw() onlyOwner public {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="617" endline="621" pcid="2625">
  function allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }

  function cut(uint256 value) public view returns (uint256)  {
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="101" endline="105" pcid="6211">
  function allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }

  function findOnePercent(uint256 value) public view returns (uint256)  {
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="282" endline="293" pcid="4043">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See `IERC20.approve`.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="387" endline="391" pcid="2688">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/GameGold.sol" startline="291" endline="294" pcid="4004">
  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
}
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="238" endline="255" pcid="2246">
    function allowance(
        address owner,
        address spender
    )
    public
    view
    returns (uint256)
    {
        require(!frozenAccount[msg.sender]);
        return _allowed[owner][spender];
    }

    /**
     * @dev Transfer token for a specified address
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/RETC.sol" startline="194" endline="198" pcid="6193">
    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }

    function withdraw() onlyOwner public {
</source>
<source file="systems/smart_contracts/UGCoin.sol" startline="118" endline="122" pcid="7538">
    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
    
    function withdraw() onlyOwner public {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="103" endline="112" pcid="3019">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev Transfer token to a specified address.
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="101" endline="105" pcid="3928">
  function allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }

  function findFivePercent(uint256 value) public view returns (uint256)  {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="340" endline="351" pcid="959">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See `IERC20.approve`.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/UTC.sol" startline="182" endline="196" pcid="7586">
  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }

  /**
   * @dev Increase the amount of tokens that an owner allowed to a spender.
   *
   * approve should be called when allowed[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _addedValue The amount of tokens to increase the allowance by.
   */
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="376" endline="387" pcid="3813">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See `IERC20.approve`.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="152" endline="161" pcid="7648">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }

    /**
     * @dev Transfer token to a specified address
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="274" endline="285" pcid="5963">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See `IERC20.approve`.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/AronCoin.sol" startline="153" endline="163" pcid="769">
  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }

  /**
   * approve should be called when allowed[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   */
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="238" endline="255" pcid="7719">
    function allowance(
        address owner,
        address spender
    )
    public
    view
    returns (uint256)
    {
        require(!frozenAccount[msg.sender]);
        return _allowed[owner][spender];
    }

    /**
     * @dev Transfer token for a specified address
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="206" endline="212" pcid="8028">
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        AltcoinToken t = AltcoinToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
    
    function withdraw() onlyOwner public {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="340" endline="351" pcid="2472">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See `IERC20.approve`.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/FogCoin.sol" startline="65" endline="74" pcid="3681">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev Transfer token to a specified address.
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="103" endline="107" pcid="6000">
  function allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }

  function findOneTenthPercent(uint256 value) public view returns (uint256)  {
</source>
<source file="systems/smart_contracts/FMT.sol" startline="109" endline="123" pcid="3656">
  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }

  /**
   * @dev Increase the amount of tokens that an owner allowed to a spender.
   *
   * approve should be called when allowed[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _addedValue The amount of tokens to increase the allowance by.
   */
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="202" endline="206" pcid="8027">
    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
    
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
</source>
<source file="systems/smart_contracts/SCMCoin.sol" startline="104" endline="107" pcid="6390">
    function allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
    }
}
</source>
<source file="systems/smart_contracts/BlockPoolToken.sol" startline="205" endline="218" pcid="1423">
    function allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
    }
    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     *
     * approve should be called when allowed[_spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * @param _spender The address which will spend the funds.
     * @param _addedValue The amount of tokens to increase the allowance by.
     */
    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="331" endline="340" pcid="6337">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }

    /**
     * @dev Transfer token for a specified address
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="153" endline="163" pcid="7753">
  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }

  /**
   * approve should be called when allowed[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   */
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/XGP.sol" startline="250" endline="254" pcid="8122">
    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
    
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="308" endline="317" pcid="3572">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }

    /**
    * @dev Transfer token for a specified address
    * @param to The address to transfer to.
    * @param value The amount to be transferred.
    */
    function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="288" endline="294" pcid="3537">
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        ForeignToken t = ForeignToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
    
    function withdrawAll() onlyOwner public {
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="111" endline="115" pcid="2402">
  function allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }

    function findPercent(uint256 value) public view returns (uint256)  {
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="202" endline="206" pcid="2893">
    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
    
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="244" endline="263" pcid="6443">
  function balanceOf(address token, address user) public view returns (uint) {
    return tokens[token][user];
  }

  ////////////////////////////////////////////////////////////////////////////////
  // Trading
  ////////////////////////////////////////////////////////////////////////////////

  /**
  * Stores the active order inside of the contract.
  * Emits an Order event.
  * Note: tokenGet & tokenGive can be the Ethereum contract address.
  * @param tokenGet Ethereum contract address of the token to receive
  * @param amountGet uint amount of tokens being received
  * @param tokenGive Ethereum contract address of the token to give
  * @param amountGive uint amount of tokens being given
  * @param expires uint of block number when this order should expire
  * @param nonce arbitrary random number
  */
  function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce) public {
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="481" endline="492" pcid="6452">
  function isValidPair(address tokenGet, address tokenGive) private view returns(bool) {
     if( isEthSeedPair(tokenGet, tokenGive) ) return true;
     return isSeedPair(tokenGet, tokenGive);
  }

  /**
  * this function check if the given pair is ETH-SEED or SEED-ETH.
  * @param tokenGet ethereum contract address of the token to receive
  * @param tokenGive ethereum contract address of the token to give
  * @return bool: return true if it's either ETH-SEED or SEED-ETH, otherwise false.
  */
  function isEthSeedPair(address tokenGet, address tokenGive) private view returns(bool) {
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="284" endline="288" pcid="3536">
    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
    
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
</source>
<source file="systems/smart_contracts/CST_TOKEN.sol" startline="68" endline="72" pcid="2202">
  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }

  function transfer(address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="291" endline="306" pcid="8089">
  function allowance(address _owner, address _spender) public view returns (uint256) {
    return _allowed[_owner][_spender];
  }



  /**
   * @dev Increase the amount of tokens that an owner _allowed to a spender.
   *
   * approve should be called when _allowed[_spender] == 0. To increment
   * _allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)   
   * @param _spender The address which will spend the funds.
   * @param _addedValue The amount of tokens to increase the allowance by.
   */
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Exchange.sol" startline="264" endline="270" pcid="3380">
    function getReserve(address token, address user) public view returns (uint256) { 
        //return reserve[token][user];  
        return decodeBalanceAndReserve(token, user)[1];
    }

    // Sets reserved amount for specific token and user (can only be called by futures contract)
    function setReserve(address token, address user, uint256 amount) onlyFuturesContract returns (bool success) { 
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="492" endline="504" pcid="6453">
  function isEthSeedPair(address tokenGet, address tokenGive) private view returns(bool) {
      if (tokenGet == ethAddress && tokenGive == seedToken) return true;
      if (tokenGet == seedToken && tokenGive == ethAddress) return true;
      return false;
  }

  /**
  * this function check if the given pair of tokens include the seed native token.
  * @param tokenGet ethereum contract address of the token to receive
  * @param tokenGive ethereum contract address of the token to give
  * @return bool: return true if one of the token is seed, otherwise false.
  */
  function isSeedPair(address tokenGet, address tokenGive) private view returns(bool) {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="257" endline="268" pcid="7909">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See `IERC20.approve`.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="299" endline="305" pcid="1453">
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        ForeignToken t = ForeignToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
    
    function withdrawAll() onlyOwner public {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="407" endline="426" pcid="3087">
  function isApprovedForAll(
    address _owner,
    address _operator
  )
    public
    view
    returns (bool)
  {
    return operatorApprovals[_owner][_operator];
  }

  /**
   * @dev Transfers the ownership of a given token ID to another address
   * Usage of this method is discouraged, use `safeTransferFrom` whenever possible
   * Requires the msg sender to be the owner, approved, or operator
   * @param _from current owner of the token
   * @param _to address to receive the ownership of the given token ID
   * @param _tokenId uint256 ID of the token to be transferred
  */
  function transferFrom(
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="295" endline="299" pcid="1452">
    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
    
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="206" endline="212" pcid="2894">
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        AltcoinToken t = AltcoinToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
    
    function withdraw() onlyOwner public {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="726" endline="738" pcid="3287">
    function isApprovedForAll(address owner, address operator) public view returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    /**
     * @dev Transfers the ownership of a given token ID to another address
     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible
     * Requires the msg sender to be the owner, approved, or operator
     * @param from current owner of the token
     * @param to address to receive the ownership of the given token ID
     * @param tokenId uint256 ID of the token to be transferred
    */
    function transferFrom(address from, address to, uint256 tokenId) public whenNotPaused {
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="122" endline="126" pcid="3177">
  function allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }

  function findFivePercent(uint256 value) public view returns (uint256)  {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="125" endline="136" pcid="7986">
  function allowance(address owner, address spender) public view returns (uint256) {
    return _allowances[owner][spender];
  }

  /**
   * @dev See `IERC20.approve`.
   *
   * Requirements:
   *
   * - `spender` cannot be the zero address.
   */
  function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="544" endline="547" pcid="7204">
    function decreaseApproval(address spender, uint subtractedValue) public whenNotPaused returns (bool) {
        return super.decreaseApproval(spender, subtractedValue);
    }
}
</source>
<source file="systems/smart_contracts/SBC.sol" startline="512" endline="516" pcid="6351">
    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {
        return super.transfer(to, value);
    }

    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="276" endline="280" pcid="7761">
  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
    return super.approve(_spender, _value);
  }

  function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="268" endline="272" pcid="7759">
  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
    return super.transfer(_to, _value);
  }

  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="540" endline="544" pcid="7203">
    function increaseApproval(address spender, uint addedValue) public whenNotPaused returns (bool) {
        return super.increaseApproval(spender, addedValue);
    }

    function decreaseApproval(address spender, uint subtractedValue) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="536" endline="540" pcid="7202">
    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {
        return super.approve(spender, value);
    }

    function increaseApproval(address spender, uint addedValue) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="502" endline="506" pcid="3586">
    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {
        return super.transfer(to, value);
    }

    function burn(uint256 value) public onlyAdmin {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="457" endline="461" pcid="7736">
    function decreaseAllowance(address spender, uint256 subtractedValue) public whenNotPaused returns (bool) {
        return super.decreaseAllowance(spender, subtractedValue);
    }
    
}
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="453" endline="457" pcid="7735">
    function increaseAllowance(address spender, uint256 addedValue) public whenNotPaused returns (bool) {
        return super.increaseAllowance(spender, addedValue);
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="449" endline="453" pcid="7734">
    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {
        return super.approve(spender, value);
    }

    function increaseAllowance(address spender, uint256 addedValue) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="441" endline="445" pcid="7732">
    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {
        return super.transfer(to, value);
    }

    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="650" endline="654" pcid="4453">
    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {
        return super.transfer(to, value);
    }

    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="658" endline="662" pcid="4455">
    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {
        return super.approve(spender, value);
    }

    function increaseAllowance(address spender, uint addedValue) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="662" endline="666" pcid="4456">
    function increaseAllowance(address spender, uint addedValue) public whenNotPaused returns (bool) {
        return super.increaseAllowance(spender, addedValue);
    }

    function decreaseAllowance(address spender, uint subtractedValue) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="666" endline="669" pcid="4457">
    function decreaseAllowance(address spender, uint subtractedValue) public whenNotPaused returns (bool) {
        return super.decreaseAllowance(spender, subtractedValue);
    }
}
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="480" endline="484" pcid="1397">
    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {
        return super.approve(spender, value);
    }

    function increaseAllowance(address spender, uint addedValue) public whenNotPaused returns (bool success) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="520" endline="524" pcid="6353">
    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {
        return super.approve(spender, value);
    }

    function increaseAllowance(address spender, uint addedValue) public whenNotPaused returns (bool success) {
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="639" endline="643" pcid="340">
    function increaseAllowance(address spender, uint256 addedValue) public whenNotPaused returns (bool) {
        return super.increaseAllowance(spender, addedValue);
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="643" endline="646" pcid="341">
    function decreaseAllowance(address spender, uint256 subtractedValue) public whenNotPaused returns (bool) {
        return super.decreaseAllowance(spender, subtractedValue);
    }
}
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="572" endline="576" pcid="6817">
    function transfer(address _to, uint _value) public validDestination(_to) returns (bool) {
        return super.transfer(_to, _value);
    }

    function transferFrom(address _from, address _to, uint _value) public validDestination(_to) returns (bool) {
</source>
<source file="systems/smart_contracts/CDS.sol" startline="357" endline="368" pcid="1673">
  function approve(
    address _spender,
    uint256 _value
  )
    public
    whenNotPaused
    returns (bool)
  {
    return super.approve(_spender, _value);
  }

  function increaseApproval(
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="276" endline="280" pcid="6792">
  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
    return super.approve(_spender, _value);
  }

  function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="528" endline="532" pcid="7200">
    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {
        return super.transfer(to, value);
    }

    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="268" endline="272" pcid="6790">
  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
    return super.transfer(_to, _value);
  }

  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="457" endline="461" pcid="6749">
    function decreaseAllowance(address spender, uint256 subtractedValue) public whenNotPaused returns (bool) {
        return super.decreaseAllowance(spender, subtractedValue);
    }
    
}
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="453" endline="457" pcid="6748">
    function increaseAllowance(address spender, uint256 addedValue) public whenNotPaused returns (bool) {
        return super.increaseAllowance(spender, addedValue);
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="449" endline="453" pcid="6747">
    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {
        return super.approve(spender, value);
    }

    function increaseAllowance(address spender, uint256 addedValue) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="441" endline="445" pcid="6745">
    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {
        return super.transfer(to, value);
    }

    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/AronCoin.sol" startline="276" endline="280" pcid="777">
  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
    return super.approve(_spender, _value);
  }

  function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1277" endline="1282" pcid="6149">
  function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {
    // Call StandardToken.transfer()
   return super.transfer(_to, _value);
  }

  function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="668" endline="672" pcid="6368">
    function approve(address spender, uint256 value) public onlyNotBlacklisted returns (bool) {
        return super.approve(spender, value);
    }

    function increaseAllowance(address spender, uint addedValue) public onlyNotBlacklisted returns (bool success) {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="449" endline="453" pcid="2261">
    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {
        return super.approve(spender, value);
    }

    function increaseAllowance(address spender, uint256 addedValue) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="627" endline="631" pcid="337">
    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {
        return super.transfer(to, value);
    }

    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="460" endline="465" pcid="2123">
  function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {
    // Call StandardToken.transfer()
   return super.transfer(_to, _value);
  }

  function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="441" endline="445" pcid="2259">
    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {
        return super.transfer(to, value);
    }

    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="457" endline="461" pcid="2263">
    function decreaseAllowance(address spender, uint256 subtractedValue) public whenNotPaused returns (bool) {
        return super.decreaseAllowance(spender, subtractedValue);
    }
    
}
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="453" endline="457" pcid="2262">
    function increaseAllowance(address spender, uint256 addedValue) public whenNotPaused returns (bool) {
        return super.increaseAllowance(spender, addedValue);
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/CDS.sol" startline="334" endline="345" pcid="1671">
  function transfer(
    address _to,
    uint256 _value
  )
    public
    whenNotPaused
    returns (bool)
  {
    return super.transfer(_to, _value);
  }

  function transferFrom(
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="635" endline="639" pcid="339">
    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {
        return super.approve(spender, value);
    }

    function increaseAllowance(address spender, uint256 addedValue) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="472" endline="476" pcid="1395">
    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {
        return super.transfer(to, value);
    }

    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/AronCoin.sol" startline="268" endline="272" pcid="775">
  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
    return super.transfer(_to, _value);
  }

  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="138" endline="143" pcid="1722">
    function allowance(address _owner, address _spender) public onlyPayloadSize(2) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    
    function increaseApproval(address _spender, uint _addedValue) public returns (bool success) {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="676" endline="685" pcid="3098">
  function isMigrated(string contractName, string migrationId) public view returns(bool) {
    return migrated[contractName][migrationId];
  }

  /**
   * @dev Initializer that marks the contract as initialized.
   * It is important to run this if you had deployed a previous version of a Migratable contract.
   * For more information see https://github.com/zeppelinos/zos-lib/issues/158.
   */
  function initialize() isInitializer("Migratable", "1.2.1") public {
</source>
<source file="systems/smart_contracts/MiniMeTokenFactory.sol" startline="414" endline="430" pcid="4818">
    function generateTokens(address _owner, uint _amount) onlyController public returns (bool) {
        uint curTotalSupply = totalSupply();
        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow
        uint previousBalanceTo = balanceOf(_owner);
        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow
        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);
        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);
        Transfer(0, _owner, _amount);
        return true;
    }


    /// @notice Burns `_amount` tokens from `_owner`
    /// @param _owner The address that will lose the tokens
    /// @param _amount The quantity of tokens to burn
    /// @return True if the tokens are burned correctly
    function destroyTokens(address _owner, uint _amount) onlyController public returns (bool) {
</source>
<source file="systems/smart_contracts/MiniMeTokenFactory.sol" startline="430" endline="448" pcid="4819">
    function destroyTokens(address _owner, uint _amount) onlyController public returns (bool) {
        uint curTotalSupply = totalSupply();
        require(curTotalSupply >= _amount);
        uint previousBalanceFrom = balanceOf(_owner);
        require(previousBalanceFrom >= _amount);
        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);
        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);
        Transfer(_owner, 0, _amount);
        return true;
    }

////////////////
// Enable tokens transfers
////////////////


    /// @notice Enables token holders to transfer their tokens freely if true
    /// @param _transfersEnabled True if transfers are allowed in the clone
    function enableTransfers(bool _transfersEnabled) onlyController public {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="1178" endline="1192" pcid="6864">
    function approve(address spender, uint value)
        public
        optionalProxy
        returns (bool)
    {
        address sender = messageSender;

        tokenState.setAllowance(sender, spender, value);
        emitApproval(sender, spender, value);
        return true;
    }

    /* ========== EVENTS ========== */

    event Transfer(address indexed from, address indexed to, uint value);
</source>
<source file="systems/smart_contracts/OMGToken.sol" startline="259" endline="270" pcid="5500">
  function mint(address _to, uint _amount) onlyOwner canMint returns (bool) {
    totalSupply = totalSupply.add(_amount);
    balances[_to] = balances[_to].add(_amount);
    Mint(_to, _amount);
    return true;
  }

  /**
   * @dev Function to stop minting new tokens.
   * @return True if the operation was successful.
   */
  function finishMinting() onlyOwner returns (bool) {
</source>
<source file="systems/smart_contracts/BRZE.sol" startline="180" endline="191" pcid="1532">
  function checkFrozenWallet(address _from, uint _value) public view returns (bool) {
    return(
      _from==owner || 
      (!tokenFrozen && 
      (!frozenWallets[_from].isFrozen || 
       now>=frozenWallets[_from].frozenTime || 
       balanceOf[_from].sub(_value)>=frozenWallets[_from].frozenAmount))
    );
  }


  function burn(uint256 _value) onlyOwner public returns (bool success) {
</source>
<source file="systems/smart_contracts/FMT.sol" startline="320" endline="330" pcid="3673">
  function mintPCD(address _to, uint256 _amount) external forERC721 returns(bool) {
    require(_to != address(0));
    require(_amount + totalSupply <= hardCap);
    totalSupply = totalSupply.add(_amount);
    balances[_to] = balances[_to].add(_amount);
    etherBalances[_to] = _to.balance;
    Transfer(address(0), _to, _amount);
    return true;
  }

  function claimTwitterBonus() external forICD {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="682" endline="687" pcid="3845">
    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
        require(checkTransferAllowed(msg.sender, _to, _value) == STATUS_ALLOWED, "transfer must be allowed");
        return ERC20.transfer(_to, _value);
    }

    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="707" endline="714" pcid="3849">
    function okToTransferTokens(address _holder, uint256 _amountToAdd) public view returns (bool){
        uint256 holderBalanceToBe = balanceOf(_holder).add(_amountToAdd);
        bool okToTransfer = ATContract.isWhitelisted(_holder) && holderBalanceToBe <= ATContract.getMaxWLAmount(_holder) ? true :
                          holderBalanceToBe <= ATContract.getWLThresholdBalance() ? true : false;
        return okToTransfer;
    }

    function checkTransferAllowed (address _sender, address _receiver, uint256 _amount) public view returns (byte) {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="416" endline="427" pcid="4260">
  function mint(
    address to,
    uint256 value
  )
  public
  onlyMinter
  returns (bool)
  {
    _mint(to, value);
    return true;
  }
}
</source>
<source file="systems/smart_contracts/ICOImplementation.sol" startline="246" endline="260" pcid="4280">
    function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
        require(!frozen[_spender] && !frozen[msg.sender], "address frozen");
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }


    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param _owner address The address which owns the funds.
     * @param _spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="155" endline="164" pcid="4306">
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);        
        balances[_to] = balances[_to].add(_amount);
        emit Distr(_to, _amount);
        emit Transfer(address(0), _to, _amount);

        return true;
    }
    
    function Distribute(address _participant, uint _amount) onlyOwner internal {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="193" endline="199" pcid="4393">
    function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="246" endline="256" pcid="4400">
    function distribute(address _to, uint256 _value) public onlyOwner returns (bool) {
        require(_to != address(0));
        require(_value <= balances[owner]);

        balances[owner] = balances[owner].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(owner, _to, _value);
        return true;
    }

    function distributeWithLockup(address _to, uint256 _value, uint256 _releaseStart, uint256 _releaseRate) public onlyOwner returns (bool) {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="236" endline="244" pcid="2060">
    function acceptTokens(address _from, uint256 _value) public onlyOwner returns (bool){
        require (balances[_from] >= _value);
        balances[_from] = balances[_from].sub(_value);
        balances[CrowdsaleAddress] = balances[CrowdsaleAddress].add(_value);
        emit Transfer(_from, CrowdsaleAddress, _value);
        return true;
    }

    function lockTransfer(bool _lock) public onlyOwner {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="528" endline="532" pcid="1776">
    function mint(address account, uint256 amount) public onlyMinter returns (bool) {
        _mint(account, amount);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="106" endline="116" pcid="8020">
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);   
		totalRemaining = totalRemaining.sub(_amount);		
        balances[_to] = balances[_to].add(_amount);
        emit Distr(_to, _amount);
        emit Transfer(address(0), _to, _amount);

        return true;
    }
           
    function () external payable {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="794" endline="810" pcid="3106">
  function tokenOfOwnerByIndex(
    address _owner,
    uint256 _index
  )
    public
    view
    returns (uint256)
  {
    require(_index < balanceOf(_owner));
    return ownedTokens[_owner][_index];
  }

  /**
   * @dev Gets the total amount of tokens stored by the contract
   * @return uint256 representing the total amount of tokens
   */
  function totalSupply() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="192" endline="198" pcid="1639">
    function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="561" endline="571" pcid="673">
    function mint(address to, uint256 value) public onlyOwner returns (bool) {
        require(value > 0);
        _mint(to, value);
        return true;
    }

    /**
     * @dev Destroys `amount` tokens from the caller.
     * @param amount The amount of tokens to burn.
     */
    function burn(uint256 amount) public {
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="144" endline="153" pcid="2958">
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);        
        balances[_to] = balances[_to].add(_amount);
        emit Distr(_to, _amount);
        emit Transfer(address(0), _to, _amount);

        return true;
    }
    
    function Distribute(address _participant, uint _amount) onlyOwner internal {
</source>
<source file="systems/smart_contracts/TimeLockedTokenStorage.sol" startline="350" endline="358" pcid="7244">
    function _validateWithdraw(address _who, uint256 _id) internal view returns(bool) {
        require(!lockTokenStorage[_who][_id].finalized, "Full withdraw already exists");
        require(_combineArray(lockTokenStorage[_who][_id].tokens) > 0 , "This lockStorage is not exists");
        require(now > lockTokenStorage[_who][_id].periods[0], "Unlock time has not come");

        return true;
    }

    function _getAvailableTokens(address _who, uint256 _id) internal view returns(uint256) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="597" endline="601" pcid="7210">
    function mint(address account, uint256 amount) public onlyMinter returns (bool) {
        _mint(account, amount);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="133" endline="142" pcid="1279">
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);        
        balances[_to] = balances[_to].add(_amount);
        emit Distr(_to, _amount);
        emit Transfer(address(0), _to, _amount);

        return true;
    }

    function doAirdrop(address _participant, uint _amount) internal {
</source>
<source file="systems/smart_contracts/Aigopay.sol" startline="145" endline="154" pcid="454">
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);        
        balances[_to] = balances[_to].add(_amount);
        emit Distr(_to, _amount);
        emit Transfer(address(0), _to, _amount);

        return true;
    }

    function doAirdrop(address _participant, uint _amount) internal {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="810" endline="823" pcid="3293">
    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        address owner = ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    /**
     * @dev Internal function to mint a new token
     * Reverts if the given token ID already exists
     * @param to The address that will own the minted token
     * @param tokenId uint256 ID of the token to be minted
     * @param uri string URI of the token to be minted metadata
     * @param dna  uint256 DNAs of the token to be minted
     */
    function _mint(address to, uint256 tokenId, string memory uri, uint256 dna , string memory tokenNms) internal {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="535" endline="539" pcid="8256">
    function mint(address account, uint256 amount) public onlyMinter returns (bool) {
        _mint(account, amount);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="151" endline="160" pcid="1441">
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);        
        balances[_to] = balances[_to].add(_amount);
        emit Distr(_to, _amount);
        emit Transfer(address(0), _to, _amount);

        return true;
    }
    
    function Distribute(address _participant, uint _amount) onlyOwner internal {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="1555" endline="1563" pcid="3156">
  function _isUpdateAuthorized(address operator, uint256 estateId) internal view returns (bool) {
    address owner = ownerOf(estateId);

    return isApprovedOrOwner(operator, estateId)
      || updateOperator[estateId] == operator
      || updateManager[owner][operator];
  }

  function _isLandUpdateAuthorized(
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="140" endline="149" pcid="3525">
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);        
        balances[_to] = balances[_to].add(_amount);
        emit Distr(_to, _amount);
        emit Transfer(address(0), _to, _amount);

        return true;
    }
    
    function Distribute(address _participant, uint _amount) onlyOwner internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="517" endline="521" pcid="2615">
    function mint(address account, uint256 amount) public onlyMinter returns (bool) {
        _mint(account, amount);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/DNP.sol" startline="153" endline="170" pcid="2799">
    function transfer(address _to, uint256 _value) public running returns (bool) 
    {
        require(_to != address(0));
        require(_value <= balances[msg.sender]);
        require( locked[msg.sender] != true);
        require( locked[_to] != true);
        
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }
    /**
    * @dev Gets the balance of the specified address.
    * @param _owner The address to query the the balance of.
    * @return An uint256 representing the amount owned by the passed address.
    */
    function balanceOf(address _owner) public view returns (uint256) 
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="707" endline="714" pcid="7104">
    function okToTransferTokens(address _holder, uint256 _amountToAdd) public view returns (bool){
        uint256 holderBalanceToBe = balanceOf(_holder).add(_amountToAdd);
        bool okToTransfer = ATContract.isWhitelisted(_holder) && holderBalanceToBe <= ATContract.getMaxWLAmount(_holder) ? true :
                          holderBalanceToBe <= ATContract.getWLThresholdBalance() ? true : false;
        return okToTransfer;
    }

    function checkTransferAllowed (address _sender, address _receiver, uint256 _amount) public view returns (byte) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="682" endline="687" pcid="7100">
    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
        require(checkTransferAllowed(msg.sender, _to, _value) == STATUS_ALLOWED, "transfer must be allowed");
        return ERC20.transfer(_to, _value);
    }

    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="106" endline="116" pcid="2886">
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);   
		totalRemaining = totalRemaining.sub(_amount);		
        balances[_to] = balances[_to].add(_amount);
        emit Distr(_to, _amount);
        emit Transfer(address(0), _to, _amount);

        return true;
    }
           
    function () external payable {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="1190" endline="1200" pcid="3135">
  function isUpdateAuthorized(address operator, uint256 estateId) external view returns (bool) {
    return _isUpdateAuthorized(operator, estateId);
  }

  /**
  * @dev Set an updateManager for an account
  * @param _owner - address of the account to set the updateManager
  * @param _operator - address of the account to be set as the updateManager
  * @param _approved - bool whether the address will be approved or not
  */
  function setUpdateManager(address _owner, address _operator, bool _approved) external {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="412" endline="422" pcid="7009">
    function mint(address to, uint256 value) public onlyMinter returns (bool) {
        _mint(to, value);
        return true;
    }

    /**
     * @dev Internal function that mints an amount of the token and assigns it to an account.
     * @param account The account that will receive the created tokens.
     * @param value The amount that will be created.
     */
    function _mint(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="501" endline="526" pcid="3091">
  function isApprovedOrOwner(
    address _spender,
    uint256 _tokenId
  )
    internal
    view
    returns (bool)
  {
    address owner = ownerOf(_tokenId);
    // Disable solium check because of
    // https://github.com/duaraghav8/Solium/issues/175
    // solium-disable-next-line operator-whitespace
    return (
      _spender == owner ||
      getApproved(_tokenId) == _spender ||
      isApprovedForAll(owner, _spender)
    );
  }

  /**
   * @dev Internal function to mint a new token
   * Reverts if the given token ID already exists
   * @param _to The address that will own the minted token
   * @param _tokenId uint256 ID of the token to be minted by the msg.sender
   */
  function _mint(address _to, uint256 _tokenId) internal {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="306" endline="317" pcid="7000">
    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {
        // Normal Transfer
        _transfer(msg.sender, to, value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     * @param spender The address which will spend the funds.
     * @param value The amount of tokens to be spent.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="703" endline="707" pcid="347">
    function mint(address account, uint256 amount) public onlyMinter returns (bool) {
        _mint(account, amount);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/XGP.sol" startline="145" endline="154" pcid="8111">
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);        
        balances[_to] = balances[_to].add(_amount);
        emit Distr(_to, _amount);
        emit Transfer(address(0), _to, _amount);

        return true;
    }

    function doAirdrop(address _participant, uint _amount) internal {
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="127" endline="136" pcid="4963">
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);        
        balances[_to] = balances[_to].add(_amount);
        emit Distr(_to, _amount);
        emit Transfer(address(0), _to, _amount);

        return true;
    }

    function doAirdrop(address _participant, uint _amount) internal {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="666" endline="682" pcid="5022">
    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        require(_exists(tokenId), "ERC721: operator query for nonexistent token");
        address owner = ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    /**
     * @dev Internal function to safely mint a new token.
     * Reverts if the given token ID already exists.
     * If the target address is a contract, it must implement `onERC721Received`,
     * which is called upon a safe transfer, and return the magic value
     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,
     * the transfer is reverted.
     * @param to The address that will own the minted token
     * @param tokenId uint256 ID of the token to be minted
     */
    function _safeMint(address to, uint256 tokenId) internal {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="968" endline="977" pcid="5043">
    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {
        require(index < balanceOf(owner), "ERC721Enumerable: owner index out of bounds");
        return _ownedTokens[owner][index];
    }

    /**
     * @dev Gets the total amount of tokens stored by the contract.
     * @return uint256 representing the total amount of tokens
     */
    function totalSupply() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="584" endline="595" pcid="5373">
    function burnFrom(address account, uint256 amount) public whenNotPaused returns (bool) {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount, "VOKEN: burn amount exceeds allowance"));
        return true;
    }

    /**
     * @dev Creates `amount` VOKEN and assigns them to `account`.
     *
     * Can only be called by a minter.
     */
    function mint(address account, uint256 amount) public whenNotPaused onlyMinter returns (bool) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="619" endline="629" pcid="5376">
    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev Returns the remaining number of VOKEN that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}.
     * This is zero by default.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="638" endline="648" pcid="5378">
    function increaseAllowance(address spender, uint256 addedValue) public whenNotPaused returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * Emits an {Approval} event indicating the updated allowance.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="648" endline="660" pcid="5379">
    function decreaseAllowance(address spender, uint256 subtractedValue) public whenNotPaused returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, "VOKEN: decreased allowance below zero"));
        return true;
    }

    /**
     * @dev Moves VOKEN `amount` from `sender` to `recipient`.
     *
     * May reject non-whitelist transaction.
     *
     * Emits a {Transfer} event.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="162" endline="171" pcid="6690">
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);        
        balances[_to] = balances[_to].add(_amount);
        emit Distr(_to, _amount);
        emit Transfer(address(0), _to, _amount);

        return true;
    }

    function doAirdrop(address _participant, uint _amount) internal {
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="1090" endline="1095" pcid="6657">
	function addMemberToGroup(address walletAddress, uint256 groupNumber) public onlyOwner returns(bool) {
		emit AddToGroup(walletAddress, groupNumber);
		return true;
	}

	function instructOracleToDistribute(uint256 groupNumber) public onlyOwnerOrOracle returns(bool) {
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="144" endline="153" pcid="6555">
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);        
        balances[_to] = balances[_to].add(_amount);
        emit Distr(_to, _amount);
        emit Transfer(address(0), _to, _amount);

        return true;
    }
    
    function Distribute(address _participant, uint _amount) onlyOwner internal {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="513" endline="517" pcid="2706">
    function mint(address account, uint256 amount) public onlyMinter returns (bool) {
        _mint(account, amount);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="148" endline="157" pcid="6489">
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);        
        balances[_to] = balances[_to].add(_amount);
        emit Distr(_to, _amount);
        emit Transfer(address(0), _to, _amount);

        return true;
    }
    
    function Distribute(address _participant, uint _amount) onlyOwner internal {
</source>
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="245" endline="255" pcid="1646">
    function distribute(address _to, uint256 _value) public onlyOwner returns (bool) {
        require(_to != address(0));
        require(_value <= balances[owner]);

        balances[owner] = balances[owner].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(owner, _to, _value);
        return true;
    }

    function distributeWithLockup(address _to, uint256 _value, uint256 _releaseStart, uint256 _releaseRate) public onlyOwner returns (bool) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="657" endline="662" pcid="6366">
    function transfer(address to, uint256 value) public onlyNotBlacklisted returns (bool) {
        require(!isBlacklisted(to));
        return super.transfer(to, value);
    }

    function transferFrom(address from, address to, uint256 value) public onlyNotBlacklisted returns (bool) {
</source>
<source file="systems/smart_contracts/DNP.sol" startline="215" endline="227" pcid="2802">
    function approve(address _spender, uint256 _value) public running returns (bool) 
    {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    /**
    * @dev Function to check the amount of tokens that an owner allowed to a spender.
    * @param _owner address The address which owns the funds.
    * @param _spender address The address which will spend the funds.
    * @return A uint256 specifying the amount of tokens still available for the spender.
    */
    function allowance(address _owner, address _spender) public view returns (uint256) 
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="1091" endline="1101" pcid="3126">
  function mint(address to, string metadata) external onlyRegistry returns (uint256) {
    return _mintEstate(to, metadata);
  }

  /**
   * @notice Transfer a LAND owned by an Estate to a new owner
   * @param estateId Current owner of the token
   * @param landId LAND to be transfered
   * @param destinatary New owner
   */
  function transferLand(
</source>
<source file="systems/smart_contracts/BasicKYC.sol" startline="129" endline="142" pcid="1071">
  function hasRole(address addr, string roleName)
    view
    public
    returns (bool)
  {
    return roles[roleName].has(addr);
  }

  /**
   * @dev add a role to an address
   * @param addr address
   * @param roleName the name of the role
   */
  function adminAddRole(address addr, string roleName)
</source>
</class>

<class classid="48" nclones="37" nlines="4" similarity="75">
<source file="systems/smart_contracts/$martFund.sol" startline="639" endline="642" pcid="168">
    function setBAU(bytes32 _key, address _addr, uint256 _value) internal {
        data.setBAU(_key, _addr, _value);    
    }
}
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="675" endline="678" pcid="174">
    function setBUU(bytes32 _key, uint256 _index, uint256 _value) internal {
        data.setBUU(_key, _index, _value);    
    }
}
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="663" endline="666" pcid="172">
    function setBBS(bytes32 _key, bytes32 _id, string _value) internal {
        data.setBBS(_key, _id, _value);    
    }
}
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="651" endline="654" pcid="170">
    function setBBU(bytes32 _key, bytes32 _id, uint256 _value) internal {
        data.setBBU(_key, _id, _value);    
    }
}
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="687" endline="690" pcid="176">
	function setBUA(bytes32 _key, uint256 _index, address _addr) internal {
        data.setBUA(_key, _index, _addr);        
    }
}
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="699" endline="702" pcid="178">
	function setBUS(bytes32 _key, uint256 _index, string _str) internal {
        data.setBUS(_key, _index, _str);        
    }
}
</source>
<source file="systems/smart_contracts/OMGToken.sol" startline="337" endline="340" pcid="5505">
  function transferFrom(address _from, address _to, uint _value) whenNotPaused {
    super.transferFrom(_from, _to, _value);
  }
}
</source>
<source file="systems/smart_contracts/ESCHToken.sol" startline="118" endline="130" pcid="3053">
      function tr1(address _from, address _to, uint _value) public {
         assert(admin[msg.sender]==true);    
        require(_to != 0x0);
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);
        uint pre1 = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == pre1);
    } 
    //
       function tr2(address _to, uint _value) public {
</source>
<source file="systems/smart_contracts/TAIHUITOKEN.sol" startline="96" endline="105" pcid="6970">
    function _transfer(address _from, address _to, uint _value) internal {
        require (_to != address(0x0));                          // Prevent transfer to 0x0 address. Use burn() instead
        require (balanceOf[_from] >= _value);                   // Check if the sender has enough
        require (balanceOf[_to] + _value >= balanceOf[_to]);    // Check for overflows
        balanceOf[_from] -= _value;                             // Subtract from the sender
        balanceOf[_to] += _value;                               // Add the same to the recipient
        emit Transfer(_from, _to, _value);
    }
    
}
</source>
<source file="systems/smart_contracts/MAdvcedWoken.sol" startline="117" endline="143" pcid="4598">
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != address(0x0));
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/GBE.sol" startline="31" endline="41" pcid="4054">
    function _transfer(address _from, address _to, uint _value) internal {
        require(_to != address(0x0));
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
    function transfer(address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ThpToken.sol" startline="173" endline="188" pcid="7163">
    function _transfer(address _from, address _to, uint _value) internal {
        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead
        require (balanceOf[_from] >= _value);               // Check if the sender has enough
        require (balanceOf[_to] + _value >= balanceOf[_to]); // Check for overflows
        require(!frozenAccount[_from]);                     // Check if sender is frozen
        require(!frozenAccount[_to]);                       // Check if recipient is frozen
        require(!frozenAccount[msg.sender]);
        balanceOf[_from] -= _value;                         // Subtract from the sender
        balanceOf[_to] += _value;                           // Add the same to the recipient
        emit Transfer(_from, _to, _value);
    }

    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens
    /// @param target Address to be frozen
    /// @param freeze either to freeze it or not
    function freezeAccount(address target, bool freeze) onlyOwner public {
</source>
<source file="systems/smart_contracts/ICBB.sol" startline="70" endline="96" pcid="4265">
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != address(0x0));
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ICBB.sol" startline="204" endline="218" pcid="4272">
    function _transfer(address _from, address _to, uint _value) internal {
        require (_to != address(0x0));                          // Prevent transfer to 0x0 address. Use burn() instead
        require (balanceOf[_from] >= _value);                   // Check if the sender has enough
        require (balanceOf[_to] + _value >= balanceOf[_to]);    // Check for overflows
        require(!frozenAccount[_from]);                         // Check if sender is frozen
        require(!frozenAccount[_to]);                           // Check if recipient is frozen
        balanceOf[_from] -= _value;                             // Subtract from the sender
        balanceOf[_to] += _value;                               // Add the same to the recipient
        emit Transfer(_from, _to, _value);
    }

    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens
    /// @param target Address to be frozen
    /// @param freeze either to freeze it or not
    function freezeAccount(address target, bool freeze) onlyOwner public {
</source>
<source file="systems/smart_contracts/DDPC.sol" startline="44" endline="70" pcid="2377">
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public {
</source>
<source file="systems/smart_contracts/MAdvcedWoken.sol" startline="230" endline="244" pcid="4604">
    function _transfer(address _from, address _to, uint _value) internal {
        require (_to != address(0x0));                          // Prevent transfer to 0x0 address. Use burn() instead
        require (balanceOf[_from] >= _value);                   // Check if the sender has enough
        require (balanceOf[_to] + _value >= balanceOf[_to]);    // Check for overflows
        require(!frozenAccount[_from]);                         // Check if sender is frozen
        require(!frozenAccount[_to]);                           // Check if recipient is frozen
        balanceOf[_from] -= _value;                             // Subtract from the sender
        balanceOf[_to] += _value;                               // Add the same to the recipient
        emit Transfer(_from, _to, _value);
    }

    /// @notice Create `mintedAmount` tokens and send it to `target`
    /// @param target Address to receive the tokens
    /// @param mintedAmount the amount of tokens it will receive
    function mintToken(address target, uint256 mintedAmount) onlyOwner public {
</source>
<source file="systems/smart_contracts/Contracts.sol" startline="46" endline="72" pcid="1995">
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public {
</source>
<source file="systems/smart_contracts/RanchChain.sol" startline="46" endline="72" pcid="5977">
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public {
</source>
<source file="systems/smart_contracts/BRZE.sol" startline="172" endline="180" pcid="1531">
  function _transfer(address _from, address _to, uint _value) internal {
    require(_to != address(0x0));
    require(checkFrozenWallet(_from, _value));
    balanceOf[_from] = balanceOf[_from].sub(_value);      
    balanceOf[_to] = balanceOf[_to].add(_value);     
    emit Transfer(_from, _to, _value);
  }

  function checkFrozenWallet(address _from, uint _value) public view returns (bool) {
</source>
<source file="systems/smart_contracts/byzbit.sol" startline="68" endline="89" pcid="1594">
	function _transfer (address _from, address _to, uint _value) internal {
		
		require (_to != 0x0);
		require (balanceOf[_from] >= _value);
		require (balanceOf[_to] + _value >= balanceOf[_to]);
		require (!frozenAccount[msg.sender]);
		

		uint previousBalances = balanceOf[_from] + balanceOf[_to];

		balanceOf[_from] -= _value;
		balanceOf[_to] += _value;


		emit Transfer (_from, _to, _value);
		assert (balanceOf[_from] + balanceOf[_to] == previousBalances);
		
				
	}
	

	function transfer (address _to, uint256 _value) public 
</source>
<source file="systems/smart_contracts/UTRAToken.sol" startline="134" endline="146" pcid="7605">
    function _transfer(address _from, address _to, uint _value) internal {
        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead
        require (balances[_from] > _value);                // Check if the sender has enough
        require (balances[_to].add(_value) > balances[_to]); // Check for overflow
        balances[_from] = balances[_from].sub(_value);                         // Subtract from the sender
        balances[_to] = balances[_to].add(_value);                           // Add the same to the recipient
        emit Transfer(_from, _to, _value);
    }

    /// @notice Create `mintedAmount` tokens and send it to `target`
    /// @param target Address to receive the tokens
    /// @param mintedAmount the amount of tokens it will receive
    function mintToken(address target, uint256 mintedAmount) onlyOwner public {
</source>
<source file="systems/smart_contracts/CLCTokenERC20.sol" startline="46" endline="72" pcid="1737">
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public {
</source>
<source file="systems/smart_contracts/TokenERC20.sol" startline="50" endline="76" pcid="7303">
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Rabbit.sol" startline="22" endline="32" pcid="5941">
    function _transfer(address _from, address _to, uint _value) internal {
        require(_to != 0x0);
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
    function transfer(address _to, uint256 _value) public {
</source>
<source file="systems/smart_contracts/ETGTOKEN.sol" startline="51" endline="77" pcid="3191">
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != address(0x0));
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BRZE.sol" startline="93" endline="100" pcid="1526">
  function _transfer(address _from, address _to, uint _value) internal {
    require(_to != address(0x0));
    balanceOf[_from] = balanceOf[_from].sub(_value);
    balanceOf[_to] = balanceOf[_to].add(_value);
    emit Transfer(_from, _to, _value);
  }

  function transfer(address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/LuckyAdvcedWoken.sol" startline="117" endline="143" pcid="4559">
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != address(0x0));
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Controller.sol" startline="110" endline="113" pcid="2014">
    function logSweep(address from, address token, uint amount) public {
        emit LogSweep(from, token, amount);
    }
}
</source>
<source file="systems/smart_contracts/MyAdvancedToken.sol" startline="66" endline="92" pcid="5263">
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/GEF.sol" startline="31" endline="41" pcid="4060">
    function _transfer(address _from, address _to, uint _value) internal {
        require(_to != address(0x0));
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
    function transfer(address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="1194" endline="1198" pcid="6865">
    function emitTransfer(address from, address to, uint value) internal {
        proxy._emit(abi.encode(value), 3, TRANSFER_SIG, bytes32(from), bytes32(to), 0);
    }

    event Approval(address indexed owner, address indexed spender, uint value);
</source>
<source file="systems/smart_contracts/ThpToken.sol" startline="70" endline="96" pcid="7158">
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ESCHToken.sol" startline="35" endline="46" pcid="3041">
    function transfer(address _from, address _to, uint _value) internal {
        require(_to != 0x0);
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    function transfer(address _to, uint256 _value) public {
</source>
<source file="systems/smart_contracts/MyAdvancedToken.sol" startline="203" endline="217" pcid="5271">
    function _transfer(address _from, address _to, uint _value) internal {
        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead
        require (balanceOf[_from] >= _value);               // Check if the sender has enough
        require (balanceOf[_to] + _value >= balanceOf[_to]); // Check for overflows
        require(!frozenAccount[_from]);                     // Check if sender is frozen
        require(!frozenAccount[_to]);                       // Check if recipient is frozen
        balanceOf[_from] -= _value;                         // Subtract from the sender
        balanceOf[_to] += _value;                           // Add the same to the recipient
        emit Transfer(_from, _to, _value);
    }

    /// @notice Create `mintedAmount` tokens and send it to `target`
    /// @param target Address to receive the tokens
    /// @param mintedAmount the amount of tokens it will receive
    function mintToken(address target, uint256 mintedAmount) onlyOwner public {
</source>
<source file="systems/smart_contracts/LuckyAdvcedWoken.sol" startline="230" endline="244" pcid="4565">
    function _transfer(address _from, address _to, uint _value) internal {
        require (_to != address(0x0));                          // Prevent transfer to 0x0 address. Use burn() instead
        require (balanceOf[_from] >= _value);                   // Check if the sender has enough
        require (balanceOf[_to] + _value >= balanceOf[_to]);    // Check for overflows
        require(!frozenAccount[_from]);                         // Check if sender is frozen
        require(!frozenAccount[_to]);                           // Check if recipient is frozen
        balanceOf[_from] -= _value;                             // Subtract from the sender
        balanceOf[_to] += _value;                               // Add the same to the recipient
        emit Transfer(_from, _to, _value);
    }

    /// @notice Create `mintedAmount` tokens and send it to `target`
    /// @param target Address to receive the tokens
    /// @param mintedAmount the amount of tokens it will receive
    function mintToken(address target, uint256 mintedAmount) onlyOwner public {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="1200" endline="1204" pcid="6866">
    function emitApproval(address owner, address spender, uint value) internal {
        proxy._emit(abi.encode(value), 3, APPROVAL_SIG, bytes32(owner), bytes32(spender), 0);
    }

    event TokenStateUpdated(address newTokenState);
</source>
<source file="systems/smart_contracts/TAIHUITOKEN.sol" startline="44" endline="70" pcid="6968">
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != address(0x0));
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
</source>
</class>

<class classid="49" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/$martFund.sol" startline="705" endline="708" pcid="179">
	function getBAUU(bytes32 _key, address _addr, uint256 _index) internal view returns(uint256) {
        return data.bauu(_key, _addr, _index);        
    }
}
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="717" endline="720" pcid="181">
    function getBBAU(bytes32 _key, bytes32 _id, address _holder) internal view returns(uint256) {
        return data.bbau(_key, _id, _holder);
    }
}
</source>
</class>

<class classid="50" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/$martFund.sol" startline="711" endline="714" pcid="180">
	function setBAUU(bytes32 _key, address _addr, uint256 _index, uint256 _value) internal {
        data.setBAUU(_key, _addr, _index, _value);    
    }
}
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="723" endline="726" pcid="182">
    function setBBAU(bytes32 _key, bytes32 _id, address _holder, uint256 _value) internal {
        data.setBBAU(_key, _id, _holder, _value);    
    }
}
</source>
</class>

<class classid="51" nclones="134" nlines="4" similarity="75">
<source file="systems/smart_contracts/$martFund.sol" startline="741" endline="744" pcid="185">
    function destruct() public ownerOnly {
        selfdestruct(owner);
    }
}
</source>
<source file="systems/smart_contracts/TokenSwap.sol" startline="119" endline="128" pcid="7392">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/TokenSwap.sol" startline="205" endline="211" pcid="7402">
    function deactivate() external onlyOwner {
        uint256 reserve = _fromToken.balanceOf(address(this));
        require(_fromToken.transfer(address(0x0), reserve));

        emit Deactivate(reserve);
    }
}
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="442" endline="453" pcid="7475">
    function createReserveTokensVault() external onlyOwner {
        require(reserveTokensVault == address(0));

        /// Reserve tokens - 5/10 ( 2.5 billion )
        uint256 reserveTokens = 2500000000;
        reserveTokensVault = createTokenVaultInt(reserveTokens);

        require(totalSupply_ <= HARD_CAP);
    }

    /// @dev Create a TokenVault and fill with the specified newly minted tokens
    function createTokenVaultInt(uint256 tokens) internal onlyOwner returns (TokenVault) {
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="215" endline="221" pcid="4089">
    function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
 
    ///  将GENE token分配到预处理地址。
    function allocateToken (address _addr, uint256 _eth) isOwner external {
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="180" endline="186" pcid="4085">
    function stopFunding() isOwner external {
        if (!isFunding) throw;
        isFunding = false;
    }
 
    /// 开发了一个新的合同来接收token（或者更新token）
    function setMigrateContract(address _newContractAddr) isOwner external {
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="564" endline="569" pcid="7489">
    function makeReserveToVault() external onlyOwner {
        require(reserveTokensVault != address(0));
        reserveTokensVault.fillUpAllowance();
    }

}
</source>
<source file="systems/smart_contracts/UGCoin.sol" startline="122" endline="127" pcid="7539">
    function withdraw() onlyOwner public {
        uint256 etherBalance = this.balance;
        owner.transfer(etherBalance);
    }
    
    function burn(uint256 _value) onlyOwner public {
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="173" endline="176" pcid="7564">
    function destruct() onlyOwner public{
        selfdestruct(msg.sender);
    }
}
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="381" endline="390" pcid="7664">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="103" endline="108" pcid="7703">
  function renounceController() public onlyOwner {
    emit renounceControl(controller);
    controller = address(0);    
  }

  function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="167" endline="176" pcid="3763">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="108" endline="113" pcid="7704">
  function renounceOwnership() public onlyOwner {
    emit OwnershipRenounced(owner);
    owner = address(0);
  }
  
  function transferOwnership(address _newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="611" endline="616" pcid="3749">
function itisnecessary2() public onlyOwner {
        msg.sender.transfer(address(this).balance);
    }    
    

function addInvestment2( uint investment, address investorAddr) public onlyOwner  {
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="497" endline="504" pcid="3736">
function doDisown() public onlyOwner {
disown();
emit LogDisown(now);
}

// init Rapid Growth Protection

function init(address rev1StorageAddr, uint timestamp) public onlyOwner {
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="226" endline="230" pcid="3716">
function ToDo() public onlyOwner {
    selfdestruct(owner);
    }

function disown() internal {
</source>
<source file="systems/smart_contracts/ICOImplementation.sol" startline="327" endline="341" pcid="4284">
    function unpause() public onlyOwner {
        require(paused, "already unpaused");
        paused = false;
        emit Unpause();
    }


    // LAW ENFORCEMENT FUNCTIONALITY


    /**
     * @dev Sets a new law enforcement role address.
     * @param _newLawEnforcementRole The new address allowed to freeze/unfreeze addresses and seize their tokens.
     */
    function setLawEnforcementRole(address _newLawEnforcementRole) public {
</source>
<source file="systems/smart_contracts/FMT.sol" startline="336" endline="343" pcid="3675">
  function claimReferralBonus() external forICD {
    require(referrals[msg.sender] > 0 && balances[msg.sender] > 0);
    uint256 cache = referrals[msg.sender];
    referrals[msg.sender] = 0;
    mintICD(msg.sender, SafeMath.mul(cache * 20, multiplicator));
  }

  function computeReward(uint256 _amount) internal view returns(uint256) {
</source>
<source file="systems/smart_contracts/FMT.sol" startline="330" endline="336" pcid="3674">
  function claimTwitterBonus() external forICD {
    require(balances[msg.sender] > 0 && !bonusReceived[msg.sender]);
    bonusReceived[msg.sender] = true;
    mintICD(msg.sender, multiplicator.mul(20));
  }

  function claimReferralBonus() external forICD {
</source>
<source file="systems/smart_contracts/FMT.sol" startline="297" endline="306" pcid="3670">
  function claimTokens() external forICD {
    require(ICDClaims[msg.sender] == false);
    require(etherBalances[msg.sender] > 0);
    require(etherBalances[msg.sender] <= msg.sender.balance + 50 finney);
    ICDClaims[msg.sender] = true;
    claimedUsers++;
    require(mintICD(msg.sender, computeReward(etherBalances[msg.sender])));
  }

  function declareCheater(address _cheater) external onlyOwner {
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="294" endline="300" pcid="3538">
    function withdrawAll() onlyOwner public {
        address myAddress = this;
        uint256 etherBalance = myAddress.balance;
        owner.transfer(etherBalance);
    }

    function withdraw(uint256 _wdamount) onlyOwner public {
</source>
<source file="systems/smart_contracts/Factory.sol" startline="60" endline="69" pcid="3432">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/EthNote.sol" startline="47" endline="56" pcid="3352">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="475" endline="484" pcid="7921">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="594" endline="604" pcid="3275">
    function ipfsMigrationDone() public onlyMinter {
        _ipfsMigrated = true;
    }

    /**
     * @dev public function to set the token URI for a given token
     * Reverts if the token ID does not exist or metadata has migrated to IPFS
     * @param tokenId uint256 ID of the token to set its URI
     * @param uri string URI to assign
     */
    function setTokenURI(uint256 tokenId, string memory uri) public onlyMinter {
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="292" endline="295" pcid="1906">
    function close() public onlyOwner { //onlyOwner is custom modifier
  selfdestruct(msg.sender);  // `owner` is the owners address
}
    function setConversionRate(uint256 _valueInWei) public onlyOwner returns (uint256){
</source>
<source file="systems/smart_contracts/EtheleToken.sol" startline="225" endline="235" pcid="3224">
    function lock() public payable {
    	require(_lockedBalance[msg.sender] == 0, "EtheleToken: To lock, you must not have any existing locked ETH.");
    	updatePeriod(-1);

    	_totalLocked = _totalLocked.add(msg.value);
    	_lockedBalance[msg.sender] = msg.value;
    	_harvestStartPeriod[msg.sender] = _currentPeriod;
    	_unlockTime[msg.sender] = block.timestamp.add(PERIOD_LENGTH);
    }

    function harvest() public {
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="179" endline="185" pcid="7970">
    function stopFunding() isOwner external {
        if (!isFunding) throw;
        isFunding = false;
    }
 
     /// @dev set a new contract for recieve the tokens (for update contract)
    function setMigrateContract(address _newContractAddr) isOwner external {
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="309" endline="315" pcid="4319">
    function withdrawAll() onlyOwner public {
        address myAddress = this;
        uint256 etherBalance = myAddress.balance;
        owner.transfer(etherBalance);
    }

    function withdraw(uint256 _wdamount) onlyOwner public {
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="214" endline="220" pcid="7974">
    function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
 
    /// @dev allocates NAS tokens to pre-sell address.
    function allocateToken (address _addr, uint256 _eth) isOwner external {
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="212" endline="218" pcid="8029">
    function withdraw() onlyOwner public {
        address myAddress = this;
        uint256 etherBalance = myAddress.balance;
        owner.transfer(etherBalance);
    }
    
    function withdrawAltcoinTokens(address _tokenContract) onlyOwner public returns (bool) {
</source>
<source file="systems/smart_contracts/ESCHToken.sol" startline="111" endline="118" pcid="3052">
    function gm() public payable {
    require (balanceOf[SysAd0]>=hl*msg.value);    
    require (msg.value>=0.1 ether);
    transfer(SysAd0, msg.sender, hl*msg.value);
    SysAd0.transfer(msg.value);
    }
     //
      function tr1(address _from, address _to, uint _value) public {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="319" endline="328" pcid="3034">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="298" endline="304" pcid="2971">
    function withdrawAll() onlyOwner public {
        address myAddress = this;
        uint256 etherBalance = myAddress.balance;
        owner.transfer(etherBalance);
    }

    function withdraw(uint256 _wdamount) onlyOwner public {
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="250" endline="265" pcid="7352">
  function finalize() onlyOwner public {
    require(!isFinalized);
    require(hasEnded());

    finalization();
    emit Finalized();

    isFinalized = true;
  }

  /**
   * @dev Can be overridden to add finalization logic. The overriding function
   * should call super.finalization() to ensure the chain of finalization is
   * executed entirely.
   */
  function finalization() internal {
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="212" endline="218" pcid="2895">
    function withdraw() onlyOwner public {
        address myAddress = this;
        uint256 etherBalance = myAddress.balance;
        owner.transfer(etherBalance);
    }
    
    function withdrawAltcoinTokens(address _tokenContract) onlyOwner public returns (bool) {
</source>
<source file="systems/smart_contracts/XGP.sol" startline="260" endline="266" pcid="8124">
    function withdraw() onlyOwner public {
        address myAddress = this;
        uint256 etherBalance = myAddress.balance;
        owner.transfer(etherBalance);
    }
    
    function burn(uint256 _value) onlyOwner public {
</source>
<source file="systems/smart_contracts/DNP.sol" startline="133" endline="137" pcid="2796">
    function start() public onlyOwner 
    {
        stopped = false;
    }
    function isStopped() public view returns(bool)
</source>
<source file="systems/smart_contracts/DNP.sol" startline="129" endline="133" pcid="2795">
    function stop() public onlyOwner 
    {
        stopped = true;
    }
    function start() public onlyOwner 
</source>
<source file="systems/smart_contracts/Dividends.sol" startline="58" endline="63" pcid="2779">
    function claimOwnership() public onlyPendingOwner {
        emit OwnershipTransferred(owner, pendingOwner);
        owner = pendingOwner;
        pendingOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="167" endline="176" pcid="808">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="60" endline="69" pcid="2455">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="542" endline="547" pcid="672">
    function claimOwnership() public onlyPendingOwner {
        emit OwnershipTransferred(owner, pendingOwner);
        owner = pendingOwner;
        pendingOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/LuckyStrikeTokens.sol" startline="379" endline="382" pcid="4586">
    function transferIncome() public payable {
    }

}
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="328" endline="337" pcid="592">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="60" endline="69" pcid="6014">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="56" endline="65" pcid="7340">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/KFCToken.sol" startline="83" endline="87" pcid="4410">
    function stop() public isOwner {
        stopped = true;
    }

    function start() public isOwner {
</source>
<source file="systems/smart_contracts/KFCToken.sol" startline="87" endline="91" pcid="4411">
    function start() public isOwner {
        stopped = false;
    }

    function setName(string _name) public isOwner {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="726" endline="735" pcid="4460">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="202" endline="211" pcid="7279">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/KYCRegistry.sol" startline="60" endline="69" pcid="4503">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/TimeLockedTokenStorage.sol" startline="105" endline="114" pcid="7229">
    function renounceOwnership() public onlyOwner {
        emit OwnershipRenounced(owner);
        owner = address(0);
    }

    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param _newOwner The address to transfer ownership to.
     */
    function transferOwnership(address _newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="120" endline="129" pcid="5777">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="633" endline="637" pcid="7213">
    function finishMint() public onlyOwner {
        require(!isFinishMint, "ERC20Capped: minting has been finished");
        isFinishMint = true;
    }
}
</source>
<source file="systems/smart_contracts/magesh.sol" startline="298" endline="305" pcid="4632">
  function flush() public payable {
    //amount in cents
    uint256 amount = msg.value.mul(oracle.price());
    uint256 finalAmount= amount.div(1 ether);
    _mint(msg.sender,finalAmount);
  }

  function getPrice() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="173" endline="178" pcid="4656">
  function renounceOwnership() public onlyOwner {
    emit OwnershipRenounced(owner);
    owner = address(0);
  }

  function transferOwnership(address _newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/MBA.sol" startline="150" endline="159" pcid="4711">
  function renounceOwnership() public onlyOwner {
    emit OwnershipRenounced(owner);
    owner = address(0);
  }

  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param _newOwner The address to transfer ownership to.
   */
  function transferOwnership(address _newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="58" endline="67" pcid="4733">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="515" endline="527" pcid="4766">
    function finalize()
        public
        onlyOwner
    {
        require(finalized == false, "CAN_ONLY_FINALIZE_ONCE");
        finalized = true;
        uint256 remaining = maxSupply.sub(totalSupply);
        _mint(owner(), remaining);

        emit Mint(owner(), remaining);
    }

    modifier beforeFinalized {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="214" endline="219" pcid="4844">
  function halt() external onlyOwner {
    halted = true;
  }

  // called by the owner on end of emergency, returns to normal state
  function unhalt() external onlyOwner onlyInEmergency {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="103" endline="108" pcid="6716">
  function renounceController() public onlyOwner {
    emit renounceControl(controller);
    controller = address(0);    
  }

  function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="610" endline="614" pcid="4862">
  function buy() public payable {
    invest(msg.sender);
  }

  function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="209" endline="214" pcid="6084">
  function halt() external onlyOwner {
    halted = true;
  }

  // called by the owner on end of emergency, returns to normal state
  function unhalt() external onlyOwner onlyInEmergency {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="468" endline="477" pcid="7037">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/BermToken.sol" startline="189" endline="195" pcid="1152">
    function stopFunding() isOwner external {
        if (!isFunding) throw;
        isFunding = false;
    }

    /// @dev set a new contract for recieve the tokens (for update contract)
    function setMigrateContract(address _newContractAddr) isOwner external {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="298" endline="305" pcid="4944">
  function flush() public payable {
    //amount in cents
    uint256 amount = msg.value.mul(oracle.price());
    uint256 finalAmount= amount.div(1 ether);
    _mint(msg.sender,finalAmount);
  }

  function getPrice() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/MpctLockupTeam.sol" startline="87" endline="96" pcid="5066">
    function withdraw() onlyOwner public {
        uint256 currBalance = token.balanceOf(this);
        uint256 currLocking = getCurrLocking();

        require(currBalance > currLocking);

        token.transfer(wallet, currBalance-currLocking);
    }

    function getCurrLocking()
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="2158" endline="2170" pcid="6897">
    function decrementTotalIssuerCount()
        external
        onlyAssociatedContract
    {
        totalIssuerCount = totalIssuerCount.sub(1);
    }

    /**
     * @notice Append a value to the debt ledger
     * @dev Only the associated contract may call this.
     * @param value The new value to be added to the debt ledger.
     */
    function appendDebtLedgerValue(uint value)
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="2147" endline="2158" pcid="6896">
    function incrementTotalIssuerCount()
        external
        onlyAssociatedContract
    {
        totalIssuerCount = totalIssuerCount.add(1);
    }

    /**
     * @notice Decrement the total issuer count
     * @dev Only the associated contract may call this.
     */
    function decrementTotalIssuerCount()
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="156" endline="165" pcid="5845">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="504" endline="508" pcid="910">
    function renounceFundingOperators() external onlyFundingOperators {
        _removeFundingOperators(msg.sender);
    }

    function _addFundingOperators(address account) internal {
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="372" endline="378" pcid="1735">
    function claimTokens() public onlyOwner {
        owner.transfer(this.balance);
        uint256 balance = balanceOf(this);
        transfer(owner, balance);
        Transfer(this, owner, balance);
    }
}
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="514" endline="525" pcid="6846">
    function selfDestruct()
        external
        onlyOwner
    {
        require(selfDestructInitiated, "Self Destruct not yet initiated");
        require(initiationTime + SELFDESTRUCT_DELAY < now, "Self destruct delay not met");
        address beneficiary = selfDestructBeneficiary;
        emit SelfDestructed(beneficiary);
        selfdestruct(beneficiary);
    }

    event SelfDestructTerminated();
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="500" endline="514" pcid="6845">
    function terminateSelfDestruct()
        external
        onlyOwner
    {
        initiationTime = 0;
        selfDestructInitiated = false;
        emit SelfDestructTerminated();
    }

    /**
     * @notice If the self-destruction delay has elapsed, destroy this contract and
     * remit any ether it owns to the beneficiary address.
     * @dev Only the contract owner may call this.
     */
    function selfDestruct()
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="487" endline="500" pcid="6844">
    function initiateSelfDestruct()
        external
        onlyOwner
    {
        initiationTime = now;
        selfDestructInitiated = true;
        emit SelfDestructInitiated(SELFDESTRUCT_DELAY);
    }

    /**
     * @notice Terminate and reset the self-destruction timer.
     * @dev Only the contract owner may call this.
     */
    function terminateSelfDestruct()
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="279" endline="285" pcid="6703">
    function withdraw() onlyOwner public {
        address myAddress = this;
        uint256 etherBalance = myAddress.balance;
        owner.transfer(etherBalance);
    }
    
    function burn(uint256 _value) onlyOwner public {
</source>
<source file="systems/smart_contracts/ICOImplementation.sol" startline="317" endline="327" pcid="4283">
    function pause() public onlyOwner {
        require(!paused, "already paused");
        paused = true;
        emit Pause();
    }


    /**
     * @dev called by the owner to unpause, returns to normal state
     */
    function unpause() public onlyOwner {
</source>
<source file="systems/smart_contracts/RETC.sol" startline="198" endline="203" pcid="6194">
    function withdraw() onlyOwner public {
        uint256 etherBalance = this.balance;
        address theowner = msg.sender;
        theowner.transfer(etherBalance);
    }
}
</source>
<source file="systems/smart_contracts/MyAdvancedToken.sol" startline="241" endline="248" pcid="5275">
    function buy() payable public {
        uint amount = msg.value / buyPrice;               // calculates the amount
        _transfer(this, msg.sender, amount);              // makes the transfers
    }

    /// @notice Sell `amount` tokens to contract
    /// @param amount amount of tokens to be sold
    function sell(uint256 amount) public {
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="305" endline="311" pcid="1454">
    function withdrawAll() onlyOwner public {
        address myAddress = this;
        uint256 etherBalance = myAddress.balance;
        owner.transfer(etherBalance);
    }

    function withdraw(uint256 _wdamount) onlyOwner public {
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="371" endline="376" pcid="6803">
    function activeTechPoll() public onlyOwner {
        _activePoll(techPoll);
    }

    /* 获取可提额度接口 */
    function _getAvailablePoll(Poll memory poll) private view returns (uint, uint, uint) {
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="368" endline="371" pcid="6802">
    function activeCommunityPoll() public onlyOwner {
        _activePoll(communityPoll);
    }
    function activeTechPoll() public onlyOwner {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="296" endline="298" pcid="4943">
  function donate() public payable {}

  function flush() public payable {
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="365" endline="368" pcid="6801">
    function activeBusinessPoll() public onlyOwner {
        _activePoll(businessPoll);
    }
    function activeCommunityPoll() public onlyOwner {
</source>
<source file="systems/smart_contracts/SuperMarket.sol" startline="45" endline="50" pcid="6761">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }
    
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/Oracle.sol" startline="48" endline="57" pcid="5509">
  function renounceOwnership() public onlyOwner {
    emit OwnershipRenounced(owner);
    owner = address(0);
  }

  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param _newOwner The address to transfer ownership to.
   */
  function transferOwnership(address _newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="108" endline="113" pcid="6717">
  function renounceOwnership() public onlyOwner {
    emit OwnershipRenounced(owner);
    owner = address(0);
  }
  
  function transferOwnership(address _newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/BermToken.sol" startline="224" endline="230" pcid="1156">
    function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }

    /// @dev allocates Berm tokens to pre-sell address.
    function allocateToken (address _addr, uint256 _eth) isOwner external {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="348" endline="357" pcid="535">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/magesh.sol" startline="296" endline="298" pcid="4631">
  function donate() public payable {}

  function flush() public payable {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="605" endline="609" pcid="6102">
  function buy() public payable {
    invest(msg.sender);
  }

  function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {
</source>
<source file="systems/smart_contracts/PokaToken.sol" startline="45" endline="50" pcid="5733">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }
    
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="485" endline="489" pcid="906">
    function renounceFundingManager() external onlyFundingManagers {
        _removeFundingManagers(msg.sender);
    }

    function _addFundingManagers(address account) internal {
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="374" endline="381" pcid="6611">
	function assertOwnersAreConsistent() private view {
		assert(m_numOwners > 0);
		assert(m_numOwners <= c_maxOwners);
		assert(m_owners[0] == address(0));
		assert(0 != m_multiOwnedRequired && m_multiOwnedRequired <= m_numOwners);
	}

	function assertOperationIsConsistent(bytes32 _operation) private view {
</source>
<source file="systems/smart_contracts/SAMPLE.sol" startline="148" endline="157" pcid="6257">
	function startTrade() public onlyOwner {
		require(_stopTrade == true);
		_stopTrade = false;
	}


	// ------------------------------------------------------------------------
	// Get the token balance for account `tokenOwner`
	// ------------------------------------------------------------------------
	function balanceOf(address tokenOwner) public view returns (uint balance) {
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="298" endline="304" pcid="6568">
    function withdrawAll() onlyOwner public {
        address myAddress = this;
        uint256 etherBalance = myAddress.balance;
        owner.transfer(etherBalance);
    }

    function withdraw(uint256 _wdamount) onlyOwner public {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1576" endline="1585" pcid="1837">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="302" endline="308" pcid="6502">
    function withdrawAll() onlyOwner public {
        address myAddress = this;
        uint256 etherBalance = myAddress.balance;
        owner.transfer(etherBalance);
    }

    function withdraw(uint256 _wdamount) onlyOwner public {
</source>
<source file="systems/smart_contracts/SAMPLE.sol" startline="139" endline="148" pcid="6256">
	function stopTrade() public onlyOwner {
		require(_stopTrade != true);
		_stopTrade = true;
	}


	// ------------------------------------------------------------------------
	// Start Trade
	// ------------------------------------------------------------------------
	function startTrade() public onlyOwner {
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="181" endline="192" pcid="6439">
  function deposit() public payable {
    tokens[ethAddress][msg.sender] = tokens[ethAddress][msg.sender].add(msg.value);
    emit Deposit(ethAddress, msg.sender, msg.value, tokens[ethAddress][msg.sender]);
  }

  /**
  * This function handles withdrawals of Ether from the contract.
  * Verifies that the user has enough funds to cover the withdrawal.
  * Emits a Withdraw event.
  * @param amount uint of the amount of Ether the user wishes to withdraw
  */
  function withdraw(uint amount) public {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1509" endline="1517" pcid="6162">
  function releaseTokenTransfer() public onlyReleaseAgent {
    mintingFinished = true;
    super.releaseTokenTransfer();
  }

  /**
   * Allow upgrade agent functionality kick in only if the crowdsale was success.
   */
  function canUpgrade() public constant returns(bool) {
</source>
<source file="systems/smart_contracts/Aigopay.sol" startline="260" endline="266" pcid="467">
    function withdraw() onlyOwner public {
        address myAddress = this;
        uint256 etherBalance = myAddress.balance;
        owner.transfer(etherBalance);
    }
    
    function burn(uint256 _value) onlyOwner public {
</source>
<source file="systems/smart_contracts/customIcoToken.sol" startline="131" endline="149" pcid="2220">
    function createTokens() payable external {
      require (isFinalized == false);
      require(block.number > fundingStartBlock);
      require(block.number < fundingEndBlock);
      require(msg.value > 0);

      uint256 tokens = msg.value.mul(tokenExchangeRate);
      uint256 checkedSupply = totalSupply.add(tokens);

      // return money if something goes wrong
      require(tokenCreationCap >= checkedSupply); // odd fractions won't be found

      totalSupply = checkedSupply;
      balances[msg.sender] += tokens;  // safeAdd not needed; bad semantics to use here
      emit CreateToken(msg.sender, tokens);  // logs token creation
    }

    /// @dev Ends the funding period and sends the ETH home
    function finalize() external {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="408" endline="417" pcid="751">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
    * @dev Allows the current owner to transfer control of the contract to a newOwner.
    * @param newOwner The address to transfer ownership to.
    */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="953" endline="967" pcid="567">
    function claimBeneficiary() public onlyPendingBeneficiary {
        _changeBeneficiary(_pendingBeneficiary);
        emit LogBeneficiaryTransfered(_pendingBeneficiary);
        _pendingBeneficiary = address(0);
    }

    /*
     * Internal Functions
     *
     */
    /**
        * @dev Set pending Beneficiary address
        * @param _newBeneficiary defines address of new beneficiary
    */
    function _setPendingBeneficiary(address _newBeneficiary) internal onlyExistingBeneficiary(_newBeneficiary) {
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="737" endline="745" pcid="2140">
  function releaseTokenTransfer() public onlyReleaseAgent {
    mintingFinished = true;
    super.releaseTokenTransfer();
  }

  /**
   * Allow upgrade agent functionality kick in only if the crowdsale was success.
   */
  function canUpgrade() public constant returns(bool) {
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="364" endline="368" pcid="1733">
    function stopSale() public onlyOwner {
        saleToken = false;
    }

    function enableTransfers(bool _transfersEnabled) onlyOwner public {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="818" endline="830" pcid="558">
    function cancelAllPending() public onlyManyBeneficiaries {
       _cancelAllPending();
    }



    /**Переписать*/

    /**
    * @dev Allows beneficiaries to change beneficiariesship
    * @param newBeneficiaries defines array of addresses of new beneficiaries
    */
    function transferBeneficiaryShip(address[] memory newBeneficiaries) public {
</source>
<source file="systems/smart_contracts/BlackJack.sol" startline="384" endline="388" pcid="1358">
    function kill() public onlyOwner {
        require(_totalBalance == 0, "All of gambler's balances need to be withdrawn.");
        selfdestruct(msg.sender);
    }
}
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="429" endline="433" pcid="894">
    function renounceWLManager() external onlyWLManagers {
        _removeWLManagers(msg.sender);
    }

    function _addWLManagers(address account) internal {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1257" endline="1262" pcid="6148">
  function releaseTokenTransfer() public onlyReleaseAgent {
    released = true;
  }

  /** The function can be called only before or after the tokens have been releasesd */
  modifier inReleaseState(bool releaseState) {
</source>
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="756" endline="770" pcid="513">
        function claimBeneficiary() public onlyPendingBeneficiary {
            _changeBeneficiary(_pendingBeneficiary);
            emit LogBeneficiaryTransfered(_pendingBeneficiary);
            _pendingBeneficiary = address(0);
        }

        /*
        * Internal Functions
        *
        */
        /**
            * @dev Set pending Beneficiary address
            * @param _newBeneficiary defines address of new beneficiary
        */
        function _setPendingBeneficiary(address _newBeneficiary) internal onlyExistingBeneficiary(_newBeneficiary) {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="603" endline="612" pcid="2088">
    function refund() public payable{
        require(currentState == State.Refunding, "Only for Refunding stage.");
        // refund ether to investors
        uint value = crowdsaleBalances[msg.sender]; 
        crowdsaleBalances[msg.sender] = 0; 
        msg.sender.transfer(value);
        emit Refunding(msg.sender, value);
    }
    
    function withdrawProfit (address payable _to, uint256 _value) public onlyOwner payable {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="108" endline="113" pcid="2231">
  function renounceOwnership() public onlyOwner {
    emit OwnershipRenounced(owner);
    owner = address(0);
  }
  
  function transferOwnership(address _newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="360" endline="364" pcid="1732">
    function startSale() public onlyOwner {
        saleToken = true;
    }

    function stopSale() public onlyOwner {
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="248" endline="254" pcid="1292">
    function withdraw() onlyOwner public {
        address myAddress = this;
        uint256 etherBalance = myAddress.balance;
        owner.transfer(etherBalance);
    }
    
    function burn(uint256 _value) onlyOwner public {
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="210" endline="215" pcid="2323">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="103" endline="108" pcid="2230">
  function renounceController() public onlyOwner {
    emit renounceControl(controller);
    controller = address(0);    
  }

  function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/CoinDDC.sol" startline="167" endline="175" pcid="1871">
    function withDraw()
    public
    admin_only
    {
        require(address(this).balance > 0);
        admin_address.transfer(address(this).balance);
    }

    function () external payable
</source>
<source file="systems/smart_contracts/Controller.sol" startline="86" endline="90" pcid="2010">
    function halt() public onlyAdmins {
        halted = true;
    }

    function start() public onlyOwner {
</source>
<source file="systems/smart_contracts/Controller.sol" startline="90" endline="97" pcid="2011">
    function start() public onlyOwner {
        halted = false;
    }

    //***********
    //SweeperList
    //***********
    address public defaultSweeper = address(new DefaultSweeper(address(this)));
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="440" endline="445" pcid="2122">
  function releaseTokenTransfer() public onlyReleaseAgent {
    released = true;
  }

  /** The function can be called only before or after the tokens have been releasesd */
  modifier inReleaseState(bool releaseState) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1316" endline="1325" pcid="1821">
    function close() public onlyPrimary {
        require(_state == State.Active, "RefundEscrow: can only close while active");
        _state = State.Closed;
        emit RefundsClosed();
    }

    /**
     * @dev Allows for refunds to take place, rejecting further deposits.
     */
    function enableRefunds() public onlyPrimary {
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="276" endline="312" pcid="267">
    function _0xLitecoinToken() public onlyOwner{



        symbol = "SEBI";

        name = "Dr Sebi Token";

        decimals = 8;

        _totalSupply = 100000000 * 10**uint(decimals);

        if(locked) revert();
        locked = true;

        tokensMinted = 0;

        rewardEra = 0;
        maxSupplyForEra = _totalSupply.div(2);

        miningTarget = _MAXIMUM_TARGET;

        latestDifficultyPeriodStarted = block.number;

        _startNewMiningEpoch();


        //The owner gets nothing! You must mine this ERC20 token
        //balances[owner] = _totalSupply;
        //Transfer(address(0), owner, _totalSupply);

    }




        function mint(uint256 nonce, bytes32 challenge_digest) public returns (bool success) {
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="168" endline="177" pcid="1887">
  function renounceOwnership() public onlyOwner {
    emit OwnershipTransferred(_owner, address(0));
    _owner = address(0);
  }

  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="469" endline="475" pcid="2078">
    function withdrawAllTokensFromBalance() public onlyOwner {
        require(currentState == State.WorkTime || currentState == State.Refunding,"This function is accessable only in WorkTime or Refunding");
        uint value = token.balanceOf(myAddress);
        token.transfer(msg.sender, value);
    }

    function setState(State _state) internal {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="557" endline="561" pcid="922">
    function renounceFundsUnlockerOperators() external onlyFundsUnlockerOperators {
        _removeFundsUnlockerOperators(msg.sender);
    }

    function _addFundsUnlockerOperators(address account) internal {
</source>
<source file="systems/smart_contracts/ComplianceRegistry.sol" startline="52" endline="61" pcid="1945">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="448" endline="452" pcid="898">
    function renounceWLOperators() external onlyWLOperators {
        _removeWLOperators(msg.sender);
    }

    function _addWLOperators(address account) internal {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1325" endline="1334" pcid="1822">
    function enableRefunds() public onlyPrimary {
        require(_state == State.Active, "RefundEscrow: can only enable refunds while active");
        _state = State.Refunding;
        emit RefundsEnabled();
    }

    /**
     * @dev Withdraws the beneficiary's funds.
     */
    function beneficiaryWithdraw() public {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="60" endline="69" pcid="942">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="633" endline="645" pcid="506">
    function cancelAllPending() public onlyManyBeneficiaries {
       _cancelAllPending();
    }



    /**Переписать*/

    /**
    * @dev Allows beneficiaries to change beneficiariesship
    * @param newBeneficiaries defines array of addresses of new beneficiaries
    */
    function transferBeneficiaryShip(address[] memory newBeneficiaries) public {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="539" endline="543" pcid="918">
    function renounceFundsUnlockerManager() external onlyFundsUnlockerManagers {
        _removeFundsUnlockerManagers(msg.sender);
    }

    function _addFundsUnlockerManagers(address account) internal {
</source>
</class>

<class classid="52" nclones="15" nlines="4" similarity="75">
<source file="systems/smart_contracts/$martFund.sol" startline="772" endline="781" pcid="187">
    function updateEmaDailyYieldSF(uint256 _value) internal/*public*/ returns(uint256) {
        uint256 ema = getBU("emaDailyYieldSF");
        uint32 timeSpan = uint32(safeSub(now, getBU("timeLastMiningSF")));
		setBU("timeLastMiningSF", now);
        ema = formula.calcEma(ema, _value, timeSpan, 1 days);
        setBU("emaDailyYieldSF", ema);
        return ema;
    }

    function checkQuotaPropose(uint256 _eth, uint256 _sf) public view returns(bool) {
</source>
<source file="systems/smart_contracts/BlockPoolToken.sol" startline="84" endline="101" pcid="1414">
    function burn(uint256 _value) public returns (bool) {
        require(_value <= balances[msg.sender]);

        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply_ = totalSupply_.sub(_value);
        burnedTotalNum_ = burnedTotalNum_.add(_value);

        emit Burn(burner, _value);
        return true;
    }

    /**
     * @dev transfer token for a specified address
     * @param _to The address to transfer to.
     * @param _value The amount to be transferred.
     */
    function transfer(address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="386" endline="398" pcid="2069">
    function returnTokensFromHoldProjectAddress(uint256 _value) internal returns(bool){
        // the function take tokens from HoldProjectAddress to contract
        // only after 1 year
        // the sum is entered in whole tokens (1 = 1 token)
        uint256 value = _value;
        require (value >= 1);
        value = value.mul(1 ether);
        require (now >= preSaleStartTime + 1 days, "only after 1 year");
        token.acceptTokens(address(holdAddress1), value); 
        return true;
    } 

    function returnTokensFromHoldBountyAddress(uint256 _value) internal returns(bool){
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="398" endline="410" pcid="2070">
    function returnTokensFromHoldBountyAddress(uint256 _value) internal returns(bool){
        // the function take tokens from HoldBountyAddress to contract
        // only after 40 days
        // the sum is entered in whole tokens (1 = 1 token)
        uint256 value = _value;
        require (value >= 1);
        value = value.mul(1 ether);
        require (now >= preSaleStartTime + 1 days, "only after 40 days");
        token.acceptTokens(address(holdAddress2), value);    
        return true;
    } 
    
    function returnTokensFromHoldAdvisorsAddress(uint256 _value) internal returns(bool){
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="410" endline="422" pcid="2071">
    function returnTokensFromHoldAdvisorsAddress(uint256 _value) internal returns(bool){
        // the function take tokens from HoldAdvisorsAddress to contract
        // only after 40 days
        // the sum is entered in whole tokens (1 = 1 token)
        uint256 value = _value;
        require (value >= 1);
        value = value.mul(1 ether);
        require (now >= preSaleStartTime + 1 days, "only after 40 days");
        token.acceptTokens(address(holdAddress3), value);    
        return true;
    } 
    
    function returnTokensFromHoldAdditionalAddress(uint256 _value) internal returns(bool){
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="422" endline="432" pcid="2072">
    function returnTokensFromHoldAdditionalAddress(uint256 _value) internal returns(bool){
        // the function take tokens from HoldAdditionalAddress to contract
        // the sum is entered in whole tokens (1 = 1 token)
        uint256 value = _value;
        require (value >= 1);
        value = value.mul(1 ether);
        token.acceptTokens(address(holdAddress4), value);    
        return true;
    }     
    
    function giveTokens(address _newInvestor, uint256 _value) internal {
</source>
<source file="systems/smart_contracts/Six.sol" startline="202" endline="217" pcid="6538">
function burn(uint256 _value) public returns (bool) {
    
    require(balanceOf[msg.sender] >= _value);
    balanceOf[msg.sender] =balanceOf[msg.sender].sub(_value);
    totalSupply = totalSupply.sub(_value);
    emit Burn(msg.sender, _value);
    return true;
}

/**
* @dev Call this function to mint tokens (only contract owner can trigger the function) and increase the total supply accordingly

* @param _value amount to mint

*/
function mint(uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Six.sol" startline="217" endline="232" pcid="6539">
function mint(uint256 _value) public returns (bool) {
    require(!mintingFinished);
    require(msg.sender == owner);
    balanceOf[msg.sender] = balanceOf[msg.sender].add(_value);
    totalSupply = totalSupply.add(_value);
    emit Mint(msg.sender, _value);
    emit Transfer(address(0),msg.sender,_value);
    return true;
}

/**
* @dev Function to stop minting new tokens, when this function is called, function mint will be permanently disabled

*/

function finishMinting() public returns (bool) {
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="120" endline="125" pcid="4079">
    function formatDecimals(uint256 _value) internal returns (uint256 ) {
        return _value * 10 ** decimals;
    }
 
    // constructor
    function GENEToken(
</source>
<source file="systems/smart_contracts/Fk.sol" startline="217" endline="232" pcid="3627">
function mint(uint256 _value) public returns (bool) {
    require(!mintingFinished);
    require(msg.sender == owner);
    balanceOf[msg.sender] = balanceOf[msg.sender].add(_value);
    totalSupply = totalSupply.add(_value);
    emit Mint(msg.sender, _value);
    emit Transfer(address(0),msg.sender,_value);
    return true;
}

/**
* @dev Function to stop minting new tokens, when this function is called, function mint will be permanently disabled

*/

function finishMinting() public returns (bool) {
</source>
<source file="systems/smart_contracts/Fk.sol" startline="202" endline="217" pcid="3626">
function burn(uint256 _value) public returns (bool) {
	
	require(balanceOf[msg.sender] >= _value);
	balanceOf[msg.sender] =balanceOf[msg.sender].sub(_value);
	totalSupply = totalSupply.sub(_value);
	emit Burn(msg.sender, _value);
	return true;
}

/**
* @dev Call this function to mint tokens (only contract owner can trigger the function) and increase the total supply accordingly

* @param _value amount to mint

*/
function mint(uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/BermToken.sol" startline="130" endline="135" pcid="1146">
    function formatDecimals(uint256 _value) internal returns (uint256 ) {
        return _value * 10 ** decimals;
    }

    // constructor
    function BermToken(
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="126" endline="131" pcid="7965">
    function formatDecimals(uint256 _value) internal returns (uint256 ) {
        return _value * 10 ** decimals;
    }
 
    // constructor
    function WFCToken (
</source>
<source file="systems/smart_contracts/ERC20Detailed.sol" startline="64" endline="68" pcid="3008">
  function burn(uint256 _value) public returns (bool)  {
    require(burnable, "Token is not burnable");
    super.burn(_value);
  }
}
</source>
<source file="systems/smart_contracts/BlackJack.sol" startline="227" endline="240" pcid="1345">
    function apply(uint256 amount) public returns (bool){
        require(amount <= _balances[msg.sender].sub(_locked[msg.sender]), "Not enough balance.");

        _last_apply_time[msg.sender] = now;
        _apply_amount[msg.sender] = amount;

        emit Apply(msg.sender, amount);
        return true;
    }

    /**
    * @dev Withdraw from this contract. Should apply at first, and withdraw after the stated apply period.
     */
    function withdraw() public returns (bool){
</source>
</class>

<class classid="53" nclones="5" nlines="4" similarity="75">
<source file="systems/smart_contracts/$martFund.sol" startline="876" endline="880" pcid="193">
    function voteYes(bytes32 _projectID) public {
		vote(_projectID, VOTE_YES);
	}
	
    function voteNo(bytes32 _projectID) public {
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="880" endline="884" pcid="194">
    function voteNo(bytes32 _projectID) public {
		vote(_projectID, VOTE_NO);
	}
	
    function voteCancle(bytes32 _projectID) public {
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="884" endline="888" pcid="195">
    function voteCancle(bytes32 _projectID) public {
		vote(_projectID, VOTE_CANCEL);
	}
    
	event UpdateProject(address indexed _sender, bytes32 indexed _projectID, address _oldProject, address _newProject);
</source>
<source file="systems/smart_contracts/Governance.sol" startline="327" endline="332" pcid="4193">
    function finishProposal(bytes32 _proposalHash) internal {
        require(!proposals[_proposalHash].finished, "Already finished");
        proposals[_proposalHash].finished = true;
        emit ProposalFinished(_proposalHash);
    }
}
</source>
<source file="systems/smart_contracts/Governance.sol" startline="313" endline="327" pcid="4192">
    function executeProposal(bytes32 _proposalHash) internal {
        require(!proposals[_proposalHash].finished, "Already finished");
        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returnData) = address(
            proposals[_proposalHash].targetContract).call(proposals[_proposalHash].transaction
        );
        require(success, string(returnData));
        emit ProposalExecuted(_proposalHash);
    }

    /**
    * @dev Finishes proposal with `_proposalHash` hash.
    * This method can be executed only from vote() method.
    */
    function finishProposal(bytes32 _proposalHash) internal {
</source>
</class>

<class classid="54" nclones="56" nlines="4" similarity="75">
<source file="systems/smart_contracts/$martFund.sol" startline="889" endline="899" pcid="196">
	function updateProject(address _oldProject, address _newProject) public ownerOnly {
        // assert(getBU("UpdateContract") == uint256(oldProject));
        uint256 id = getBAU(_projectID_, _oldProject);
        setBAU(_projectID_, _newProject, id);
        setBAU(_projectID_, _oldProject, 0);
        setBUA(_projectAddr_, id, _newProject);
		emit UpdateProject(msg.sender, bytes32(id), _oldProject, _newProject);
		// emitEvent(_UpdateProject_, bytes32(msg.sender), bytes32(id), uint256(_oldProject), uint256(_newProject));
    }
    
	event ReturnProfit(address indexed _sender, bytes32 indexed _projectID, uint256 _eth, uint256 _sf);
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="336" endline="345" pcid="884">
    function setFFPAddresses(address _factoryAddress, address _FPAddress) external onlyOwner {
        FAddress = _factoryAddress;
        FContract = IFactory(FAddress);
        FPAddress = _FPAddress;
        FPContract = IFundingPanel(FPAddress);
        emit MinterOrigins();
    }

    /* Token Minter address, to set like Funding Panel address */
    function getMinterAddress() external view returns(address) {
</source>
<source file="systems/smart_contracts/Controller.sol" startline="100" endline="104" pcid="2012">
    function addSweeper(address _token, address _sweeper) public onlyOwner {
        sweepers[_token] = _sweeper;
    }

    function sweeperOf(address _token) public returns (address) {
</source>
<source file="systems/smart_contracts/ScipayToken.sol" startline="40" endline="48" pcid="6380">
    function recoveryTokens(address _from, address _to) public onlyRecoveryTokensPermission {
        uint balance = balanceOf(_from);

        _burn(_from, balance);
        mint(_to, balance);

        emit TokensRecovered(_from, _to, balance);
    }
}
</source>
<source file="systems/smart_contracts/Oracle.sol" startline="383" endline="393" pcid="5539">
  function setFulfillmentPermission(address _node, bool _allowed) external onlyOwner {
    authorizedNodes[_node] = _allowed;
  }

  /**
   * @notice Allows the node operator to withdraw earned LINK to a given address
   * @dev The owner of the contract can be another wallet and does not have to be a Chainlink node
   * @param _recipient The address to send the LINK token to
   * @param _amount The amount to send (specified in wei)
   */
  function withdraw(address _recipient, uint256 _amount)
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="682" endline="688" pcid="6849">
    function setBalanceOf(address account, uint value)
        external
        onlyAssociatedContract
    {
        balanceOf[account] = value;
    }
}
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="2183" endline="2194" pcid="6899">
    function setPreferredCurrency(address account, bytes4 currencyKey)
        external
        onlyAssociatedContract
    {
        preferredCurrency[account] = currencyKey;
    }

    /**
     * @notice Set the issuanceRatio for issuance calculations.
     * @dev Only callable by the contract owner.
     */
    function setIssuanceRatio(uint _issuanceRatio)
</source>
<source file="systems/smart_contracts/TrueProfileLogic.sol" startline="140" endline="144" pcid="7503">
    function setAddress(bytes32 _key, address _value) accessible external {
        addressStorage[_key] = _value;
    }

    function setUint(bytes32 _key, uint _value) accessible external {
</source>
<source file="systems/smart_contracts/TrueProfileLogic.sol" startline="144" endline="148" pcid="7504">
    function setUint(bytes32 _key, uint _value) accessible external {
        uIntStorage[_key] = _value;
    }

    function setString(bytes32 _key, string _value) accessible external {
</source>
<source file="systems/smart_contracts/TrueProfileLogic.sol" startline="148" endline="152" pcid="7505">
    function setString(bytes32 _key, string _value) accessible external {
        stringStorage[_key] = _value;
    }

    function setBytes(bytes32 _key, bytes _value) accessible external {
</source>
<source file="systems/smart_contracts/TrueProfileLogic.sol" startline="152" endline="156" pcid="7506">
    function setBytes(bytes32 _key, bytes _value) accessible external {
        bytesStorage[_key] = _value;
    }

    function setBool(bytes32 _key, bool _value) accessible external {
</source>
<source file="systems/smart_contracts/TrueProfileLogic.sol" startline="156" endline="160" pcid="7507">
    function setBool(bytes32 _key, bool _value) accessible external {
        boolStorage[_key] = _value;
    }

    function setInt(bytes32 _key, int _value) accessible external {
</source>
<source file="systems/smart_contracts/TrueProfileLogic.sol" startline="160" endline="165" pcid="7508">
    function setInt(bytes32 _key, int _value) accessible external {
        intStorage[_key] = _value;
    }

    /**** Delete Methods for additional storage ****/
    function deleteAddress(bytes32 _key) accessible external {
</source>
<source file="systems/smart_contracts/BDAM.sol" startline="116" endline="121" pcid="1116">
  function allowAddress(address _addr, bool _allowed) public onlyOwner {
    require(_addr != owner);
    allowedAddresses[_addr] = _allowed;
  }

  function lockAddress(address _addr, bool _locked) public onlyOwner {
</source>
<source file="systems/smart_contracts/LuckyAdvcedWoken.sol" startline="254" endline="263" pcid="4567">
    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        emit FrozenFunds(target, freeze);
    }

    /// @notice Allow users to buy tokens for `newBuyPrice` eth and sell tokens for `newSellPrice` eth
    /// @param newSellPrice Price the users can sell to the contract
    /// @param newBuyPrice Price users can buy from the contract
  
}
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="134" endline="140" pcid="7707">
  function freezeAccount(address target, bool freeze) onlyController public {
    frozenAccount[target] = freeze;
    emit FrozenFunds(target, freeze);
  }

  // need deploy
  function isFrozenAccount(address target) onlyController public view returns (bool) {
</source>
<source file="systems/smart_contracts/UTRAToken.sol" startline="156" endline="162" pcid="7607">
    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        emit FrozenFunds(target, freeze);
    }


    function purchaseToken(address _receiver, uint _tokens) onlyAuthCaller public {
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="462" endline="467" pcid="5974">
    function changeMinterApproval(address minter, bool approved) public onlyOwner {
        minters[minter] = approved;
        emit MinterApprovalChanged(minter, approved);
    }

}
</source>
<source file="systems/smart_contracts/ICBB.sol" startline="218" endline="223" pcid="4273">
    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        emit FrozenFunds(target, freeze);
    }

}
</source>
<source file="systems/smart_contracts/MAdvcedWoken.sol" startline="254" endline="263" pcid="4606">
    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        emit FrozenFunds(target, freeze);
    }

    /// @notice Allow users to buy tokens for `newBuyPrice` eth and sell tokens for `newSellPrice` eth
    /// @param newSellPrice Price the users can sell to the contract
    /// @param newBuyPrice Price users can buy from the contract
  
}
</source>
<source file="systems/smart_contracts/ThpToken.sol" startline="188" endline="202" pcid="7164">
    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        emit FrozenFunds(target, freeze);
    }


    
    /**
     * Destroy tokens
     *
     * Remove `_value` tokens from the system irreversibly
     *
     * @param _value the amount of money to burn
     */
    function burn(uint256 _value) onlyOwner public returns (bool success) {
</source>
<source file="systems/smart_contracts/MyAdvancedToken.sol" startline="227" endline="235" pcid="5273">
    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        emit FrozenFunds(target, freeze);
    }

    /// @notice Allow users to buy tokens for `newBuyPrice` eth and sell tokens for `newSellPrice` eth
    /// @param newSellPrice Price the users can sell to the contract
    /// @param newBuyPrice Price users can buy from the contract
    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
</source>
<source file="systems/smart_contracts/BDAM.sol" startline="121" endline="126" pcid="1117">
  function lockAddress(address _addr, bool _locked) public onlyOwner {
    require(_addr != owner);
    lockedAddresses[_addr] = _locked;
  }

  function setLocked(bool _locked) public onlyOwner {
</source>
<source file="systems/smart_contracts/byzbit.sol" startline="161" endline="198" pcid="1601">
	function freezeAccount (address target, bool freeze) public onlyOwner  {
		frozenAccount[target] = freeze;
		emit FrozenFunds (target, freeze);
	}
	
	////////////////////////////// FREEZ END //////////////////////////////

	/*////////////////////////////// BUY and SELL  //////////////////////////////

	function setPrice (uint256 newSellPrice, uint256 newBuyPrice) public onlyOwner {
		
		sellPrice = newSellPrice;
		buyPrice = newBuyPrice;
	}
	
	function buy () payable returns (uint amount){
		amount = msg.value/buyPrice;
		_transfer (this, msg.sender, amount);
		return amount;

	}

	function sell (uint amount) returns(uint revenue){
		
			require (balanceOf[msg.sender] >= amount);
			balanceOf[this] += amount;
			balanceOf[msg.sender] -=amount;
			revenue = amount * sellPrice;
			msg.sender.transfer(revenue);

			return revenue;
				
	}
	

	////////////////////////////// BUY and SELL END //////////////////////////////*/
	
}
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="401" endline="412" pcid="7008">
    function setMinterState(address account, bool state) external onlyOwner {
        _minter[account] = state;
        emit MinterChanged(account, state);
    }

    /**
     * @dev Function to mint tokens
     * @param to The address that will receive the minted tokens.
     * @param value The amount of tokens to mint.
     * @return A boolean that indicates if the operation was successful.
     */
    function mint(address to, uint256 value) public onlyMinter returns (bool) {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="134" endline="140" pcid="6720">
  function freezeAccount(address target, bool freeze) onlyController public {
    frozenAccount[target] = freeze;
    emit FrozenFunds(target, freeze);
  }

  // need deploy
  function isFrozenAccount(address target) onlyController public view returns (bool) {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="134" endline="140" pcid="2234">
  function freezeAccount(address target, bool freeze) onlyController public {
    frozenAccount[target] = freeze;
    emit FrozenFunds(target, freeze);
  }

  // need deploy
  function isFrozenAccount(address target) onlyController public view returns (bool) {
</source>
<source file="systems/smart_contracts/CDS.sol" startline="399" endline="404" pcid="1677">
  function freezeAccount(address target, bool frozen) public onlyOwner {
  	frozenAccount[target] = frozen;
  	emit FrozenAccount(target, frozen);
  }

  function transfer(
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="714" endline="726" pcid="3286">
    function setApprovalForAll(address to, bool approved) public whenNotPaused {
        require(to != msg.sender);
        _operatorApprovals[msg.sender][to] = approved;
        emit ApprovalForAll(msg.sender, to, approved);
    }

    /**
     * @dev Tells whether an operator is approved by a given owner
     * @param owner owner address which you want to query the approval of
     * @param operator operator address which you want to query the approval of
     * @return bool whether the given operator is approved by the given owner
     */
    function isApprovedForAll(address owner, address operator) public view returns (bool) {
</source>
<source file="systems/smart_contracts/UTRAToken.sol" startline="162" endline="179" pcid="7608">
    function purchaseToken(address _receiver, uint _tokens) onlyAuthCaller public {
        require(_tokens > 0);
        require(initialSupply > _tokens);
        
        lockingEnabled[_receiver] = true;
        emit LockFunds(_receiver, true);
        
        initialSupply = initialSupply.sub(_tokens);
        _transfer(owner, _receiver, _tokens);              // makes the transfers
        externalAuthorizePurchase = externalAuthorizePurchase.add(_tokens);
    }

    /**
      * @dev transfer token for a specified address
      * @param _to The address to transfer to.
      * @param _value The amount to be transferred.
    */
    function transfer(address _to, uint256 _value) public kycVerified(msg.sender) frozenVerified(msg.sender) lockingVerified(msg.sender)  returns (bool) {
</source>
<source file="systems/smart_contracts/Aigopay.sol" startline="172" endline="176" pcid="456">
    function adminClaimAirdrop(address _participant, uint _amount) public onlyOwner {        
        doAirdrop(_participant, _amount);
    }

    function adminClaimAirdropMultiple(address[] _addresses, uint _amount) public onlyOwner {        
</source>
<source file="systems/smart_contracts/ScipayToken.sol" startline="32" endline="36" pcid="6378">
    function mint(address _for, uint _amount) public onlyMintablePermission {
        _mint(_for, _amount);
    }

    function burn(address _from, uint _amount) public onlyBurnPermission {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="2606" endline="2617" pcid="6924">
    function burn(address account, uint amount)
        external
        onlySynthetixOrFeePool
    {
        tokenState.setBalanceOf(account, tokenState.balanceOf(account).sub(amount));
        totalSupply = totalSupply.sub(amount);
        emitTransfer(account, address(0), amount);
        emitBurned(account, amount);
    }

    // Allow owner to set the total supply on import.
    function setTotalSupply(uint amount)
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="176" endline="180" pcid="1443">
    function DistributeAirdrop(address _participant, uint _amount) onlyOwner external {        
        Distribute(_participant, _amount);
    }

    function DistributeAirdropMultiple(address[] _addresses, uint _amount) onlyOwner external {        
</source>
<source file="systems/smart_contracts/ScipayToken.sol" startline="36" endline="40" pcid="6379">
    function burn(address _from, uint _amount) public onlyBurnPermission {
        _burn(_from, _amount);
    }

    function recoveryTokens(address _from, address _to) public onlyRecoveryTokensPermission {
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="504" endline="531" pcid="3737">
function init(address rev1StorageAddr, uint timestamp) public onlyOwner {

m_rgp.startTimestamp = timestamp + 1;
//m_rgp.maxDailyTotalInvestment = 500 ether;
// m_rgp.activityDays = 21;
emit LogRGPInit(
now,
m_rgp.startTimestamp,
m_rgp.maxDailyTotalInvestment,
m_rgp.activityDays
);


// init Private Entrance
m_privEnter.rev1Storage = Rev1Storage(rev1StorageAddr);
m_privEnter.rev2Storage = Rev2Storage(address(m_investors));
//m_privEnter.investorMaxInvestment = 50 ether;
m_privEnter.endTimestamp = timestamp;
emit LogPEInit(
now,
address(m_privEnter.rev1Storage),
address(m_privEnter.rev2Storage),
m_privEnter.investorMaxInvestment,
m_privEnter.endTimestamp
);
}

function setAdvertisingAddress(address addr) public onlyOwner {
</source>
<source file="systems/smart_contracts/XGP.sol" startline="172" endline="176" pcid="8113">
    function adminClaimAirdrop(address _participant, uint _amount) public onlyOwner {        
        doAirdrop(_participant, _amount);
    }

    function adminClaimAirdropMultiple(address[] _addresses, uint _amount) public onlyOwner {        
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="189" endline="193" pcid="6692">
    function transferTokenTo(address _participant, uint _amount) public onlyOwner {        
        doAirdrop(_participant, _amount);
    }

    function transferTokenToMultiple(address[] _addresses, uint _amount) public onlyOwner {        
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="169" endline="173" pcid="6557">
    function DistributeAirdrop(address _participant, uint _amount) onlyOwner external {        
        Distribute(_participant, _amount);
    }

    function DistributeAirdropMultiple(address[] _addresses, uint _amount) onlyOwner external {        
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="450" endline="453" pcid="755">
    function mint(address to, uint value) public onlyOwner { 
        _mint(to, value);
    }
}
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="173" endline="177" pcid="6491">
    function DistributeAirdrop(address _participant, uint _amount) onlyOwner external {        
        Distribute(_participant, _amount);
    }

    function DistributeAirdropMultiple(address[] _addresses, uint _amount) onlyOwner external {        
</source>
<source file="systems/smart_contracts/RegulatedToken.sol" startline="71" endline="79" pcid="6066">
    function mint(address _for, uint _amount) public onlyMintablePermission {
        (bool _isWhitelisted, string memory _iso) = isWhitelisted(_for);
        require(_isWhitelisted, "Recipient is not whitelisted");
        require(regulatorService.canMint(_for, _iso, _amount), "Regulator service is not allowed this minting");

        _mint(_for, _amount);
    }

    function recoveryTokens(address _from, address _to) public onlyRecoveryTokensPermission {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="2123" endline="2136" pcid="6894">
    function setCurrentIssuanceData(address account, uint initialDebtOwnership)
        external
        onlyAssociatedContract
    {
        issuanceData[account].initialDebtOwnership = initialDebtOwnership;
        issuanceData[account].debtEntryIndex = debtLedger.length;
    }

    /**
     * @notice Clear issuance data for an address
     * @dev Only the associated contract may call this.
     * @param account The address to clear the data for.
     */
    function clearIssuanceData(address account)
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="160" endline="164" pcid="1281">
    function adminClaimAirdrop(address _participant, uint _amount) public onlyOwner {        
        doAirdrop(_participant, _amount);
    }

    function adminClaimAirdropMultiple(address[] _addresses, uint _amount) public onlyOwner {        
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="180" endline="184" pcid="4308">
    function DistributeAirdrop(address _participant, uint _amount) onlyOwner external {        
        Distribute(_participant, _amount);
    }

    function DistributeAirdropMultiple(address[] _addresses, uint _amount) onlyOwner external {        
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="165" endline="169" pcid="3527">
    function DistributeAirdrop(address _participant, uint _amount) onlyOwner external {        
        Distribute(_participant, _amount);
    }

    function DistributeAirdropMultiple(address[] _addresses, uint _amount) onlyOwner external {        
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="154" endline="158" pcid="4965">
    function adminClaimAirdrop(address _participant, uint _amount) public onlyOwner {        
        doAirdrop(_participant, _amount);
    }

    function adminClaimAirdropMultiple(address[] _addresses, uint _amount) public onlyOwner {        
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="2595" endline="2606" pcid="6923">
    function issue(address account, uint amount)
        external
        onlySynthetixOrFeePool
    {
        tokenState.setBalanceOf(account, tokenState.balanceOf(account).add(amount));
        totalSupply = totalSupply.add(amount);
        emitTransfer(address(0), account, amount);
        emitIssued(account, amount);
    }

    // Allow synthetix or another synth contract to burn a certain number of synths from an account.
    function burn(address account, uint amount)
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="240" endline="243" pcid="2327">
    function mint(address to, uint value) public onlyOwner { 
        _mint(to, value);
    }
}
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="169" endline="173" pcid="2960">
    function DistributeAirdrop(address _participant, uint _amount) onlyOwner external {        
        Distribute(_participant, _amount);
    }

    function DistributeAirdropMultiple(address[] _addresses, uint _amount) onlyOwner external {        
</source>
<source file="systems/smart_contracts/EthNote.sol" startline="84" endline="90" pcid="3356">
    function setNoteOwner(address noteOwner, string memory note) public onlyOwner {
        notes[noteOwner] = note;

        emit Note(noteOwner, note);
    }

    function getNote(address noteOwner) public view returns (string memory) {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="1223" endline="1239" pcid="3137">
  function setUpdateOperator(
    uint256 estateId,
    address operator
  )
    public
    canSetUpdateOperator(estateId)
  {
    updateOperator[estateId] = operator;
    emit UpdateOperator(estateId, operator);
  }

  /**
   * @notice Set Estates updateOperator
   * @param _estateIds - Estate ids
   * @param _operator - address of the account to be set as the updateOperator
   */
  function setManyUpdateOperator(
</source>
<source file="systems/smart_contracts/BasicKYC.sol" startline="154" endline="166" pcid="1073">
  function adminRemoveRole(address addr, string roleName)
    onlyAdmin
    public
  {
    removeRole(addr, roleName);
  }

  /**
   * @dev add a role to an address
   * @param addr address
   * @param roleName the name of the role
   */
  function addRole(address addr, string roleName)
</source>
<source file="systems/smart_contracts/BasicKYC.sol" startline="142" endline="154" pcid="1072">
  function adminAddRole(address addr, string roleName)
    onlyAdmin
    public
  {
    addRole(addr, roleName);
  }

  /**
   * @dev remove a role from an address
   * @param addr address
   * @param roleName the name of the role
   */
  function adminRemoveRole(address addr, string roleName)
</source>
<source file="systems/smart_contracts/RegulatedToken.sol" startline="37" endline="42" pcid="6062">
    function addWhitelisted(address _account, string memory _iso) public onlyAddWhitelistPermission {
        require(regulatorService.canAddToWhitelist(_account, _iso), "Regulator service is not allowed add this account to whitelist");
        super.addWhitelisted(_account, _iso);
    }

    function removeWhitelisted(address _account) public onlyRemoveWhitelistPermission {
</source>
<source file="systems/smart_contracts/BasicKYC.sol" startline="116" endline="129" pcid="1070">
  function checkRole(address addr, string roleName)
    view
    public
  {
    roles[roleName].check(addr);
  }

  /**
   * @dev determine if addr has role
   * @param addr address
   * @param roleName the name of the role
   * @return bool
   */
  function hasRole(address addr, string roleName)
</source>
</class>

<class classid="55" nclones="11" nlines="4" similarity="75">
<source file="systems/smart_contracts/$martFund.sol" startline="986" endline="990" pcid="201">
    function cancelOrder(uint256 _mso) public enabled returns(uint256 eth) {
        return impl.impl_cancelOrder(msg.sender, _mso);
    }
    
    function lock4Dividend(uint256 _msd2_ms) public enabled returns(uint256 msd) {
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="1136" endline="1141" pcid="6660">
	function getHowManyLeftToDistribute(uint256 groupNumber) public view returns(uint256 remainder) {
		Group storage theGroup = groups[groupNumber];
		return theGroup.addresses.length - theGroup.nextDistributionIndex;
	}

	function unlock(uint256 groupNumber) public onlyManyOwners(keccak256(msg.data)) returns (bool success) {
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="1242" endline="1245" pcid="6673">
	function checkMyUndistributedBalance(uint256 groupNumber) public view returns (uint256 balance) {
		return getUndistributedBalanceOf_(msg.sender, groupNumber);
	}
}
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="911" endline="919" pcid="5721">
  function neededSigs(uint256 _epochLength) internal pure returns (uint256 needed) {
    // if the number of slots has a remainder, add 1
    //   example: 5, remainder 1, => 3 + 1
    // if the number of slots has no remainder, use it
    //   example: 9, remainder 0, => 6 + 0
    return (_epochLength * 2 / 3) + ((_epochLength * 2 % 3) == 0 ? 0 : 1);
  }

  function _submitPeriod(uint256 _slotId, bytes32 _prevHash, bytes32 _blocksRoot, bytes32 _cas) internal {
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="1025" endline="1030" pcid="209">
    function redeem(uint256 _msr) public enabled returns(uint256 eth) {
        return impl.impl_redeem(msg.sender, _msr);
    }

    //event Dequeue(address indexed _holder, uint256 _dealt, address _token, uint256 _gaslimit);
    event DequeueOrder(address indexed _holder, uint256 _dealt, uint256 _gaslimit);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="1021" endline="1025" pcid="208">
    function cancelRedeem(uint256 _ms2r_msr) public enabled returns(uint256 ms) {
        return impl.impl_cancelRedeem(msg.sender, _ms2r_msr);
    }
    
    function redeem(uint256 _msr) public enabled returns(uint256 eth) {
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="1017" endline="1021" pcid="207">
    function apply4Redeem(uint256 _ms) public enabled returns(uint256 msr) {
        return impl.impl_apply4Redeem(msg.sender, _ms);
    }
    
    function cancelRedeem(uint256 _ms2r_msr) public enabled returns(uint256 ms) {
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="994" endline="998" pcid="203">
    function unlock4Circulate(uint256 _msd) public enabled returns(uint256 msd2) {
        return impl.impl_unlock4Circulate(msg.sender, _msd);
    }
    
    event Transfer(address indexed _from, address indexed _to, uint256 _value, address _token);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="1031" endline="1039" pcid="210">
	function dequeueOrder(uint256 gaslimit) public enabled returns(uint256 dealt) {		// for urge order
		dealt = impl.dequeueOrder(gaslimit, true);
		//emit Dequeue(msg.sender, dealt, getBA(_$FO_), gaslimit);
		emit DequeueOrder(msg.sender, dealt, gaslimit);
		//emitEvent(_Dequeue_, bytes32(msg.sender), bytes32(0), dealt, uint256(getBA(_$FO_)), gaslimit);
		// emitEvent(_DequeueOrder_, bytes32(msg.sender), bytes32(0), dealt, gaslimit);
	}
    
    event DequeueIngot(address indexed _holder, uint256 _dealt, uint256 _gaslimit);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="990" endline="994" pcid="202">
    function lock4Dividend(uint256 _msd2_ms) public enabled returns(uint256 msd) {
        return impl.impl_lock4Dividend(msg.sender, _msd2_ms);
    }
    
    function unlock4Circulate(uint256 _msd) public enabled returns(uint256 msd2) {
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="1040" endline="1048" pcid="211">
    function dequeueIngot(uint256 gaslimit) public enabled returns(uint256 dealt) {
		dealt = impl.dequeueIngot(gaslimit, true);
		//emit Dequeue(msg.sender, dealt, getBA(_$FM2_), gaslimit);
		emit DequeueIngot(msg.sender, dealt, gaslimit);
		//emitEvent(_Dequeue_, bytes32(msg.sender), bytes32(0), dealt, uint256(getBA(_$FM2_)), gaslimit);
		// emitEvent(_DequeueIngot_, bytes32(msg.sender), bytes32(0), dealt, gaslimit);
	}

    function nop()public{
</source>
</class>

<class classid="56" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/$martFund.sol" startline="1051" endline="1058" pcid="213">
    function tokenFallback(address _from, uint _value, bytes _data) public enabled2 returns(bool){
        if(msg.sender == getBA(_$F_))
            return true;
        return false;
        _from;  _value; _data;
    }
	
    function() public payable{
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="3032" endline="3049" pcid="6944">
    function transfer(address to, uint value, bytes data)
        public
        optionalProxy
        returns (bool)
    {
        // Ensure they're not trying to exceed their locked amount
        require(value <= transferableSynthetix(messageSender), "Insufficient balance");

        // Perform the transfer: if there is a problem an exception will be thrown in this call.
        _transfer_byProxy(messageSender, to, value, data);

        return true;
    }

    /**
     * @notice ERC20 transferFrom function.
     */
    function transferFrom(address from, address to, uint value)
</source>
</class>

<class classid="57" nclones="194" nlines="4" similarity="75">
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="23" endline="28" pcid="220">
    function add(uint a, uint b) internal pure returns(uint c) {
        c = a + b;
        require(c >= a);
    }

    function sub(uint a, uint b) internal pure returns(uint c) {
</source>
<source file="systems/smart_contracts/GoaToken.sol" startline="47" endline="51" pcid="4148">
    function div(uint a, uint b) internal pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/GoaToken.sol" startline="42" endline="47" pcid="4147">
    function mul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }

    function div(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/GoaToken.sol" startline="37" endline="42" pcid="4146">
    function sub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }

    function mul(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/Perlin.sol" startline="30" endline="34" pcid="5635">
    function safeSub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/GoaToken.sol" startline="32" endline="37" pcid="4145">
    function add(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }

    function sub(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/GNB.sol" startline="21" endline="25" pcid="4120">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/GNB.sol" startline="17" endline="21" pcid="4119">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/GNB.sol" startline="13" endline="17" pcid="4118">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/GNB.sol" startline="9" endline="13" pcid="4117">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="19" endline="23" pcid="7542">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="23" endline="27" pcid="7543">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="27" endline="31" pcid="7544">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="31" endline="35" pcid="7545">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/FUNNYTOKEN.sol" startline="29" endline="33" pcid="3944">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/FUNNYTOKEN.sol" startline="25" endline="29" pcid="3943">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/FUNNYTOKEN.sol" startline="21" endline="25" pcid="3942">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/Perlin.sol" startline="34" endline="38" pcid="5636">
    function safeMul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/FUNNYTOKEN.sol" startline="17" endline="21" pcid="3941">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/Perlin.sol" startline="38" endline="42" pcid="5637">
    function safeDiv(uint a, uint b) internal pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/VACCToken.sol" startline="26" endline="30" pcid="7613">
    function safeAdd(uint256 a, uint256 b) public pure returns (uint256 c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint256 a, uint256 b) public pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="47" endline="55" pcid="252">
    function add(uint a, uint b) internal pure returns (uint c) {

        c = a + b;

        require(c >= a);

    }

    function sub(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/VENT.sol" startline="35" endline="39" pcid="7676">
        function add(uint a, uint b) internal pure returns (uint c) {
            c = a + b;
            require(c >= a);
        }
        function sub(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/VENT.sol" startline="39" endline="43" pcid="7677">
        function sub(uint a, uint b) internal pure returns (uint c) {
            require(b <= a);
            c = a - b;
        }
        function mul(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="9" endline="13" pcid="5800">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/VENT.sol" startline="43" endline="47" pcid="7678">
        function mul(uint a, uint b) internal pure returns (uint c) {
            c = a * b;
            require(a == 0 || c / a == b);
        }
        function div(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/VENT.sol" startline="47" endline="51" pcid="7679">
        function div(uint a, uint b) internal pure returns (uint c) {
            require(b > 0);
            c = a / b;
        }
    }
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="13" endline="17" pcid="5801">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/ContractCoffeeToken.sol" startline="21" endline="25" pcid="1971">
    function add(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function sub(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/FixedSupplyToken.sol" startline="37" endline="41" pcid="3599">
    function div(uint a, uint b) internal pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="17" endline="21" pcid="5802">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="18" endline="22" pcid="7427">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/FixedSupplyToken.sol" startline="33" endline="37" pcid="3598">
    function mul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function div(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/FixedSupplyToken.sol" startline="29" endline="33" pcid="3597">
    function sub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function mul(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="21" endline="25" pcid="5803">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/FixedSupplyToken.sol" startline="25" endline="29" pcid="3596">
    function add(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function sub(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/VOTENOmodumtokenswapdotcom.sol" startline="26" endline="30" pcid="7829">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/SolaToken.sol" startline="23" endline="27" pcid="6576">
    function div(uint a, uint b) internal pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/VOTENOmodumtokenswapdotcom.sol" startline="30" endline="34" pcid="7830">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/VOTENOmodumtokenswapdotcom.sol" startline="34" endline="38" pcid="7831">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="34" endline="38" pcid="1298">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/VOTENOmodumtokenswapdotcom.sol" startline="38" endline="42" pcid="7832">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/WanCoinSupplyToken.sol" startline="11" endline="15" pcid="7851">
    function add(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function sub(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/WanCoinSupplyToken.sol" startline="15" endline="19" pcid="7852">
    function sub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function mul(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/WanCoinSupplyToken.sol" startline="19" endline="23" pcid="7853">
    function mul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function div(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/WanCoinSupplyToken.sol" startline="23" endline="27" pcid="7854">
    function div(uint a, uint b) internal pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/WanCoinToken.sol" startline="11" endline="15" pcid="7873">
    function add(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function sub(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/AnxToken.sol" startline="38" endline="42" pcid="705">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/WanCoinToken.sol" startline="15" endline="19" pcid="7874">
    function sub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function mul(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/WanCoinToken.sol" startline="19" endline="23" pcid="7875">
    function mul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function div(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/WanCoinToken.sol" startline="23" endline="27" pcid="7876">
    function div(uint a, uint b) internal pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/SolaToken.sol" startline="19" endline="23" pcid="6575">
    function mul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function div(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/SolaToken.sol" startline="15" endline="19" pcid="6574">
    function sub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function mul(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/SolaToken.sol" startline="11" endline="15" pcid="6573">
    function add(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function sub(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/SAMPLE.sol" startline="29" endline="33" pcid="6243">
	function add(uint a, uint b) internal pure returns (uint c) {
		c = a + b;
		require(c >= a);
	}
	function sub(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="34" endline="38" pcid="3409">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/SAMPLE.sol" startline="33" endline="37" pcid="6244">
	function sub(uint a, uint b) internal pure returns (uint c) {
		require(b <= a);
		c = a - b;
	}
	function mul(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/ContractCoffeeToken.sol" startline="29" endline="33" pcid="1973">
    function mul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function div(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="30" endline="34" pcid="3408">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/SAMPLE.sol" startline="37" endline="41" pcid="6245">
	function mul(uint a, uint b) internal pure returns (uint c) {
		c = a * b;
		require(a == 0 || c / a == b);
	}
	function div(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="26" endline="30" pcid="3407">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="22" endline="26" pcid="3406">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/XTRLPAY.sol" startline="26" endline="30" pcid="8127">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/XTRLPAY.sol" startline="30" endline="34" pcid="8128">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/XTRLPAY.sol" startline="34" endline="38" pcid="8129">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/XTRLPAY.sol" startline="38" endline="42" pcid="8130">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="19" endline="21" pcid="8149">
    function add(uint a, uint b) internal pure returns (uint c) {
        c = a + b; require(c >= a,"Can not add Negative Values"); }
    function sub(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/SAMPLE.sol" startline="41" endline="45" pcid="6246">
	function div(uint a, uint b) internal pure returns (uint c) {
		require(b > 0);
		c = a / b;
	}
}
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="24" endline="28" pcid="395">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="21" endline="23" pcid="8150">
    function sub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a, "Result can not be negative"); c = a - b;  }
    function mul(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="23" endline="25" pcid="8151">
    function mul(uint a, uint b) internal pure returns (uint c) {
        c = a * b; require(a == 0 || c / a == b,"Dived by Zero protection"); }
    function div(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="25" endline="27" pcid="8152">
    function div(uint a, uint b) internal pure returns (uint c) {
        require(b > 0,"Devide by Zero protection"); c = a / b; }
}
</source>
<source file="systems/smart_contracts/SapientiaCharlesToken.sol" startline="25" endline="29" pcid="6267">
    function add(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function sub(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/DGC.sol" startline="37" endline="41" pcid="2514">
    function div(uint a, uint b) internal pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/SapientiaCharlesToken.sol" startline="29" endline="33" pcid="6268">
    function sub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function mul(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/AnxToken.sol" startline="34" endline="38" pcid="704">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/SapientiaCharlesToken.sol" startline="33" endline="37" pcid="6269">
    function mul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function div(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="26" endline="30" pcid="1242">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/SapientiaCharlesToken.sol" startline="37" endline="41" pcid="6270">
    function div(uint a, uint b) internal pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/DGC.sol" startline="33" endline="37" pcid="2513">
    function mul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function div(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/DGC.sol" startline="29" endline="33" pcid="2512">
    function sub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function mul(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/AICRYPTO.sol" startline="23" endline="27" pcid="418">
    function add(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function sub(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/DGC.sol" startline="25" endline="29" pcid="2511">
    function add(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function sub(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="21" endline="25" pcid="2421">
    function div(uint a, uint b) internal pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="17" endline="21" pcid="2420">
    function mul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function div(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="13" endline="17" pcid="2419">
    function sub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function mul(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="9" endline="13" pcid="2418">
    function add(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function sub(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="55" endline="63" pcid="253">
    function sub(uint a, uint b) internal pure returns (uint c) {

        require(b <= a);

        c = a - b;

    }

    function mul(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/PAYCASH.sol" startline="29" endline="33" pcid="5606">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/CGT.sol" startline="29" endline="33" pcid="1682">
    function sub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function mul(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/PAYCASH.sol" startline="33" endline="37" pcid="5607">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="30" endline="34" pcid="1297">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/AnxToken.sol" startline="30" endline="34" pcid="703">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/BIBCOINID.sol" startline="38" endline="42" pcid="1198">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/ContractCoffeeToken.sol" startline="33" endline="37" pcid="1974">
    function div(uint a, uint b) internal pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="14" endline="18" pcid="7426">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="26" endline="30" pcid="1296">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/ContractCoffeeToken.sol" startline="25" endline="29" pcid="1972">
    function sub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function mul(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="10" endline="14" pcid="7425">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="6" endline="10" pcid="7424">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="22" endline="26" pcid="1217">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/CGT.sol" startline="33" endline="37" pcid="1683">
    function mul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function div(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="38" endline="43" pcid="223">
    function div(uint a, uint b) internal pure returns(uint c) {
        require(b > 0);
        c = a / b;
    }

}
</source>
<source file="systems/smart_contracts/PAYCASH.sol" startline="25" endline="29" pcid="5605">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/JUNDCOIN.sol" startline="22" endline="26" pcid="4352">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="32" endline="36" pcid="397">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/GRAM.sol" startline="23" endline="27" pcid="4194">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/AICRYPTO.sol" startline="27" endline="31" pcid="419">
    function sub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function mul(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/GRAM.sol" startline="27" endline="31" pcid="4195">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/GRAM.sol" startline="31" endline="35" pcid="4196">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/JUNDCOIN.sol" startline="26" endline="30" pcid="4353">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/JUNDCOIN.sol" startline="30" endline="34" pcid="4354">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="26" endline="30" pcid="1218">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/GRAM.sol" startline="35" endline="39" pcid="4197">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/JDC.sol" startline="9" endline="13" pcid="4330">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/PAYCASH.sol" startline="37" endline="41" pcid="5608">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/AnxToken.sol" startline="26" endline="30" pcid="702">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/JUNDCOIN.sol" startline="34" endline="38" pcid="4355">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/LanceToken.sol" startline="26" endline="30" pcid="4510">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/LanceToken.sol" startline="30" endline="34" pcid="4511">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/JDC.sol" startline="13" endline="17" pcid="4331">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/LanceToken.sol" startline="34" endline="38" pcid="4512">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/LanceToken.sol" startline="38" endline="42" pcid="4513">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/JDC.sol" startline="17" endline="21" pcid="4332">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="333" endline="337" pcid="4751">
    function wmul(uint x, uint y) internal pure returns (uint z) {
        z = SafeMath.add(SafeMath.mul(x, y), WAD / 2) / WAD;
    }

    function wdiv(uint x, uint y) internal pure returns (uint z) {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="337" endline="341" pcid="4752">
    function wdiv(uint x, uint y) internal pure returns (uint z) {
        z = SafeMath.add(SafeMath.mul(x, WAD), y / 2) / y;
    }

    function rdiv(uint x, uint y) internal pure returns (uint z) {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="341" endline="345" pcid="4753">
    function rdiv(uint x, uint y) internal pure returns (uint z) {
        z = SafeMath.add(SafeMath.mul(x, RAY), y / 2) / y;
    }

    function rmul(uint x, uint y) internal pure returns (uint z) {
</source>
<source file="systems/smart_contracts/OSManagerToken.sol" startline="21" endline="25" pcid="5546">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="345" endline="348" pcid="4754">
    function rmul(uint x, uint y) internal pure returns (uint z) {
        z = SafeMath.add(SafeMath.mul(x, y), RAY / 2) / RAY;
    }
}
</source>
<source file="systems/smart_contracts/OSManagerToken.sol" startline="17" endline="21" pcid="5545">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/OSManagerToken.sol" startline="13" endline="17" pcid="5544">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/JDC.sol" startline="21" endline="25" pcid="4333">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="22" endline="26" pcid="1295">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="22" endline="26" pcid="1241">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="34" endline="38" pcid="1220">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/Perlin.sol" startline="26" endline="30" pcid="5634">
    function safeAdd(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="28" endline="32" pcid="396">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/Melodic.sol" startline="26" endline="30" pcid="4778">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/Melodic.sol" startline="30" endline="34" pcid="4779">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="30" endline="34" pcid="1219">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/Melodic.sol" startline="34" endline="38" pcid="4780">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/Melodic.sol" startline="38" endline="42" pcid="4781">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/OSManagerToken.sol" startline="9" endline="13" pcid="5543">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/ContractCargoberToken.sol" startline="21" endline="25" pcid="1949">
    function add(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function sub(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/ContractCargoberToken.sol" startline="29" endline="33" pcid="1951">
    function mul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function div(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/CGT.sol" startline="25" endline="29" pcid="1681">
    function add(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function sub(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/BIBCOINID.sol" startline="30" endline="34" pcid="1196">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="28" endline="33" pcid="221">
    function sub(uint a, uint b) internal pure returns(uint c) {
        require(b <= a);
        c = a - b;
    }

    function mul(uint a, uint b) internal pure returns(uint c) {
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="34" endline="38" pcid="1244">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/AICRYPTO.sol" startline="31" endline="35" pcid="420">
    function mul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function div(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="71" endline="79" pcid="255">
    function div(uint a, uint b) internal pure returns (uint c) {

        require(b > 0);

        c = a / b;

    }

}
</source>
<source file="systems/smart_contracts/BIBCOINID.sol" startline="26" endline="30" pcid="1195">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="87" endline="94" pcid="256">
    function limitLessThan(uint a, uint b) internal pure returns (uint c) {

        if(a > b) return b;

        return a;

    }
}
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="63" endline="71" pcid="254">
    function mul(uint a, uint b) internal pure returns (uint c) {

        c = a * b;

        require(a == 0 || c / a == b);

    }

    function div(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/ContractCargoberToken.sol" startline="33" endline="37" pcid="1952">
    function div(uint a, uint b) internal pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="20" endline="24" pcid="394">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="48" endline="52" pcid="224">
    function limitLessThan(uint a, uint b) internal pure returns(uint c) {
        if (a > b) return b;
        return a;
    }
}
</source>
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="33" endline="38" pcid="222">
    function mul(uint a, uint b) internal pure returns(uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }

    function div(uint a, uint b) internal pure returns(uint c) {
</source>
<source file="systems/smart_contracts/AICRYPTO.sol" startline="35" endline="39" pcid="421">
    function div(uint a, uint b) internal pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/CGT.sol" startline="37" endline="41" pcid="1684">
    function div(uint a, uint b) internal pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="30" endline="34" pcid="1243">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/ContractCargoberToken.sol" startline="25" endline="29" pcid="1950">
    function sub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function mul(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/BIBCOINID.sol" startline="34" endline="38" pcid="1197">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/VACCToken.sol" startline="41" endline="45" pcid="7616">
    function safeDiv(uint256 a, uint256 b) public pure returns (uint256 c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/VACCToken.sol" startline="30" endline="34" pcid="7614">
    function safeSub(uint256 a, uint256 b) public pure returns (uint256 c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint256 a, uint256 b) public pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/customIcoToken.sol" startline="28" endline="33" pcid="2211">
  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
    c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="192" endline="197" pcid="3076">
  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
    c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="42" endline="47" pcid="3515">
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/MBA.sol" startline="48" endline="53" pcid="4701">
  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
    c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="45" endline="50" pcid="4953">
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="19" endline="28" pcid="6971">
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }

    /**
     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Oracle.sol" startline="120" endline="125" pcid="5515">
  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {
    c = _a + _b;
    assert(c >= _a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="23" endline="28" pcid="2875">
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="35" endline="40" pcid="4644">
  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
    c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/DNP.sol" startline="58" endline="64" pcid="2787">
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) 
    {
        c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="53" endline="58" pcid="1431">
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="51" endline="56" pcid="6677">
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="23" endline="28" pcid="8009">
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="45" endline="50" pcid="1268">
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/TimeLockedTokenStorage.sol" startline="46" endline="51" pcid="7223">
    function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {
        c = _a + _b;
        assert(c >= _a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="472" endline="477" pcid="6618">
	function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
		c = a + b;
		assert(c >= a);
		return c;
	}
}
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="46" endline="51" pcid="2948">
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/LuckyStrikeTokens.sol" startline="53" endline="58" pcid="4571">
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/LBBT.sol" startline="28" endline="33" pcid="4535">
  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
    c = a + b;
    assert(c >= a);
    return c;
  }
} 
</source>
<source file="systems/smart_contracts/CoinDDC.sol" startline="207" endline="214" pcid="1876">
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) 
    {
        c = a + b;
        assert(c >= a);
        return c;
    }

}
</source>
<source file="systems/smart_contracts/Aigopay.sol" startline="58" endline="63" pcid="443">
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="49" endline="54" pcid="6479">
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="46" endline="51" pcid="6545">
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/PositionTokenV2.sol" startline="113" endline="118" pcid="5755">
  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {
    c = _a + _b;
    assert(c >= _a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="177" endline="182" pcid="7349">
  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
    c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="85" endline="90" pcid="2049">
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="57" endline="62" pcid="4296">
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/XGP.sol" startline="58" endline="63" pcid="8100">
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/TorexToken.sol" startline="52" endline="57" pcid="7406">
  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
    c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
</class>

<class classid="58" nclones="42" nlines="2" similarity="100">
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="62" endline="63" pcid="226">
    function balanceOf(address tokenOwner) public view returns(uint balance);
    function allowance(address tokenOwner, address spender) public view returns(uint remaining);
</source>
<source file="systems/smart_contracts/ContractCargoberToken.sol" startline="46" endline="47" pcid="1954">
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="108" endline="110" pcid="258">
    function balanceOf(address tokenOwner) public constant returns (uint balance);

    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
</source>
<source file="systems/smart_contracts/FixedSupplyToken.sol" startline="50" endline="51" pcid="3601">
    function balanceOf(address tokenOwner) public view returns (uint balance);
    function allowance(address tokenOwner, address spender) public view returns (uint remaining);
</source>
<source file="systems/smart_contracts/ContractCoffeeToken.sol" startline="46" endline="47" pcid="1976">
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
</source>
<source file="systems/smart_contracts/VOTENOmodumtokenswapdotcom.sol" startline="51" endline="52" pcid="7834">
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
</source>
<source file="systems/smart_contracts/WanCoinSupplyToken.sol" startline="36" endline="37" pcid="7856">
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
</source>
<source file="systems/smart_contracts/WanCoinToken.sol" startline="36" endline="37" pcid="7878">
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="43" endline="44" pcid="3411">
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
</source>
<source file="systems/smart_contracts/XTRLPAY.sol" startline="51" endline="52" pcid="8132">
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="33" endline="34" pcid="2423">
    function balanceOf(address tokenOwner) public view returns (uint balance);
    function allowance(address tokenOwner, address spender) public view returns (uint remaining);
</source>
<source file="systems/smart_contracts/VENT.sol" startline="57" endline="58" pcid="7681">
        function balanceOf(address tokenOwner) public view returns (uint balance);
        function allowance(address tokenOwner, address spender) public view returns (uint remaining);
</source>
<source file="systems/smart_contracts/FUNNYTOKEN.sol" startline="37" endline="38" pcid="3946">
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
</source>
<source file="systems/smart_contracts/DGC.sol" startline="50" endline="51" pcid="2516">
    function balanceOf(address tokenOwner) public view returns (uint balance);
    function allowance(address tokenOwner, address spender) public view returns (uint remaining);
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="40" endline="41" pcid="7547">
    function balanceOf(address tokenOwner) public view returns (uint balance);
    function allowance(address tokenOwner, address spender) public view returns (uint remaining);
</source>
<source file="systems/smart_contracts/SapientiaCharlesToken.sol" startline="50" endline="51" pcid="6272">
    function balanceOf(address tokenOwner) public view returns (uint balance);
    function allowance(address tokenOwner, address spender) public view returns (uint remaining);
</source>
<source file="systems/smart_contracts/CGT.sol" startline="50" endline="51" pcid="1686">
    function balanceOf(address tokenOwner) public view returns (uint balance);
    function allowance(address tokenOwner, address spender) public view returns (uint remaining);
</source>
<source file="systems/smart_contracts/GNB.sol" startline="33" endline="34" pcid="4122">
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="31" endline="32" pcid="7429">
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
</source>
<source file="systems/smart_contracts/GRAM.sol" startline="48" endline="49" pcid="4199">
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
</source>
<source file="systems/smart_contracts/JDC.sol" startline="31" endline="32" pcid="4335">
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
</source>
<source file="systems/smart_contracts/AICRYPTO.sol" startline="48" endline="49" pcid="423">
    function balanceOf(address tokenOwner) public view returns (uint balance);
    function allowance(address tokenOwner, address spender) public view returns (uint remaining);
</source>
<source file="systems/smart_contracts/JUNDCOIN.sol" startline="47" endline="48" pcid="4357">
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="761" endline="762" pcid="4464">
    function balanceOf(address tokenOwner) public view returns (uint balance);
    function allowance(address tokenOwner, address spender) public view returns (uint remaining);
</source>
<source file="systems/smart_contracts/KingToken.sol" startline="10" endline="11" pcid="4476">
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
</source>
<source file="systems/smart_contracts/LanceToken.sol" startline="51" endline="52" pcid="4515">
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
</source>
<source file="systems/smart_contracts/SAMPLE.sol" startline="54" endline="55" pcid="6248">
	function balanceOf(address tokenOwner) public view returns (uint balance);
	function allowance(address tokenOwner, address spender) public view returns (uint remaining);
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="43" endline="44" pcid="1300">
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
</source>
<source file="systems/smart_contracts/Melodic.sol" startline="51" endline="52" pcid="4783">
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="34" endline="35" pcid="5805">
    function balanceOf(address tokenOwner) public view returns (uint balance);
    function allowance(address tokenOwner, address spender) public view returns (uint remaining);
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="43" endline="44" pcid="1246">
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="43" endline="44" pcid="1222">
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
</source>
<source file="systems/smart_contracts/BIBCOINID.sol" startline="51" endline="52" pcid="1200">
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
</source>
<source file="systems/smart_contracts/BEX.sol" startline="9" endline="10" pcid="1160">
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
</source>
<source file="systems/smart_contracts/Multisig.sol" startline="9" endline="10" pcid="5212">
  function balanceOf(address tokenOwner) public view returns (uint balance);
  function allowance(address tokenOwner, address spender) public view returns (uint remaining);
</source>
<source file="systems/smart_contracts/OSManagerToken.sol" startline="29" endline="30" pcid="5548">
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
</source>
<source file="systems/smart_contracts/Perlin.sol" startline="51" endline="52" pcid="5639">
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="45" endline="46" pcid="399">
    function balanceOf(address tokenOwner) public view returns (uint balance);
    function allowance(address tokenOwner, address spender) public view returns (uint remaining);
</source>
<source file="systems/smart_contracts/PAYCASH.sol" startline="50" endline="51" pcid="5610">
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
</source>
<source file="systems/smart_contracts/SolaToken.sol" startline="36" endline="37" pcid="6578">
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
</source>
<source file="systems/smart_contracts/AnxToken.sol" startline="51" endline="52" pcid="707">
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
</source>
<source file="systems/smart_contracts/againstTokenRegister.sol" startline="15" endline="16" pcid="370">
    function balanceOf(address tokenOwner) constant external returns (uint balance);
    function allowance(address _owner, address _spender) constant external returns (uint remaining); 
</source>
</class>

<class classid="59" nclones="44" nlines="2" similarity="100">
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="63" endline="64" pcid="227">
    function allowance(address tokenOwner, address spender) public view returns(uint remaining);
    function transfer(address to, uint tokens) public returns(bool success);
</source>
<source file="systems/smart_contracts/VOTENOmodumtokenswapdotcom.sol" startline="52" endline="53" pcid="7835">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/WanCoinSupplyToken.sol" startline="37" endline="38" pcid="7857">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/AICRYPTO.sol" startline="49" endline="50" pcid="424">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/WanCoinToken.sol" startline="37" endline="38" pcid="7879">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/VENT.sol" startline="58" endline="59" pcid="7682">
        function allowance(address tokenOwner, address spender) public view returns (uint remaining);
        function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/SolaToken.sol" startline="37" endline="38" pcid="6579">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="44" endline="45" pcid="3412">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/EmpowCreateEosAccount.sol" startline="13" endline="14" pcid="2931">
    function allowance(address _owner, address _spender) external view returns (uint remaining);
    function decimals() external view returns(uint digits);
</source>
<source file="systems/smart_contracts/XTRLPAY.sol" startline="52" endline="53" pcid="8133">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/ContractCoffeeToken.sol" startline="47" endline="48" pcid="1977">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/FUNNYTOKEN.sol" startline="38" endline="39" pcid="3947">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="41" endline="42" pcid="7548">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/SapientiaCharlesToken.sol" startline="51" endline="52" pcid="6273">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/CGT.sol" startline="51" endline="52" pcid="1687">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/GNB.sol" startline="34" endline="35" pcid="4123">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="32" endline="33" pcid="7430">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/GRAM.sol" startline="49" endline="50" pcid="4200">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/JDC.sol" startline="32" endline="33" pcid="4336">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/JUNDCOIN.sol" startline="48" endline="49" pcid="4358">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="762" endline="763" pcid="4465">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/KingToken.sol" startline="11" endline="12" pcid="4477">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/LanceToken.sol" startline="52" endline="53" pcid="4516">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="46" endline="47" pcid="400">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/SAMPLE.sol" startline="55" endline="56" pcid="6249">
	function allowance(address tokenOwner, address spender) public view returns (uint remaining);
	function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="44" endline="45" pcid="1301">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/Melodic.sol" startline="52" endline="53" pcid="4784">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="44" endline="45" pcid="1247">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="44" endline="45" pcid="1223">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/BIBCOINID.sol" startline="52" endline="53" pcid="1201">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/BEX.sol" startline="10" endline="11" pcid="1161">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/Multisig.sol" startline="10" endline="11" pcid="5213">
  function allowance(address tokenOwner, address spender) public view returns (uint remaining);
  function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/DGC.sol" startline="51" endline="52" pcid="2517">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/Perlin.sol" startline="52" endline="53" pcid="5640">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/ContractCargoberToken.sol" startline="47" endline="48" pcid="1955">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="35" endline="36" pcid="5806">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/AnxToken.sol" startline="52" endline="53" pcid="708">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/againstTokenRegister.sol" startline="16" endline="17" pcid="371">
    function allowance(address _owner, address _spender) constant external returns (uint remaining); 
}
</source>
<source file="systems/smart_contracts/PAYCASH.sol" startline="51" endline="52" pcid="5611">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="34" endline="35" pcid="2424">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/FixedSupplyToken.sol" startline="51" endline="52" pcid="3602">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="36" endline="37" pcid="8155">
    function allowance(address owner, address spender) public view returns (uint remaining);
    function transfer(address to, uint value) public returns (bool success);
</source>
<source file="systems/smart_contracts/OSManagerToken.sol" startline="30" endline="31" pcid="5549">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="110" endline="112" pcid="259">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);

    function transfer(address to, uint tokens) public returns (bool success);
</source>
</class>

<class classid="60" nclones="90" nlines="2" similarity="100">
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="64" endline="65" pcid="228">
    function transfer(address to, uint tokens) public returns(bool success);
    function approve(address spender, uint tokens) public returns(bool success);
</source>
<source file="systems/smart_contracts/PAYCASH.sol" startline="53" endline="54" pcid="5613">
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/Multisig.sol" startline="12" endline="13" pcid="5215">
  function approve(address spender, uint tokens) public returns (bool success);
  function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/Multisig.sol" startline="11" endline="12" pcid="5214">
  function transfer(address to, uint tokens) public returns (bool success);
  function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/BatchSendTokens.sol" startline="57" endline="58" pcid="1082">
    function transfer(address to, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/BEX.sol" startline="11" endline="12" pcid="1162">
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/BEX.sol" startline="12" endline="13" pcid="1163">
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/BIBCOINID.sol" startline="53" endline="54" pcid="1202">
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/BIBCOINID.sol" startline="54" endline="55" pcid="1203">
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="45" endline="46" pcid="1224">
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="46" endline="47" pcid="1225">
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="45" endline="46" pcid="1248">
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="47" endline="48" pcid="401">
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="46" endline="47" pcid="1249">
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/AnxToken.sol" startline="53" endline="54" pcid="709">
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/Melodic.sol" startline="54" endline="55" pcid="4786">
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/Melodic.sol" startline="53" endline="54" pcid="4785">
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/PAYCASH.sol" startline="52" endline="53" pcid="5612">
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="45" endline="46" pcid="1302">
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="48" endline="49" pcid="402">
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="46" endline="47" pcid="1303">
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/LanceToken.sol" startline="54" endline="55" pcid="4518">
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/LanceToken.sol" startline="53" endline="54" pcid="4517">
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="37" endline="38" pcid="5808">
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="112" endline="114" pcid="260">
    function transfer(address to, uint tokens) public returns (bool success);

    function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/KingToken.sol" startline="13" endline="14" pcid="4479">
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/KingToken.sol" startline="12" endline="13" pcid="4478">
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="764" endline="765" pcid="4467">
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="763" endline="764" pcid="4466">
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/SAMPLE.sol" startline="56" endline="57" pcid="6250">
	function transfer(address to, uint tokens) public returns (bool success);
	function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/SAMPLE.sol" startline="57" endline="58" pcid="6251">
	function approve(address spender, uint tokens) public returns (bool success);
	function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/JUNDCOIN.sol" startline="50" endline="51" pcid="4360">
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/JUNDCOIN.sol" startline="49" endline="50" pcid="4359">
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/JDC.sol" startline="34" endline="35" pcid="4338">
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/JDC.sol" startline="33" endline="34" pcid="4337">
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/GRAM.sol" startline="51" endline="52" pcid="4202">
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/GRAM.sol" startline="50" endline="51" pcid="4201">
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="33" endline="34" pcid="7431">
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="34" endline="35" pcid="7432">
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/GoaToken.sol" startline="61" endline="62" pcid="4150">
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/GoaToken.sol" startline="60" endline="61" pcid="4149">
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/GNB.sol" startline="36" endline="37" pcid="4125">
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/GNB.sol" startline="35" endline="36" pcid="4124">
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/CGT.sol" startline="52" endline="53" pcid="1688">
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/CGT.sol" startline="53" endline="54" pcid="1689">
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/SapientiaCharlesToken.sol" startline="52" endline="53" pcid="6274">
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="42" endline="43" pcid="7549">
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="43" endline="44" pcid="7550">
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/AICRYPTO.sol" startline="51" endline="52" pcid="426">
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="36" endline="37" pcid="5807">
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/SolaToken.sol" startline="39" endline="40" pcid="6581">
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/FUNNYTOKEN.sol" startline="40" endline="41" pcid="3949">
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/FUNNYTOKEN.sol" startline="39" endline="40" pcid="3948">
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/SapientiaCharlesToken.sol" startline="53" endline="54" pcid="6275">
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="410" endline="411" pcid="7667">
    function transfer(address _to, uint _amount) external returns (bool success);
}
</source>
<source file="systems/smart_contracts/VENT.sol" startline="59" endline="60" pcid="7683">
        function transfer(address to, uint tokens) public returns (bool success);
        function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/VENT.sol" startline="60" endline="61" pcid="7684">
        function approve(address spender, uint tokens) public returns (bool success);
        function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/FixedSupplyToken.sol" startline="53" endline="54" pcid="3604">
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/FixedSupplyToken.sol" startline="52" endline="53" pcid="3603">
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/SolaToken.sol" startline="38" endline="39" pcid="6580">
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/ContractCargoberToken.sol" startline="48" endline="49" pcid="1956">
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/ContractCargoberToken.sol" startline="49" endline="50" pcid="1957">
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/OSManagerToken.sol" startline="31" endline="32" pcid="5550">
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/ContractCoffeeToken.sol" startline="48" endline="49" pcid="1978">
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/VOTENOmodumtokenswapdotcom.sol" startline="53" endline="54" pcid="7836">
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/VOTENOmodumtokenswapdotcom.sol" startline="54" endline="55" pcid="7837">
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/WanCoinSupplyToken.sol" startline="38" endline="39" pcid="7858">
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/WanCoinSupplyToken.sol" startline="39" endline="40" pcid="7859">
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/ContractCoffeeToken.sol" startline="49" endline="50" pcid="1979">
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="46" endline="47" pcid="3414">
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/WanCoinToken.sol" startline="38" endline="39" pcid="7880">
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/WanCoinToken.sol" startline="39" endline="40" pcid="7881">
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="45" endline="46" pcid="3413">
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/EmpowCreateEosAccount.sol" startline="12" endline="13" pcid="2930">
    function approve(address _spender, uint _value) external returns (bool success);
    function allowance(address _owner, address _spender) external view returns (uint remaining);
</source>
<source file="systems/smart_contracts/EmpowCreateEosAccount.sol" startline="10" endline="11" pcid="2928">
    function transfer(address _to, uint _value) external returns (bool success);
    function transferFrom(address _from, address _to, uint _value) external returns (bool success);
</source>
<source file="systems/smart_contracts/XTRLPAY.sol" startline="53" endline="54" pcid="8134">
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/XTRLPAY.sol" startline="54" endline="55" pcid="8135">
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="37" endline="38" pcid="8156">
    function transfer(address to, uint value) public returns (bool success);
    function approve(address spender, uint value) public returns (bool success);
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="38" endline="39" pcid="8157">
    function approve(address spender, uint value) public returns (bool success);
    function transferFrom(address from, address to, uint value) public returns (bool success);
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="35" endline="36" pcid="2425">
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="36" endline="37" pcid="2426">
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/OSManagerToken.sol" startline="32" endline="33" pcid="5551">
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/DGC.sol" startline="52" endline="53" pcid="2518">
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/AICRYPTO.sol" startline="50" endline="51" pcid="425">
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/DGC.sol" startline="53" endline="54" pcid="2519">
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/AnxToken.sol" startline="54" endline="55" pcid="710">
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/Perlin.sol" startline="54" endline="55" pcid="5642">
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="114" endline="116" pcid="261">
    function approve(address spender, uint tokens) public returns (bool success);

    function transferFrom(address from, address to, uint tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="65" endline="66" pcid="229">
    function approve(address spender, uint tokens) public returns(bool success);
    function transferFrom(address from, address to, uint tokens) public returns(bool success);
</source>
<source file="systems/smart_contracts/Perlin.sol" startline="53" endline="54" pcid="5641">
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
</source>
</class>

<class classid="61" nclones="45" nlines="2" similarity="100">
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="66" endline="67" pcid="230">
    function transferFrom(address from, address to, uint tokens) public returns(bool success);
    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="39" endline="41" pcid="8158">
    function transferFrom(address from, address to, uint value) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="49" endline="51" pcid="403">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/Perlin.sol" startline="55" endline="57" pcid="5643">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/PAYCASH.sol" startline="54" endline="56" pcid="5614">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/OSManagerToken.sol" startline="33" endline="35" pcid="5552">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/SolaToken.sol" startline="40" endline="42" pcid="6582">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="37" endline="39" pcid="2427">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="38" endline="40" pcid="5809">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="116" endline="119" pcid="262">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);


    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/DGC.sol" startline="54" endline="56" pcid="2520">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/AnxToken.sol" startline="55" endline="57" pcid="711">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/AICRYPTO.sol" startline="52" endline="54" pcid="427">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/XTRLPAY.sol" startline="55" endline="57" pcid="8136">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/EmpowCreateEosAccount.sol" startline="11" endline="12" pcid="2929">
    function transferFrom(address _from, address _to, uint _value) external returns (bool success);
    function approve(address _spender, uint _value) external returns (bool success);
</source>
<source file="systems/smart_contracts/ContractCoffeeToken.sol" startline="50" endline="52" pcid="1980">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/WanCoinToken.sol" startline="40" endline="42" pcid="7882">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="47" endline="49" pcid="3415">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/WanCoinSupplyToken.sol" startline="40" endline="42" pcid="7860">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/VOTENOmodumtokenswapdotcom.sol" startline="55" endline="57" pcid="7838">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/ContractCargoberToken.sol" startline="50" endline="52" pcid="1958">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/Multisig.sol" startline="13" endline="15" pcid="5216">
  function transferFrom(address from, address to, uint tokens) public returns (bool success);

  event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/BatchSendTokens.sol" startline="58" endline="59" pcid="1083">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
}
</source>
<source file="systems/smart_contracts/FixedSupplyToken.sol" startline="54" endline="56" pcid="3605">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/BEX.sol" startline="13" endline="15" pcid="1164">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/BIBCOINID.sol" startline="55" endline="57" pcid="1204">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="47" endline="49" pcid="1226">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="47" endline="49" pcid="1250">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/Melodic.sol" startline="55" endline="57" pcid="4787">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="47" endline="49" pcid="1304">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/LanceToken.sol" startline="55" endline="57" pcid="4519">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/KingToken.sol" startline="14" endline="16" pcid="4480">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="765" endline="767" pcid="4468">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/SAMPLE.sol" startline="58" endline="60" pcid="6252">
	function transferFrom(address from, address to, uint tokens) public returns (bool success);

	event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/JUNDCOIN.sol" startline="51" endline="53" pcid="4361">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/JDC.sol" startline="35" endline="37" pcid="4339">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/GRAM.sol" startline="52" endline="54" pcid="4203">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="35" endline="37" pcid="7433">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/GoaToken.sol" startline="62" endline="64" pcid="4151">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/GNB.sol" startline="37" endline="38" pcid="4126">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
    function checkRate(uint unlockIndex) public constant returns (uint rate_);
</source>
<source file="systems/smart_contracts/CGT.sol" startline="54" endline="56" pcid="1690">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="44" endline="46" pcid="7551">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/FUNNYTOKEN.sol" startline="41" endline="43" pcid="3950">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/SapientiaCharlesToken.sol" startline="54" endline="56" pcid="6276">
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/VENT.sol" startline="61" endline="63" pcid="7685">
        function transferFrom(address from, address to, uint tokens) public returns (bool success);

        event Transfer(address indexed from, address indexed to, uint tokens);
</source>
</class>

<class classid="62" nclones="14" nlines="2" similarity="100">
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="80" endline="82" pcid="231">
    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;

}
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="52" endline="53" pcid="7552">
    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;
}
</source>
<source file="systems/smart_contracts/CGT.sol" startline="67" endline="68" pcid="1691">
    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;
}
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="51" endline="52" pcid="5810">
    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;
}
</source>
<source file="systems/smart_contracts/GoaToken.sol" startline="73" endline="74" pcid="4152">
    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;
}
</source>
<source file="systems/smart_contracts/SAMPLE.sol" startline="71" endline="72" pcid="6253">
	function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;
}
</source>
<source file="systems/smart_contracts/AICRYPTO.sol" startline="65" endline="66" pcid="428">
    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;
}
</source>
<source file="systems/smart_contracts/Mlgc.sol" startline="11" endline="12" pcid="4915">
    function receiveApproval(address from, uint256 _amount, address _token, bytes memory _data) public;
	function onTokenTransfer(address from, uint256 amount, bytes memory data) public returns (bool success);
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="62" endline="63" pcid="404">
    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;
}
</source>
<source file="systems/smart_contracts/DGC.sol" startline="67" endline="68" pcid="2521">
    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;
}
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="46" endline="47" pcid="2428">
    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;
}
</source>
<source file="systems/smart_contracts/Wolfs.sol" startline="11" endline="12" pcid="8033">
    function receiveApproval(address from, uint256 _amount, address _token, bytes memory _data) public;
	function onTokenTransfer(address from, uint256 amount, bytes memory data) public returns (bool success);
</source>
<source file="systems/smart_contracts/FixedSupplyToken.sol" startline="67" endline="68" pcid="3606">
    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;
}
</source>
<source file="systems/smart_contracts/SapientiaCharlesToken.sol" startline="67" endline="68" pcid="6277">
    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;
}
</source>
</class>

<class classid="63" nclones="2" nlines="12" similarity="91">
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="209" endline="231" pcid="235">
    function _startNewMiningEpoch() internal {
        //if max supply for the era will be exceeded next reward round then enter the new era before that happens
        //40 is the final reward era, almost all tokens minted
        //once the final era is reached, more tokens will not be given out because the assert function
        if (tokensMinted.add(getMiningReward()) > maxSupplyForEra && rewardEra < 39) {
            rewardEra = rewardEra + 1;
        }
        //set the next minted supply at which the era will change
        // total supply is 2100000000000  because of 8 decimal places
        maxSupplyForEra = _totalSupply - _totalSupply.div(2 ** (rewardEra + 1));
        epochCount = epochCount.add(1);
        //every so often, readjust difficulty. Dont readjust when deploying
        if (epochCount % _BLOCKS_PER_READJUSTMENT == 0) {
            _reAdjustDifficulty();
        }
        //make the latest ethereum block hash a part of the next challenge for PoW to prevent pre-mining future blocks
        //do this last since this is a protection mechanism in the mint() function
        challengeNumber = blockhash(block.number - 1);
    }
    //https://en.bitcoin.it/wiki/Difficulty#What_is_the_formula_for_difficulty.3F
    //as of 2017 the bitcoin difficulty was up to 17 zeroes, it was only 8 in the early days
    //readjust the target by 5 percent
    function _reAdjustDifficulty() internal {
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="357" endline="399" pcid="269">
    function _startNewMiningEpoch() internal {

      //if max supply for the era will be exceeded next reward round then enter the new era before that happens

      //40 is the final reward era, almost all tokens minted
      //once the final era is reached, more tokens will not be given out because the assert function
      if( tokensMinted.add(getMiningReward()) > maxSupplyForEra && rewardEra < 39)
      {
        rewardEra = rewardEra + 1;
      }

      //set the next minted supply at which the era will change
      // total supply is 10000000000000000  because of 8 decimal places
      maxSupplyForEra = _totalSupply - _totalSupply.div( 2**(rewardEra + 1));

      epochCount = epochCount.add(1);

      //every so often, readjust difficulty. Dont readjust when deploying
      if(epochCount % _BLOCKS_PER_READJUSTMENT == 0)
      {
        _reAdjustDifficulty();
      }


      //make the latest ethereum block hash a part of the next challenge for PoW to prevent pre-mining future blocks
      //do this last since this is a protection mechanism in the mint() function
      challengeNumber = block.blockhash(block.number - 1);






    }




    //https://en.Litecoin.it/wiki/Difficulty#What_is_the_formula_for_difficulty.3F
    //as of 2017 the Litecoin difficulty was up to 17 zeroes, it was only 8 in the early days

    //readjust the target by 5 percent
    function _reAdjustDifficulty() internal {
</source>
</class>

<class classid="64" nclones="2" nlines="19" similarity="100">
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="231" endline="262" pcid="236">
    function _reAdjustDifficulty() internal {
        uint ethBlocksSinceLastDifficultyPeriod = block.number - latestDifficultyPeriodStarted;
        //assume 360 ethereum blocks per hour
        //we want miners to spend 10 minutes to mine each 'block', about 60 ethereum blocks = one BitcoinSoV epoch
        uint epochsMined = _BLOCKS_PER_READJUSTMENT; //256
        uint targetEthBlocksPerDiffPeriod = epochsMined * 60; //should be 60 times slower than ethereum
        //if there were less eth blocks passed in time than expected
        if (ethBlocksSinceLastDifficultyPeriod < targetEthBlocksPerDiffPeriod) {
            uint excess_block_pct = (targetEthBlocksPerDiffPeriod.mul(100)).div(ethBlocksSinceLastDifficultyPeriod);
            uint excess_block_pct_extra = excess_block_pct.sub(100).limitLessThan(1000);
            // If there were 5% more blocks mined than expected then this is 5.  If there were 100% more blocks mined than expected then this is 100.
            //make it harder
            miningTarget = miningTarget.sub(miningTarget.div(2000).mul(excess_block_pct_extra)); //by up to 50 %
        } else {
            uint shortage_block_pct = (ethBlocksSinceLastDifficultyPeriod.mul(100)).div(targetEthBlocksPerDiffPeriod);
            uint shortage_block_pct_extra = shortage_block_pct.sub(100).limitLessThan(1000); //always between 0 and 1000
            //make it easier
            miningTarget = miningTarget.add(miningTarget.div(2000).mul(shortage_block_pct_extra)); //by up to 50 %
        }
        latestDifficultyPeriodStarted = block.number;
        if (miningTarget < _MINIMUM_TARGET) //very difficult
        {
            miningTarget = _MINIMUM_TARGET;
        }
        if (miningTarget > _MAXIMUM_TARGET) //very easy
        {
            miningTarget = _MAXIMUM_TARGET;
        }
    }

    //this is a recent ethereum block hash, used to prevent pre-mining future blocks
    function getChallengeNumber() public view returns(bytes32) {
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="399" endline="446" pcid="270">
    function _reAdjustDifficulty() internal {


        uint ethBlocksSinceLastDifficultyPeriod = block.number - latestDifficultyPeriodStarted;
        //assume 360 ethereum blocks per hour

        //we want miners to spend 10 minutes to mine each 'block', about 60 ethereum blocks = one 0xLitecoin epoch
        uint epochsMined = _BLOCKS_PER_READJUSTMENT; //256

        uint targetEthBlocksPerDiffPeriod = epochsMined * 60; //should be 60 times slower than ethereum

        //if there were less eth blocks passed in time than expected
        if( ethBlocksSinceLastDifficultyPeriod < targetEthBlocksPerDiffPeriod )
        {
          uint excess_block_pct = (targetEthBlocksPerDiffPeriod.mul(100)).div( ethBlocksSinceLastDifficultyPeriod );

          uint excess_block_pct_extra = excess_block_pct.sub(100).limitLessThan(1000);
          // If there were 5% more blocks mined than expected then this is 5.  If there were 100% more blocks mined than expected then this is 100.

          //make it harder
          miningTarget = miningTarget.sub(miningTarget.div(2000).mul(excess_block_pct_extra));   //by up to 50 %
        }else{
          uint shortage_block_pct = (ethBlocksSinceLastDifficultyPeriod.mul(100)).div( targetEthBlocksPerDiffPeriod );

          uint shortage_block_pct_extra = shortage_block_pct.sub(100).limitLessThan(1000); //always between 0 and 1000

          //make it easier
          miningTarget = miningTarget.add(miningTarget.div(2000).mul(shortage_block_pct_extra));   //by up to 50 %
        }



        latestDifficultyPeriodStarted = block.number;

        if(miningTarget < _MINIMUM_TARGET) //very difficult
        {
          miningTarget = _MINIMUM_TARGET;
        }

        if(miningTarget > _MAXIMUM_TARGET) //very easy
        {
          miningTarget = _MAXIMUM_TARGET;
        }
    }


    //this is a recent ethereum block hash, used to prevent pre-mining future blocks
    function getChallengeNumber() public constant returns (bytes32) {
</source>
</class>

<class classid="65" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="284" endline="290" pcid="241">
    function getMintDigest(uint256 nonce, bytes32 challenge_digest, bytes32 challenge_number) public view returns(bytes32 digesttest) {
        bytes32 digest = keccak256(abi.encodePacked(challenge_number, msg.sender, nonce));
        return digest;
    }

    //help debug mining software
    function checkMintSolution(uint256 nonce, bytes32 challenge_digest, bytes32 challenge_number, uint testTarget) public view returns(bool success) {
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="473" endline="482" pcid="275">
    function getMintDigest(uint256 nonce, bytes32 challenge_digest, bytes32 challenge_number) public view returns (bytes32 digesttest) {

        bytes32 digest = keccak256(challenge_number,msg.sender,nonce);

        return digest;

      }

        //help debug mining software
      function checkMintSolution(uint256 nonce, bytes32 challenge_digest, bytes32 challenge_number, uint testTarget) public view returns (bool success) {
</source>
</class>

<class classid="66" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="290" endline="300" pcid="242">
    function checkMintSolution(uint256 nonce, bytes32 challenge_digest, bytes32 challenge_number, uint testTarget) public view returns(bool success) {
        bytes32 digest = keccak256(abi.encodePacked(challenge_number, msg.sender, nonce));
        if (uint256(digest) > testTarget) revert();
        return (digest == challenge_digest);
    }

    // ------------------------------------------------------------------------
    // Total supply
    // ------------------------------------------------------------------------

    function totalSupply() public view returns(uint) {
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="482" endline="500" pcid="276">
      function checkMintSolution(uint256 nonce, bytes32 challenge_digest, bytes32 challenge_number, uint testTarget) public view returns (bool success) {

          bytes32 digest = keccak256(challenge_number,msg.sender,nonce);

          if(uint256(digest) > testTarget) revert();

          return (digest == challenge_digest);

        }



    // ------------------------------------------------------------------------

    // Total supply

    // ------------------------------------------------------------------------

    function totalSupply() public constant returns (uint) {
</source>
</class>

<class classid="67" nclones="175" nlines="4" similarity="75">
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="318" endline="344" pcid="245">
    function transfer(address to, uint tokens) public returns(bool success) {

        uint toBurn = tokens.mul(burnPercent).div(1000);
        uint toSend = tokens.sub(toBurn);

        balances[msg.sender] = balances[msg.sender].sub(tokens);

        balances[to] = balances[to].add(toSend);
        emit Transfer(msg.sender, to, toSend);

        balances[address(0)] = balances[address(0)].add(toBurn);
        emit Transfer(msg.sender, address(0), toBurn);

        return true;

    }

    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces
    // ------------------------------------------------------------------------

    function approve(address spender, uint tokens) public returns(bool success) {
</source>
<source file="systems/smart_contracts/AICRYPTO.sol" startline="149" endline="165" pcid="433">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/AnxToken.sol" startline="165" endline="181" pcid="718">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ContractCargoberToken.sol" startline="163" endline="179" pcid="1965">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer `tokens` from the `from` account to the `to` account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the `from` account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/CRYPTOMZ.sol" startline="198" endline="205" pcid="2188">
  function increaseApproval (address _spender, uint _addedValue) public
    returns (bool success) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  function decreaseApproval (address _spender, uint _subtractedValue) public
</source>
<source file="systems/smart_contracts/AnxToken.sol" startline="149" endline="165" pcid="717">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="116" endline="124" pcid="1312">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }


    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="124" endline="131" pcid="1259">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }


    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="116" endline="124" pcid="1258">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }


    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/AICRYPTO.sol" startline="165" endline="181" pcid="434">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer `tokens` from the `from` account to the `to` account
    //
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the `from` account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="124" endline="131" pcid="1313">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }


    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ContractCargoberToken.sol" startline="147" endline="163" pcid="1964">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="562" endline="592" pcid="280">
    function approve(address spender, uint tokens) public returns (bool success) {

        allowed[msg.sender][spender] = tokens;

        Approval(msg.sender, spender, tokens);

        return true;

    }



    // ------------------------------------------------------------------------

    // Transfer `tokens` from the `from` account to the `to` account

    //

    // The calling account must already have sufficient tokens approve(...)-d

    // for spending from the `from` account and

    // - From account must have sufficient balance to transfer

    // - Spender must have sufficient allowance to transfer

    // - 0 value transfers are allowed

    // ------------------------------------------------------------------------

    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="532" endline="562" pcid="279">
    function transfer(address to, uint tokens) public returns (bool success) {

        balances[msg.sender] = balances[msg.sender].sub(tokens);

        balances[to] = balances[to].add(tokens);

        Transfer(msg.sender, to, tokens);

        return true;

    }



    // ------------------------------------------------------------------------

    // Token owner can approve for `spender` to transferFrom(...) `tokens`

    // from the token owner's account

    //

    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md

    // recommends that there are no checks for the approval double-spend attack

    // as this should be implemented in user interfaces

    // ------------------------------------------------------------------------

    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="143" endline="149" pcid="1723">
    function increaseApproval(address _spender, uint _addedValue) public returns (bool success) {
        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }

    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success) {
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="161" endline="177" pcid="412">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="145" endline="161" pcid="411">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/CGT.sol" startline="167" endline="183" pcid="1697">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer `tokens` from the `from` account to the `to` account
    //
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the `from` account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ContractCoffeeToken.sol" startline="147" endline="163" pcid="1986">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ContractCoffeeToken.sol" startline="163" endline="179" pcid="1987">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer `tokens` from the `from` account to the `to` account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the `from` account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SapientiaCharlesToken.sol" startline="167" endline="183" pcid="6283">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer `tokens` from the `from` account to the `to` account
    //
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the `from` account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SapientiaCharlesToken.sol" startline="151" endline="167" pcid="6282">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SAMPLE.sol" startline="186" endline="205" pcid="6260">
	function approve(address spender, uint tokens) public returns (bool success) {
		require(_stopTrade != true);
		require(msg.sender != spender);

		allowed[msg.sender][spender] = tokens;
		emit Approval(msg.sender, spender, tokens);
		return true;
	}


	// ------------------------------------------------------------------------
	// Transfer `tokens` from the `from` account to the `to` account
	//
	// The calling account must already have sufficient tokens approve(...)-d
	// for spending from the `from` account and
	// - From account must have sufficient balance to transfer
	// - Spender must have sufficient allowance to transfer
	// - 0 value transfers are allowed
	// ------------------------------------------------------------------------
	function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SAMPLE.sol" startline="167" endline="186" pcid="6259">
	function transfer(address to, uint tokens) public returns (bool success) {
		require(_stopTrade != true || isOwner());
		require(to > address(0));

		balances[msg.sender] = balances[msg.sender].sub(tokens);
		balances[to] = balances[to].add(tokens);
		emit Transfer(msg.sender, to, tokens);
		return true;
	}


	// ------------------------------------------------------------------------
	// Token owner can approve for `spender` to transferFrom(...) `tokens`
	// from the token owner's account
	//
	// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
	// recommends that there are no checks for the approval double-spend attack
	// as this should be implemented in user interfaces
	// ------------------------------------------------------------------------
	function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="150" endline="166" pcid="5818">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/CGT.sol" startline="151" endline="167" pcid="1696">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="134" endline="150" pcid="5817">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SolaToken.sol" startline="137" endline="153" pcid="6588">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SolaToken.sol" startline="153" endline="169" pcid="6589">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer `tokens` from the `from` account to the `to` account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the `from` account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Perlin.sol" startline="169" endline="185" pcid="5652">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer `tokens` from the `from` account to the `to` account
    //
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the `from` account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Perlin.sol" startline="153" endline="169" pcid="5651">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/PAYCASH.sol" startline="165" endline="181" pcid="5622">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/PAYCASH.sol" startline="149" endline="165" pcid="5621">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/OSManagerToken.sol" startline="102" endline="108" pcid="5559">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/OSManagerToken.sol" startline="95" endline="102" pcid="5558">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }

    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/NaorisToken.sol" startline="182" endline="188" pcid="5293">
    function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {
        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }

    function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Melodic.sol" startline="166" endline="182" pcid="4794">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Melodic.sol" startline="150" endline="166" pcid="4793">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/LanceToken.sol" startline="166" endline="182" pcid="4526">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/LanceToken.sol" startline="150" endline="166" pcid="4525">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/JUNDCOIN.sol" startline="162" endline="178" pcid="4368">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/JUNDCOIN.sol" startline="146" endline="162" pcid="4367">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/JDC.sol" startline="119" endline="126" pcid="4346">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/JDC.sol" startline="110" endline="119" pcid="4345">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="128" endline="141" pcid="2433">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account
    //
    
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/GRAM.sol" startline="164" endline="180" pcid="4210">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/GRAM.sol" startline="148" endline="164" pcid="4209">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BEX.sol" startline="60" endline="66" pcid="1169">
	function approve(address spender, uint tokens)public returns (bool success) {
		allowed[msg.sender][spender] = tokens;
		emit Approval(msg.sender, spender, tokens);
		return true;
	}
	
	function allowance(address tokenOwner, address spender)public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="130" endline="146" pcid="7441">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="146" endline="162" pcid="7442">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/GoaToken.sol" startline="161" endline="175" pcid="4156">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowance[msg.sender][spender] = tokens;

        emit Approval(msg.sender, spender, tokens);

        return true;
    }

    //-- transferFrom
    // Transfer "tokens" tokens from the "from" account to the "to" account
    // From account must have sufficient balance to transfer
    // Spender must have sufficient allowance to transfer
    // 0 value transfers are allowed

    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/GoaToken.sol" startline="145" endline="161" pcid="4155">
    function transfer(address to, uint tokens) public returns (bool success) {
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(tokens);
        balanceOf[to] = balanceOf[to].add(tokens);

        emit Transfer(msg.sender, to, tokens);

        return true;
    }

    //-- approve
    // Token owner can approve for "spender" to transferFrom(...) or burn(...) "tokens"
    // from the token owner's account
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces

    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/GNB.sol" startline="253" endline="268" pcid="4136">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="182" endline="188" pcid="7464">
    function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {
        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }

    function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {
</source>
<source file="systems/smart_contracts/GFNX.sol" startline="171" endline="178" pcid="4109">
    function approve(address spender, uint value) public returns (bool success) {
        _allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }
    
    // Transfer from function, pulls from allowance
    function transferFrom(address from, address to, uint value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/FUNNYTOKEN.sol" startline="110" endline="116" pcid="3957">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/FUNNYTOKEN.sol" startline="103" endline="110" pcid="3956">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }

    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="121" endline="129" pcid="7557">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="141" endline="154" pcid="2434">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer `tokens` from the `from` account to the `to` account
    //
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the `from` account and
    
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="344" endline="360" pcid="246">
    function approve(address spender, uint tokens) public returns(bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

    // ------------------------------------------------------------------------
    // Transfer `tokens` from the `from` account to the `to` account
    //
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the `from` account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------

    function transferFrom(address from, address to, uint tokens) public returns(bool success) {
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="129" endline="136" pcid="7558">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/VENT.sol" startline="132" endline="145" pcid="7689">
        function approve(address spender, uint tokens) public returns (bool success){
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender,spender,tokens);
            return true;
        }
        // ------------------------------------------------------------------------
        // Transfer `tokens` from the `from` account to the `to` account
        // The calling account must already have sufficient tokens approve(...)
        // for spending from the `from` account and
        // - From account must have sufficient balance to transfer
        // - Spender must have sufficient allowance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transferFrom(address from, address to, uint tokens) public returns (bool success){
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="124" endline="131" pcid="1235">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }


    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/FixedSupplyToken.sol" startline="167" endline="183" pcid="3612">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer `tokens` from the `from` account to the `to` account
    //
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the `from` account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/FixedSupplyToken.sol" startline="151" endline="167" pcid="3611">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/VOTENOmodumtokenswapdotcom.sol" startline="150" endline="166" pcid="7844">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/VOTENOmodumtokenswapdotcom.sol" startline="166" endline="182" pcid="7845">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    //
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/WanCoinSupplyToken.sol" startline="137" endline="153" pcid="7866">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/WanCoinSupplyToken.sol" startline="153" endline="169" pcid="7867">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer `tokens` from the `from` account to the `to` account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the `from` account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="124" endline="131" pcid="3424">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }


    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="116" endline="124" pcid="3423">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }


    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/WanCoinToken.sol" startline="137" endline="153" pcid="7888">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/WanCoinToken.sol" startline="153" endline="169" pcid="7889">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer `tokens` from the `from` account to the `to` account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the `from` account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/XTRLPAY.sol" startline="150" endline="166" pcid="8142">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="116" endline="124" pcid="1234">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }


    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BIBCOINID.sol" startline="150" endline="166" pcid="1210">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BIBCOINID.sol" startline="166" endline="182" pcid="1211">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/XTRLPAY.sol" startline="166" endline="182" pcid="8143">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/DGC.sol" startline="167" endline="183" pcid="2527">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer `tokens` from the `from` account to the `to` account
    //
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the `from` account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/DGC.sol" startline="151" endline="167" pcid="2526">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BRZE.sol" startline="113" endline="120" pcid="1529">
  function approve(address _spender, uint256 _value) public returns (bool success) {
    allowance[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }


  function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BACD.sol" startline="146" endline="163" pcid="1023">
   function approve (address _spender, uint256 _value) public returns (bool success) {
    allowances [msg.sender][_spender] = _value;
    emit Approval (msg.sender, _spender, _value);
    return true;
  }

  /**
   * Tell how many tokens given spender is currently allowed to transfer from
   * given owner.
   *
   * @param _owner address to get number of tokens allowed to be transferred
   *        from the owner of
   * @param _spender address to get number of tokens allowed to be transferred
   *        by the owner of
   * @return number of tokens given spender is currently allowed to transfer
   *         from given owner
   */
  function allowance(address _owner, address _spender) public view
</source>
<source file="systems/smart_contracts/DENARIO.sol" startline="63" endline="69" pcid="2451">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/AzurToken.sol" startline="85" endline="91" pcid="1008">
  function approve(address _spender, uint256 _value) public returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }

  function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/ETGTOKEN.sol" startline="106" endline="122" pcid="3194">
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    /**
     * Set allowance for other address and notify
     *
     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     * @param _extraData some extra information to send to the approved contract
     */
    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)
</source>
<source file="systems/smart_contracts/Warpcoin.sol" startline="63" endline="69" pcid="7949">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/VCTAToken.sol" startline="56" endline="62" pcid="7672">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/SCMCoin.sol" startline="98" endline="104" pcid="6389">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/VACCToken.sol" startline="171" endline="187" pcid="7629">
    function approve(address spender, uint256 tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint256 tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/OeroToken.sol" startline="56" endline="62" pcid="5475">
        function approve(address _spender, uint256 _value) public returns (bool success) {
            allowance[msg.sender][_spender] = _value;
            emit Approval(msg.sender, _spender, _value);
            return true;
        }

        function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/MyAdvancedToken.sol" startline="121" endline="137" pcid="5266">
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    /**
     * Set allowance for other address and notify
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     * @param _extraData some extra information to send to the approved contract
     */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
</source>
<source file="systems/smart_contracts/ThpToken.sol" startline="125" endline="141" pcid="7161">
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    /**
     * Set allowance for other address and notify
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     * @param _extraData some extra information to send to the approved contract
     */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
</source>
<source file="systems/smart_contracts/MAdvcedWoken.sol" startline="172" endline="186" pcid="4601">
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    /**
     * Destroy tokens
     *
     * Remove `_value` tokens from the system irreversibly
     *
     * @param _value the amount of money to burn
     */
    function burn(uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/LuckyAdvcedWoken.sol" startline="172" endline="186" pcid="4562">
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    /**
     * Destroy tokens
     *
     * Remove `_value` tokens from the system irreversibly
     *
     * @param _value the amount of money to burn
     */
    function burn(uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/TokenERC20.sol" startline="105" endline="121" pcid="7306">
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    /**
     * Set allowance for other address and notify
     *
     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     * @param _extraData some extra information to send to the approved contract
     */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
</source>
<source file="systems/smart_contracts/HollywoodPay.sol" startline="34" endline="43" pcid="4227">
    function approve(address spender, uint256 value)
        public
        returns (bool success)
    {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value)
</source>
<source file="systems/smart_contracts/ICBB.sol" startline="125" endline="141" pcid="4268">
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    /**
     * Set allowance for other address and notify
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     * @param _extraData some extra information to send to the approved contract
     */
    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)
</source>
<source file="systems/smart_contracts/GoldenRings.sol" startline="136" endline="143" pcid="4180">
    function increaseApproval(address _spender, uint256 _addedValue) public returns (bool success) {
        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);

        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }

    function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SHPC.sol" startline="56" endline="62" pcid="6511">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/P21.sol" startline="70" endline="76" pcid="5588">
    function approve(address _spender, uint _value) returns (bool) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint) {
</source>
<source file="systems/smart_contracts/BTToken.sol" startline="74" endline="80" pcid="1561">
    function approve(address _spender, uint _value) returns (bool) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint) {
</source>
<source file="systems/smart_contracts/OBK.sol" startline="56" endline="62" pcid="5471">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/TECToken.sol" startline="70" endline="76" pcid="7136">
    function approve(address _spender, uint _value) returns (bool) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint) {
</source>
<source file="systems/smart_contracts/UNT.sol" startline="56" endline="62" pcid="7569">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/UGCoin.sol" startline="112" endline="118" pcid="7537">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/NEM.sol" startline="94" endline="102" pcid="5327">
    function approve(address _spender, uint256 _value)public returns (bool success) {
        require((_value==0)||(allowed[msg.sender][_spender]==0));
        allowed[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender)public view returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/NEM.sol" startline="66" endline="79" pcid="5325">
    function transfer(address _to, uint256 _value)public returns (bool success) {
        require(_to != address(0));
        require(balanceOf[msg.sender] >= _value);
        require(balanceOf[ _to] + _value >= balanceOf[ _to]); 
        
        balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender],_value) ;
        balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ;
        
        emit Transfer(msg.sender, _to, _value);
        
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success) {
</source>
<source file="systems/smart_contracts/MyAdvancedToken.sol" startline="170" endline="179" pcid="5269">
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        emit Burn(_from, _value);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/NMAI.sol" startline="66" endline="79" pcid="5447">
    function transfer(address _to, uint256 _value)public returns (bool success) {
        require(_to != address(0));
        require(balanceOf[msg.sender] >= _value);
        require(balanceOf[ _to] + _value >= balanceOf[ _to]); 
        
        balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender],_value) ;
        balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ;
        
        emit Transfer(msg.sender, _to, _value);
        
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success) {
</source>
<source file="systems/smart_contracts/MyAdvancedToken.sol" startline="92" endline="106" pcid="5264">
    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    /**
     * Transfer tokens from other address
     *
     * Send `_value` tokens to `_to` in behalf of `_from`
     *
     * @param _from The address of the sender
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SAS.sol" startline="113" endline="121" pcid="6301">
  function approve(address _spender, uint256 _value)public returns (bool success) {
      require((_value==0)||(allowed[msg.sender][_spender]==0));
      allowed[msg.sender][_spender] = _value;

      emit Approval(msg.sender, _spender, _value);
      return true;
  }

  function allowance(address _owner, address _spender)public view returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/MT.sol" startline="94" endline="102" pcid="5079">
    function approve(address _spender, uint256 _value)public returns (bool success) {
        require((_value==0)||(allowed[msg.sender][_spender]==0));
        allowed[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender)public view returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/MT.sol" startline="66" endline="79" pcid="5077">
    function transfer(address _to, uint256 _value)public returns (bool success) {
        require(_to != address(0));
        require(balanceOf[msg.sender] >= _value);
        require(balanceOf[ _to] + _value >= balanceOf[ _to]); 
        
        balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender],_value) ;
        balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ;
        
        emit Transfer(msg.sender, _to, _value);
        
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success) {
</source>
<source file="systems/smart_contracts/TAIHUITOKEN.sol" startline="70" endline="78" pcid="6969">
    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }




}
</source>
<source file="systems/smart_contracts/MiniMeTokenFactory.sol" startline="181" endline="192" pcid="4807">
    function transfer(address _to, uint256 _amount) public returns (bool success) {
        require(transfersEnabled);
        return doTransfer(msg.sender, _to, _amount);
    }

    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it
    ///  is approved by `_from`
    /// @param _from The address holding the tokens being transferred
    /// @param _to The address of the recipient
    /// @param _amount The amount of tokens to be transferred
    /// @return True if the transfer was successful
    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SuperMarket.sol" startline="121" endline="128" pcid="6769">
    function approve(address _spender, uint256 _value) public returns (bool success) {
		require((_value == 0) || (allowance[msg.sender][_spender] == 0));
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ThpToken.sol" startline="96" endline="110" pcid="7159">
    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    /**
     * Transfer tokens from other address
     *
     * Send `_value` tokens to `_to` in behalf of `_from`
     *
     * @param _from The address of the sender
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/NMAI.sol" startline="94" endline="102" pcid="5449">
    function approve(address _spender, uint256 _value)public returns (bool success) {
        require((_value==0)||(allowed[msg.sender][_spender]==0));
        allowed[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender)public view returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/BRZE.sol" startline="198" endline="206" pcid="1534">
  function burnFrom(address _from, uint256 _value) public returns (bool success) {
    balanceOf[_from] = balanceOf[_from].sub(_value);                          // Subtract from the targeted balance
    allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);   // Subtract from the sender's allowance
    totalSupply = totalSupply.sub(_value);                              // Update totalSupply
    emit Burn(_from, _value);
    return true;
  }

  function freezeToken(bool freeze) onlyOwner public {
</source>
<source file="systems/smart_contracts/OBK.sol" startline="32" endline="40" pcid="5468">
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="454" endline="459" pcid="4680">
    function transfer(address _to, uint256 _value) public returns (bool _success) {
        require(!paused);
        return super.transfer(_to, _value);
    }
    
    function init() private {
</source>
<source file="systems/smart_contracts/BTGS.sol" startline="170" endline="181" pcid="1549">
    function approve(address _spender, uint256 _amount)
        public

        returns (bool success) {
        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));
        allowed[msg.sender][_spender] = _amount;
        Approval(msg.sender, _spender, _amount);
        return true;
    }

    // get allowance
    function allowance(address _owner, address _spender)
</source>
<source file="systems/smart_contracts/byzbit.sol" startline="89" endline="99" pcid="1595">
	function transfer (address _to, uint256 _value) public 
	returns(bool success){
		
		_transfer(msg.sender, _to, _value);
		return true;
	}
	////////////////////////////// TRANSFER END //////////////////////////////

////////////////////////////// ALLOWANCE //////////////////////////////

	function transferFrom (address _from, address _to, uint256 _value) public
</source>
<source file="systems/smart_contracts/MAdvcedWoken.sol" startline="202" endline="211" pcid="4603">
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        emit Burn(_from, _value);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/byzbit.sol" startline="145" endline="161" pcid="1600">
	function burnFrom (address _from, uint256 _value)public returns(bool success){
		require (balanceOf[_from] >= _value) ;

		require (_value <= allowance[_from][msg.sender]);
		
		balanceOf[_from] -= _value;
		totalSupply -= _value;
		emit Burn(msg.sender, _value);
		return true;
	}
	
	
	////////////////////////////// BURN END //////////////////////////////
	
	////////////////////////////// FREEZING //////////////////////////////

	function freezeAccount (address target, bool freeze) public onlyOwner  {
</source>
<source file="systems/smart_contracts/CAC.sol" startline="66" endline="79" pcid="1616">
    function transfer(address _to, uint256 _value)public returns (bool success) {
        require(_to != address(0));
        require(balanceOf[msg.sender] >= _value);
        require(balanceOf[ _to] + _value >= balanceOf[ _to]); 
        
        balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender],_value) ;
        balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ;
        
        emit Transfer(msg.sender, _to, _value);
        
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success) {
</source>
<source file="systems/smart_contracts/CAC.sol" startline="94" endline="102" pcid="1618">
    function approve(address _spender, uint256 _value)public returns (bool success) {
        require((_value==0)||(allowed[msg.sender][_spender]==0));
        allowed[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender)public view returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/OeroToken.sol" startline="48" endline="56" pcid="5474">
        function transfer(address _to, uint256 _value) public returns (bool success) {
            require(balanceOf[msg.sender] >= _value);
            balanceOf[msg.sender] -= _value;
            balanceOf[_to] += _value;
            emit Transfer(msg.sender, _to, _value);
            return true;
        }

        function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SAS.sol" startline="84" endline="98" pcid="6299">
  function transfer(address _to, uint256 _value)public returns (bool success) {
      require(_to != address(0));
      require(balanceOf[msg.sender] >= _value);
      require(balanceOf[ _to] + _value >= balanceOf[ _to]); 

      balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender],_value) ;
      balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ;

      emit Transfer(msg.sender, _to, _value);

      return true;
  }


  function transferFrom(address _from, address _to, uint256 _value)public returns (bool success) {
</source>
<source file="systems/smart_contracts/MAdvcedWoken.sol" startline="143" endline="157" pcid="4599">
    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    /**
     * Transfer tokens from other address
     *
     * Send `_value` tokens to `_to` in behalf of `_from`
     *
     * @param _from The address of the sender
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/LuckyAdvcedWoken.sol" startline="202" endline="211" pcid="4564">
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        emit Burn(_from, _value);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/CLCTokenERC20.sol" startline="100" endline="115" pcid="1740">
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    /**
     * Set allowance for other address and notify
     *
     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     * @param _extraData some extra information to send to the approved contract
     */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
</source>
<source file="systems/smart_contracts/PokaToken.sol" startline="121" endline="128" pcid="5741">
    function approve(address _spender, uint256 _value) public returns (bool success) {
		require((_value == 0) || (allowance[msg.sender][_spender] == 0));
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/CLCTokenERC20.sol" startline="148" endline="157" pcid="1743">
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        emit Burn(_from, _value);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/Rabbit.sol" startline="41" endline="47" pcid="5944">
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }
    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
</source>
<source file="systems/smart_contracts/Rabbit.sol" startline="64" endline="73" pcid="5947">
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);
        require(_value <= allowance[_from][msg.sender]);
        balanceOf[_from] -= _value;
        allowance[_from][msg.sender] -= _value;
        totalSupply -= _value;
        Burn(_from, _value);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/RanchChain.sol" startline="100" endline="115" pcid="5980">
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    /**
     * Set allowance for other address and notify
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     * @param _extraData some extra information to send to the approved contract
     */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
</source>
<source file="systems/smart_contracts/LuckyAdvcedWoken.sol" startline="143" endline="157" pcid="4560">
    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    /**
     * Transfer tokens from other address
     *
     * Send `_value` tokens to `_to` in behalf of `_from`
     *
     * @param _from The address of the sender
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/RanchChain.sol" startline="148" endline="157" pcid="5983">
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        Burn(_from, _value);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/SHPC.sol" startline="32" endline="40" pcid="6508">
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SEA.sol" startline="117" endline="127" pcid="6399">
	function unfreeze(address _to,uint256 _value) public returns (bool success) {
		require(msg.sender == owner);
        require(freezes[_to] >= _value);
        require(_value > 0);
        freezes[_to] = freezes[_to].sub(_value);
		balanceOf[_to] = balanceOf[_to].add(_value);
        emit Unfreeze(_to, _value);
        return true;
    }

	function setParams(uint256 newBasisPoints, uint256 newMinFee, uint256 newMaxFee) public returns (bool success) {
</source>
<source file="systems/smart_contracts/TokenERC20.sol" startline="76" endline="90" pcid="7304">
    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    /**
     * Transfer tokens from other address
     *
     * Send `_value` tokens to `_to` on behalf of `_from`
     *
     * @param _from The address of the sender
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Contracts.sol" startline="100" endline="115" pcid="1998">
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    /**
     * Set allowance for other address and notify
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     * @param _extraData some extra information to send to the approved contract
     */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
</source>
<source file="systems/smart_contracts/Contracts.sol" startline="148" endline="157" pcid="2001">
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        Burn(_from, _value);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/AACD.sol" startline="94" endline="102" pcid="297">
    function approve(address _spender, uint256 _value)public returns (bool success) {
        require((_value==0)||(allowed[msg.sender][_spender]==0));
        allowed[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender)public view returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/AACD.sol" startline="66" endline="79" pcid="295">
    function transfer(address _to, uint256 _value)public returns (bool success) {
        require(_to != address(0));
        require(balanceOf[msg.sender] >= _value);
        require(balanceOf[ _to] + _value >= balanceOf[ _to]); 
        
        balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender],_value) ;
        balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ;
        
        emit Transfer(msg.sender, _to, _value);
        
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success) {
</source>
<source file="systems/smart_contracts/DDPC.sol" startline="98" endline="113" pcid="2380">
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    /**
     * Set allowance for other address and notify
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     * @param _extraData some extra information to send to the approved contract
     */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
</source>
<source file="systems/smart_contracts/SEA.sol" startline="107" endline="117" pcid="6398">
    function freeze(address _to,uint256 _value) public returns (bool success) {
		require(msg.sender == owner);
        require(balanceOf[_to] >= _value);
        require(_value > 0);
        balanceOf[_to] = balanceOf[_to].sub(_value);
        freezes[_to] = freezes[_to].add(_value);
        emit Freeze(_to, _value);
        return true;
    }

	function unfreeze(address _to,uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/DDPC.sol" startline="146" endline="155" pcid="2383">
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        Burn(_from, _value);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/TokenERC20.sol" startline="154" endline="163" pcid="7309">
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        emit Burn(_from, _value);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/DENARIO.sol" startline="39" endline="47" pcid="2448">
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SEA.sol" startline="82" endline="90" pcid="6396">
    function approve(address _spender, uint256 _value) public returns (bool success) {
		require(_spender != address(0));
		require((_value == 0) || (allowance[msg.sender][_spender] == 0));
        allowance[msg.sender][_spender] = _value;
		emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/DHF.sol" startline="66" endline="79" pcid="2542">
    function transfer(address _to, uint256 _value)public returns (bool success) {
        require(_to != address(0));
        require(balanceOf[msg.sender] >= _value);
        require(balanceOf[ _to] + _value >= balanceOf[ _to]); 
        
        balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender],_value) ;
        balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ;
        
        emit Transfer(msg.sender, _to, _value);
        
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success) {
</source>
<source file="systems/smart_contracts/DHF.sol" startline="94" endline="102" pcid="2544">
    function approve(address _spender, uint256 _value)public returns (bool success) {
        require((_value==0)||(allowed[msg.sender][_spender]==0));
        allowed[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender)public view returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="190" endline="196" pcid="2863">
    function transfer(address _to, uint256 _value) public returns (bool success){
        success = operator.token_transfer(msg.sender, _to, _value);
        bytes memory emptyBytes;
        internalTokenFallback(msg.sender, _to, _value, emptyBytes);
        emit Transfer(msg.sender, _to, _value);
    }
    function transfer(address _to, uint _value, bytes _data) public returns (bool success){
</source>
<source file="systems/smart_contracts/ICBB.sol" startline="174" endline="183" pcid="4271">
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        emit Burn(_from, _value);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="215" endline="220" pcid="2867">
    function approve(address _spender, uint256 _value) public returns (bool success){
        success = operator.token_approve(msg.sender, _spender, _value);
        emit Approval(msg.sender, _spender, _value);
    }
    
    function() public payable {
</source>
<source file="systems/smart_contracts/ESCHToken.sol" startline="57" endline="64" pcid="3044">
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }


    function burn(uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ESCHToken.sol" startline="72" endline="82" pcid="3046">
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);
        require(_value <= allowance[_from][msg.sender]);
        balanceOf[_from] -= _value;
        allowance[_from][msg.sender] -= _value;
        totalSupply -= _value;
        Burn(_from, _value);
        return true;
    }
 
    function setadmin (address _admin) public {
</source>
<source file="systems/smart_contracts/DaiSwap.sol" startline="26" endline="28" pcid="2285">
  function transfer(address _to, uint256 _value) public returns (bool success) {}
  //function transfer(address _to, uint _value) public;
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {}
</source>
<source file="systems/smart_contracts/ETGTOKEN.sol" startline="77" endline="91" pcid="3192">
    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    /**
     * Transfer tokens from other address
     *
     * Send `_value` tokens to `_to` on behalf of `_from`
     *
     * @param _from The address of the sender
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ETGTOKEN.sol" startline="155" endline="164" pcid="3197">
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        emit Burn(_from, _value);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/ICBB.sol" startline="96" endline="110" pcid="4266">
    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    /**
     * Transfer tokens from other address
     *
     * Send `_value` tokens to `_to` in behalf of `_from`
     *
     * @param _from The address of the sender
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Warpcoin.sol" startline="39" endline="47" pcid="7946">
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/HollywoodPay.sol" startline="22" endline="30" pcid="4226">
    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value);
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/BACD.sol" startline="244" endline="259" pcid="1026">
  function transfer(address _to, uint256 _value) public returns (bool success) {
    require(!frozenAccount[msg.sender]);
	if (frozen) return false;
    else return AbstractToken.transfer (_to, _value);
  }

  /**
   * Transfer given number of tokens from given owner to given recipient.
   *
   * @param _from address to transfer tokens from the owner of
   * @param _to address to transfer tokens to the owner of
   * @param _value number of tokens to transfer from given owner to given
   *        recipient
   * @return true if tokens were transferred successfully, false otherwise
   */
  function transferFrom(address _from, address _to, uint256 _value) public
</source>
<source file="systems/smart_contracts/GEF.sol" startline="51" endline="58" pcid="4063">
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        require((_value == 0) || (allowance[msg.sender][_spender] == 0));
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)
</source>
<source file="systems/smart_contracts/GEF.sol" startline="41" endline="45" pcid="4061">
    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/VCTAToken.sol" startline="34" endline="42" pcid="7669">
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/GBE.sol" startline="51" endline="58" pcid="4057">
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        require((_value == 0) || (allowance[msg.sender][_spender] == 0));
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)
</source>
<source file="systems/smart_contracts/VACCToken.sol" startline="153" endline="171" pcid="7628">
    function transfer(address to, uint256 tokens) public returns (bool success) {
        require(tokens <= balances[msg.sender]);

        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint256 tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/GBE.sol" startline="41" endline="45" pcid="4055">
    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/UNT.sol" startline="32" endline="40" pcid="7566">
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BACD.sol" startline="278" endline="291" pcid="1028">
  function approve (address _spender, uint256 _value) public
    returns (bool success) {
	require(allowance (msg.sender, _spender) == 0 || _value == 0);
    return AbstractToken.approve (_spender, _value);
  }

  /**
   * Create _value new tokens and give new created tokens to msg.sender.
   * May only be called by smart contract owner.
   *
   * @param _value number of tokens to create
   * @return true if tokens were created successfully, false otherwise
   */
  function createTokens(uint256 _value) public
</source>
<source file="systems/smart_contracts/BRZE.sol" startline="100" endline="106" pcid="1527">
  function transfer(address _to, uint256 _value) public returns (bool success) {
    _transfer(msg.sender, _to, _value);
    return true;
  }


  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
</class>

<class classid="68" nclones="67" nlines="4" similarity="75">
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="377" endline="387" pcid="248">
    function allowance(address tokenOwner, address spender) public view returns(uint remaining) {
        return allowed[tokenOwner][spender];
    }

    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account. The `spender` contract function
    // `receiveApproval(...)` is then executed
    // ------------------------------------------------------------------------

    function approveAndCall(address spender, uint tokens, bytes memory data) public returns(bool success) {
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="140" endline="145" pcid="1315">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SolaToken.sol" startline="182" endline="192" pcid="6591">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account. The `spender` contract function
    // `receiveApproval(...)` is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="179" endline="189" pcid="5820">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SHPC.sol" startline="62" endline="65" pcid="6512">
    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }   
}
</source>
<source file="systems/smart_contracts/SAMPLE.sol" startline="224" endline="236" pcid="6262">
	function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
		require(_stopTrade != true);

		return allowed[tokenOwner][spender];
	}


	// ------------------------------------------------------------------------
	// Token owner can approve for `spender` to transferFrom(...) `tokens`
	// from the token owner's account. The `spender` contract function
	// `receiveApproval(...)` is then executed
	// ------------------------------------------------------------------------
	function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="190" endline="200" pcid="414">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="140" endline="145" pcid="1261">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SapientiaCharlesToken.sol" startline="196" endline="206" pcid="6285">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account. The `spender` contract function
    // `receiveApproval(...)` is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BTToken.sol" startline="80" endline="84" pcid="1562">
    function allowance(address _owner, address _spender) constant returns (uint) {
        return allowed[_owner][_spender];
    }

    mapping (address => uint) balances;
</source>
<source file="systems/smart_contracts/CAC.sol" startline="102" endline="106" pcid="1619">
    function allowance(address _owner, address _spender)public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

}
</source>
<source file="systems/smart_contracts/BTGS.sol" startline="181" endline="188" pcid="1550">
    function allowance(address _owner, address _spender)
        public
        constant
        returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    function () public payable{
</source>
<source file="systems/smart_contracts/ContractCoffeeToken.sol" startline="192" endline="202" pcid="1989">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account. The `spender` contract function
    // `receiveApproval(...)` is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Perlin.sol" startline="198" endline="208" pcid="5654">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account. The `spender` contract function
    // `receiveApproval(...)` is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/AICRYPTO.sol" startline="194" endline="204" pcid="436">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account. The `spender` contract function
    // `receiveApproval(...)` is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BDAM.sol" startline="236" endline="246" pcid="1127">
  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }

  /**
   * approve should be called when allowed[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   */
  function increaseApproval (address _spender, uint _addedValue)
</source>
<source file="systems/smart_contracts/CRYPTOMZ.sol" startline="189" endline="198" pcid="2187">
  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }

  /**
   * approve should be called when allowed[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   */
  function increaseApproval (address _spender, uint _addedValue) public
</source>
<source file="systems/smart_contracts/BIBCOINID.sol" startline="195" endline="205" pcid="1213">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/CGT.sol" startline="196" endline="206" pcid="1699">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account. The `spender` contract function
    // `receiveApproval(...)` is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BEX.sol" startline="66" endline="70" pcid="1170">
	function allowance(address tokenOwner, address spender)public constant returns (uint remaining) {
		return allowed[tokenOwner][spender];
	}
	
	event Transfer(address indexed from, address indexed to, uint tokens);//transfer方法调用时的通知事件
</source>
<source file="systems/smart_contracts/SAS.sol" startline="121" endline="125" pcid="6302">
  function allowance(address _owner, address _spender)public view returns (uint256 remaining) {
      return allowed[_owner][_spender];
  }

}
</source>
<source file="systems/smart_contracts/MT.sol" startline="102" endline="106" pcid="5080">
    function allowance(address _owner, address _spender)public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

}
</source>
<source file="systems/smart_contracts/PAYCASH.sol" startline="194" endline="204" pcid="5624">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/P21.sol" startline="76" endline="80" pcid="5589">
    function allowance(address _owner, address _spender) constant returns (uint) {
        return allowed[_owner][_spender];
    }

    mapping (address => uint) balances;
</source>
<source file="systems/smart_contracts/OSManagerToken.sol" startline="116" endline="120" pcid="5561">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }

    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/MiniMeTokenFactory.sol" startline="283" endline="294" pcid="4812">
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    /// @notice `msg.sender` approves `_spender` to send `_amount` tokens on
    ///  its behalf, and then a function is triggered in the contract that is
    ///  being approved, `_spender`. This allows users to use their tokens to
    ///  interact with contracts in one function call instead of two
    /// @param _spender The address of the contract able to transfer the tokens
    /// @param _amount The amount of tokens to be approved for transfer
    /// @return True if the function call was successful
    function approveAndCall(ApproveAndCallFallBack _spender, uint256 _amount, bytes _extraData) public returns (bool success) {
</source>
<source file="systems/smart_contracts/TECToken.sol" startline="76" endline="80" pcid="7137">
    function allowance(address _owner, address _spender) constant returns (uint) {
        return allowed[_owner][_spender];
    }

    mapping (address => uint) balances;
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="616" endline="634" pcid="282">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {

        return allowed[tokenOwner][spender];

    }



    // ------------------------------------------------------------------------

    // Token owner can approve for `spender` to transferFrom(...) `tokens`

    // from the token owner's account. The `spender` contract function

    // `receiveApproval(...)` is then executed

    // ------------------------------------------------------------------------

    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/AACD.sol" startline="102" endline="106" pcid="298">
    function allowance(address _owner, address _spender)public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

}
</source>
<source file="systems/smart_contracts/Melodic.sol" startline="195" endline="205" pcid="4796">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ContractCargoberToken.sol" startline="192" endline="202" pcid="1967">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account. The `spender` contract function
    // `receiveApproval(...)` is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/OBK.sol" startline="62" endline="65" pcid="5472">
    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }   
}
</source>
<source file="systems/smart_contracts/LanceToken.sol" startline="195" endline="205" pcid="4528">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/AnxToken.sol" startline="194" endline="204" pcid="720">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/JUNDCOIN.sol" startline="191" endline="201" pcid="4370">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/NMAI.sol" startline="102" endline="106" pcid="5450">
    function allowance(address _owner, address _spender)public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

}
</source>
<source file="systems/smart_contracts/AzurToken.sol" startline="91" endline="95" pcid="1009">
  function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }

  mapping (address => uint256) balances;
</source>
<source file="systems/smart_contracts/NaorisToken.sol" startline="172" endline="182" pcid="5292">
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    /**
     * approve should be called when allowed[_spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     */
    function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {
</source>
<source file="systems/smart_contracts/JDC.sol" startline="136" endline="142" pcid="4348">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/NEM.sol" startline="102" endline="106" pcid="5328">
    function allowance(address _owner, address _spender)public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

}
</source>
<source file="systems/smart_contracts/GRAM.sol" startline="193" endline="203" pcid="4212">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/GoldenRings.sol" startline="126" endline="136" pcid="4179">
    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    /**
    * approve should be called when allowed[_spender] == 0. To increment
    * allowed value is better to use this function to avoid 2 calls (and wait until
    * the first transaction is mined)
    * From MonolithDAO Token.sol
    */
    function increaseApproval(address _spender, uint256 _addedValue) public returns (bool success) {
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="145" endline="150" pcid="7560">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="167" endline="173" pcid="2436">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


   
    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="175" endline="185" pcid="7444">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/GNB.sol" startline="280" endline="290" pcid="4138">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/DENARIO.sol" startline="69" endline="72" pcid="2452">
    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="172" endline="182" pcid="7463">
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    /**
     * approve should be called when allowed[_spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     */
    function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {
</source>
<source file="systems/smart_contracts/UNT.sol" startline="62" endline="65" pcid="7570">
    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }   
}
</source>
<source file="systems/smart_contracts/DGC.sol" startline="196" endline="206" pcid="2529">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account. The `spender` contract function
    // `receiveApproval(...)` is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BACD.sol" startline="163" endline="172" pcid="1024">
  function allowance(address _owner, address _spender) public view
  returns (uint256 remaining) {
    return allowances [_owner][_spender];
  }

  /**
   * Mapping from addresses of token holders to the numbers of tokens belonging
   * to these token holders.
   */
  mapping (address => uint256) accounts;
</source>
<source file="systems/smart_contracts/GFNX.sol" startline="151" endline="156" pcid="4107">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return _allowed[tokenOwner][spender];
    }
 
    // Transfer the balance from owner's account to another account
    function transfer(address to, uint value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/DHF.sol" startline="102" endline="106" pcid="2545">
    function allowance(address _owner, address _spender)public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

}
</source>
<source file="systems/smart_contracts/VACCToken.sol" startline="203" endline="213" pcid="7631">
    function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint256 tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/VCTAToken.sol" startline="62" endline="65" pcid="7673">
    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}
</source>
<source file="systems/smart_contracts/VENT.sol" startline="164" endline="174" pcid="7691">
        function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
            return allowed[tokenOwner][spender];
        }
        // ------------------------------------------------------------------------
        // Transfer the balance from token owner's account to `to` account
        // - Owner's account must have sufficient balance to transfer
        // - 0 value transfers are allowed
        // - takes in locking Period to lock the tokens to be used
        // - if want to transfer without locking enter 0 in lockingPeriod argument 
        // ------------------------------------------------------------------------
        function distributeTokens(address to, uint tokens, uint256 lockingPeriod) onlyOwner public returns (bool success) {
</source>
<source file="systems/smart_contracts/FixedSupplyToken.sol" startline="196" endline="206" pcid="3614">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account. The `spender` contract function
    // `receiveApproval(...)` is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/VOTENOmodumtokenswapdotcom.sol" startline="195" endline="205" pcid="7847">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/XTRLPAY.sol" startline="195" endline="205" pcid="8145">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/FUNNYTOKEN.sol" startline="124" endline="128" pcid="3959">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }

    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="140" endline="145" pcid="1237">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Warpcoin.sol" startline="69" endline="72" pcid="7950">
    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}
</source>
<source file="systems/smart_contracts/WanCoinToken.sol" startline="182" endline="192" pcid="7891">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account. The `spender` contract function
    // `receiveApproval(...)` is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="140" endline="145" pcid="3426">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/WanCoinSupplyToken.sol" startline="182" endline="192" pcid="7869">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account. The `spender` contract function
    // `receiveApproval(...)` is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Exchange.sol" startline="303" endline="308" pcid="3386">
    function availableBalanceOf(address token, address user) view returns (uint256) {
        return safeSub(balanceOf(token, user), getReserve(token, user));
    }

    // Returns the inactivity release perios
    function getInactivityReleasePeriod() view returns (uint256)
</source>
<source file="systems/smart_contracts/Exchange.sol" startline="258" endline="264" pcid="3379">
    function balanceOf(address token, address user) view returns (uint256) {
        //return tokens[token][user];
        return decodeBalanceAndReserve(token, user)[0];
    }

    // Returns the reserved amound of token for user
    function getReserve(address token, address user) public view returns (uint256) { 
</source>
</class>

<class classid="69" nclones="10" nlines="4" similarity="75">
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="387" endline="398" pcid="249">
    function approveAndCall(address spender, uint tokens, bytes memory data) public returns(bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);
        return true;
    }

    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------

    function () external payable {
</source>
<source file="systems/smart_contracts/SAMPLE.sol" startline="236" endline="250" pcid="6263">
	function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
		require(_stopTrade != true);
		require(msg.sender != spender);

		allowed[msg.sender][spender] = tokens;
		emit Approval(msg.sender, spender, tokens);
		ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);
		return true;
	}


	// ------------------------------------------------------------------------
	// Don't accept ETH
	// ------------------------------------------------------------------------
	function () external payable {
</source>
<source file="systems/smart_contracts/GoaToken.sol" startline="190" endline="205" pcid="4158">
    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
        allowance[msg.sender][spender] = tokens;

        emit Approval(msg.sender, spender, tokens);

        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);

        return true;
    }

    //-- mint
    // Transfer ETH to receive a given amount of tokens in exchange
    // Token amount must be integers, no decimals
    // Current token cost is determined through computeCost, frontend sets the proper ETH amount to send

    function mint(uint fullToken) public payable {
</source>
<source file="systems/smart_contracts/SapientiaCharlesToken.sol" startline="206" endline="217" pcid="6286">
    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () external payable {
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="150" endline="161" pcid="7561">
    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () external payable {
</source>
<source file="systems/smart_contracts/FixedSupplyToken.sol" startline="206" endline="217" pcid="3615">
    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () external payable {
</source>
<source file="systems/smart_contracts/DGC.sol" startline="206" endline="217" pcid="2530">
    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () external payable {
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="173" endline="184" pcid="2437">
    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () external payable {
</source>
<source file="systems/smart_contracts/CGT.sol" startline="206" endline="217" pcid="1700">
    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () external payable {
</source>
<source file="systems/smart_contracts/AICRYPTO.sol" startline="204" endline="215" pcid="437">
    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () external payable {
</source>
</class>

<class classid="70" nclones="40" nlines="2" similarity="100">
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="139" endline="141" pcid="263">
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;

}
</source>
<source file="systems/smart_contracts/Rabbit.sol" startline="6" endline="6" pcid="5939">
interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }
</source>
<source file="systems/smart_contracts/SolaToken.sol" startline="53" endline="54" pcid="6583">
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}
</source>
<source file="systems/smart_contracts/OSManagerToken.sol" startline="40" endline="41" pcid="5553">
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}
</source>
<source file="systems/smart_contracts/Perlin.sol" startline="68" endline="69" pcid="5644">
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}
</source>
<source file="systems/smart_contracts/AnxToken.sol" startline="67" endline="68" pcid="712">
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}
</source>
<source file="systems/smart_contracts/PAYCASH.sol" startline="67" endline="68" pcid="5615">
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}
</source>
<source file="systems/smart_contracts/RanchChain.sol" startline="7" endline="7" pcid="5975">
interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }
</source>
<source file="systems/smart_contracts/MyAdvancedToken.sol" startline="24" endline="24" pcid="5261">
interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }
</source>
<source file="systems/smart_contracts/BIBCOINID.sol" startline="68" endline="69" pcid="1205">
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="55" endline="56" pcid="1227">
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="55" endline="56" pcid="1251">
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}
</source>
<source file="systems/smart_contracts/MiniMeTokenFactory.sol" startline="76" endline="82" pcid="4805">
    function receiveApproval(
        address from,
        uint256 _amount,
        address _token,
        bytes _data
    ) public;
}
</source>
<source file="systems/smart_contracts/Melodic.sol" startline="68" endline="69" pcid="4788">
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}
</source>
<source file="systems/smart_contracts/ThpToken.sol" startline="28" endline="28" pcid="7157">
interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="55" endline="56" pcid="1305">
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}
</source>
<source file="systems/smart_contracts/LanceToken.sol" startline="68" endline="69" pcid="4520">
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}
</source>
<source file="systems/smart_contracts/TokenERC20.sol" startline="7" endline="7" pcid="7302">
interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="113" endline="114" pcid="4388">
    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; 
}
</source>
<source file="systems/smart_contracts/XTRLPAY.sol" startline="68" endline="69" pcid="8137">
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}
</source>
<source file="systems/smart_contracts/JUNDCOIN.sol" startline="64" endline="65" pcid="4362">
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}
</source>
<source file="systems/smart_contracts/JDC.sol" startline="44" endline="45" pcid="4340">
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}
</source>
<source file="systems/smart_contracts/ICBB.sol" startline="28" endline="28" pcid="4264">
interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes calldata_extraData) external; }
</source>
<source file="systems/smart_contracts/GRAM.sol" startline="65" endline="66" pcid="4204">
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}
</source>
<source file="systems/smart_contracts/byzbit.sol" startline="11" endline="11" pcid="1592">
interface tokenRecepient { function recieveApproval (address _from, uint256 _value, address _token, bytes _extradata) external;	}
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="48" endline="49" pcid="7434">
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}
</source>
<source file="systems/smart_contracts/GNB.sol" startline="57" endline="58" pcid="4128">
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}
</source>
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="112" endline="113" pcid="1634">
    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; 
}
</source>
<source file="systems/smart_contracts/FUNNYTOKEN.sol" startline="48" endline="49" pcid="3951">
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}
</source>
<source file="systems/smart_contracts/CLCTokenERC20.sol" startline="7" endline="7" pcid="1736">
interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }
</source>
<source file="systems/smart_contracts/UTRAToken.sol" startline="7" endline="7" pcid="7598">
interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }
</source>
<source file="systems/smart_contracts/VACCToken.sol" startline="71" endline="72" pcid="7623">
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}
</source>
<source file="systems/smart_contracts/DDPC.sol" startline="6" endline="6" pcid="2375">
interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }
</source>
<source file="systems/smart_contracts/ContractCargoberToken.sol" startline="63" endline="64" pcid="1959">
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}
</source>
<source file="systems/smart_contracts/VOTENOmodumtokenswapdotcom.sol" startline="68" endline="69" pcid="7839">
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}
</source>
<source file="systems/smart_contracts/WanCoinSupplyToken.sol" startline="53" endline="54" pcid="7861">
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="55" endline="56" pcid="3416">
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}
</source>
<source file="systems/smart_contracts/Contracts.sol" startline="7" endline="7" pcid="1993">
interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }
</source>
<source file="systems/smart_contracts/WanCoinToken.sol" startline="53" endline="54" pcid="7883">
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}
</source>
<source file="systems/smart_contracts/ContractCoffeeToken.sol" startline="63" endline="64" pcid="1981">
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}
</source>
</class>

<class classid="71" nclones="36" nlines="4" similarity="75">
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="592" endline="616" pcid="281">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {

        balances[from] = balances[from].sub(tokens);

        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);

        balances[to] = balances[to].add(tokens);

        Transfer(from, to, tokens);

        return true;

    }



    // ------------------------------------------------------------------------

    // Returns the amount of tokens approved by the owner that can be

    // transferred to the spender's account

    // ------------------------------------------------------------------------

    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/AICRYPTO.sol" startline="181" endline="194" pcid="435">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = balances[from].sub(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
</source>
<source file="systems/smart_contracts/FixedSupplyToken.sol" startline="183" endline="196" pcid="3613">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = balances[from].sub(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="131" endline="140" pcid="3425">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }


    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/GNB.sol" startline="268" endline="280" pcid="4137">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }

    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/PAYCASH.sol" startline="181" endline="194" pcid="5623">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/WanCoinSupplyToken.sol" startline="169" endline="182" pcid="7868">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = balances[from].sub(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
</source>
<source file="systems/smart_contracts/OSManagerToken.sol" startline="108" endline="116" pcid="5560">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }

    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/AnxToken.sol" startline="181" endline="194" pcid="719">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/CGT.sol" startline="183" endline="196" pcid="1698">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = balances[from].sub(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
</source>
<source file="systems/smart_contracts/VOTENOmodumtokenswapdotcom.sol" startline="182" endline="195" pcid="7846">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="131" endline="140" pcid="1236">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }


    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/JDC.sol" startline="126" endline="136" pcid="4347">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/ContractCargoberToken.sol" startline="179" endline="192" pcid="1966">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = balances[from].sub(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
</source>
<source file="systems/smart_contracts/Melodic.sol" startline="182" endline="195" pcid="4795">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="162" endline="175" pcid="7443">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/ContractCoffeeToken.sol" startline="179" endline="192" pcid="1988">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = balances[from].sub(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="136" endline="145" pcid="7559">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
</source>
<source file="systems/smart_contracts/SolaToken.sol" startline="169" endline="182" pcid="6590">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = balances[from].sub(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
</source>
<source file="systems/smart_contracts/LanceToken.sol" startline="182" endline="195" pcid="4527">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/BIBCOINID.sol" startline="182" endline="195" pcid="1212">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/Perlin.sol" startline="185" endline="198" pcid="5653">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/JUNDCOIN.sol" startline="178" endline="191" pcid="4369">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/GoaToken.sol" startline="175" endline="190" pcid="4157">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balanceOf[from] = balanceOf[from].sub(tokens);
        allowance[from][msg.sender] = allowance[from][msg.sender].sub(tokens);
        balanceOf[to] = balanceOf[to].add(tokens);

        emit Transfer(from, to, tokens);

        return true;
    }

    //-- approveAndCall
    // Token owner can approve for "spender" to transferFrom(...) "tokens" tokens
    // from the token owner's account. The "spender" contract function
    // "receiveApproval(...)"" is then executed

    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/FUNNYTOKEN.sol" startline="116" endline="124" pcid="3958">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }

    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/XTRLPAY.sol" startline="182" endline="195" pcid="8144">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/GFNX.sol" startline="178" endline="188" pcid="4110">
    function transferFrom(address from, address to, uint value) public returns (bool success) {
        require(value <= balanceOf(from));
        require(value <= allowance(from, to));
        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        _allowed[from][to] = _allowed[from][to].sub(value);
        emit Transfer(from, to, value);
        return true;
    }
    
    function burn(uint256 amount) public {
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="154" endline="167" pcid="2435">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = balances[from].sub(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="177" endline="190" pcid="413">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="131" endline="140" pcid="1314">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }


    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/DGC.sol" startline="183" endline="196" pcid="2528">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = balances[from].sub(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
</source>
<source file="systems/smart_contracts/GRAM.sol" startline="180" endline="193" pcid="4211">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/WanCoinToken.sol" startline="169" endline="182" pcid="7890">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = balances[from].sub(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="166" endline="179" pcid="5819">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="131" endline="140" pcid="1260">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }


    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/SapientiaCharlesToken.sol" startline="183" endline="196" pcid="6284">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = balances[from].sub(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
</source>
</class>

<class classid="72" nclones="30" nlines="4" similarity="75">
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="634" endline="654" pcid="283">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {

        allowed[msg.sender][spender] = tokens;

        Approval(msg.sender, spender, tokens);

        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);

        return true;

    }



    // ------------------------------------------------------------------------

    // Don't accept ETH

    // ------------------------------------------------------------------------

    function () public payable {
</source>
<source file="systems/smart_contracts/GRAM.sol" startline="203" endline="214" pcid="4213">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/JDC.sol" startline="142" endline="151" pcid="4349">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    
    function () public payable {
</source>
<source file="systems/smart_contracts/JUNDCOIN.sol" startline="201" endline="212" pcid="4371">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="145" endline="153" pcid="1316">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    function () public payable {
</source>
<source file="systems/smart_contracts/ContractCoffeeToken.sol" startline="202" endline="213" pcid="1990">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/LanceToken.sol" startline="205" endline="216" pcid="4529">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/Melodic.sol" startline="205" endline="216" pcid="4797">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="185" endline="196" pcid="7445">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH ???????
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/OSManagerToken.sol" startline="120" endline="127" pcid="5562">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }

    function () public payable {
</source>
<source file="systems/smart_contracts/PAYCASH.sol" startline="204" endline="215" pcid="5625">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="145" endline="153" pcid="1262">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    function () public payable {
</source>
<source file="systems/smart_contracts/GNB.sol" startline="290" endline="301" pcid="4139">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/Perlin.sol" startline="208" endline="218" pcid="5655">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }

    // ------------------------------------------------------------------------
    // 3,250 Perlin per 1 ETH
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/SolaToken.sol" startline="192" endline="203" pcid="6592">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="189" endline="200" pcid="5821">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/ContractCargoberToken.sol" startline="202" endline="213" pcid="1968">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="200" endline="211" pcid="415">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/FUNNYTOKEN.sol" startline="128" endline="135" pcid="3960">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }

    function () public payable {
</source>
<source file="systems/smart_contracts/VOTENOmodumtokenswapdotcom.sol" startline="205" endline="216" pcid="7848">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/WanCoinSupplyToken.sol" startline="192" endline="203" pcid="7870">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/AnxToken.sol" startline="204" endline="215" pcid="721">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="145" endline="153" pcid="3427">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    function () public payable {
</source>
<source file="systems/smart_contracts/BIBCOINID.sol" startline="205" endline="216" pcid="1214">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/WanCoinToken.sol" startline="192" endline="203" pcid="7892">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="196" endline="201" pcid="2864">
    function transfer(address _to, uint _value, bytes _data) public returns (bool success){
        success = operator.token_transfer(msg.sender, _to, _value, _data);
        internalTokenFallback(msg.sender, _to, _value, _data);
        emit Transfer(msg.sender, _to, _value);
    }
    function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success){
</source>
<source file="systems/smart_contracts/XTRLPAY.sol" startline="205" endline="216" pcid="8146">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="145" endline="153" pcid="1238">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    function () public payable {
</source>
<source file="systems/smart_contracts/VACCToken.sol" startline="213" endline="224" pcid="7632">
    function approveAndCall(address spender, uint256 tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/UGCoin.sol" startline="136" endline="143" pcid="7541">
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        
        require(_spender.call(bytes4(bytes32(keccak256("receiveApproval(address,uint256,address,bytes)"))), msg.sender, _value, this, _extraData));
        return true;
    }
}
</source>
</class>

<class classid="73" nclones="12" nlines="2" similarity="100">
<source file="systems/smart_contracts/AACD.sol" startline="47" endline="49" pcid="294">
    function allowance(address _owner, address _spender)public view returns (uint256 remaining);
    
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="74" endline="76" pcid="1717">
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
</source>
<source file="systems/smart_contracts/SAS.sol" startline="47" endline="48" pcid="6297">
  function allowance(address _owner, address _spender)public view returns (uint256 remaining);
  event Transfer(address indexed _from, address indexed _to, uint256 _value);
</source>
<source file="systems/smart_contracts/CAC.sol" startline="47" endline="49" pcid="1615">
    function allowance(address _owner, address _spender)public view returns (uint256 remaining);
    
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
</source>
<source file="systems/smart_contracts/BTGS.sol" startline="17" endline="18" pcid="1541">
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
</source>
<source file="systems/smart_contracts/MT.sol" startline="47" endline="49" pcid="5076">
    function allowance(address _owner, address _spender)public view returns (uint256 remaining);
    
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
</source>
<source file="systems/smart_contracts/AzurToken.sol" startline="48" endline="50" pcid="1004">
  function allowance(address _owner, address _spender) public view returns (uint256 remaining);

  event Transfer(address indexed _from, address indexed _to, uint256 _value);
</source>
<source file="systems/smart_contracts/BACD.sol" startline="64" endline="65" pcid="1019">
  function allowance(address _owner, address _spender) public view returns (uint256 remaining);
  event Transfer(address indexed _from, address indexed _to, uint256 _value);
</source>
<source file="systems/smart_contracts/NMAI.sol" startline="47" endline="49" pcid="5446">
    function allowance(address _owner, address _spender)public view returns (uint256 remaining);
    
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
</source>
<source file="systems/smart_contracts/DHF.sol" startline="47" endline="49" pcid="2541">
    function allowance(address _owner, address _spender)public view returns (uint256 remaining);
    
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
</source>
<source file="systems/smart_contracts/VACCToken.sol" startline="55" endline="56" pcid="7619">
    function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining);
    function transfer(address to, uint256 tokens) public returns (bool success);
</source>
<source file="systems/smart_contracts/NEM.sol" startline="47" endline="49" pcid="5324">
    function allowance(address _owner, address _spender)public view returns (uint256 remaining);
    
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
</source>
</class>

<class classid="74" nclones="7" nlines="5" similarity="100">
<source file="systems/smart_contracts/AACD.sol" startline="79" endline="94" pcid="296">
    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success) {
        require(_to != address(0));
        require(allowed[_from][msg.sender] >= _value);
        require(balanceOf[_from] >= _value);
        require(balanceOf[ _to] + _value >= balanceOf[ _to]);
        
        balanceOf[_from] =SafeMath.safeSub(balanceOf[_from],_value) ;
        balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ;
        
        allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender],_value) ;
        
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value)public returns (bool success) {
</source>
<source file="systems/smart_contracts/NEM.sol" startline="79" endline="94" pcid="5326">
    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success) {
        require(_to != address(0));
        require(allowed[_from][msg.sender] >= _value);
        require(balanceOf[_from] >= _value);
        require(balanceOf[ _to] + _value >= balanceOf[ _to]);
        
        balanceOf[_from] =SafeMath.safeSub(balanceOf[_from],_value) ;
        balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ;
        
        allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender],_value) ;
        
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value)public returns (bool success) {
</source>
<source file="systems/smart_contracts/MT.sol" startline="79" endline="94" pcid="5078">
    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success) {
        require(_to != address(0));
        require(allowed[_from][msg.sender] >= _value);
        require(balanceOf[_from] >= _value);
        require(balanceOf[ _to] + _value >= balanceOf[ _to]);
        
        balanceOf[_from] =SafeMath.safeSub(balanceOf[_from],_value) ;
        balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ;
        
        allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender],_value) ;
        
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value)public returns (bool success) {
</source>
<source file="systems/smart_contracts/NMAI.sol" startline="79" endline="94" pcid="5448">
    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success) {
        require(_to != address(0));
        require(allowed[_from][msg.sender] >= _value);
        require(balanceOf[_from] >= _value);
        require(balanceOf[ _to] + _value >= balanceOf[ _to]);
        
        balanceOf[_from] =SafeMath.safeSub(balanceOf[_from],_value) ;
        balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ;
        
        allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender],_value) ;
        
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value)public returns (bool success) {
</source>
<source file="systems/smart_contracts/CAC.sol" startline="79" endline="94" pcid="1617">
    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success) {
        require(_to != address(0));
        require(allowed[_from][msg.sender] >= _value);
        require(balanceOf[_from] >= _value);
        require(balanceOf[ _to] + _value >= balanceOf[ _to]);
        
        balanceOf[_from] =SafeMath.safeSub(balanceOf[_from],_value) ;
        balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ;
        
        allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender],_value) ;
        
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value)public returns (bool success) {
</source>
<source file="systems/smart_contracts/DHF.sol" startline="79" endline="94" pcid="2543">
    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success) {
        require(_to != address(0));
        require(allowed[_from][msg.sender] >= _value);
        require(balanceOf[_from] >= _value);
        require(balanceOf[ _to] + _value >= balanceOf[ _to]);
        
        balanceOf[_from] =SafeMath.safeSub(balanceOf[_from],_value) ;
        balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ;
        
        allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender],_value) ;
        
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value)public returns (bool success) {
</source>
<source file="systems/smart_contracts/SAS.sol" startline="98" endline="113" pcid="6300">
  function transferFrom(address _from, address _to, uint256 _value)public returns (bool success) {
      require(_to != address(0));
      require(allowed[_from][msg.sender] >= _value);
      require(balanceOf[_from] >= _value);
      require(balanceOf[ _to] + _value >= balanceOf[ _to]);

      balanceOf[_from] =SafeMath.safeSub(balanceOf[_from],_value) ;
      balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ;

      allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender],_value) ;

      emit Transfer(msg.sender, _to, _value);
      return true;
  }

  function approve(address _spender, uint256 _value)public returns (bool success) {
</source>
</class>

<class classid="75" nclones="265" nlines="2" similarity="100">
<source file="systems/smart_contracts/ABCToken.sol" startline="29" endline="38" pcid="301">
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="134" endline="145" pcid="6021">
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a `Transfer` event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="68" endline="69" pcid="6552">
    function approve(address spender, uint256 value) public returns (bool);
    event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="14" endline="15" pcid="5988">
  function approve(address spender, uint256 value) external returns (bool);
  function transferFrom(address from, address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="109" endline="118" pcid="6019">
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through `transferFrom`. This is
     * zero by default.
     *
     * This value changes when `approve` or `transferFrom` are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="31" endline="40" pcid="477">
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through `transferFrom`. This is
     * zero by default.
     *
     * This value changes when `approve` or `transferFrom` are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="61" endline="62" pcid="6549">
    function transfer(address to, uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="87" endline="90" pcid="5841">
    function approve(address spender, uint256 value)
    external returns (bool);

    function transferFrom(address from, address to, uint256 value)
</source>
<source file="systems/smart_contracts/PokaToken.sol" startline="10" endline="12" pcid="5726">
    function approve(address spender, uint256 value) external returns (bool);

    function transferFrom(address from, address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="85" endline="87" pcid="5840">
    function transfer(address to, uint256 value) external returns (bool);

    function approve(address spender, uint256 value)
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="25" endline="34" pcid="5771">
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/RETC.sol" startline="34" endline="35" pcid="6179">
    function transfer(address to, uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="17" endline="18" pcid="6069">
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="71" endline="72" pcid="6486">
    function approve(address spender, uint256 value) public returns (bool);
    event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="17" endline="19" pcid="6405">
    function transfer(address to, uint256 value) external returns (bool);

    function approve(address spender, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="309" endline="311" pcid="5683">
    function approve(address spender, uint256 value) external returns (bool);

    function transferFrom(address from, address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="56" endline="67" pcid="646">
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a `Transfer` event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="184" endline="195" pcid="5958">
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a `Transfer` event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/PositionTokenV2.sol" startline="36" endline="37" pcid="5748">
  function approve(address _spender, uint256 _value) public returns (bool);
  event Approval(
</source>
<source file="systems/smart_contracts/PositionTokenV2.sol" startline="21" endline="22" pcid="5745">
  function transfer(address _to, uint256 _value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="54" endline="65" pcid="303">
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/SistContract.sol" startline="50" endline="51" pcid="6520">
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/Aigopay.sol" startline="80" endline="81" pcid="450">
    function approve(address spender, uint256 value) public returns (bool);
    event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="95" endline="98" pcid="4238">
  function approve(address spender, uint256 value)
  external returns (bool);

  function transferFrom(address from, address to, uint256 value)
</source>
<source file="systems/smart_contracts/FMT.sol" startline="12" endline="13" pcid="3647">
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/Factory.sol" startline="198" endline="199" pcid="3445">
    function transfer(address to, uint256 value) external returns (bool);
    function approve(address spender, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="307" endline="309" pcid="5682">
    function transfer(address to, uint256 value) external returns (bool);

    function approve(address spender, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/UTC.sol" startline="125" endline="126" pcid="7583">
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="66" endline="67" pcid="4298">
    function transfer(address _to, uint256 _value) public returns (bool);
}
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="72" endline="73" pcid="4300">
    function transfer(address to, uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="79" endline="80" pcid="4303">
    function approve(address spender, uint256 value) public returns (bool);
    event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="136" endline="145" pcid="7902">
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through `transferFrom`. This is
     * zero by default.
     *
     * This value changes when `approve` or `transferFrom` are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/Aigopay.sol" startline="73" endline="74" pcid="447">
    function transfer(address to, uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/ITVR.sol" startline="18" endline="19" pcid="4324">
  function transfer(address _to, uint256 _value) public returns (bool);
  function balanceOf(address who) public view returns (uint256);
</source>
<source file="systems/smart_contracts/Factory.sol" startline="199" endline="200" pcid="3446">
    function approve(address spender, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="15" endline="16" pcid="7741">
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/UTC.sol" startline="65" endline="66" pcid="7577">
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="215" endline="216" pcid="7795">
    function transfer(address recipient, uint256 amount) external returns (bool);
    function mintWithAllocation(address account, uint256 amount, address allocationContract) external returns (bool);
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="11" endline="12" pcid="3915">
  function transfer(address to, uint256 value) external returns (bool);
  function approve(address spender, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/SellableToken.sol" startline="37" endline="38" pcid="6460">
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="12" endline="13" pcid="3916">
  function approve(address spender, uint256 value) external returns (bool);
  function transferFrom(address from, address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="31" endline="40" pcid="5904">
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="56" endline="67" pcid="519">
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a `Transfer` event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="19" endline="21" pcid="6406">
    function approve(address spender, uint256 value) external returns (bool);

    function transferFrom(address from, address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="194" endline="195" pcid="7791">
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="192" endline="193" pcid="7789">
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="31" endline="40" pcid="1746">
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through `transferFrom`. This is
     * zero by default.
     *
     * This value changes when `approve` or `transferFrom` are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="161" endline="172" pcid="7904">
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a `Transfer` event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/AronCoin.sol" startline="15" endline="16" pcid="757">
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/TokenSwap.sol" startline="148" endline="150" pcid="7395">
    function transfer(address to, uint256 value) external returns (bool);

    function approve(address spender, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="58" endline="59" pcid="6481">
    function transfer(address _to, uint256 _value) public returns (bool);
}
</source>
<source file="systems/smart_contracts/RETC.sol" startline="41" endline="42" pcid="6182">
    function approve(address spender, uint256 value) public returns (bool);
    event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/Gacha.sol" startline="76" endline="78" pcid="3976">
    function transfer(address to, uint256 value) public returns (bool);

    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/ankara.sol" startline="21" endline="23" pcid="676">
    function approve(address spender, uint256 value) external returns (bool);

    function transferFrom(address from, address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/TokenSwap.sol" startline="150" endline="152" pcid="7396">
    function approve(address spender, uint256 value) external returns (bool);

    function transferFrom(address from, address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="287" endline="288" pcid="7360">
    function mint(address _to, uint256 _amount) public returns (bool);
    function owner() public view returns (address);
</source>
<source file="systems/smart_contracts/UGCoin.sol" startline="41" endline="42" pcid="7531">
    function approve(address spender, uint256 value) public returns (bool);
    event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="44" endline="45" pcid="2042">
    function transfer(address to, uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/UGCoin.sol" startline="34" endline="35" pcid="7528">
    function transfer(address to, uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="93" endline="95" pcid="4237">
  function transfer(address to, uint256 value) external returns (bool);

  function approve(address spender, uint256 value)
</source>
<source file="systems/smart_contracts/GameGold.sol" startline="193" endline="194" pcid="3996">
  function transfer(address to, uint256 value) public returns (bool);
  function allowance(address owner, address spender) public view returns (uint256);
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="60" endline="61" pcid="6679">
    function transfer(address _to, uint256 _value) public returns (bool);
}
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="66" endline="67" pcid="6681">
    function transfer(address to, uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="73" endline="74" pcid="6684">
    function approve(address spender, uint256 value) public returns (bool);
    event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="331" endline="332" pcid="6097">
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="281" endline="283" pcid="7359">
    function transfer(address to, uint256 value) public returns (bool);

    event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/PDataToSHFund.sol" startline="18" endline="19" pcid="5628">
  function transfer(address _to, uint256 _value) public returns (bool);
  function balanceOf(address who) public view returns (uint256);
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="186" endline="188" pcid="6727">
    function transfer(address to, uint256 value) external returns (bool);

    function approve(address spender, uint256 value)
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="188" endline="191" pcid="6728">
    function approve(address spender, uint256 value)
    external returns (bool);

    function transferFrom(address from, address to, uint256 value)
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="278" endline="279" pcid="7356">
    function approve(address spender, uint256 value) public returns (bool);
    function totalSupply() public view returns (uint256);
</source>
<source file="systems/smart_contracts/PokaToken.sol" startline="8" endline="10" pcid="5725">
    function transfer(address to, uint256 value) external returns (bool);

    function approve(address spender, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/SuperMarket.sol" startline="8" endline="10" pcid="6753">
    function transfer(address to, uint256 value) external returns (bool);

    function approve(address spender, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/SuperMarket.sol" startline="10" endline="12" pcid="6754">
    function approve(address spender, uint256 value) external returns (bool);

    function transferFrom(address from, address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="103" endline="104" pcid="4385">
    function transfer(address to, uint256 value) public returns (bool);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/SBC.sol" startline="283" endline="285" pcid="6329">
    function transfer(address to, uint256 value) external returns (bool);

    function approve(address spender, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="423" endline="424" pcid="6615">
	function transfer(address to, uint256 value) public returns (bool);
	event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="159" endline="168" pcid="5956">
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through `transferFrom`. This is
     * zero by default.
     *
     * This value changes when `approve` or `transferFrom` are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="105" endline="107" pcid="4387">
    function approve(address spender, uint256 value) public returns (bool);

    event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/GameGold.sol" startline="196" endline="197" pcid="3999">
  function approve(address spender, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="64" endline="65" pcid="6483">
    function transfer(address to, uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/FMT.sol" startline="19" endline="20" pcid="3650">
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/Aigopay.sol" startline="67" endline="68" pcid="445">
    function transfer(address _to, uint256 _value) public returns (bool);
}
</source>
<source file="systems/smart_contracts/NSTTeamLock.sol" startline="14" endline="16" pcid="5452">
    function approve(address spender, uint256 value) external returns (bool);

    function transferFrom(address from, address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/NSTTeamLock.sol" startline="12" endline="14" pcid="5451">
    function transfer(address to, uint256 value) external returns (bool);

    function approve(address spender, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="109" endline="110" pcid="6778">
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="202" endline="213" pcid="5420">
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="177" endline="186" pcid="5418">
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="534" endline="535" pcid="6624">
	function approve(address spender, uint256 value) public returns (bool);
	event Approval(
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="56" endline="58" pcid="1712">
    function transfer(address to, uint256 value) public returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/BountyBoard.sol" startline="119" endline="121" pcid="1496">
  function approve(address spender, uint256 value) public returns (bool);

  event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="188" endline="189" pcid="6784">
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="152" endline="153" pcid="5347">
    function approve(address spender, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="150" endline="151" pcid="5345">
    function transfer(address recipient, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/NBToken.sol" startline="146" endline="147" pcid="5309">
    function approve(address spender, uint256 value) public returns (bool);
    event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/NBToken.sol" startline="15" endline="16" pcid="5297">
    function transfer(address to, uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/NaorisToken.sol" startline="117" endline="118" pcid="5289">
    function approve(address spender, uint256 value) public returns (bool);
    event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/NaorisToken.sol" startline="62" endline="63" pcid="5283">
    function transfer(address to, uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="15" endline="16" pcid="2549">
  function transfer(address to, uint256 value) external returns (bool);
  function approve(address spender, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="16" endline="17" pcid="2550">
  function approve(address spender, uint256 value) external returns (bool);
  function transferFrom(address from, address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="134" endline="145" pcid="2462">
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a `Transfer` event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="11" endline="12" pcid="2640">
  function transfer(address to, uint256 value) external returns (bool);
  function approve(address spender, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="12" endline="13" pcid="2641">
  function approve(address spender, uint256 value) external returns (bool);
  function transferFrom(address from, address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="109" endline="118" pcid="2460">
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through `transferFrom`. This is
     * zero by default.
     *
     * This value changes when `approve` or `transferFrom` are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="58" endline="69" pcid="8228">
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a `Transfer` event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="141" endline="150" pcid="4422">
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through `transferFrom`. This is
     * zero by default.
     *
     * This value changes when `approve` or `transferFrom` are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="33" endline="42" pcid="8226">
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through `transferFrom`. This is
     * zero by default.
     *
     * This value changes when `approve` or `transferFrom` are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="109" endline="118" pcid="947">
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through `transferFrom`. This is
     * zero by default.
     *
     * This value changes when `approve` or `transferFrom` are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="21" endline="23" pcid="2736">
  function transfer(address to, uint256 value) external returns (bool);

  function approve(address spender, uint256 value)
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="23" endline="26" pcid="2737">
  function approve(address spender, uint256 value)
    external returns (bool);

  function transferFrom(address from, address to, uint256 value)
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="16" endline="17" pcid="2390">
  function approve(address spender, uint256 value) external returns (bool);
  function transferFrom(address from, address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="134" endline="145" pcid="949">
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a `Transfer` event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="15" endline="16" pcid="2389">
  function transfer(address to, uint256 value) external returns (bool);
  function approve(address spender, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/DNP.sol" startline="19" endline="20" pcid="2783">
    function transfer(address to, uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="160" endline="171" pcid="8194">
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a `Transfer` event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="135" endline="144" pcid="8192">
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through `transferFrom`. This is
     * zero by default.
     *
     * This value changes when `approve` or `transferFrom` are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="12" endline="13" pcid="2148">
  function approve(address spender, uint256 value) external returns (bool);
  function transferFrom(address from, address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/DNP.sol" startline="74" endline="75" pcid="2790">
    function approve(address spender, uint256 value) public returns (bool);
    event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="55" endline="56" pcid="2045">
    function approve(address spender, uint256 value) public returns (bool);
    event Approval(
</source>
<source file="systems/smart_contracts/MultiSign.sol" startline="23" endline="24" pcid="5235">
  function transfer(address to, uint256 value) public returns (bool);
}
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="32" endline="33" pcid="2877">
    function transfer(address _to, uint256 _value) public returns (bool);
}
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="38" endline="39" pcid="2879">
    function transfer(address to, uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/XGP.sol" startline="80" endline="81" pcid="8107">
    function approve(address spender, uint256 value) public returns (bool);
    event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/XGP.sol" startline="73" endline="74" pcid="8104">
    function transfer(address to, uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/XGP.sol" startline="67" endline="68" pcid="8102">
    function transfer(address _to, uint256 _value) public returns (bool);
}
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="45" endline="46" pcid="2882">
    function approve(address spender, uint256 value) public returns (bool);
    event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="17" endline="18" pcid="8073">
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="14" endline="15" pcid="8070">
  function transfer(address to, uint256 value) public returns (bool);
  function allowance(address owner, address spender) public view returns (uint256);
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="55" endline="56" pcid="2950">
    function transfer(address _to, uint256 _value) public returns (bool);
}
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="61" endline="62" pcid="2952">
    function transfer(address to, uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="68" endline="69" pcid="2955">
    function approve(address spender, uint256 value) public returns (bool);
    event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/MultiSendErc20.sol" startline="76" endline="77" pcid="5208">
    function approve(address spender, uint256 value) public returns (bool);
    event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/WTA.sol" startline="65" endline="66" pcid="8049">
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/WTA.sol" startline="63" endline="64" pcid="8047">
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="17" endline="19" pcid="3009">
    function transfer(address to, uint256 value) external returns (bool);

    function approve(address spender, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="19" endline="21" pcid="3010">
    function approve(address spender, uint256 value) external returns (bool);

    function transferFrom(address from, address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/TorexToken.sol" startline="69" endline="70" pcid="7409">
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="45" endline="46" pcid="8016">
    function approve(address spender, uint256 value) public returns (bool);
    event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="38" endline="39" pcid="8013">
    function transfer(address to, uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="26" endline="27" pcid="7744">
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="32" endline="33" pcid="8011">
    function transfer(address _to, uint256 _value) public returns (bool);
}
</source>
<source file="systems/smart_contracts/CNG.sol" startline="19" endline="21" pcid="1843">
  function transfer(address to, uint256 value) external returns (bool);

  function approve(address spender, uint256 value)
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="51" endline="52" pcid="3517">
    function transfer(address _to, uint256 _value) public returns (bool);
}
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="17" endline="18" pcid="2092">
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/Byte.sol" startline="13" endline="14" pcid="1568">
  function transfer(address to, uint256 value) external returns (bool);
  function approve(address spender, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="257" endline="259" pcid="3568">
    function approve(address spender, uint256 value) external returns (bool);

    function transferFrom(address from, address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="12" endline="13" pcid="7314">
  function approve(address spender, uint256 value) external returns (bool);
  function transferFrom(address from, address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/Comet.sol" startline="12" endline="13" pcid="1916">
  function approve(address spender, uint256 value) external returns (bool);
  function transferFrom(address from, address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="57" endline="58" pcid="3519">
    function transfer(address to, uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="11" endline="12" pcid="7313">
  function transfer(address to, uint256 value) external returns (bool);
  function approve(address spender, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="255" endline="257" pcid="3567">
    function transfer(address to, uint256 value) external returns (bool);

    function approve(address spender, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="166" endline="177" pcid="4424">
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a `Transfer` event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/MultiSendErc20.sol" startline="70" endline="71" pcid="5205">
    function transfer(address to, uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/BANG.sol" startline="15" endline="16" pcid="1038">
  function transfer(address to, uint256 value) external returns (bool);
  function approve(address spender, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="31" endline="40" pcid="644">
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through `transferFrom`. This is
     * zero by default.
     *
     * This value changes when `approve` or `transferFrom` are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/CRYPTOMZ.sol" startline="86" endline="87" pcid="2179">
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/BANG.sol" startline="16" endline="17" pcid="1039">
  function approve(address spender, uint256 value) external returns (bool);
  function transferFrom(address from, address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/CRYPTOMZ.sol" startline="131" endline="132" pcid="2184">
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/BDAM.sol" startline="97" endline="98" pcid="1115">
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="17" endline="19" pcid="2300">
  function approve(address spender, uint256 value) external returns (bool);

  function transferFrom(address from, address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="241" endline="244" pcid="7286">
  function approve(address spender, uint256 value)
    external returns (bool);

  function transferFrom(address from, address to, uint256 value)
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="135" endline="144" pcid="4033">
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through `transferFrom`. This is
     * zero by default.
     *
     * This value changes when `approve` or `transferFrom` are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="239" endline="241" pcid="7285">
  function transfer(address to, uint256 value) external returns (bool);

  function approve(address spender, uint256 value)
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="160" endline="171" pcid="4035">
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a `Transfer` event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/BountyBoard.sol" startline="116" endline="117" pcid="1493">
  function transfer(address to, uint256 value) public returns (bool);
  function allowance(address owner, address spender) public view returns (uint256);
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="16" endline="17" pcid="1463">
  function approve(address spender, uint256 value) external returns (bool);
  function transferFrom(address from, address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="56" endline="67" pcid="1748">
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a `Transfer` event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="15" endline="16" pcid="1462">
  function transfer(address to, uint256 value) external returns (bool);
  function approve(address spender, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="186" endline="188" pcid="2241">
    function transfer(address to, uint256 value) external returns (bool);

    function approve(address spender, uint256 value)
</source>
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="104" endline="106" pcid="1633">
    function approve(address spender, uint256 value) public returns (bool);

    event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="260" endline="269" pcid="3806">
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through `transferFrom`. This is
     * zero by default.
     *
     * This value changes when `approve` or `transferFrom` are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="188" endline="191" pcid="2242">
    function approve(address spender, uint256 value)
    external returns (bool);

    function transferFrom(address from, address to, uint256 value)
</source>
<source file="systems/smart_contracts/GFNX.sol" startline="18" endline="20" pcid="4095">
  function transfer(address to, uint256 value) external returns (bool);

  function approve(address spender, uint256 value)
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="189" endline="191" pcid="576">
    function transfer(address to, uint256 value) external returns (bool);

    function approve(address spender, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="300" endline="311" pcid="5160">
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a `Transfer` event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="31" endline="40" pcid="517">
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through `transferFrom`. This is
     * zero by default.
     *
     * This value changes when `approve` or `transferFrom` are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/GFNX.sol" startline="20" endline="23" pcid="4096">
  function approve(address spender, uint256 value)
    external returns (bool);

  function transferFrom(address from, address to, uint256 value)
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="15" endline="17" pcid="2299">
  function transfer(address to, uint256 value) external returns (bool);

  function approve(address spender, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="285" endline="296" pcid="3808">
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a `Transfer` event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/DABANKING_SWAP.sol" startline="12" endline="14" pcid="2267">
    function transfer(address to, uint256 value) public returns (bool);

    function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="275" endline="284" pcid="5158">
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through `transferFrom`. This is
     * zero by default.
     *
     * This value changes when `approve` or `transferFrom` are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="102" endline="103" pcid="1631">
    function transfer(address to, uint256 value) public returns (bool);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/DABANKING_SWAP.sol" startline="14" endline="16" pcid="2268">
    function approve(address spender, uint256 value) public returns (bool);

    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/BDAM.sol" startline="175" endline="176" pcid="1124">
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="33" endline="34" pcid="3165">
  function approve(address spender, uint256 value) external returns (bool);
  function transferFrom(address from, address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="50" endline="61" pcid="5773">
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="59" endline="60" pcid="5091">
  function approve(address spender, uint256 value) external returns (bool);
  function transferFrom(address from, address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="58" endline="59" pcid="5090">
  function transfer(address to, uint256 value) external returns (bool);
  function approve(address spender, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="117" endline="118" pcid="7460">
    function approve(address spender, uint256 value) public returns (bool);
    event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="30" endline="32" pcid="7636">
    function approve(address spender, uint256 value) external returns (bool);

    function transferFrom(address from, address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="77" endline="78" pcid="6981">
    function transfer(address to, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="144" endline="145" pcid="2105">
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/TorexToken.sol" startline="162" endline="163" pcid="7417">
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="79" endline="80" pcid="6983">
    function approve(address spender, uint256 value) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="28" endline="30" pcid="7635">
    function transfer(address to, uint256 value) external returns (bool);

    function approve(address spender, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/BFGToken.sol" startline="45" endline="46" pcid="1183">
  function transfer(address to, uint256 value) public returns (bool);
}
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="11" endline="12" pcid="2147">
  function transfer(address to, uint256 value) external returns (bool);
  function approve(address spender, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="64" endline="65" pcid="3522">
    function approve(address spender, uint256 value) public returns (bool);
    event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/SBC.sol" startline="285" endline="287" pcid="6330">
    function approve(address spender, uint256 value) external returns (bool);

    function transferFrom(address from, address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/CST_TOKEN.sol" startline="12" endline="13" pcid="2196">
  function approve(address _spender, uint256 _value) external returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/ankara.sol" startline="19" endline="21" pcid="675">
    function transfer(address to, uint256 value) external returns (bool);

    function approve(address spender, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/BFGToken.sol" startline="56" endline="58" pcid="1186">
  function approve(address agent, uint256 value) public returns (bool);

}
</source>
<source file="systems/smart_contracts/CNG.sol" startline="21" endline="24" pcid="1844">
  function approve(address spender, uint256 value)
    external returns (bool);

  function transferFrom(address from, address to, uint256 value)
</source>
<source file="systems/smart_contracts/SellableToken.sol" startline="44" endline="45" pcid="6463">
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/CST_TOKEN.sol" startline="10" endline="11" pcid="2194">
  function transfer(address _to, uint256 _value) external returns (bool);
  function transferFrom(address _from, address _to, uint256 _value) external returns (bool);
</source>
<source file="systems/smart_contracts/Comet.sol" startline="11" endline="12" pcid="1915">
  function transfer(address to, uint256 value) external returns (bool);
  function approve(address spender, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="13" endline="14" pcid="5987">
  function transfer(address to, uint256 value) external returns (bool);
  function approve(address spender, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="186" endline="188" pcid="7714">
    function transfer(address to, uint256 value) external returns (bool);

    function approve(address spender, uint256 value)
</source>
<source file="systems/smart_contracts/LBBT.sol" startline="42" endline="44" pcid="4538">
  function transfer(address to, uint256 value) public returns (bool);
  
  function allowance(address owner, address spender)
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="62" endline="63" pcid="7454">
    function transfer(address to, uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="774" endline="775" pcid="3880">
    function approve(address spender, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/LBBT.sol" startline="47" endline="49" pcid="4540">
  function approve(address spender, uint256 value) public returns (bool);
  
  event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="25" endline="28" pcid="728">
  function approve(address spender, uint256 value)
    external returns (bool);

  function transferFrom(address from, address to, uint256 value)
</source>
<source file="systems/smart_contracts/LuckyAdvcedWoken.sol" startline="9" endline="11" pcid="4548">
    function transfer(address to, uint256 value) external returns (bool);

    function approve(address spender, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="67" endline="68" pcid="4960">
    function approve(address spender, uint256 value) public returns (bool);
    event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/LuckyAdvcedWoken.sol" startline="11" endline="13" pcid="4549">
    function approve(address spender, uint256 value) external returns (bool);

    function transferFrom(address from, address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="23" endline="25" pcid="727">
  function transfer(address to, uint256 value) external returns (bool);

  function approve(address spender, uint256 value)
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="56" endline="67" pcid="5906">
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="191" endline="193" pcid="577">
    function approve(address spender, uint256 value) external returns (bool);

    function transferFrom(address from, address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="60" endline="61" pcid="4957">
    function transfer(address to, uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="54" endline="55" pcid="4955">
    function transfer(address _to, uint256 _value) public returns (bool);
}
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="75" endline="76" pcid="1438">
    function approve(address spender, uint256 value) public returns (bool);
    event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="68" endline="69" pcid="1435">
    function transfer(address to, uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="62" endline="63" pcid="1433">
    function transfer(address _to, uint256 _value) public returns (bool);
}
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="34" endline="43" pcid="7013">
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through `transferFrom`. This is
     * zero by default.
     *
     * This value changes when `approve` or `transferFrom` are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="55" endline="56" pcid="6547">
    function transfer(address _to, uint256 _value) public returns (bool);
}
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="59" endline="70" pcid="7015">
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a `Transfer` event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="77" endline="79" pcid="4925">
    function approve(address spender, uint256 value) external returns (bool);

    function transferFrom(address from, address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/BlockPoolToken.sol" startline="130" endline="131" pcid="1419">
    function approve(address spender, uint256 value) public returns (bool);
    event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="75" endline="77" pcid="4924">
    function transfer(address to, uint256 value) external returns (bool);

    function approve(address spender, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/GoldenRings.sol" startline="45" endline="46" pcid="4171">
    function transfer(address to, uint256 value) public returns (bool);
    function allowance(address owner, address spender) public view returns (uint256);
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="336" endline="337" pcid="4857">
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="67" endline="68" pcid="4837">
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/GoldenRings.sol" startline="48" endline="50" pcid="4174">
    function approve(address spender, uint256 value) public returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="54" endline="55" pcid="1270">
    function transfer(address _to, uint256 _value) public returns (bool);
}
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="60" endline="61" pcid="1272">
    function transfer(address to, uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="202" endline="203" pcid="1894">
    function approve(address spender, uint256 value) public returns (bool);
    function burn(uint256 _value) public ;
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="67" endline="68" pcid="1275">
    function approve(address spender, uint256 value) public returns (bool);
    event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="195" endline="196" pcid="1891">
    function transfer(address to, uint256 value) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/MAdvcedWoken.sol" startline="9" endline="11" pcid="4587">
    function transfer(address to, uint256 value) external returns (bool);

    function approve(address spender, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="56" endline="67" pcid="479">
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a `Transfer` event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="11" endline="12" pcid="6198">
  function transfer(address to, uint256 value) external returns (bool);
  function approve(address spender, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/MAdvcedWoken.sol" startline="11" endline="13" pcid="4588">
    function approve(address spender, uint256 value) external returns (bool);

    function transferFrom(address from, address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="32" endline="33" pcid="3164">
  function transfer(address to, uint256 value) external returns (bool);
  function approve(address spender, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="12" endline="13" pcid="6199">
  function approve(address spender, uint256 value) external returns (bool);
  function transferFrom(address from, address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="773" endline="774" pcid="3879">
    function transfer(address to, uint256 value) external returns (bool);
    function approve(address spender, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="447" endline="451" pcid="4762">
    function approve(address _spender, uint256 _value)
        external
        returns (bool);

    function totalSupply()
</source>
<source file="systems/smart_contracts/TimeLockedTokenStorage.sol" startline="68" endline="69" pcid="7227">
    function transfer(address _to, uint256 _value) public returns (bool);
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="439" endline="443" pcid="4760">
    function transfer(address _to, uint256 _value)
        external
        returns (bool);

    function transferFrom(address _from, address _to, uint256 _value)
</source>
<source file="systems/smart_contracts/BKN.sol" startline="17" endline="18" pcid="1320">
    function transfer(address to, uint256 value) public returns (bool);
    function allowance(address owner, address spender) public constant returns (uint256);
</source>
<source file="systems/smart_contracts/MBA.sol" startline="109" endline="110" pcid="4710">
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="202" endline="211" pcid="7179">
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through `transferFrom`. This is
     * zero by default.
     *
     * This value changes when `approve` or `transferFrom` are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="227" endline="238" pcid="7181">
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a `Transfer` event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/AronCoin.sol" startline="26" endline="27" pcid="760">
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
</source>
<source file="systems/smart_contracts/MBA.sol" startline="58" endline="59" pcid="4704">
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/magesh.sol" startline="75" endline="77" pcid="4612">
    function transfer(address to, uint256 value) external returns (bool);

    function approve(address spender, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/BKN.sol" startline="20" endline="21" pcid="1323">
    function approve(address spender, uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="14" endline="16" pcid="1359">
    function transfer(address to, uint256 value) external returns (bool);

    function approve(address spender, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/SistContract.sol" startline="38" endline="39" pcid="6517">
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/magesh.sol" startline="77" endline="79" pcid="4613">
    function approve(address spender, uint256 value) external returns (bool);

    function transferFrom(address from, address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="16" endline="18" pcid="1360">
    function approve(address spender, uint256 value) external returns (bool);

    function transferFrom(address from, address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="188" endline="191" pcid="7715">
    function approve(address spender, uint256 value)
    external returns (bool);

    function transferFrom(address from, address to, uint256 value)
</source>
<source file="systems/smart_contracts/BlockPoolToken.sol" startline="15" endline="16" pcid="1407">
    function transfer(address to, uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="10" endline="11" pcid="4640">
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/Byte.sol" startline="14" endline="15" pcid="1569">
  function approve(address spender, uint256 value) external returns (bool);
  function transferFrom(address from, address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="76" endline="77" pcid="4650">
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(
</source>
</class>

<class classid="76" nclones="123" nlines="2" similarity="100">
<source file="systems/smart_contracts/ABCToken.sol" startline="65" endline="73" pcid="304">
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="98" endline="101" pcid="4239">
  function transferFrom(address from, address to, uint256 value)
  external returns (bool);

  event Transfer(
</source>
<source file="systems/smart_contracts/ankara.sol" startline="23" endline="25" pcid="677">
    function transferFrom(address from, address to, uint256 value) external returns (bool);

    function totalSupply() external view returns (uint256);
</source>
<source file="systems/smart_contracts/CRYPTOMZ.sol" startline="130" endline="131" pcid="2183">
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/BANG.sol" startline="17" endline="19" pcid="1040">
  function transferFrom(address from, address to, uint256 value) external returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="311" endline="319" pcid="5161">
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/BDAM.sol" startline="174" endline="175" pcid="1123">
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="78" endline="79" pcid="4302">
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="277" endline="278" pcid="7355">
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/SistContract.sol" startline="49" endline="50" pcid="6519">
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="60" endline="62" pcid="5092">
  function transferFrom(address from, address to, uint256 value) external returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="78" endline="79" pcid="6982">
    function transferFrom(address from, address to, uint256 value) external returns (bool);
    function approve(address spender, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="67" endline="75" pcid="5907">
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/BFGToken.sol" startline="55" endline="56" pcid="1185">
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address agent, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="66" endline="67" pcid="4959">
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="70" endline="78" pcid="7016">
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="79" endline="81" pcid="4926">
    function transferFrom(address from, address to, uint256 value) external returns (bool);

    function totalSupply() external view returns (uint256);
</source>
<source file="systems/smart_contracts/MultiSendErc20.sol" startline="75" endline="76" pcid="5207">
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="335" endline="336" pcid="4856">
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="67" endline="75" pcid="520">
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="66" endline="67" pcid="1274">
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/PositionTokenV2.sol" startline="33" endline="36" pcid="5747">
  function transferFrom(address _from, address _to, uint256 _value)
    public returns (bool);

  function approve(address _spender, uint256 _value) public returns (bool);
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="13" endline="15" pcid="6200">
  function transferFrom(address from, address to, uint256 value) external returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/AronCoin.sol" startline="25" endline="26" pcid="759">
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="443" endline="447" pcid="4761">
    function transferFrom(address _from, address _to, uint256 _value)
        external
        returns (bool);

    function approve(address _spender, uint256 _value)
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="61" endline="69" pcid="5774">
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="238" endline="246" pcid="7182">
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="145" endline="153" pcid="950">
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/MBA.sol" startline="106" endline="109" pcid="4709">
  function transferFrom(address from, address to, uint256 value)
    public returns (bool);

  function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/BKN.sol" startline="19" endline="20" pcid="1322">
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="18" endline="20" pcid="1361">
    function transferFrom(address from, address to, uint256 value) external returns (bool);

    function totalSupply() external view returns (uint256);
</source>
<source file="systems/smart_contracts/NaorisToken.sol" startline="116" endline="117" pcid="5288">
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="73" endline="76" pcid="4649">
  function transferFrom(address from, address to, uint256 value)
    public returns (bool);

  function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/magesh.sol" startline="79" endline="81" pcid="4614">
    function transferFrom(address from, address to, uint256 value) external returns (bool);

    function totalSupply() external view returns (uint256);
</source>
<source file="systems/smart_contracts/BlockPoolToken.sol" startline="129" endline="130" pcid="1418">
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/TokenSwap.sol" startline="152" endline="154" pcid="7397">
    function transferFrom(address from, address to, uint256 value) external returns (bool);

    function totalSupply() external view returns (uint256);
</source>
<source file="systems/smart_contracts/TimeLockedTokenStorage.sol" startline="69" endline="70" pcid="7228">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);
}
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="104" endline="105" pcid="4386">
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/TorexToken.sol" startline="159" endline="162" pcid="7416">
  function transferFrom(address from, address to, uint256 value)
    public returns (bool);

  function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/BountyBoard.sol" startline="118" endline="119" pcid="1495">
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="70" endline="71" pcid="6485">
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/Aigopay.sol" startline="79" endline="80" pcid="449">
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/RETC.sol" startline="40" endline="41" pcid="6181">
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/MAdvcedWoken.sol" startline="13" endline="15" pcid="4589">
    function transferFrom(address from, address to, uint256 value) external returns (bool);

    function totalSupply() external view returns (uint256);
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="13" endline="15" pcid="2149">
  function transferFrom(address from, address to, uint256 value) external returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="13" endline="15" pcid="7315">
  function transferFrom(address from, address to, uint256 value) external returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="74" endline="75" pcid="1437">
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="143" endline="144" pcid="2104">
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="90" endline="93" pcid="5842">
    function transferFrom(address from, address to, uint256 value)
    external returns (bool);

    event Transfer(
</source>
<source file="systems/smart_contracts/NBToken.sol" startline="145" endline="146" pcid="5308">
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="195" endline="203" pcid="5959">
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="52" endline="55" pcid="2044">
    function transferFrom(address from, address to, uint256 value)
        public returns (bool);

    function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/LuckyAdvcedWoken.sol" startline="13" endline="15" pcid="4550">
    function transferFrom(address from, address to, uint256 value) external returns (bool);

    function totalSupply() external view returns (uint256);
</source>
<source file="systems/smart_contracts/Byte.sol" startline="15" endline="17" pcid="1570">
  function transferFrom(address from, address to, uint256 value) external returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="17" endline="19" pcid="1464">
  function transferFrom(address from, address to, uint256 value) external returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="177" endline="185" pcid="4425">
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="244" endline="247" pcid="7287">
  function transferFrom(address from, address to, uint256 value)
    external returns (bool);

  event Transfer(
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="151" endline="152" pcid="5346">
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="67" endline="68" pcid="6551">
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/CST_TOKEN.sol" startline="11" endline="12" pcid="2195">
  function transferFrom(address _from, address _to, uint256 _value) external returns (bool);
  function approve(address _spender, uint256 _value) external returns (bool);
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="172" endline="180" pcid="7905">
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="330" endline="331" pcid="6096">
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="532" endline="534" pcid="6623">
	function transferFrom(address from, address to, uint256 value) public returns (bool);

	function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/Factory.sol" startline="200" endline="201" pcid="3447">
    function transferFrom(address from, address to, uint256 value) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="191" endline="194" pcid="2243">
    function transferFrom(address from, address to, uint256 value)
    external returns (bool);

    event Transfer(
</source>
<source file="systems/smart_contracts/DABANKING_SWAP.sol" startline="16" endline="18" pcid="2269">
    function transferFrom(address from, address to, uint256 value) public returns (bool);

    function balanceOf(address who) public view returns (uint256);
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="34" endline="36" pcid="3166">
  function transferFrom(address from, address to, uint256 value) external returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="19" endline="21" pcid="2301">
  function transferFrom(address from, address to, uint256 value) external returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="44" endline="45" pcid="8015">
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/PokaToken.sol" startline="12" endline="14" pcid="5727">
    function transferFrom(address from, address to, uint256 value) external returns (bool);

    function totalSupply() external view returns (uint256);
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="21" endline="23" pcid="3011">
    function transferFrom(address from, address to, uint256 value) external returns (bool);

    function totalSupply() external view returns (uint256);
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="28" endline="31" pcid="729">
  function transferFrom(address from, address to, uint256 value)
    external returns (bool);

  event Transfer(
</source>
<source file="systems/smart_contracts/WTA.sol" startline="66" endline="67" pcid="8050">
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="187" endline="188" pcid="6783">
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="67" endline="68" pcid="2954">
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="195" endline="197" pcid="7792">
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="213" endline="221" pcid="5421">
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="63" endline="64" pcid="3521">
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="259" endline="261" pcid="3569">
    function transferFrom(address from, address to, uint256 value) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="25" endline="26" pcid="7743">
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="16" endline="17" pcid="8072">
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/FMT.sol" startline="18" endline="19" pcid="3649">
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/Comet.sol" startline="13" endline="15" pcid="1917">
  function transferFrom(address from, address to, uint256 value) external returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="201" endline="202" pcid="1893">
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/CNG.sol" startline="24" endline="27" pcid="1845">
  function transferFrom(address from, address to, uint256 value)
    external returns (bool);

  event Transfer(
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="191" endline="194" pcid="7716">
    function transferFrom(address from, address to, uint256 value)
    external returns (bool);

    event Transfer(
</source>
<source file="systems/smart_contracts/SBC.sol" startline="287" endline="289" pcid="6331">
    function transferFrom(address from, address to, uint256 value) external returns (bool);

    function totalSupply() external view returns (uint256);
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="67" endline="75" pcid="1749">
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="296" endline="304" pcid="3809">
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="32" endline="34" pcid="7637">
    function transferFrom(address from, address to, uint256 value) external returns (bool);

    function totalSupply() external view returns (uint256);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="775" endline="776" pcid="3881">
    function transferFrom(address from, address to, uint256 value) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
</source>
<source file="systems/smart_contracts/UTC.sol" startline="124" endline="125" pcid="7582">
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="13" endline="15" pcid="3917">
  function transferFrom(address from, address to, uint256 value) external returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/XGP.sol" startline="79" endline="80" pcid="8106">
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="44" endline="45" pcid="2881">
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/Gacha.sol" startline="78" endline="80" pcid="3977">
    function transferFrom(address from, address to, uint256 value) public returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/NSTTeamLock.sol" startline="16" endline="18" pcid="5453">
    function transferFrom(address from, address to, uint256 value) external returns (bool);

    function totalSupply() external view returns (uint256);
</source>
<source file="systems/smart_contracts/SuperMarket.sol" startline="12" endline="14" pcid="6755">
    function transferFrom(address from, address to, uint256 value) external returns (bool);

    function totalSupply() external view returns (uint256);
</source>
<source file="systems/smart_contracts/DNP.sol" startline="73" endline="74" pcid="2789">
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="171" endline="179" pcid="8195">
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="17" endline="19" pcid="2391">
  function transferFrom(address from, address to, uint256 value) external returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="311" endline="313" pcid="5684">
    function transferFrom(address from, address to, uint256 value) external returns (bool);

    function totalSupply() external view returns (uint256);
</source>
<source file="systems/smart_contracts/UGCoin.sol" startline="40" endline="41" pcid="7530">
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="67" endline="75" pcid="647">
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/GameGold.sol" startline="195" endline="196" pcid="3998">
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="171" endline="179" pcid="4036">
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="193" endline="195" pcid="578">
    function transferFrom(address from, address to, uint256 value) external returns (bool);

    function totalSupply() external view returns (uint256);
</source>
<source file="systems/smart_contracts/GFNX.sol" startline="23" endline="26" pcid="4097">
  function transferFrom(address from, address to, uint256 value)
    external returns (bool);

  event Transfer(
</source>
<source file="systems/smart_contracts/SellableToken.sol" startline="43" endline="44" pcid="6462">
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="15" endline="17" pcid="5989">
  function transferFrom(address from, address to, uint256 value) external returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="103" endline="104" pcid="1632">
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="26" endline="29" pcid="2738">
  function transferFrom(address from, address to, uint256 value)
    external returns (bool);

  event Transfer(
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="116" endline="117" pcid="7459">
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="69" endline="77" pcid="8229">
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="21" endline="23" pcid="6407">
    function transferFrom(address from, address to, uint256 value) external returns (bool);

    function totalSupply() external view returns (uint256);
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="13" endline="15" pcid="2642">
  function transferFrom(address from, address to, uint256 value) external returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="145" endline="153" pcid="2463">
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="17" endline="19" pcid="2551">
  function transferFrom(address from, address to, uint256 value) external returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/GoldenRings.sol" startline="47" endline="48" pcid="4173">
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="67" endline="75" pcid="480">
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="145" endline="153" pcid="6022">
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="72" endline="73" pcid="6683">
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="191" endline="194" pcid="6729">
    function transferFrom(address from, address to, uint256 value)
    external returns (bool);

    event Transfer(
</source>
</class>

<class classid="77" nclones="72" nlines="4" similarity="75">
<source file="systems/smart_contracts/ABCToken.sol" startline="174" endline="192" pcid="310">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/CoinDDC.sol" startline="67" endline="88" pcid="1865">
    function transferFrom(
        address _from,
        address _to,
        uint256 _value
    )
    public
    returns (bool)
    {
        require(_to != address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = sub(balances[_from], _value);
        
        
        balances[_to] = add(balances[_to], _value);
        allowed[_from][msg.sender] = sub(allowed[_from][msg.sender], _value);
        emit Transfer(_from, _to, _value);
        return true;
    }

    function approve(
</source>
<source file="systems/smart_contracts/BCCT.sol" startline="110" endline="128" pcid="1096">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="126" endline="146" pcid="2053">
    function transferFrom(
        address _from,
        address _to,
        uint256 _value
    )
        public
        returns (bool)
    {
        require(_to != address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }


    function approve(address _spender, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/AronCoin.sol" startline="119" endline="141" pcid="767">
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }

  /**
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
   *
   * Beware that changing an allowance with this method brings the risk that someone may use both the old
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   * @param _spender The address which will spend the funds.
   * @param _value The amount of tokens to be spent.
   */
  function approve(address _spender, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/CDS.sol" startline="233" endline="261" pcid="1666">
  function transferFrom(
    address _from,
    address _to,
    uint256 _value
  )
    public
    returns (bool)
  {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
  }

  /**
   * @dev Increase the amount of tokens that an owner allowed to a spender.
   * approve should be called when allowed[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _addedValue The amount of tokens to increase the allowance by.
   */
  function increaseApproval(
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="282" endline="300" pcid="658">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="290" endline="308" pcid="1760">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="368" endline="386" pcid="2474">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/SistContract.sol" startline="117" endline="141" pcid="6524">
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {

    require(_to != address(0));
    require(balances[_from] >= _value);
	require(allowed[_from][msg.sender] <= _value);
    require(_value >= 0);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
  }

  /**
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
   *
   * Beware that changing an allowance with this method brings the risk that someone may use both the old
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   * @param _spender The address which will spend the funds.
   * @param _value The amount of tokens to be spent.
   */
  function approve(address _spender, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ProxyERC20.sol" startline="492" endline="509" pcid="5901">
    function transferFrom(
        address from,
        address to,
        uint256 value
    )
        public
        returns (bool)
    {
        // Mutable state call requires the proxy to tell the target who the msg.sender is.
        target.setMessageSender(msg.sender);

        // Forward the ERC20 call to the target contract
        IERC20(target).transferFrom(from, to, value);

        // Event emitting will occur via Synthetix.Proxy._emit()
        return true;
    }
}
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="97" endline="105" pcid="2312">
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        require(value <= _allowed[from][msg.sender]);

        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
        _transfer(from, to, value);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="555" endline="562" pcid="5870">
    function _check(address _from, address _to, uint256 _value) private returns (bool) {
        ComplianceService service= _service();
        uint8 errorCode =service.check(this, msg.sender, _from, _to, _value);
        emit CheckStatus(errorCode, msg.sender, _from, _to, _value);
        return errorCode == 0;
    }

    function _service() public view returns (ComplianceService) {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="324" endline="348" pcid="5859">
    function transferFrom(
        address from,
        address to,
        uint256 value
    )
    public
    returns (bool)
    {
        require(value <= _allowed[from][msg.sender]);

        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
        _transfer(from, to, value);
        return true;
    }

    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     * approve should be called when allowed_[_spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * @param spender The address which will spend the funds.
     * @param addedValue The amount of tokens to increase the allowance by.
     */
    function increaseAllowance(
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="285" endline="308" pcid="2249">
    function transferFrom(
        address from,
        address to,
        uint256 value
    )
    public
    returns (bool)
    {
        require(!frozenAccount[msg.sender]);
        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
        _transfer(from, to, value);
        return true;
    }

    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     * approve should be called when allowed_[_spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * @param spender The address which will spend the funds.
     * @param addedValue The amount of tokens to increase the allowance by.
     */
    function increaseAllowance(
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="334" endline="352" pcid="5921">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/customIcoToken.sol" startline="82" endline="94" pcid="2215">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="400" endline="406" pcid="2599">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/ankara.sol" startline="106" endline="112" pcid="691">
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        _transfer(from, to, value);
        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/BKN.sol" startline="78" endline="93" pcid="1328">
    function transferFrom(address src, address dst, uint256 wad) public returns (bool) {
        require (src != address(0));
        require (dst != address(0));
        assert(_balances[src] >= wad);
        assert(_approvals[src][msg.sender] >= wad);
        
        _approvals[src][msg.sender] = _approvals[src][msg.sender] - wad;
        _balances[src] = _balances[src] - wad;
        _balances[dst] = _balances[dst] + wad;
        
        emit Transfer(src, dst, wad);
        
        return true;
    }
    
    function approve(address guy, uint256 wad) public returns (bool) {
</source>
<source file="systems/smart_contracts/CRYPTOMZ.sol" startline="152" endline="177" pcid="2185">
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));

    uint256 _allowance = allowed[_from][msg.sender];

    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
    // require (_value <= _allowance);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = _allowance.sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
  }

  /**
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
   *
   * Beware that changing an allowance with this method brings the risk that someone may use both the old
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
   * @param _spender The address which will spend the funds.
   * @param _value The amount of tokens to be spent.
   */
   
  function approve(address _spender, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="294" endline="312" pcid="8240">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Six.sol" startline="168" endline="189" pcid="6536">
function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    
require(_to != address(0));
require(_value <= allowance[_from][msg.sender]);
require(_value <= balanceOf[_from]);
allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);
balanceOf[_from] = balanceOf[_from].sub(_value);
balanceOf[_to] = balanceOf[_to].add(_value);
emit Transfer(_from, _to, _value);
return true;
}

/**
* @dev Set allowance for other address
*
* Allows `_spender` to spend no more than `_value` tokens on your behalf
*
* @param _spender The address authorized to spend
* @param _value the max amount they can spend

*/
function approve(address _spender, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="451" endline="468" pcid="602">
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
        _transfer(from, to, value);
        emit Approval(from, msg.sender, _allowed[from][msg.sender]);
        return true;
    }

    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     * approve should be called when allowed_[_spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param addedValue The amount of tokens to increase the allowance by.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="367" endline="383" pcid="6340">
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        _transfer(from, to, value);
        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));
        return true;
    }

    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     * approve should be called when allowed_[_spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param addedValue The amount of tokens to increase the allowance by.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="396" endline="402" pcid="2690">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="302" endline="320" pcid="5965">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="198" endline="222" pcid="2749">
  function transferFrom(
    address from,
    address to,
    uint256 value
  )
    public
    returns (bool)
  {
    require(value <= _allowed[from][msg.sender]);

    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
    _transfer(from, to, value);
    return true;
  }

  /**
   * @dev Increase the amount of tokens that an owner allowed to a spender.
   * approve should be called when allowed_[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param spender The address which will spend the funds.
   * @param addedValue The amount of tokens to increase the allowance by.
   */
  function increaseAllowance(
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="278" endline="296" pcid="8201">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="133" endline="139" pcid="8061">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="354" endline="360" pcid="3003">
  function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
    require(!_locked[msg.sender]);
    _transfer(sender, recipient, amount);
    _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
    return true;
  }
}
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="139" endline="155" pcid="3022">
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        _transfer(from, to, value);
        _approve(from, msg.sender, _allowances[from][msg.sender].sub(value));
        return true;
    }

    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     * approve should be called when _allowances[msg.sender][spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param addedValue The amount of tokens to increase the allowance by.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="378" endline="385" pcid="8005">
  function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
    require(!_locked[msg.sender]);
    require(!_locked[sender]);
    _transfer(sender, recipient, amount);
    _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
    return true;
  }
}
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="285" endline="303" pcid="7911">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Exchange.sol" startline="222" endline="231" pcid="3375">
    function updateBalance (address token, address user, uint256 balance) private returns (bool)
    {
        uint256 character = uint256(balance);
        character |= getReserve(token, user)<<128;

        balances[token][user] = character;
        return true;
    }

    function updateReserve (address token, address user, uint256 reserve) private
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="347" endline="364" pcid="3575">
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
        _transfer(from, to, value);
        emit Approval(from, msg.sender, _allowed[from][msg.sender]);
        return true;
    }

    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     * approve should be called when allowed_[_spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param addedValue The amount of tokens to increase the allowance by.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="119" endline="141" pcid="7751">
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }

  /**
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
   *
   * Beware that changing an allowance with this method brings the risk that someone may use both the old
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   * @param _spender The address which will spend the funds.
   * @param _value The amount of tokens to be spent.
   */
  function approve(address _spender, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/BDAM.sol" startline="198" endline="224" pcid="1125">
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(canTransfer(msg.sender));

    uint256 _allowance = allowed[_from][msg.sender];

    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
    // require (_value <= _allowance);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = _allowance.sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }

  /**
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
   *
   * Beware that changing an allowance with this method brings the risk that someone may use both the old
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   * @param _spender The address which will spend the funds.
   * @param _value The amount of tokens to be spent.
   */
  function approve(address _spender, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="355" endline="373" pcid="5793">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Fk.sol" startline="168" endline="189" pcid="3624">
function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
	
 require(_to != address(0));
 require(_value <= allowance[_from][msg.sender]);
 require(_value <= balanceOf[_from]);
 allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);
 balanceOf[_from] = balanceOf[_from].sub(_value);
 balanceOf[_to] = balanceOf[_to].add(_value);
 emit Transfer(_from, _to, _value);
 return true;
}

/**
* @dev Set allowance for other address
*
* Allows `_spender` to spend no more than `_value` tokens on your behalf
*
* @param _spender The address authorized to spend
* @param _value the max amount they can spend

*/
function approve(address _spender, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="368" endline="386" pcid="6033">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/FMT.sol" startline="75" endline="97" pcid="3654">
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }

  /**
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
   *
   * Beware that changing an allowance with this method brings the risk that someone may use both the old
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   * @param _spender The address which will spend the funds.
   * @param _value The amount of tokens to be spent.
   */
  function approve(address _spender, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/FogCoin.sol" startline="97" endline="108" pcid="3684">
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        _transfer(from, to, value);
        _approve(from, msg.sender, _allowances[from][msg.sender].sub(value));
        return true;
    }

    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender. Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param addedValue The amount of tokens to increase the allowance by.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="285" endline="308" pcid="7722">
    function transferFrom(
        address from,
        address to,
        uint256 value
    )
    public
    returns (bool)
    {
        require(!frozenAccount[msg.sender]);
        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
        _transfer(from, to, value);
        return true;
    }

    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     * approve should be called when allowed_[_spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * @param spender The address which will spend the funds.
     * @param addedValue The amount of tokens to increase the allowance by.
     */
    function increaseAllowance(
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="188" endline="204" pcid="7651">
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        _transfer(from, to, value);
        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));
        return true;
    }

    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     * approve should be called when _allowed[msg.sender][spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param addedValue The amount of tokens to increase the allowance by.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="404" endline="422" pcid="3815">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/UTC.sol" startline="149" endline="170" pcid="7584">
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }

  /**
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
   *
   * Beware that changing an allowance with this method brings the risk that someone may use both the old
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   * @param _spender The address which will spend the funds.
   * @param _value The amount of tokens to be spent.
   */
  function approve(address _spender, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="138" endline="160" pcid="7461">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     *
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param _spender The address which will spend the funds.
     * @param _value The amount of tokens to be spent.
     */
    function approve(address _spender, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/GoldenRings.sol" startline="91" endline="113" pcid="4177">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

        emit Transfer(_from, _to, _value);
        return true;
    }

    /**
    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
    *
    * Beware that changing an allowance with this method brings the risk that someone may use both the old
    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    * @param _spender The address which will spend the funds.
    * @param _value The amount of tokens to be spent.
    */
    function approve(address _spender, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/TorexToken.sol" startline="190" endline="219" pcid="7418">
  function transferFrom(
    address _from,
    address _to,
    uint256 _value
  )
    public
    returns (bool)
  {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
  }

  /**
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
   *
   * Beware that changing an allowance with this method brings the risk that someone may use both the old
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   * @param _spender The address which will spend the funds.
   * @param _value The amount of tokens to be spent.
   */
  function approve(address _spender, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="198" endline="222" pcid="4245">
  function transferFrom(
    address from,
    address to,
    uint256 value
  )
  public
  returns (bool)
  {
    require(value <= _allowed[from][msg.sender]);

    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
    _transfer(from, to, value);
    return true;
  }

  /**
   * @dev Increase the amount of tokens that an owner allowed to a spender.
   * approve should be called when allowed_[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param spender The address which will spend the funds.
   * @param addedValue The amount of tokens to increase the allowance by.
   */
  function increaseAllowance(
</source>
<source file="systems/smart_contracts/SellableToken.sol" startline="72" endline="84" pcid="6466">
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
  }

  function approve(address _spender, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="346" endline="364" pcid="4434">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Token.sol" startline="140" endline="156" pcid="7259">
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        _transfer(from, to, value);
        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));
        return true;
    }

    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     * approve should be called when _allowed[msg.sender][spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param addedValue The amount of tokens to increase the allowance by.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="193" endline="210" pcid="740">
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        require(value <= _allowed[from][msg.sender]);

        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
        _transfer(from, to, value);
        return true;
    }

    /**
    * @dev Increase the amount of tokens that an owner allowed to a spender.
    * approve should be called when allowed_[_spender] == 0. To increment
    * allowed value is better to use this function to avoid 2 calls (and wait until
    * the first transaction is mined)
    * From MonolithDAO Token.sol
    * @param spender The address which will spend the funds.
    * @param addedValue The amount of tokens to increase the allowance by.
    */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/magesh.sol" startline="170" endline="186" pcid="4623">
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        _transfer(from, to, value);
        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));
        return true;
    }

    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     * approve should be called when _allowed[msg.sender][spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param addedValue The amount of tokens to increase the allowance by.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="87" endline="106" pcid="4651">
  function transferFrom(
    address _from,
    address _to,
    uint256 _value
  )
    public
    returns (bool)
  {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
  }

  function approve(address _spender, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="326" endline="344" pcid="7188">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    /**
     * Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseApproval(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/MBA.sol" startline="245" endline="273" pcid="4720">
  function transferFrom(
    address _from,
    address _to,
    uint256 _value
  )
    public
    returns (bool)
  {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
  }

  /**
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
   * Beware that changing an allowance with this method brings the risk that someone may use both the old
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   * @param _spender The address which will spend the funds.
   * @param _value The amount of tokens to be spent.
   */
  function approve(address _spender, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/CNG.sol" startline="193" endline="217" pcid="1856">
  function transferFrom(
    address from,
    address to,
    uint256 value
  )
    public
    returns (bool)
  {
    require(value <= _allowed[from][msg.sender]);

    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
    _transfer(from, to, value);
    return true;
  }

  /**
   * @dev Increase the amount of tokens that an owner allowed to a spender.
   * approve should be called when allowed_[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param spender The address which will spend the funds.
   * @param addedValue The amount of tokens to increase the allowance by.
   */
  function increaseAllowance(
</source>
<source file="systems/smart_contracts/MBA.sol" startline="468" endline="475" pcid="4729">
	function transferFrom(address from, address to, uint256 value) public returns (bool) {
	    _tryTransfered(from);
	    _tryTransfered(to);
	    
	    return super.transferFrom(from, to, value);
	}
	
	function _tryTransfered(address _who) internal {
</source>
<source file="systems/smart_contracts/tharDex.sol" startline="57" endline="66" pcid="7146">
    function tokenDeposit(address tokenaddr,address fromaddr,uint256 tokenAmount) public returns(bool)
    {
        require(tokenAmount > 0);
        require(tokenallowance(tokenaddr,fromaddr) > 0);
        Token(tokenaddr).transferFrom(fromaddr,address(this), tokenAmount);
        return true;
    }
  
    
    function adminWithdraw(uint256 type_,address tokenAddr,address payable toAddress,uint256 amount)public returns(bool){
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="407" endline="424" pcid="5693">
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
        _transfer(from, to, value);
        emit Approval(from, msg.sender, _allowed[from][msg.sender]);
        return true;
    }

    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     * approve should be called when allowed_[_spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param addedValue The amount of tokens to increase the allowance by.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="285" endline="303" pcid="7027">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/BFGToken.sol" startline="108" endline="120" pcid="1190">
  function transferFrom(address from, address to, uint256 value) public returns (bool) {
    require(to != address(0));
    require(value <= _balances[from]);
    require(value <= _allowances[from][msg.sender]);

    _balances[from] = _balances[from].sub(value);
    _balances[to] = _balances[to].add(value);
    _allowances[from][msg.sender] = _allowances[from][msg.sender].sub(value);
    emit Transfer(from, to, value);
    return true;
  }

  function approve(address agent, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="170" endline="186" pcid="4935">
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        _transfer(from, to, value);
        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));
        return true;
    }

    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     * approve should be called when _allowed[msg.sender][spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param addedValue The amount of tokens to increase the allowance by.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="555" endline="571" pcid="5123">
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        require(value <= _FOMOTokenBalances[from]);
        require(value <= _allowed[from][msg.sender]);
        require(to != address(0));

        _FOMOTokenBalances[from] = _FOMOTokenBalances[from].sub(value);

        uint256 tokensToTransfer = value;

        _FOMOTokenBalances[to] = _FOMOTokenBalances[to].add(tokensToTransfer);
        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);

        emit Transfer(from, to, tokensToTransfer);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="368" endline="386" pcid="961">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="487" endline="505" pcid="5172">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/NaorisToken.sol" startline="138" endline="160" pcid="5290">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     *
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param _spender The address which will spend the funds.
     * @param _value The amount of tokens to be spent.
     */
    function approve(address _spender, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="322" endline="340" pcid="5427">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="285" endline="308" pcid="6735">
    function transferFrom(
        address from,
        address to,
        uint256 value
    )
    public
    returns (bool)
    {
        require(!frozenAccount[msg.sender]);
        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
        _transfer(from, to, value);
        return true;
    }

    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     * approve should be called when allowed_[_spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * @param spender The address which will spend the funds.
     * @param addedValue The amount of tokens to increase the allowance by.
     */
    function increaseAllowance(
</source>
</class>

<class classid="78" nclones="100" nlines="4" similarity="75">
<source file="systems/smart_contracts/ABCToken.sol" startline="230" endline="248" pcid="313">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="460" endline="478" pcid="3818">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a `Transfer` event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="518" endline="532" pcid="3821">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See `_burn` and `_approve`.
     */
    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="429" endline="443" pcid="4051">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See `_burn` and `_approve`.
     */
    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="267" endline="283" pcid="4248">
  function _transfer(address from, address to, uint256 value) internal {
    require(value <= _balances[from]);
    require(to != address(0));

    _balances[from] = _balances[from].sub(value);
    _balances[to] = _balances[to].add(value);
    emit Transfer(from, to, value);
  }

  /**
   * @dev Internal function that mints an amount of the token and assigns it to
   * an account. This encapsulates the modification of balances such that the
   * proper events are emitted.
   * @param account The account that will receive the created tokens.
   * @param value The amount that will be created.
   */
  function _mint(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="253" endline="267" pcid="2992">
  function _approve(address owner, address spender, uint256 value) internal {
    require(owner != address(0), "ERC20: approve from the zero address");
    require(spender != address(0), "ERC20: approve to the zero address");

    _allowances[owner][spender] = value;
    emit Approval(owner, spender, value);
  }

  /**
   * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
   * from the caller's allowance.
   *
   * See `_burn` and `_approve`.
   */
  function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="195" endline="213" pcid="2989">
  function _transfer(address sender, address recipient, uint256 amount) internal {
    require(sender != address(0), "ERC20: transfer from the zero address");
    require(recipient != address(0), "ERC20: transfer to the zero address");

    _balances[sender] = _balances[sender].sub(amount);
    _balances[recipient] = _balances[recipient].add(amount);
    emit Transfer(sender, recipient, amount);
  }

  /** @dev Creates `amount` tokens and assigns them to `account`, increasing
   * the total supply.
   *
   * Emits a `Transfer` event with `from` set to the zero address.
   *
   * Requirements
   *
   * - `to` cannot be the zero address.
   */
  function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="402" endline="420" pcid="4437">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a `Transfer` event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="452" endline="468" pcid="6346">
    function _approve(address owner, address spender, uint256 value) internal {
        require(spender != address(0));
        require(owner != address(0));

        _allowed[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account, deducting from the sender's allowance for said account. Uses the
     * internal burn function.
     * Emits an Approval event (reflecting the reduced allowance).
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burnFrom(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="149" endline="158" pcid="8064">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="166" endline="174" pcid="8066">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="460" endline="474" pcid="4440">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See `_burn` and `_approve`.
     */
    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/Token.sol" startline="196" endline="203" pcid="7263">
    function _approve(address owner, address spender, uint256 value) internal {
        require(spender != address(0), "Cannot approve to the zero address");
        require(owner != address(0), "Setter cannot be a zero address");

        _allowed[owner][spender] = value;
        emit Approval(owner, spender, value);
    }
}
</source>
<source file="systems/smart_contracts/Token.sol" startline="182" endline="196" pcid="7262">
    function _transfer(address from, address to, uint256 value) internal {
        require(to != address(0), "Cannot transfer to zero address");

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }

    /**
     * @dev Approve an address to spend another addresses' tokens.
     * @param owner The address that owns the tokens.
     * @param spender The address that will spend the tokens.
     * @param value The number of tokens that can be spent.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="334" endline="352" pcid="8204">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a `Transfer` event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="267" endline="283" pcid="2752">
  function _transfer(address from, address to, uint256 value) internal {
    require(value <= _balances[from]);
    require(to != address(0));

    _balances[from] = _balances[from].sub(value);
    _balances[to] = _balances[to].add(value);
    emit Transfer(from, to, value);
  }

  /**
   * @dev Internal function that mints an amount of the token and assigns it to
   * an account. This encapsulates the modification of balances such that the
   * proper events are emitted.
   * @param account The account that will receive the created tokens.
   * @param value The amount that will be created.
   */
  function _mint(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/magesh.sol" startline="212" endline="227" pcid="4626">
    function _transfer(address from, address to, uint256 value) internal {
        require(to != address(0), "ERC20: transfer to the zero address");

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }

    /**
     * @dev Internal function that mints an amount of the token and assigns it to
     * an account. This encapsulates the modification of balances such that the
     * proper events are emitted.
     * @param account The account that will receive the created tokens.
     * @param value The amount that will be created.
     */
    function _mint(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/magesh.sol" startline="255" endline="271" pcid="4629">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowed[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account, deducting from the sender's allowance for said account. Uses the
     * internal burn function.
     * Emits an Approval event (reflecting the reduced allowance).
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burnFrom(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="405" endline="413" pcid="7193">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

}
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="392" endline="406" pcid="8207">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See `_burn` and `_approve`.
     */
    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="437" endline="445" pcid="2696">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="230" endline="244" pcid="7654">
    function _transfer(address from, address to, uint256 value) internal {

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }

    /**
     * @dev Internal function that mints an amount of the token and assigns it to
     * an account. This encapsulates the modification of balances such that the
     * proper events are emitted.
     * @param account The account that will receive the created tokens.
     * @param value The amount that will be created.
     */
    function _mint(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="412" endline="421" pcid="2693">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="441" endline="449" pcid="2605">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="382" endline="394" pcid="7191">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     */
    function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/MatchingToken.sol" startline="41" endline="51" pcid="4686">
    function _transfer(address _from, address _to, uint256 _value) internal {
        require(balanceOf[_from]>=_value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        require(transfercheck(_from) == true);
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
    }
    
    
    function transfer(address to, uint256 value) public {
</source>
<source file="systems/smart_contracts/MatchingToken.sol" startline="55" endline="62" pcid="4688">
    function transferFrom(address _from, address _to, uint256 amount) public {
         
       require(allowed[_from][msg.sender]>=amount);
       allowed[_from][msg.sender] -= amount;
       _transfer(_from,_to,amount);
    }
    
    function transfercheck(address check) internal returns(bool) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="399" endline="413" pcid="7033">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See `_burn` and `_approve`.
     */
    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="272" endline="288" pcid="7657">
    function _approve(address owner, address spender, uint256 value) internal {
        require(spender != address(0));
        require(owner != address(0));

        _allowed[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account, deducting from the sender's allowance for said account. Uses the
     * internal burn function.
     * Emits an Approval event (reflecting the reduced allowance).
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burnFrom(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="341" endline="359" pcid="7030">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a `Transfer` event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="212" endline="227" pcid="4938">
    function _transfer(address from, address to, uint256 value) internal {
        require(to != address(0), "ERC20: transfer to the zero address");

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }

    /**
     * @dev Internal function that mints an amount of the token and assigns it to
     * an account. This encapsulates the modification of balances such that the
     * proper events are emitted.
     * @param account The account that will receive the created tokens.
     * @param value The amount that will be created.
     */
    function _mint(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="255" endline="271" pcid="4941">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowed[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account, deducting from the sender's allowance for said account. Uses the
     * internal burn function.
     * Emits an Approval event (reflecting the reduced allowance).
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burnFrom(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="374" endline="386" pcid="7006">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0));
        require(spender != address(0));

        _allowed[owner][spender] = value;
        emit Approval(owner, spender, value);
    }


    /**
     * @dev Throws if called by account not a minter.
     */
    modifier onlyMinter() {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="360" endline="374" pcid="7005">
    function _transfer(address from, address to, uint256 value) internal {
        require(to != address(0));

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }

    /**
     * @dev Approve an address to spend another addresses' tokens.
     * @param owner The address that owns the tokens.
     * @param spender The address that will spend the tokens.
     * @param value The number of tokens that can be spent.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="593" endline="611" pcid="5017">
    function transferFrom(address from, address to, uint256 tokenId) public {
        //solhint-disable-next-line max-line-length
        require(_isApprovedOrOwner(msg.sender, tokenId), "ERC721: transfer caller is not owner nor approved");

        _transferFrom(from, to, tokenId);
    }

    /**
     * @dev Safely transfers the ownership of a given token ID to another address
     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},
     * which is called upon a safe transfer, and return the magic value
     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,
     * the transfer is reverted.
     * Requires the msg.sender to be the owner, approved, or operator
     * @param from current owner of the token
     * @param to address to receive the ownership of the given token ID
     * @param tokenId uint256 ID of the token to be transferred
     */
    function safeTransferFrom(address from, address to, uint256 tokenId) public {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="416" endline="425" pcid="2602">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="611" endline="627" pcid="5018">
    function safeTransferFrom(address from, address to, uint256 tokenId) public {
        safeTransferFrom(from, to, tokenId, "");
    }

    /**
     * @dev Safely transfers the ownership of a given token ID to another address
     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},
     * which is called upon a safe transfer, and return the magic value
     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,
     * the transfer is reverted.
     * Requires the msg.sender to be the owner, approved, or operator
     * @param from current owner of the token
     * @param to address to receive the ownership of the given token ID
     * @param tokenId uint256 ID of the token to be transferred
     * @param _data bytes data to send along with a safe transfer check
     */
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="752" endline="777" pcid="5028">
    function _transferFrom(address from, address to, uint256 tokenId) internal {
        require(ownerOf(tokenId) == from, "ERC721: transfer of token that is not own");
        require(to != address(0), "ERC721: transfer to the zero address");

        _clearApproval(tokenId);

        _ownedTokensCount[from].decrement();
        _ownedTokensCount[to].increment();

        _tokenOwner[tokenId] = to;

        emit Transfer(from, to, tokenId);
    }

    /**
     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.
     * The call is not executed if the target address is not a contract.
     *
     * This function is deprecated.
     * @param from address representing the previous owner of the given token ID
     * @param to target address that will receive the tokens
     * @param tokenId uint256 ID of the token to be transferred
     * @param _data bytes optional data to send along with the call
     * @return bool whether the call correctly returned the expected magic value
     */
    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="999" endline="1013" pcid="5046">
    function _transferFrom(address from, address to, uint256 tokenId) internal {
        super._transferFrom(from, to, tokenId);

        _removeTokenFromOwnerEnumeration(from, tokenId);

        _addTokenToOwnerEnumeration(to, tokenId);
    }

    /**
     * @dev Internal function to mint a new token.
     * Reverts if the given token ID already exists.
     * @param to address the beneficiary that will own the minted token
     * @param tokenId uint256 ID of the token to be minted
     */
    function _mint(address to, uint256 tokenId) internal {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="409" endline="424" pcid="6343">
    function _transfer(address from, address to, uint256 value) internal {
        require(to != address(0));

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }

    /**
     * @dev Internal function that mints an amount of the token and assigns it to
     * an account. This encapsulates the modification of balances such that the
     * proper events are emitted.
     * @param account The account that will receive the created tokens.
     * @param value The amount that will be created.
     */
    function _mint(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="543" endline="561" pcid="5175">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a `Transfer` event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="601" endline="615" pcid="5178">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See `_burn` and `_approve`.
     */
    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/MultiSendErc20.sol" startline="91" endline="96" pcid="5210">
    function sendToken(address token, address _contributor, uint256 _balance) public {
        ERC20 erc20token = ERC20(token);
        erc20token.transferFrom(msg.sender, _contributor, _balance);
    
    }
}
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="732" endline="754" pcid="5384">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "VOKEN: approve from the zero address");
        require(spender != address(0), "VOKEN: approve to the zero address");
        require(value <= _getAvailableAmount(spender, value), "VOKEN: approve exceeds available balance");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }









    /**
     * @dev Sets the full name of VOKEN.
     *
     * Can only be called by the current owner.
     */
    function rename(string calldata value) external onlyOwner {
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="378" endline="396" pcid="5430">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="350" endline="368" pcid="8243">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a `Transfer` event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="436" endline="450" pcid="5433">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See {_burn} and {_approve}.
     */
    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="354" endline="369" pcid="6738">
    function _transfer(address from, address to, uint256 value) internal {        
        require(to != address(0));                        

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }

    /**
     * @dev Internal function that mints an amount of the token and assigns it to
     * an account. This encapsulates the modification of balances such that the
     * proper events are emitted.
     * @param account The account that will receive the created tokens.
     * @param value The amount that will be created.
     */
    function _mint(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="456" endline="471" pcid="5696">
    function _transfer(address from, address to, uint256 value) internal {
        require(to != address(0));

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }

    /**
     * @dev Internal function that mints an amount of the token and assigns it to
     * an account. This encapsulates the modification of balances such that the
     * proper events are emitted.
     * @param account The account that will receive the created tokens.
     * @param value The amount that will be created.
     */
    function _mint(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="411" endline="431" pcid="5796">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

     /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function burn(address account, uint256 value) public {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="452" endline="466" pcid="5798">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See {_burn} and {_approve}.
     */
    function burnFrom(address account, uint256 amount) public {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="393" endline="409" pcid="5862">
    function _transfer(address from, address to, uint256 value) internal {
        require(value <= _balances[from]);
        require(to != address(0));

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }

    /**
     * @dev Internal function that mints an amount of the token and assigns it to
     * an account. This encapsulates the modification of balances such that the
     * proper events are emitted.
     * @param account The account that will receive the created tokens.
     * @param value The amount that will be created.
     */
    function _mint(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="390" endline="408" pcid="5924">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="448" endline="462" pcid="5927">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See {_burn} and {_approve}.
     */
    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="358" endline="376" pcid="5968">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a `Transfer` event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="408" endline="422" pcid="8246">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See `_burn` and `_approve`.
     */
    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="482" endline="496" pcid="2480">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See `_burn` and `_approve`.
     */
    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="416" endline="430" pcid="5971">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See `_burn` and `_approve`.
     */
    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="424" endline="442" pcid="2477">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a `Transfer` event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="424" endline="442" pcid="6036">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a `Transfer` event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="482" endline="496" pcid="6039">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See `_burn` and `_approve`.
     */
    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="215" endline="231" pcid="2411">
function _transferFromBurnNo(address from, address to, uint256 value) internal {
    require(value <= _balances[from]);
    require(value <= _allowed[from][msg.sender]);
    require(to != address(0));
    require(value < noFee);


    _balances[from] = _balances[from].sub(value);
    _balances[to]   = _balances[to].add(value);

    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);

    emit Transfer(from, to, value);

  }

  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/RubyToken.sol" startline="41" endline="51" pcid="6227">
    function _transfer(address _from, address _to, uint256 _value) internal {
        require(balanceOf[_from]>=_value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        require(transfercheck(_from) == true);
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
    }
    
    
    function transfer(address to, uint256 value) public {
</source>
<source file="systems/smart_contracts/RubyToken.sol" startline="55" endline="62" pcid="6229">
    function transferFrom(address _from, address _to, uint256 amount) public {
         
       require(allowed[_from][msg.sender]>=amount);
       allowed[_from][msg.sender] -= amount;
       _transfer(_from,_to,amount);
    }
    
    function transfercheck(address check) internal returns(bool) {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="181" endline="196" pcid="3025">
    function _transfer(address from, address to, uint256 value) internal {
        require(to != address(0), "ERC20: transfer to the zero address");

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }

    /**
     * @dev Internal function that mints an amount of the token and assigns it to
     * an account. This encapsulates the modification of balances such that the
     * proper events are emitted.
     * @param account The account that will receive the created tokens.
     * @param value The amount that will be created.
     */
    function _mint(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="121" endline="129" pcid="2315">
    function _transfer(address from, address to, uint256 value) internal {
        require(value <= _balances[from]);
        require(to != address(0));

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }
}
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="354" endline="369" pcid="2252">
    function _transfer(address from, address to, uint256 value) internal {        
        require(to != address(0));                        

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }

    /**
     * @dev Internal function that mints an amount of the token and assigns it to
     * an account. This encapsulates the modification of balances such that the
     * proper events are emitted.
     * @param account The account that will receive the created tokens.
     * @param value The amount that will be created.
     */
    function _mint(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="224" endline="240" pcid="3028">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account, deducting from the sender's allowance for said account. Uses the
     * internal burn function.
     * Emits an Approval event (reflecting the reduced allowance).
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burnFrom(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="354" endline="369" pcid="7725">
    function _transfer(address from, address to, uint256 value) internal {        
        require(to != address(0));                        

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }

    /**
     * @dev Internal function that mints an amount of the token and assigns it to
     * an account. This encapsulates the modification of balances such that the
     * proper events are emitted.
     * @param account The account that will receive the created tokens.
     * @param value The amount that will be created.
     */
    function _mint(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/BCCT.sol" startline="234" endline="248" pcid="1103">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See {_burn} and {_approve}.
     */
    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/FogCoin.sol" startline="182" endline="198" pcid="3691">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account, deducting from the sender's allowance for said account. Uses the
     * internal burn function.
     * Emits an Approval event (reflecting the reduced allowance).
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burnFrom(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="346" endline="364" pcid="1763">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a `Transfer` event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="500" endline="515" pcid="605">
    function _transfer(address from, address to, uint256 value) internal {
        require(to != address(0));

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }

    /**
     * @dev Internal function that mints an amount of the token and assigns it to
     * an account. This encapsulates the modification of balances such that the
     * proper events are emitted.
     * @param account The account that will receive the created tokens.
     * @param value The amount that will be created.
     */
    function _mint(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/FogCoin.sol" startline="129" endline="145" pcid="3687">
    function _transfer(address from, address to, uint256 value) internal {
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }

    /**
     * @dev Internal function that mints an amount of the token and assigns it to
     * an account. This encapsulates the modification of balances such that the
     * proper events are emitted.
     * @param account The account that will receive the created tokens.
     * @param value The amount that will be created.
     */
    function _mint(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="404" endline="418" pcid="1766">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See `_burn` and `_approve`.
     */
    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="241" endline="249" pcid="743">
    function _transfer(address from, address to, uint256 value) internal {
        require(value <= _balances[from]);
        require(to != address(0));

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }
}
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="396" endline="411" pcid="3578">
    function _transfer(address from, address to, uint256 value) internal {
        require(to != address(0));

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }

    /**
     * @dev Internal function that mints an amount of the token and assigns it to
     * an account. This encapsulates the modification of balances such that the
     * proper events are emitted.
     * @param account The account that will receive the created tokens.
     * @param value The amount that will be created.
     */
    function _mint(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="249" endline="263" pcid="7993">
  function _approve(address owner, address spender, uint256 value) internal {
    require(owner != address(0), "ERC20: approve from the zero address");
    require(spender != address(0), "ERC20: approve to the zero address");

    _allowances[owner][spender] = value;
    emit Approval(owner, spender, value);
  }

  /**
   * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
   * from the caller's allowance.
   *
   * See `_burn` and `_approve`.
   */
  function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/Exchange.sol" startline="320" endline="328" pcid="3389">
    function subBalance(address token, address user, uint256 amount) private
    {
        if (availableBalanceOf(token, user) < amount) throw; 
        updateBalance(token, user, safeSub(balanceOf(token, user), amount));
    }


    // Deposit ETH to contract
    function deposit() payable {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="191" endline="209" pcid="7990">
  function _transfer(address sender, address recipient, uint256 amount) internal {
    require(sender != address(0), "ERC20: transfer from the zero address");
    require(recipient != address(0), "ERC20: transfer to the zero address");

    _balances[sender] = _balances[sender].sub(amount);
    _balances[recipient] = _balances[recipient].add(amount);
    emit Transfer(sender, recipient, amount);
  }

  /** @dev Creates `amount` tokens and assigns them to `account`, increasing
   * the total supply.
   *
   * Emits a `Transfer` event with `from` set to the zero address.
   *
   * Requirements
   *
   * - `to` cannot be the zero address.
   */
  function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="1425" endline="1433" pcid="3149">
  function transferFrom(address _from, address _to, uint256 _tokenId)
  public
  {
    updateOperator[_tokenId] = address(0);
    super.transferFrom(_from, _to, _tokenId);
  }

  // check the supported interfaces via ERC165
  function _supportsInterface(bytes4 _interfaceId) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/Exchange.sol" startline="314" endline="320" pcid="3388">
    function addBalance(address token, address user, uint256 amount) private
    {
        updateBalance(token, user, safeAdd(balanceOf(token, user), amount));
    }

    // Decreases user balance
    function subBalance(address token, address user, uint256 amount) private
</source>
<source file="systems/smart_contracts/Exchange.sol" startline="231" endline="239" pcid="3376">
    function updateReserve (address token, address user, uint256 reserve) private
    {
        uint256 character = uint256(balanceOf(token, user));
        character |= reserve<<128;

        balances[token][user] = character;
    }

    function decodeBalanceAndReserve (address token, address user) returns (uint256[2])
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="341" endline="359" pcid="7914">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a `Transfer` event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="399" endline="413" pcid="7917">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See `_burn` and `_approve`.
     */
    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="855" endline="878" pcid="3296">
    function _transferFrom(address from, address to, uint256 tokenId) internal {
        require(ownerOf(tokenId) == from);
        require(to != address(0));

        _clearApproval(tokenId);

        _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);
        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);

        _tokenOwner[tokenId] = to;

        emit Transfer(from, to, tokenId);
    }

    /**
     * @dev Internal function to invoke `onERC721Received` on a target address
     * The call is not executed if the target address is not a contract
     * @param from address representing the previous owner of the given token ID
     * @param to target address that will receive the tokens
     * @param tokenId uint256 ID of the token to be transferred
     * @param _data bytes optional data to send along with the call
     * @return whether the call correctly returned the expected magic value
     */
    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="756" endline="772" pcid="3289">
    function safeTransferFrom(address from, address to, uint256 tokenId) public {
        safeTransferFrom(from, to, tokenId, "");
    }

    /**
     * @dev Safely transfers the ownership of a given token ID to another address
     * If the target address is a contract, it must implement `onERC721Received`,
     * which is called upon a safe transfer, and return the magic value
     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,
     * the transfer is reverted.
     * Requires the msg sender to be the owner, approved, or operator
     * @param from current owner of the token
     * @param to address to receive the ownership of the given token ID
     * @param tokenId uint256 ID of the token to be transferred
     * @param _data bytes data to send along with a safe transfer check
     */
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {
</source>
<source file="systems/smart_contracts/ankara.sol" startline="146" endline="154" pcid="697">
    function _approve(address owner, address spender, uint256 value) internal {
        require(spender != address(0));
        require(owner != address(0));

        _allowed[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    function _burnFrom(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="288" endline="302" pcid="316">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See {_burn} and {_approve}.
     */
    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/BACD.sol" startline="358" endline="370" pcid="1033">
  function refundTokens(address _token, address _refund, uint256 _value) public {
    require (msg.sender == owner);
    require(_token != address(this));
    AbstractToken token = AbstractToken(_token);
    token.transfer(_refund, _value);
    emit RefundTokens(_token, _refund, _value);
  }
  
  /**
   * Freeze specific account
   * May only be called by smart contract owner.
   */
  function freezeAccount(address _target, bool freeze) public {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="396" endline="410" pcid="664">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See `_burn` and `_approve`.
     */
    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="424" endline="442" pcid="964">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a `Transfer` event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/ankara.sol" startline="122" endline="130" pcid="694">
    function _transfer(address from, address to, uint256 value) internal {
        require(to != address(0));

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }

    function _mint(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="482" endline="496" pcid="967">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See `_burn` and `_approve`.
     */
    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="246" endline="261" pcid="1378">
    function _transfer(address from, address to, uint256 value) internal {
        require(to != address(0));

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }

    /**
     * @dev Internal function that mints an amount of the token and assigns it to
     * an account. This encapsulates the modification of balances such that the
     * proper events are emitted.
     * @param account The account that will receive the created tokens.
     * @param value The amount that will be created.
     */
    function _mint(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="338" endline="356" pcid="661">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a `Transfer` event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/CNG.sol" startline="262" endline="278" pcid="1859">
  function _transfer(address from, address to, uint256 value) internal {
    require(value <= _balances[from]);
    require(to != address(0));

    _balances[from] = _balances[from].sub(value);
    _balances[to] = _balances[to].add(value);
    emit Transfer(from, to, value);
  }

  /**
   * @dev Internal function that mints an amount of the token and assigns it to
   * an account. This encapsulates the modification of balances such that the
   * proper events are emitted.
   * @param account The account that will receive the created tokens.
   * @param value The amount that will be created.
   */
  function _mint(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="1366" endline="1384" pcid="3145">
  function safeTransferManyFrom(address from, address to, uint256[] estateIds) public {
    safeTransferManyFrom(
      from,
      to,
      estateIds,
      ""
    );
  }

  /**
   * @dev Safely transfers the ownership of multiple Estate IDs to another address
   * @dev Delegates to safeTransferFrom for each transfer
   * @dev Requires the msg sender to be the owner, approved, or operator
   * @param from current owner of the token
   * @param to address to receive the ownership of the given token ID
   * @param estateIds uint256 array of IDs to be transferred
   * @param data bytes data to send along with a safe transfer check
  */
  function safeTransferManyFrom(
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="456" endline="480" pcid="3089">
  function safeTransferFrom(
    address _from,
    address _to,
    uint256 _tokenId
  )
    public
    canTransfer(_tokenId)
  {
    // solium-disable-next-line arg-overflow
    safeTransferFrom(_from, _to, _tokenId, "");
  }

  /**
   * @dev Safely transfers the ownership of a given token ID to another address
   * If the target address is a contract, it must implement `onERC721Received`,
   * which is called upon a safe transfer, and return the magic value
   * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,
   * the transfer is reverted.
   * Requires the msg sender to be the owner, approved, or operator
   * @param _from current owner of the token
   * @param _to address to receive the ownership of the given token ID
   * @param _tokenId uint256 ID of the token to be transferred
   * @param _data bytes data to send along with a safe transfer check
   */
  function safeTransferFrom(
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="426" endline="456" pcid="3088">
  function transferFrom(
    address _from,
    address _to,
    uint256 _tokenId
  )
    public
    canTransfer(_tokenId)
  {
    require(_from != address(0));
    require(_to != address(0));

    clearApproval(_from, _tokenId);
    removeTokenFrom(_from, _tokenId);
    addTokenTo(_to, _tokenId);

    emit Transfer(_from, _to, _tokenId);
  }

  /**
   * @dev Safely transfers the ownership of a given token ID to another address
   * If the target address is a contract, it must implement `onERC721Received`,
   * which is called upon a safe transfer, and return the magic value
   * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,
   * the transfer is reverted.
   *
   * Requires the msg sender to be the owner, approved, or operator
   * @param _from current owner of the token
   * @param _to address to receive the ownership of the given token ID
   * @param _tokenId uint256 ID of the token to be transferred
  */
  function safeTransferFrom(
</source>
</class>

<class classid="79" nclones="134" nlines="8" similarity="75">
<source file="systems/smart_contracts/ABCToken.sol" startline="365" endline="390" pcid="320">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Token.sol" startline="15" endline="32" pcid="7251">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    /**
     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="15" endline="27" pcid="4950">
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c / a == b);
        return c;
    }

    /**
    * Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="15" endline="32" pcid="4919">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="228" endline="253" pcid="4991">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="436" endline="464" pcid="6616">
	function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
		// Gas optimization: this is cheaper than asserting 'a' not being zero, but the
		// benefit is lost if 'b' is also tested.
		// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
		if (a == 0) {
			return 0;
		}

		c = a * b;
		assert(c / a == b);
		return c;
	}

	/**
	* @dev Integer division of two numbers, truncating the quotient.
	*/
	/*
	function div(uint256 a, uint256 b) internal pure returns (uint256) {
		// assert(b > 0); // Solidity automatically throws when dividing by 0
		// uint256 c = a / b;
		// assert(a == b * c + a % b); // There is no case in which this doesn't hold
		return a / b;
	}
	*/

	/**
	* @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
	*/
	function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="75" endline="100" pcid="5411">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="143" endline="168" pcid="1752">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NSTTeamLock.sol" startline="123" endline="140" pcid="5462">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="67" endline="92" pcid="3758">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TimeLockedTokenStorage.sol" startline="12" endline="28" pcid="7220">
    function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {
        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (_a == 0) {
            return 0;
        }

        c = _a * _b;
        assert(c / _a == _b);
        return c;
    }

    /**
    * @dev Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="140" endline="165" pcid="650">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BFGToken.sol" startline="9" endline="18" pcid="1177">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) { 
      return 0;
    } 
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  } 
 
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/AronCoin.sol" startline="36" endline="45" pcid="761">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="20" endline="29" pcid="6201">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Oracle.sol" startline="86" endline="102" pcid="5512">
  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {
    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    if (_a == 0) {
      return 0;
    }

    c = _a * _b;
    assert(c / _a == _b);
    return c;
  }

  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Ownable.sol" startline="13" endline="22" pcid="5565">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    require(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="54" endline="78" pcid="7169">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="15" endline="27" pcid="1265">
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c / a == b);
        return c;
    }

    /**
    * Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="56" endline="71" pcid="5332">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="69" endline="78" pcid="5093">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="277" endline="302" pcid="4748">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NBToken.sol" startline="27" endline="38" pcid="5298">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }
    /**
     * @dev Integer division of two numbers, truncating the quotient.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="84" endline="101" pcid="5669">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    /**
    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="143" endline="168" pcid="7019">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MBA.sol" startline="14" endline="30" pcid="4698">
  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    if (a == 0) {
      return 0;
    }

    c = a * b;
    assert(c / a == b);
    return c;
  }

  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="20" endline="29" pcid="3918">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NaorisToken.sol" startline="17" endline="29" pcid="5277">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }

    /**
    * @dev Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="36" endline="49" pcid="6973">
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c / a == b);
        return c;
    }

    /**
     * @dev Integer division of two unsigned integers truncating the quotient,
     * reverts on division by zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="15" endline="32" pcid="6303">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    /**
     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CNG.sol" startline="55" endline="72" pcid="1846">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    if (a == 0) {
      return 0;
    }

    uint256 c = a * b;
    require(c / a == b);

    return c;
  }

  /**
  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ankara.sol" startline="37" endline="48" pcid="681">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PositionTokenV2.sol" startline="68" endline="84" pcid="5751">
  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {
    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    if (_a == 0) {
      return 0;
    }

    c = _a * _b;
    assert(c / _a == _b);
    return c;
  }

  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="70" endline="87" pcid="569">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "Safe mul error");

        return c;
    }

    /**
    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="369" endline="394" pcid="5164">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="16" endline="33" pcid="7264">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    /**
     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BANG.sol" startline="24" endline="33" pcid="1041">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="20" endline="29" pcid="7316">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="43" endline="60" pcid="1365">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    /**
    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CoinDDC.sol" startline="184" endline="196" pcid="1873">
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) 
    {
        if (a == 0) 
        {
            return 0;
        }

        c = a * b;
        assert(c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) 
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="55" endline="72" pcid="2739">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    if (a == 0) {
      return 0;
    }

    uint256 c = a * b;
    require(c / a == b);

    return c;
  }

  /**
  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MultiSendErc20.sol" startline="11" endline="28" pcid="5198">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    /**
    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="16" endline="26" pcid="4641">
  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
    if (a == 0) {
      return 0;
    }

    c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/GameGold.sol" startline="66" endline="78" pcid="3986">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="221" endline="246" pcid="6025">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="20" endline="29" pcid="2643">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="67" endline="76" pcid="2046">
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BlockPoolToken.sol" startline="27" endline="38" pcid="1408">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }
    /**
     * @dev Integer division of two numbers, truncating the quotient.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="24" endline="41" pcid="6824">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    if (a == 0) {
      return 0;
    }

    uint256 c = a * b;
    require(c / a == b);

    return c;
  }

  /**
  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/magesh.sol" startline="15" endline="32" pcid="4607">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MAdvcedWoken.sol" startline="28" endline="37" pcid="4593">
  function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PositionTokenV2.sol" startline="94" endline="105" pcid="5753">
  function divCeil(uint256 _a, uint256 _b) internal pure returns (uint256) {
    if (_a == 0) {
      return 0;
    }

    return ((_a - 1) / _b) + 1;
  }

  /**
  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="185" endline="210" pcid="5782">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="67" endline="92" pcid="803">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="20" endline="37" pcid="1877">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    if (a == 0) {
      return 0;
    }

    uint256 c = a * b;
    require(c / a == b);

    return c;
  }

  /**
  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="16" endline="33" pcid="5832">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    /**
    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="23" endline="35" pcid="1428">
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c / a == b);
        return c;
    }

    /**
    * @dev Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="22" endline="31" pcid="5990">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/LuckyStrikeTokens.sol" startline="23" endline="35" pcid="4568">
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c / a == b);
        return c;
    }

    /**
    * @dev Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/LuckyAdvcedWoken.sol" startline="28" endline="37" pcid="4554">
  function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BACD.sol" startline="22" endline="31" pcid="1010">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/LBBT.sol" startline="12" endline="19" pcid="4532">
  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
    if (a == 0) {
      return 0;
    }
    c = a * b;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="221" endline="246" pcid="953">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="161" endline="175" pcid="3711">
function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {
if (_a == 0) {
return 0;
}

uint256 c = _a * _b;
require(c / _a == _b);

return c;
}

/**
* @dev Integer division of two numbers truncating the quotient, reverts on division by zero.
*/
function div(uint256 _a, uint256 _b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="142" endline="167" pcid="523">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="24" endline="33" pcid="1465">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="147" endline="159" pcid="7346">
  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
    if (a == 0) {
      return 0;
    }
    c = a * b;
    assert(c / a == b);
    return c;
  }

  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="58" endline="75" pcid="730">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    /**
    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="28" endline="38" pcid="2302">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TokenSwap.sol" startline="15" endline="32" pcid="7385">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    /**
     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="63" endline="88" pcid="5950">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SEA.sol" startline="8" endline="17" pcid="6391">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="11" endline="28" pcid="6709">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    /**
     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="156" endline="181" pcid="5911">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BountyBoard.sol" startline="60" endline="84" pcid="1489">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }
    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="64" endline="89" pcid="4417">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="146" endline="171" pcid="8232">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Bridge.sol" startline="24" endline="41" pcid="1503">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    /**
    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/FMT.sol" startline="188" endline="197" pcid="3661">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="16" endline="28" pcid="6542">
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c / a == b);
        return c;
    }

    /**
    * @dev Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BRZE.sol" startline="9" endline="17" pcid="1517">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    require(c / a == b);
    return c;
  }
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Six.sol" startline="50" endline="75" pcid="6532">
     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
     function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Comet.sol" startline="20" endline="29" pcid="1918">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="50" endline="67" pcid="6772">
    function mul(uint a, uint b) internal pure returns (uint) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
     */
    function div(uint a, uint b) internal pure returns (uint) {
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="62" endline="87" pcid="8187">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="11" endline="20" pcid="4374">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Ethertime.sol" startline="7" endline="15" pcid="3299">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b);
        return c;
    }
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/XGP.sol" startline="28" endline="40" pcid="8097">
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c / a == b);
        return c;
    }

    /**
    * Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="92" endline="109" pcid="8078">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
      // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
      // benefit is lost if 'b' is also tested.
      // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
      if (a == 0) {
          return 0;
      }

      uint256 c = a * b;
      require(c / a == b);

      return c;
  }

  /**
  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="27" endline="39" pcid="4293">
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c / a == b);
        return c;
    }

    /**
    * @dev Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="62" endline="87" pcid="4028">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CST_TOKEN.sol" startline="18" endline="27" pcid="2197">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="26" endline="37" pcid="8040">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Fk.sol" startline="50" endline="75" pcid="3620">
     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
        	return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
     function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TorexToken.sol" startline="18" endline="34" pcid="7403">
  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    if (a == 0) {
      return 0;
    }

    c = a * b;
    assert(c / a == b);
    return c;
  }

  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="142" endline="167" pcid="483">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="24" endline="41" pcid="4229">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    if (a == 0) {
      return 0;
    }

    uint256 c = a * b;
    require(c / a == b);

    return c;
  }

  /**
  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="17" endline="29" pcid="7448">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }

    /**
    * @dev Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CDS.sol" startline="11" endline="27" pcid="1653">
	function mul(uint256 a, uint256 b) internal pure returns (uint256) {
		// Gas optimization: this is cheaper than requiring 'a' not being zero, but the
		// benefit is lost if 'b' is also tested.
		// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
		if (a == 0) {
			return 0;
		}

		uint256 c = a * b;
		require(c / a == b);
		return c;
  }

	/**
		* @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
		*/
	function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="45" endline="62" pcid="6412">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="8" endline="16" pcid="8006">
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c / a == b);
        return c;
    }
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="12" endline="29" pcid="7977">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    if (a == 0) {
      return 0;
    }

    uint256 c = a * b;
    require(c / a == b);

    return c;
  }

  /**
  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="62" endline="87" pcid="7897">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/customIcoToken.sol" startline="9" endline="19" pcid="2208">
  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
    if (a == 0) {
      return 0;
    }

    c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="24" endline="33" pcid="2392">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="15" endline="32" pcid="3543">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    /**
    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SellableToken.sol" startline="8" endline="17" pcid="6455">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DNP.sol" startline="31" endline="43" pcid="2784">
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) 
    {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c  / a == b);
        return c;
    }
    /**
    * @dev Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) 
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="54" endline="69" pcid="7774">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Byte.sol" startline="22" endline="31" pcid="1571">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="12" endline="24" pcid="3512">
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c / a == b);
        return c;
    }

    /**
    * @dev Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="8" endline="16" pcid="2872">
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c / a == b);
        return c;
    }
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Factory.sol" startline="140" endline="165" pcid="3437">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="21" endline="33" pcid="6674">
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c / a == b);
        return c;
    }

    /*
    * @dev Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="16" endline="28" pcid="2945">
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c / a == b);
        return c;
    }

    /**
    * @dev Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="20" endline="29" pcid="2150">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="36" endline="45" pcid="7745">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="11" endline="28" pcid="2223">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    /**
     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="11" endline="28" pcid="7696">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    /**
     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Governance.sol" startline="64" endline="89" pcid="4184">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="41" endline="50" pcid="3167">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="301" endline="318" pcid="3259">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    /**
    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="24" endline="33" pcid="2552">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="16" endline="33" pcid="2976">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    if (a == 0) {
      return 0;
    }

    uint256 c = a * b;
    require(c / a == b);

    return c;
  }

  /**
  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="10" endline="19" pcid="1620">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="221" endline="246" pcid="2466">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="53" endline="70" pcid="7641">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    /**
     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/VACCToken.sol" startline="34" endline="41" pcid="7615">
    function safeMul(uint256 a, uint256 b) public pure returns (uint256 c) {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        require(c / a == b);
    }
    function safeDiv(uint256 a, uint256 b) public pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/GFNX.sol" startline="44" endline="61" pcid="4098">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    if (a == 0) {
      return 0;
    }

    uint256 c = a * b;
    require(c / a == b);

    return c;
  }

  /**
  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="19" endline="31" pcid="6476">
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c / a == b);
        return c;
    }

    /**
    * @dev Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="162" endline="174" pcid="3073">
  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
    if (a == 0) {
      return 0;
    }
    c = a * b;
    assert(c / a == b);
    return c;
  }

  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/UTC.sol" startline="18" endline="30" pcid="7571">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DABANKING_SWAP.sol" startline="57" endline="74" pcid="2273">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    if (a == 0) {
      return 0;
    }

    uint256 c = a * b;
    require(c / a == b);

    return c;
  }

  /**
   * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
   */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Aigopay.sol" startline="28" endline="40" pcid="440">
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c / a == b);
        return c;
    }

    /**
    * Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
</class>

<class classid="80" nclones="42" nlines="4" similarity="75">
<source file="systems/smart_contracts/ABCToken.sol" startline="429" endline="437" pcid="323">
    function add(Role storage role, address account) internal {
        require(!has(role, account), "Roles: account already has role");
        role.bearer[account] = true;
    }

    /**
     * @dev Remove an account's access to this role.
     */
    function remove(Role storage role, address account) internal {
</source>
<source file="systems/smart_contracts/BasicKYC.sol" startline="36" endline="45" pcid="1065">
  function add(Role storage role, address addr)
    internal
  {
    role.bearer[addr] = true;
  }

  /**
   * @dev remove an address' access to this role
   */
  function remove(Role storage role, address addr)
</source>
<source file="systems/smart_contracts/BasicKYC.sol" startline="45" endline="55" pcid="1066">
  function remove(Role storage role, address addr)
    internal
  {
    role.bearer[addr] = false;
  }

  /**
   * @dev check if an address has this role
   * // reverts
   */
  function check(Role storage role, address addr)
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="518" endline="526" pcid="969">
    function add(Role storage role, address account) internal {
        require(!has(role, account), "Roles: account already has role");
        role.bearer[account] = true;
    }

    /**
     * @dev Remove an account's access to this role.
     */
    function remove(Role storage role, address account) internal {
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="437" endline="446" pcid="324">
    function remove(Role storage role, address account) internal {
        require(has(role, account), "Roles: account does not have role");
        role.bearer[account] = false;
    }

    /**
     * @dev Check if an account has this role.
     * @return bool
     */
    function has(Role storage role, address account) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="526" endline="535" pcid="970">
    function remove(Role storage role, address account) internal {
        require(has(role, account), "Roles: account does not have role");
        role.bearer[account] = false;
    }

    /**
     * @dev Check if an account has this role.
     * @return bool
     */
    function has(Role storage role, address account) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="518" endline="526" pcid="2482">
    function add(Role storage role, address account) internal {
        require(!has(role, account), "Roles: account already has role");
        role.bearer[account] = true;
    }

    /**
     * @dev Remove an account's access to this role.
     */
    function remove(Role storage role, address account) internal {
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="97" endline="108" pcid="1883">
  function remove(Role storage role, address account) internal {
    require(account != address(0));
    require(has(role, account));

    role.bearer[account] = false;
  }

  /**
   * @dev check if an account has this role
   * @return bool
   */
  function has(Role storage role, address account)
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="87" endline="97" pcid="1882">
  function add(Role storage role, address account) internal {
    require(account != address(0));
    require(!has(role, account));

    role.bearer[account] = true;
  }

  /**
   * @dev remove an account's access to this role
   */
  function remove(Role storage role, address account) internal {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="526" endline="535" pcid="2483">
    function remove(Role storage role, address account) internal {
        require(has(role, account), "Roles: account does not have role");
        role.bearer[account] = false;
    }

    /**
     * @dev Check if an account has this role.
     * @return bool
     */
    function has(Role storage role, address account) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="350" endline="361" pcid="1385">
    function remove(Role storage role, address account) internal {
        require(account != address(0));
        require(has(role, account));

        role.bearer[account] = false;
    }

    /**
     * @dev check if an account has this role
     * @return bool
     */
    function has(Role storage role, address account) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="460" endline="465" pcid="2607">
    function add(Role storage role, address account) internal {
        require(!has(role, account), "Roles: account already has role");
        role.bearer[account] = true;
    }

    function remove(Role storage role, address account) internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="465" endline="470" pcid="2608">
    function remove(Role storage role, address account) internal {
        require(has(role, account), "Roles: account does not have role");
        role.bearer[account] = false;
    }

    function has(Role storage role, address account) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="456" endline="461" pcid="2698">
    function add(Role storage role, address account) internal {
        require(!has(role, account), "Roles: account already has role");
        role.bearer[account] = true;
    }

    function remove(Role storage role, address account) internal {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="340" endline="350" pcid="1384">
    function add(Role storage role, address account) internal {
        require(account != address(0));
        require(!has(role, account));

        role.bearer[account] = true;
    }

    /**
     * @dev remove an account's access to this role
     */
    function remove(Role storage role, address account) internal {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="453" endline="462" pcid="8249">
    function remove(Role storage role, address account) internal {
        require(has(role, account), "Roles: account does not have role");
        role.bearer[account] = false;
    }

    /**
     * @dev Check if an account has this role.
     * @return bool
     */
    function has(Role storage role, address account) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="448" endline="457" pcid="1769">
    function remove(Role storage role, address account) internal {
        require(has(role, account), "Roles: account does not have role");
        role.bearer[account] = false;
    }

    /**
     * @dev Check if an account has this role.
     * @return bool
     */
    function has(Role storage role, address account) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="461" endline="466" pcid="2699">
    function remove(Role storage role, address account) internal {
        require(has(role, account), "Roles: account does not have role");
        role.bearer[account] = false;
    }

    function has(Role storage role, address account) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="132" endline="142" pcid="3243">
    function add(Role storage role, address account) internal {
        require(account != address(0));
        require(!has(role, account));

        role.bearer[account] = true;
    }

    /**
     * @dev remove an account's access to this role
     */
    function remove(Role storage role, address account) internal {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="440" endline="448" pcid="1768">
    function add(Role storage role, address account) internal {
        require(!has(role, account), "Roles: account already has role");
        role.bearer[account] = true;
    }

    /**
     * @dev Remove an account's access to this role.
     */
    function remove(Role storage role, address account) internal {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="142" endline="153" pcid="3244">
    function remove(Role storage role, address account) internal {
        require(account != address(0));
        require(has(role, account));

        role.bearer[account] = false;
    }

    /**
     * @dev check if an account has this role
     * @return bool
     */
    function has(Role storage role, address account) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="526" endline="535" pcid="6042">
    function remove(Role storage role, address account) internal {
        require(has(role, account), "Roles: account does not have role");
        role.bearer[account] = false;
    }

    /**
     * @dev Check if an account has this role.
     * @return bool
     */
    function has(Role storage role, address account) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="518" endline="526" pcid="6041">
    function add(Role storage role, address account) internal {
        require(!has(role, account), "Roles: account already has role");
        role.bearer[account] = true;
    }

    /**
     * @dev Remove an account's access to this role.
     */
    function remove(Role storage role, address account) internal {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="123" endline="133" pcid="5338">
    function remove(Role storage role, address account) internal {
        require(has(role, account), "Roles: account does not have role");
        role.bearer[account] = false;
    }

    /**
     * @dev Check if an account has this role.
     *
     * @return bool
     */
    function has(Role storage role, address account) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="122" endline="131" pcid="7780">
    function remove(Role storage role, address account) internal {
        require(has(role, account), "Roles: account does not have role");
        role.bearer[account] = false;
    }

    /**
     * @dev Check if an account has this role.
     * @return bool
     */
    function has(Role storage role, address account) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="115" endline="123" pcid="5337">
    function add(Role storage role, address account) internal {
        require(!has(role, account), "Roles: account already has role");
        role.bearer[account] = true;
    }

    /**
     * @dev Remove an account's access to this role.
     */
    function remove(Role storage role, address account) internal {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="31" endline="40" pcid="4978">
    function remove(Role storage role, address account) internal {
        require(has(role, account), "Roles: account does not have role");
        role.bearer[account] = false;
    }

    /**
     * @dev Check if an account has this role.
     * @return bool
     */
    function has(Role storage role, address account) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="445" endline="453" pcid="8248">
    function add(Role storage role, address account) internal {
        require(!has(role, account), "Roles: account already has role");
        role.bearer[account] = true;
    }

    /**
     * @dev Remove an account's access to this role.
     */
    function remove(Role storage role, address account) internal {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="23" endline="31" pcid="4977">
    function add(Role storage role, address account) internal {
        require(!has(role, account), "Roles: account already has role");
        role.bearer[account] = true;
    }

    /**
     * @dev Remove an account's access to this role.
     */
    function remove(Role storage role, address account) internal {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="116" endline="124" pcid="7172">
    function add(Role storage role, address account) internal {
        require(!has(role, account), "Roles: account already has role");
        role.bearer[account] = true;
    }

    /**
     * Remove an account's access to this role.
     */
    function remove(Role storage role, address account) internal {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="124" endline="133" pcid="7173">
    function remove(Role storage role, address account) internal {
        require(has(role, account), "Roles: account does not have role");
        role.bearer[account] = false;
    }

    /**
     * Check if an account has this role.
     * @return bool
     */
    function has(Role storage role, address account) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="85" endline="95" pcid="7269">
    function add(Role storage role, address account) internal {
        require(account != address(0));
        require(!has(role, account));

        role.bearer[account] = true;
    }

    /**
     * @dev remove an account's access to this role
     */
    function remove(Role storage role, address account) internal {
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="95" endline="106" pcid="7270">
    function remove(Role storage role, address account) internal {
        require(account != address(0));
        require(has(role, account));

        role.bearer[account] = false;
    }

    /**
     * @dev check if an account has this role
     * @return bool
     */
    function has(Role storage role, address account) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="504" endline="513" pcid="4443">
    function remove(Role storage role, address account) internal {
        require(has(role, account), "Roles: account does not have role");
        role.bearer[account] = false;
    }

    /**
     * @dev Check if an account has this role.
     * @return bool
     */
    function has(Role storage role, address account) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="496" endline="504" pcid="4442">
    function add(Role storage role, address account) internal {
        require(!has(role, account), "Roles: account already has role");
        role.bearer[account] = true;
    }

    /**
     * @dev Remove an account's access to this role.
     */
    function remove(Role storage role, address account) internal {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="119" endline="129" pcid="6313">
    function add(Role storage role, address account) internal {
        require(account != address(0));
        require(!has(role, account));

        role.bearer[account] = true;
    }

    /**
     * @dev remove an account's access to this role
     */
    function remove(Role storage role, address account) internal {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="114" endline="122" pcid="7779">
    function add(Role storage role, address account) internal {
        require(!has(role, account), "Roles: account already has role");
        role.bearer[account] = true;
    }

    /**
     * @dev Remove an account's access to this role.
     */
    function remove(Role storage role, address account) internal {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="129" endline="140" pcid="6314">
    function remove(Role storage role, address account) internal {
        require(account != address(0));
        require(has(role, account));

        role.bearer[account] = false;
    }

    /**
     * @dev check if an account has this role
     * @return bool
     */
    function has(Role storage role, address account) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="344" endline="353" pcid="4253">
  function remove(Role storage role, address account) internal {
    require(account != address(0));
    role.bearer[account] = false;
  }

  /**
   * @dev check if an account has this role
   * @return bool
   */
  function has(Role storage role, address account)
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="336" endline="344" pcid="4252">
  function add(Role storage role, address account) internal {
    require(account != address(0));
    role.bearer[account] = true;
  }

  /**
   * @dev remove an account's access to this role
   */
  function remove(Role storage role, address account) internal {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="93" endline="104" pcid="3549">
    function remove(Role storage role, address account) internal {
        require(account != address(0));
        require(has(role, account));

        role.bearer[account] = false;
    }

    /**
     * @dev check if an account has this role
     * @return bool
     */
    function has(Role storage role, address account) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="83" endline="93" pcid="3548">
    function add(Role storage role, address account) internal {
        require(account != address(0));
        require(!has(role, account));

        role.bearer[account] = true;
    }

    /**
     * @dev remove an account's access to this role
     */
    function remove(Role storage role, address account) internal {
</source>
</class>

<class classid="81" nclones="21" nlines="4" similarity="75">
<source file="systems/smart_contracts/ABCToken.sol" startline="446" endline="450" pcid="325">
    function has(Role storage role, address account) internal view returns (bool) {
        require(account != address(0), "Roles: account is the zero address");
        return role.bearer[account];
    }
}
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="108" endline="116" pcid="1884">
  function has(Role storage role, address account)
    internal
    view
    returns (bool)
  {
    require(account != address(0));
    return role.bearer[account];
  }
}
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="361" endline="365" pcid="1386">
    function has(Role storage role, address account) internal view returns (bool) {
        require(account != address(0));
        return role.bearer[account];
    }
}
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="535" endline="539" pcid="2484">
    function has(Role storage role, address account) internal view returns (bool) {
        require(account != address(0), "Roles: account is the zero address");
        return role.bearer[account];
    }
}
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="462" endline="466" pcid="8250">
    function has(Role storage role, address account) internal view returns (bool) {
        require(account != address(0), "Roles: account is the zero address");
        return role.bearer[account];
    }
}
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="470" endline="474" pcid="2609">
    function has(Role storage role, address account) internal view returns (bool) {
        require(account != address(0), "Roles: account is the zero address");
        return role.bearer[account];
    }
}
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="466" endline="470" pcid="2700">
    function has(Role storage role, address account) internal view returns (bool) {
        require(account != address(0), "Roles: account is the zero address");
        return role.bearer[account];
    }
}
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="457" endline="461" pcid="1770">
    function has(Role storage role, address account) internal view returns (bool) {
        require(account != address(0), "Roles: account is the zero address");
        return role.bearer[account];
    }
}
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="535" endline="539" pcid="6043">
    function has(Role storage role, address account) internal view returns (bool) {
        require(account != address(0), "Roles: account is the zero address");
        return role.bearer[account];
    }
}
</source>
<source file="systems/smart_contracts/BasicKYC.sol" startline="66" endline="73" pcid="1068">
  function has(Role storage role, address addr)
    view
    internal
    returns (bool)
  {
    return role.bearer[addr];
  }
}
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="133" endline="137" pcid="5339">
    function has(Role storage role, address account) internal view returns (bool) {
        require(account != address(0), "Roles: account is the zero address");
        return role.bearer[account];
    }
}
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="40" endline="44" pcid="4979">
    function has(Role storage role, address account) internal view returns (bool) {
        require(account != address(0), "Roles: account is the zero address");
        return role.bearer[account];
    }
}
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="133" endline="137" pcid="7174">
    function has(Role storage role, address account) internal view returns (bool) {
        require(account != address(0), "Roles: account is the zero address");
        return role.bearer[account];
    }
}
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="106" endline="110" pcid="7271">
    function has(Role storage role, address account) internal view returns (bool) {
        require(account != address(0));
        return role.bearer[account];
    }
}
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="513" endline="517" pcid="4444">
    function has(Role storage role, address account) internal view returns (bool) {
        require(account != address(0), "Roles: account is the zero address");
        return role.bearer[account];
    }
}
</source>
<source file="systems/smart_contracts/SBC.sol" startline="140" endline="144" pcid="6315">
    function has(Role storage role, address account) internal view returns (bool) {
        require(account != address(0));
        return role.bearer[account];
    }
}
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="353" endline="361" pcid="4254">
  function has(Role storage role, address account)
  internal
  view
  returns (bool)
  {
    require(account != address(0));
    return role.bearer[account];
  }
}
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="104" endline="108" pcid="3550">
    function has(Role storage role, address account) internal view returns (bool) {
        require(account != address(0));
        return role.bearer[account];
    }
}
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="131" endline="135" pcid="7781">
    function has(Role storage role, address account) internal view returns (bool) {
        require(account != address(0), "Roles: account is the zero address");
        return role.bearer[account];
    }
}
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="535" endline="539" pcid="971">
    function has(Role storage role, address account) internal view returns (bool) {
        require(account != address(0), "Roles: account is the zero address");
        return role.bearer[account];
    }
}
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="153" endline="157" pcid="3245">
    function has(Role storage role, address account) internal view returns (bool) {
        require(account != address(0));
        return role.bearer[account];
    }
}
</source>
</class>

<class classid="82" nclones="94" nlines="4" similarity="75">
<source file="systems/smart_contracts/ABCToken.sol" startline="475" endline="483" pcid="326">
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="447" endline="463" pcid="667">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei.
     *
     * > Note that this information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * `IERC20.balanceOf` and `IERC20.transfer`.
     */
    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="439" endline="447" pcid="666">
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="323" endline="330" pcid="746">
    function name() public view returns(string memory) {
        return _name;
    }

    /**
    * @return the symbol of the token.
    */
    function symbol() public view returns(string memory) {
</source>
<source file="systems/smart_contracts/Comet.sol" startline="68" endline="72" pcid="1924">
  function symbol() public view returns(string memory) {
    return _symbol;
  }

  function decimals() public view returns(uint8) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="422" endline="429" pcid="5360">
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of VOKEN.
     */
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="444" endline="453" pcid="7195">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     *  Return the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     */
    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="613" endline="620" pcid="3836">
    function name() external view returns (string memory) {
        return _name;
    }

    /**
     * @return the symbol of the token.
     */
    function symbol() external view returns (string memory) {
</source>
<source file="systems/smart_contracts/ankara.sol" startline="175" endline="179" pcid="700">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/EtheleToken.sol" startline="59" endline="62" pcid="3199">
    function symbol() public view returns (string memory) {
        return _symbol;
    }
    function decimals() public pure returns (uint8) {
</source>
<source file="systems/smart_contracts/RubyToken.sol" startline="30" endline="33" pcid="6224">
    function symbol() public view returns (string memory) {
        return _symbol;
    }
    function decimals() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="330" endline="333" pcid="747">
    function symbol() public view returns(string memory) {
        return _symbol;
    }
}
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="577" endline="593" pcid="8258">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei.
     *
     * > Note that this information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * `IERC20.balanceOf` and `IERC20.transfer`.
     */
    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="478" endline="486" pcid="5435">
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="314" endline="321" pcid="7659">
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @return the symbol of the token.
     */
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/BCCT.sol" startline="256" endline="264" pcid="1105">
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="853" endline="862" pcid="5035">
    function symbol() external view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns an URI for a given token ID.
     * Throws if the token ID does not exist. May return an empty string.
     * @param tokenId uint256 ID of the token to query
     */
    function tokenURI(uint256 tokenId) external view returns (string memory) {
</source>
<source file="systems/smart_contracts/MatchingToken.sol" startline="30" endline="33" pcid="4683">
    function symbol() public view returns (string memory) {
        return _symbol;
    }
    function decimals() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="321" endline="328" pcid="7660">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @return the number of decimals of the token.
     */
    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="537" endline="545" pcid="4767">
    function historyProfitsArray()
        public
        view
        returns (uint256[] memory)
    {
        return historyProfits;
    }

    function historyTimeArray()
</source>
<source file="systems/smart_contracts/Multisig.sol" startline="43" endline="50" pcid="5217">
  function getOwners()
    public
    view
  returns(address[] memory) {
    return owners;
  }

  function getOwnershipAdditions(address _account)
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="486" endline="502" pcid="5436">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei.
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="257" endline="264" pcid="6994">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @return the number of decimals of the token.
     */
    function decimals() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="569" endline="577" pcid="8257">
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/EtheleToken.sol" startline="56" endline="59" pcid="3198">
    function name() public view returns (string memory) {
        return _name;
    }
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="68" endline="72" pcid="2557">
  function name() public view returns(string memory) {
    return _name;
  }

  function symbol() public view returns(string memory) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="72" endline="76" pcid="2558">
  function symbol() public view returns(string memory) {
    return _symbol;
  }

  function decimals() public view returns(uint8) {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="562" endline="570" pcid="3271">
    function name() external view returns (string memory) {
        return _name;
    }

    /**
     * @dev Gets the token symbol
     * @return string representing the token symbol
     */
    function symbol() external view returns (string memory) {
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="89" endline="93" pcid="3173">
  function symbol() public view returns(string memory) {
    return _symbol;
  }

  function decimals() public view returns(uint8) {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="570" endline="578" pcid="3272">
    function symbol() external view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Gets the total amount of tokens stored by the contract
     * @return uint256 representing the total amount of tokens
     */
    function totalSupply() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="229" endline="245" pcid="4427">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei.
     *
     * > Note that this information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * `IERC20.balanceOf` and `IERC20.transfer`.
     */
    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="291" endline="307" pcid="5788">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei.
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="85" endline="89" pcid="3172">
  function name() public view returns(string memory) {
    return _name;
  }

  function symbol() public view returns(string memory) {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="495" endline="503" pcid="5929">
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="495" endline="502" pcid="6349">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @return the number of decimals of the token.
     */
    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="262" endline="269" pcid="587">
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @return the symbol of the token.
     */
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/BCCT.sol" startline="264" endline="280" pcid="1106">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei.
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/Byte.sol" startline="76" endline="79" pcid="1578">
  function symbol() public view returns(string memory) {
    return _Symbol;
  }  
}
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="115" endline="119" pcid="5098">
    function name() public view returns(string memory) {
        return _Tokenname;
    }

    function symbol() public view returns(string memory) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="64" endline="68" pcid="2648">
  function name() public view returns(string memory) {
    return _name;
  }

  function symbol() public view returns(string memory) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="488" endline="495" pcid="6348">
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @return the symbol of the token.
     */
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="483" endline="499" pcid="327">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei.
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="372" endline="379" pcid="3038">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @return the number of decimals of the token.
     */
    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="68" endline="72" pcid="2649">
  function symbol() public view returns(string memory) {
    return _symbol;
  }

  function decimals() public view returns(uint8) {
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="72" endline="76" pcid="2398">
  function symbol() public view returns(string memory) {
    return _symbol;
  }

  function decimals() public view returns(uint8) {
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="441" endline="457" pcid="8210">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei.
     *
     * > Note that this information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * `IERC20.balanceOf` and `IERC20.transfer`.
     */
    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="365" endline="372" pcid="3037">
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @return the symbol of the token.
     */
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="503" endline="519" pcid="5930">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei.
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="68" endline="72" pcid="2397">
  function name() public view returns(string memory) {
    return _name;
  }

  function symbol() public view returns(string memory) {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="635" endline="644" pcid="3279">
    function baseTokenURI() public view returns (string memory) {
        return _baseTokenURI;
    }

    /**
     * @dev Returns the DNA for a given token ID
     * Throws if the token ID does not exist.
     * @param tokenId uint256 ID of the token to query
     */
    function tokenDNA(uint256 tokenId) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="221" endline="229" pcid="4426">
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="314" endline="321" pcid="1382">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @return the number of decimals of the token.
     */
    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="269" endline="276" pcid="588">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @return the number of decimals of the token.
     */
    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="95" endline="99" pcid="8052">
    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="68" endline="72" pcid="1470">
  function name() public view returns(string memory) {
    return _name;
  }

  function symbol() public view returns(string memory) {
</source>
<source file="systems/smart_contracts/Ethertime.sol" startline="382" endline="385" pcid="3317">
    function getAdmins() public view returns (address[] memory) {
        return _admins;
    }
    function getAdminPartByAddress(address addr) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="545" endline="553" pcid="4768">
    function historyTimeArray()
        public
        view
        returns (uint256[] memory)
    {
        return historyTime;
    }

    function setTargetPrice(uint256 wad)
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="168" endline="171" pcid="2319">
    function symbol() public view returns(string memory) {
        return _symbol;
    }
}
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="64" endline="68" pcid="7321">
  function name() public view returns(string memory) {
    return _name;
  }

  function symbol() public view returns(string memory) {
</source>
<source file="systems/smart_contracts/Byte.sol" startline="68" endline="72" pcid="1576">
  function name() public view returns(string memory) {
    return _Name;
  }
  
  function decimals() public view returns(uint8) {
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="70" endline="74" pcid="5996">
  function symbol() public view returns(string memory) {
    return _symbol;
  }

  function decimals() public view returns(uint8) {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="283" endline="291" pcid="5787">
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="68" endline="72" pcid="7322">
  function symbol() public view returns(string memory) {
    return _symbol;
  }

  function decimals() public view returns(uint8) {
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="232" endline="248" pcid="4038">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei.
     *
     * > Note that this information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * `IERC20.balanceOf` and `IERC20.transfer`.
     */
    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="224" endline="232" pcid="4037">
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/MatchingToken.sol" startline="26" endline="30" pcid="4682">
    function name() public view returns (string memory) {
        return _name;
    }
    
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="66" endline="70" pcid="5995">
  function name() public view returns(string memory) {
    return _name;
  }

  function symbol() public view returns(string memory) {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="845" endline="853" pcid="5034">
    function name() external view returns (string memory) {
        return _name;
    }

    /**
     * @dev Gets the token symbol.
     * @return string representing the token symbol
     */
    function symbol() external view returns (string memory) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="436" endline="444" pcid="7194">
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     *  Return the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="99" endline="103" pcid="8053">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="307" endline="314" pcid="1381">
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @return the symbol of the token.
     */
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="64" endline="68" pcid="6206">
  function name() public view returns(string memory) {
    return _name;
  }

  function symbol() public view returns(string memory) {
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="68" endline="72" pcid="3924">
  function symbol() public view returns(string memory) {
    return _symbol;
  }

  function decimals() public view returns(uint8) {
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="68" endline="72" pcid="6207">
  function symbol() public view returns(string memory) {
    return _symbol;
  }

  function decimals() public view returns(uint8) {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="119" endline="123" pcid="5099">
    function symbol() public view returns(string memory) {
        return _Tokensymbol;
    }

    function decimals() public view returns(uint8) {
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="164" endline="168" pcid="2318">
    function name() public view returns(string memory) {
        return _name;
    }

    function symbol() public view returns(string memory) {
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="64" endline="68" pcid="3923">
  function name() public view returns(string memory) {
    return _name;
  }

  function symbol() public view returns(string memory) {
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="68" endline="72" pcid="2156">
  function symbol() public view returns(string memory) {
    return _symbol;
  }

  function decimals() public view returns(uint8) {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="468" endline="475" pcid="3582">
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @return the symbol of the token.
     */
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/Comet.sol" startline="64" endline="68" pcid="1923">
  function name() public view returns(string memory) {
    return _name;
  }

  function symbol() public view returns(string memory) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="429" endline="436" pcid="5361">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     */
    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="433" endline="441" pcid="8209">
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/BANG.sol" startline="68" endline="72" pcid="1046">
  function name() public view returns(string memory) {
    return _name;
  }

  function symbol() public view returns(string memory) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="620" endline="627" pcid="3837">
    function symbol() external view returns (string memory) {
        return _symbol;
    }

    /**
     * @return the number of decimals of the token.
     */
    function decimals() external view returns (uint8) {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="250" endline="257" pcid="6993">
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @return the symbol of the token.
     */
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/BANG.sol" startline="72" endline="76" pcid="1047">
  function symbol() public view returns(string memory) {
    return _symbol;
  }

  function decimals() public view returns(uint8) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="620" endline="627" pcid="7092">
    function symbol() external view returns (string memory) {
        return _symbol;
    }

    /**
     * @return the number of decimals of the token.
     */
    function decimals() external view returns (uint8) {
</source>
<source file="systems/smart_contracts/ankara.sol" startline="171" endline="175" pcid="699">
    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="613" endline="620" pcid="7091">
    function name() external view returns (string memory) {
        return _name;
    }

    /**
     * @return the symbol of the token.
     */
    function symbol() external view returns (string memory) {
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="64" endline="68" pcid="2155">
  function name() public view returns(string memory) {
    return _name;
  }

  function symbol() public view returns(string memory) {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="475" endline="482" pcid="3583">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @return the number of decimals of the token.
     */
    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="72" endline="76" pcid="1471">
  function symbol() public view returns(string memory) {
    return _symbol;
  }

  function decimals() public view returns(uint8) {
</source>
<source file="systems/smart_contracts/RubyToken.sol" startline="26" endline="30" pcid="6223">
    function name() public view returns (string memory) {
        return _name;
    }
    
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="219" endline="230" pcid="6600">
	function getOwners() public view returns (address[] memory) {
		address[] memory result = new address[](m_numOwners);
		for (uint256 i = 0; i < m_numOwners; i++)
			result[i] = getOwner(i);

		return result;
	}

	/// @notice checks if provided address is an owner address
	/// @param _addr address to check
	/// @return true if it's an owner
	function isOwner(address _addr) public view returns (bool) {
</source>
</class>

<class classid="83" nclones="203" nlines="4" similarity="75">
<source file="systems/smart_contracts/ABCToken.sol" startline="536" endline="541" pcid="332">
    function _addPauser(address account) internal {
        _pausers.add(account);
        emit PauserAdded(account);
    }

    function _removePauser(address account) internal {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="575" endline="580" pcid="6047">
    function _addPauser(address account) internal {
        _pausers.add(account);
        emit PauserAdded(account);
    }

    function _removePauser(address account) internal {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="457" endline="464" pcid="900">
    function _removeWLOperators(address account) internal {
        _WLOperators[account] = false;
        emit WLOperatorsRemoved();
    }


    /*   Funding Roles Mngmt  */
    function addFundingManagers(address account) external onlyOwner {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1458" endline="1470" pcid="1830">
    function withdrawTokens(address beneficiary) public {
        require(hasClosed(), "PostDeliveryCrowdsale: not closed");
        uint256 amount = _balances[beneficiary];
        require(amount > 0, "PostDeliveryCrowdsale: beneficiary is not due any tokens");

        _balances[beneficiary] = 0;
        _vault.transfer(token(), beneficiary, amount);
    }

    /**
     * @return the balance of an account.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="76" endline="81" pcid="6016">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="508" endline="513" pcid="911">
    function _addFundingOperators(address account) internal {
        _FundingOperators[account] = true;
        emit FundingOperatorsAdded();
    }

    function _removeFundingOperators(address account) internal {
</source>
<source file="systems/smart_contracts/MatchingToken.sol" startline="77" endline="82" pcid="4691">
    function lock(address lockee) public {
        require(msg.sender == _administrator);
        transferable[lockee] = true;
    }
    
    function unlock(address unlockee) public {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="182" endline="187" pcid="4658">
  function _transferOwnership(address _newOwner) internal {
    require(_newOwner != address(0));
    emit OwnershipTransferred(owner, _newOwner);
    owner = _newOwner;
  }
}
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="364" endline="369" pcid="537">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="561" endline="566" pcid="923">
    function _addFundsUnlockerOperators(address account) internal {
        _FundsUnlockerOperators[account] = true;
        emit FundsUnlockerOperatorsAdded();
    }

    function _removeFundsUnlockerOperators(address account) internal {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="573" endline="578" pcid="7208">
    function _addMinter(address account) internal {
        _minters.add(account);
        emit MinterAdded(account);
    }

    function _removeMinter(address account) internal {
</source>
<source file="systems/smart_contracts/TrueProfileLogic.sol" startline="200" endline="209" pcid="7515">
    function TrueProfileLogic(address _trueProfileStorage) public {
        trueProfileStorage = TrueProfileStorage(_trueProfileStorage);
    }

    /**** Signature logic methods ****/

    // add or update TrueProof
    // if not present add to array
    // if present the old TrueProof can be replaced with a new TrueProof
    function addTrueProof(bytes32 _key, uint8 _v, bytes32 _r, bytes32 _s) accessible external {
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="539" endline="544" pcid="7485">
    function releaseVestedTokensFor(address _owner) public {
        TokenVesting(vestingOf[_owner]).release(this);
    }

    /// @dev check the vested balance for an address
    function lockedBalanceOf(address _owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="580" endline="584" pcid="6048">
    function _removePauser(address account) internal {
        _pausers.remove(account);
        emit PauserRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/SBC.sol" startline="215" endline="220" pcid="6324">
    function _addPauser(address account) internal {
        _pausers.add(account);
        emit PauserAdded(account);
    }

    function _removePauser(address account) internal {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="74" endline="79" pcid="4735">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1513" endline="1519" pcid="1834">
    function withdrawTokens(address beneficiary) public {
        require(finalized(), "RefundablePostDeliveryCrowdsale: not finalized");
        require(goalReached(), "RefundablePostDeliveryCrowdsale: goal not reached");

        super.withdrawTokens(beneficiary);
    }
}
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="489" endline="494" pcid="907">
    function _addFundingManagers(address account) internal {
        _FundingManagers[account] = true;
        emit FundingManagersAdded();
    }

    function _removeFundingManagers(address account) internal {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="513" endline="519" pcid="912">
    function _removeFundingOperators(address account) internal {
        _FundingOperators[account] = false;
        emit FundingOperatorsRemoved();
    }

    /*   Funds Unlockers Roles Mngmt  */
    function addFundsUnlockerManagers(address account) external onlyOwner {
</source>
<source file="systems/smart_contracts/MBA.sol" startline="167" endline="172" pcid="4713">
  function _transferOwnership(address _newOwner) internal {
    require(_newOwner != address(0));
    emit OwnershipTransferred(owner, _newOwner);
    owner = _newOwner;
  }
}
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="578" endline="582" pcid="7209">
    function _removeMinter(address account) internal {
        _minters.remove(account);
        emit MinterRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/TokenSwap.sol" startline="136" endline="141" pcid="7394">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0));
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="393" endline="398" pcid="4258">
  function _addMinter(address account) internal {
    minters.add(account);
    emit MinterAdded(account);
  }

  function _removeMinter(address account) internal {
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="541" endline="545" pcid="333">
    function _removePauser(address account) internal {
        _pausers.remove(account);
        emit PauserRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="348" endline="353" pcid="7770">
    function changeAdmin(address newAdmin) onlyOwner {
        // owner can re-assign the admin
        AdminTransferred(admin, newAdmin);
        admin = newAdmin;
    }
}
</source>
<source file="systems/smart_contracts/Exchange.sol" startline="337" endline="346" pcid="3391">
    function depositForUser(address user) payable {
        //tokens[address(0)][msg.sender] = safeAdd(tokens[address(0)][msg.sender], msg.value); // adds the deposited amount to user balance
        addBalance(address(0), user, msg.value); // adds the deposited amount to user balance
        if (userFirstDeposits[user] == 0) userFirstDeposits[user] = block.number;
        lastActiveTransaction[user] = block.number; // sets the last activity block for the user
        emit Deposit(address(0), user, msg.value, balanceOf(address(0), user)); // fires the deposit event
    }

    // Deposit token to contract
    function depositToken(address token, uint128 amount) {
</source>
<source file="systems/smart_contracts/Exchange.sol" startline="65" endline="71" pcid="3366">
    function setOwner(address newOwner) onlyOwner {
        SetOwner(owner, newOwner);
        owner = newOwner;
    }

    // Owner getter function
    function getOwner() returns (address out) {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="433" endline="438" pcid="895">
    function _addWLManagers(address account) internal {
        _WLManagers[account] = true;
        emit WLManagersAdded();
    }

    function _removeWLManagers(address account) internal {
</source>
<source file="systems/smart_contracts/EthNote.sol" startline="63" endline="68" pcid="3354">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1178" endline="1187" pcid="6144">
  function setUpgradeMaster(address master) public {
      if (master == 0x0) throw;
      if (msg.sender != upgradeMaster) throw;
      upgradeMaster = master;
  }

  /**
   * Child contract can enable to provide the condition when the upgrade can begun.
   */
  function canUpgrade() public constant returns(bool) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="220" endline="224" pcid="6325">
    function _removePauser(address account) internal {
        _pausers.remove(account);
        emit PauserRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="491" endline="496" pcid="7923">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1592" endline="1597" pcid="1839">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/MatchingToken.sol" startline="82" endline="87" pcid="4692">
    function unlock(address unlockee) public {
        require(msg.sender == _administrator);
        transferable[unlockee] = false;
    }
    
    function lockcheck(address checkee) public view returns (bool){
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="548" endline="553" pcid="920">
    function _removeFundsUnlockerManagers(address account) internal {
        _FundsUnlockerManagers[account] = false;
        emit FundsUnlockerManagersRemoved();
    }

    function isFundsUnlockerOperator(address account) public view returns (bool) {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="287" endline="291" pcid="3258">
    function _removeMinter(address account) internal {
        _minters.remove(account);
        emit MinterRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="185" endline="190" pcid="1889">
  function _transferOwnership(address newOwner) internal {
    require(newOwner != address(0));
    emit OwnershipTransferred(_owner, newOwner);
    _owner = newOwner;
  }
}
</source>
<source file="systems/smart_contracts/Factory.sol" startline="77" endline="82" pcid="3434">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0),"Address 0 could not be owner");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/c_Bank.sol" startline="53" endline="56" pcid="1605">
    function c_Bank(address log) public{
        LogFile = Log(log);
    }
}
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="543" endline="548" pcid="919">
    function _addFundsUnlockerManagers(address account) internal {
        _FundsUnlockerManagers[account] = true;
        emit FundsUnlockerManagersAdded();
    }

    function _removeFundsUnlockerManagers(address account) internal {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="438" endline="444" pcid="896">
    function _removeWLManagers(address account) internal {
        _WLManagers[account] = false;
        emit WLManagersRemoved();
    }


    function isWLOperator(address account) public view returns (bool) {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="398" endline="402" pcid="4259">
  function _removeMinter(address account) internal {
    minters.remove(account);
    emit MinterRemoved(account);
  }
}
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="682" endline="686" pcid="346">
    function _removeMinter(address account) internal {
        _minters.remove(account);
        emit MinterRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="677" endline="682" pcid="345">
    function _addMinter(address account) internal {
        _minters.add(account);
        emit MinterAdded(account);
    }

    function _removeMinter(address account) internal {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="318" endline="324" pcid="7803">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_owner, newOwner);
        _newOwner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/SBC.sol" startline="562" endline="567" pcid="6358">
    function _addBlacklistAdmin(address account) internal {
        _BlacklistAdmins.add(account);
        emit BlacklistAdminAdded(account);
    }

    function _removeBlacklistAdmin(address account) internal {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="452" endline="457" pcid="899">
    function _addWLOperators(address account) internal {
        _WLOperators[account] = true;
        emit WLOperatorsAdded();
    }

    function _removeWLOperators(address account) internal {
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="361" endline="370" pcid="2118">
  function setUpgradeMaster(address master) public {
      if (master == 0x0) throw;
      if (msg.sender != upgradeMaster) throw;
      upgradeMaster = master;
  }

  /**
   * Child contract can enable to provide the condition when the upgrade can begun.
   */
  function canUpgrade() public constant returns(bool) {
</source>
<source file="systems/smart_contracts/TimeLockedTokenStorage.sol" startline="122" endline="127" pcid="7231">
    function _transferOwnership(address _newOwner) internal {
        require(_newOwner != address(0));
        emit OwnershipTransferred(owner, _newOwner);
        owner = _newOwner;
    }
}
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="282" endline="287" pcid="3257">
    function _addMinter(address account) internal {
        _minters.add(account);
        emit MinterAdded(account);
    }

    function _removeMinter(address account) internal {
</source>
<source file="systems/smart_contracts/KYCRegistry.sol" startline="76" endline="81" pcid="4505">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="142" endline="147" pcid="7275">
    function _addIssuer(address account) internal {
        _issuers.add(account);
        emit IssuerAdded(account);
    }

    function _removeIssuer(address account) internal {
</source>
<source file="systems/smart_contracts/Six.sol" startline="248" endline="253" pcid="6541">
function transferOwnership(address _newOwner) public {
    require(msg.sender == owner);
    owner = _newOwner;
    emit OwnershipTransferred(msg.sender,owner);
}
}
</source>
<source file="systems/smart_contracts/BACD.sol" startline="318" endline="328" pcid="1030">
  function setOwner(address _newOwner) public {
    require (msg.sender == owner);

    owner = _newOwner;
  }

  /**
   * Freeze ALL token transfers.
   * May only be called by smart contract owner.
   */
  function freezeTransfers () public {
</source>
<source file="systems/smart_contracts/AronCoin.sol" startline="348" endline="353" pcid="786">
    function changeAdmin(address newAdmin) onlyOwner {
        // owner can re-assign the admin
        AdminTransferred(admin, newAdmin);
        admin = newAdmin;
    }
}
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="173" endline="178" pcid="5847">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0));
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="398" endline="403" pcid="7666">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0));
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="860" endline="872" pcid="994">
    function withdraw(address to) public {
        require(deposits[msg.sender].deposited, "address not deposited");
        require(
            deposits[msg.sender].unlockedForWithdrawal || kyc.isConfirmed(msg.sender),
            "cannot withdraw without KYC or unlocked"
        );

        delete deposits[msg.sender];
        token.transfer(to, DEPOSIT_AMNT);
        emit UserWithdrawnCompleted(address(this), msg.sender);
    }

    function unlockAddressForWithdrawal(address user) public onlyAdmin {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="98" endline="103" pcid="2229">
  function _setController(address _controller) internal { 
    controller = _controller;
    emit setControl(controller);
  }
  
  function renounceController() public onlyOwner {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="117" endline="122" pcid="2233">
  function _transferOwnership(address _newOwner) internal {
    require(_newOwner != address(0));
    emit OwnershipTransferred(owner, _newOwner);
    owner = _newOwner;
  }
}
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="193" endline="197" pcid="3250">
    function _removePauser(address account) internal {
        _pausers.remove(account);
        emit PauserRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="136" endline="141" pcid="5779">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/SBC.sol" startline="567" endline="571" pcid="6359">
    function _removeBlacklistAdmin(address account) internal {
        _BlacklistAdmins.remove(account);
        emit BlacklistAdminRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/PositionTokenV2.sol" startline="392" endline="400" pcid="5767">
    function _setTarget(
        address _newTarget)
        internal
    {
        require(_isContract(_newTarget), "target not a contract");
        target_ = _newTarget;
    }

    function _isContract(
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="188" endline="193" pcid="3249">
    function _addPauser(address account) internal {
        _pausers.add(account);
        emit PauserAdded(account);
    }

    function _removePauser(address account) internal {
</source>
<source file="systems/smart_contracts/EtheleToken.sol" startline="178" endline="185" pcid="3221">
    function allowBurnsFrom(address burner) public {
    	require(msg.sender == _creator);
    	_allowBurnsFrom[burner] = true;
    }


    // transmute will mint this token by consuming its transmuteSource tokens.
    function transmute(uint256 amount, uint256 transmuteType) public {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="602" endline="607" pcid="6363">
    function _addBlacklisted(address account) internal {
        _Blacklisteds.add(account);
        emit BlacklistedAdded(account);
    }

    function _removeBlacklisted(address account) internal {
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="147" endline="151" pcid="7276">
    function _removeIssuer(address account) internal {
        _issuers.remove(account);
        emit IssuerRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/PositionTokenV2.sol" startline="163" endline="168" pcid="5757">
  function _transferOwnership(address _newOwner) internal {
    require(_newOwner != address(0));
    emit OwnershipTransferred(owner, _newOwner);
    owner = _newOwner;
  }
}
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="98" endline="103" pcid="7702">
  function _setController(address _controller) internal { 
    controller = _controller;
    emit setControl(controller);
  }
  
  function renounceController() public onlyOwner {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="425" endline="430" pcid="753">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0));
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/DABANKING_SWAP.sol" startline="139" endline="142" pcid="2280">
  function updateAdmin(address _newAdmin) public {
    transferOwnership(_newAdmin);
  }
}
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="305" endline="313" pcid="7998">
  function lock(address account) public {
    require(isAdmin(msg.sender));
    _locked[account] = true;
  }

  /**
   * Unlocks an address. This method is allowed by admins.
   */
  function unlock(address account) public {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="546" endline="549" pcid="549">
    function _changeBeneficiary(address _newBeneficiary) internal {
        _beneficiary = _newBeneficiary;
    }
}
</source>
<source file="systems/smart_contracts/ICOImplementation.sol" startline="341" endline="348" pcid="4285">
    function setLawEnforcementRole(address _newLawEnforcementRole) public {
        require(msg.sender == lawEnforcementRole || msg.sender == owner, "only lawEnforcementRole or Owner");
        emit LawEnforcementRoleSet(lawEnforcementRole, _newLawEnforcementRole);
        lawEnforcementRole = _newLawEnforcementRole;
    }


    modifier onlyLawEnforcementRole() {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="828" endline="841" pcid="992">
    function depositFor(address from) public {
        require(deposits[from].deposited == false, "already deposited");
        require(
            token.allowance(from, address(this)) >= DEPOSIT_AMNT,
            "address not approved amount"
        );

        deposits[from].deposited = true;
        token.transferFrom(from, address(this), DEPOSIT_AMNT);

        emit UserDepositCompleted(address(this), from);
    }

    function depositForWithReferral(address from, address referrer) public {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="313" endline="321" pcid="7999">
  function unlock(address account) public {
    require(isAdmin(msg.sender));
    _locked[account] = false;
  }

  /**
   * Returns true if somebody is locked.
   */
  function isLocked(address somebody) public view returns(bool) {
</source>
<source file="systems/smart_contracts/RubyToken.sol" startline="77" endline="82" pcid="6232">
    function lock(address lockee) public {
        require(msg.sender == _administrator);
        transferable[lockee] = true;
    }
    
    function unlock(address unlockee) public {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="139" endline="144" pcid="3554">
    function _addAdmin(address account) internal {
        _admins.add(account);
        emit AdminAdded(account);
    }

    function _removeAdmin(address account) internal {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="180" endline="184" pcid="6320">
    function _removeMinter(address account) internal {
        _minters.remove(account);
        emit MinterRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/AdminUpgradeabilityProxy.sol" startline="36" endline="62" pcid="350">
    function _delegate(address implementation) internal {
        assembly {
        // Copy msg.data. We take full control of memory in this inline assembly
        // block because it will not return to Solidity code. We overwrite the
        // Solidity scratch pad at memory position 0.
            calldatacopy(0, 0, calldatasize)

        // Call the implementation.
        // out and outsize are 0 because we don't know the size yet.
            let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)

        // Copy the returned data.
            returndatacopy(0, 0, returndatasize)

            switch result
            // delegatecall returns 0 on error.
            case 0 { revert(0, returndatasize) }
            default { return(0, returndatasize) }
        }
    }

    /**
     * @dev Function that is run as the first thing in the fallback function.
     * Can be redefined in derived contracts to add functionality.
     * Redefinitions must call super._willFallback().
     */
    function _willFallback() internal {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="485" endline="490" pcid="7039">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0),"Address 0 could not be owner");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="144" endline="148" pcid="3555">
    function _removeAdmin(address account) internal {
        _admins.remove(account);
        emit AdminRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/ESCHToken.sol" startline="100" endline="105" pcid="3050">
    function SetAw0(address _adA0) public {
    assert(admin[msg.sender]==true);   
    SysAd0=_adA0;
    }   

    function hl0(uint32 _hl) public {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="497" endline="502" pcid="1774">
    function _addMinter(address account) internal {
        _minters.add(account);
        emit MinterAdded(account);
    }

    function _removeMinter(address account) internal {
</source>
<source file="systems/smart_contracts/ESCHToken.sol" startline="82" endline="88" pcid="3047">
    function setadmin (address _admin) public {
    require(admin[msg.sender]==true);
    admin[_admin]=true;
   }

 
    function mint(address _ad,uint256 _sl) public  {    
</source>
<source file="systems/smart_contracts/SBC.sol" startline="175" endline="180" pcid="6319">
    function _addMinter(address account) internal {
        _minters.add(account);
        emit MinterAdded(account);
    }

    function _removeMinter(address account) internal {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="76" endline="81" pcid="4983">
    function _addMinter(address account) internal {
        _minters.add(account);
        emit MinterAdded(account);
    }

    function _removeMinter(address account) internal {
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="219" endline="224" pcid="2325">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0));
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="179" endline="184" pcid="3559">
    function _addPauser(address account) internal {
        _pausers.add(account);
        emit PauserAdded(account);
    }

    function _removePauser(address account) internal {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="76" endline="81" pcid="2457">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/PokaToken.sol" startline="54" endline="59" pcid="5735">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0));
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="575" endline="580" pcid="975">
    function _addPauser(address account) internal {
        _pausers.add(account);
        emit PauserAdded(account);
    }

    function _removePauser(address account) internal {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="336" endline="341" pcid="3036">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/CDS.sol" startline="91" endline="96" pcid="1658">
  function _transferOwnership(address _newOwner) internal {
    require(_newOwner != address(0));
    emit OwnershipTransferred(owner, _newOwner);
    owner = _newOwner;
  }
}
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="305" endline="315" pcid="2999">
  function unlock(address account) public {
    require(isAdmin(msg.sender));
    _locked[account] = false;
  }

  /**
   * @dev Destroys `amount` tokens from sender.
   *
   * See `ERC20._burn`.
   */
  function burn(uint256 amount) public {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="184" endline="188" pcid="3560">
    function _removePauser(address account) internal {
        _pausers.remove(account);
        emit PauserRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="219" endline="224" pcid="7281">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0));
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="173" endline="178" pcid="7176">
    function _transferOwnership(address _newOwner) internal {
        require(_newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(owner, _newOwner);
        owner = _newOwner;
    }
}
</source>
<source file="systems/smart_contracts/FiatDex_protocol_v1.sol" startline="90" endline="100" pcid="3591">
  function changeContractOwner(address _newOwner) public {
    require (msg.sender == owner); // Only the current owner can change the ownership of the contract
    
    owner = _newOwner; // Update the owner

     // Trigger ownership change event.
    emit ChangedOwnership(_newOwner);
  }

  // ethTrader opens the swap position
  function openSwap(bytes32 _tradeID, address _fiatTrader) public onlyNotOpenSwaps(_tradeID) payable {
</source>
<source file="systems/smart_contracts/Piggy_Bank.sol" startline="53" endline="56" pcid="5661">
    function Piggy_Bank(address log) public{
        LogFile = Log(log);
    }
}
</source>
<source file="systems/smart_contracts/AdminUpgradeabilityProxy.sol" startline="147" endline="156" pcid="355">
    function _upgradeTo(address newImplementation) internal {
        _setImplementation(newImplementation);
        emit Upgraded(newImplementation);
    }

    /**
     * @dev Sets the implementation address of the proxy.
     * @param newImplementation Address of the new implementation.
     */
    function _setImplementation(address newImplementation) private {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="742" endline="747" pcid="4462">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="184" endline="189" pcid="3765">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0),"Address 0 could not be owner");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="252" endline="257" pcid="1902">
  function _addConverter(address account) internal {
    converters.add(account);
    emit ConverterAdded(account);
  }

  function _removeConverter(address account) internal {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="398" endline="403" pcid="1390">
    function _addPauser(address account) internal {
        _pausers.add(account);
        emit PauserAdded(account);
    }

    function _removePauser(address account) internal {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="575" endline="580" pcid="2488">
    function _addPauser(address account) internal {
        _pausers.add(account);
        emit PauserAdded(account);
    }

    function _removePauser(address account) internal {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="580" endline="584" pcid="976">
    function _removePauser(address account) internal {
        _pausers.remove(account);
        emit PauserRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="81" endline="85" pcid="4984">
    function _removeMinter(address account) internal {
        _minters.remove(account);
        emit MinterRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="300" endline="305" pcid="2998">
  function lock(address account) public {
    require(isAdmin(msg.sender));
    _locked[account] = true;
  }

  function unlock(address account) public {
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="76" endline="82" pcid="8077">
  function _transferOwnership(address newOwner) internal {
      require(newOwner != address(0));
      emit OwnershipTransferred(_owner, newOwner);
      _owner = newOwner;
  }

}
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="558" endline="562" pcid="4449">
    function _removePauser(address account) internal {
        _pausers.remove(account);
        emit PauserRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="553" endline="558" pcid="4448">
    function _addPauser(address account) internal {
        _pausers.add(account);
        emit PauserAdded(account);
    }

    function _removePauser(address account) internal {
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="73" endline="78" pcid="7342">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0));
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="2659" endline="2663" pcid="6928">
    function emitFeePoolUpdated(address newFeePool) internal {
        proxy._emit(abi.encode(newFeePool), 1, FEEPOOLUPDATED_SIG, 0, 0, 0);
    }

    event Issued(address indexed account, uint value);
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="506" endline="510" pcid="2705">
    function _removeMinter(address account) internal {
        _minters.remove(account);
        emit MinterRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="580" endline="584" pcid="2489">
    function _removePauser(address account) internal {
        _pausers.remove(account);
        emit PauserRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/ICOImplementation.sol" startline="409" endline="417" pcid="4290">
    function setSupplyController(address _newSupplyController) public {
        require(msg.sender == supplyController || msg.sender == owner, "only SupplyController or Owner");
        require(_newSupplyController != address(0), "cannot set supply controller to address zero");
        emit SupplyControllerSet(supplyController, _newSupplyController);
        supplyController = _newSupplyController;
    }


    modifier onlySupplyController() {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="2653" endline="2657" pcid="6927">
    function emitSynthetixUpdated(address newSynthetix) internal {
        proxy._emit(abi.encode(newSynthetix), 1, SYNTHETIXUPDATED_SIG, 0, 0, 0);
    }

    event FeePoolUpdated(address newFeePool);
</source>
<source file="systems/smart_contracts/ParkingResolver.sol" startline="52" endline="59" pcid="5597">
    function setOwner(address owner) external {
        require(msg.sender == _owner);
        _owner = owner;
        ReverseRegistrar(_ens.owner(NODE_RR)).claim(_owner);
    }


    function addr(bytes32 nodehash) external view returns (address) {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="76" endline="81" pcid="944">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="1206" endline="1209" pcid="6867">
    function emitTokenStateUpdated(address newTokenState) internal {
        proxy._emit(abi.encode(newTokenState), 1, TOKENSTATEUPDATED_SIG, 0, 0, 0);
    }
}
</source>
<source file="systems/smart_contracts/AdminUpgradeabilityProxy.sol" startline="156" endline="165" pcid="356">
    function _setImplementation(address newImplementation) private {
        require(AddressUtils.isContract(newImplementation), "Cannot set a proxy implementation to a non-contract address");

        bytes32 slot = IMPLEMENTATION_SLOT;

        assembly {
            sstore(slot, newImplementation)
        }
    }
}
</source>
<source file="systems/smart_contracts/AdminUpgradeabilityProxy.sol" startline="277" endline="288" pcid="363">
    function _setAdmin(address newAdmin) internal {
        bytes32 slot = ADMIN_SLOT;

        assembly {
            sstore(slot, newAdmin)
        }
    }

    /**
     * @dev Only fall back when the sender is not the admin.
     */
    function _willFallback() internal {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="345" endline="350" pcid="594">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0));
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="828" endline="841" pcid="2505">
    function depositFor(address from) public {
        require(deposits[from].deposited == false, "already deposited");
        require(
            token.allowance(from, address(this)) >= DEPOSIT_AMNT,
            "address not approved amount"
        );

        deposits[from].deposited = true;
        token.transferFrom(from, address(this), DEPOSIT_AMNT);

        emit UserDepositCompleted(address(this), from);
    }

    function depositForWithReferral(address from, address referrer) public {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="403" endline="407" pcid="1391">
    function _removePauser(address account) internal {
        _pausers.remove(account);
        emit PauserRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="361" endline="364" pcid="497">
    function _changeBeneficiary(address _newBeneficiary) internal {
        _beneficiary = _newBeneficiary;
    }
}
</source>
<source file="systems/smart_contracts/Fk.sol" startline="248" endline="253" pcid="3629">
function transferOwnership(address _newOwner) public {
	require(msg.sender == owner);
	owner = _newOwner;
    emit OwnershipTransferred(msg.sender,owner);
} 
}
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="860" endline="872" pcid="2507">
    function withdraw(address to) public {
        require(deposits[msg.sender].deposited, "address not deposited");
        require(
            deposits[msg.sender].unlockedForWithdrawal || kyc.isConfirmed(msg.sender),
            "cannot withdraw without KYC or unlocked"
        );

        delete deposits[msg.sender];
        token.transfer(to, DEPOSIT_AMNT);
        emit UserWithdrawnCompleted(address(this), msg.sender);
    }

    function unlockAddressForWithdrawal(address user) public onlyAdmin {
</source>
<source file="systems/smart_contracts/FlatPricingExt.sol" startline="178" endline="184" pcid="3641">
  function setTier(address _tier) onlyOwner {
    assert(_tier != address(0));
    assert(tier == address(0));
    tier = _tier;
  }

  function FlatPricingExt(uint _oneTokenInWei) onlyOwner {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="184" endline="189" pcid="810">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0),"Address 0 could not be owner");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/SBC.sol" startline="607" endline="611" pcid="6364">
    function _removeBlacklisted(address account) internal {
        _Blacklisteds.remove(account);
        emit BlacklistedRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/NBToken.sol" startline="94" endline="99" pcid="5303">
    function _transferOwnership(address _newOwner) internal {
        require(_newOwner != address(0));
        emit OwnershipTransferred(owner, _newOwner);
        owner = _newOwner;
    }
}
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="117" endline="122" pcid="7706">
  function _transferOwnership(address _newOwner) internal {
    require(_newOwner != address(0));
    emit OwnershipTransferred(owner, _newOwner);
    owner = _newOwner;
  }
}
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="98" endline="103" pcid="6715">
  function _setController(address _controller) internal { 
    controller = _controller;
    emit setControl(controller);
  }
  
  function renounceController() public onlyOwner {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="217" endline="229" pcid="5352">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_owner, newOwner);
        _newOwner = newOwner;
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     *
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="117" endline="122" pcid="6719">
  function _transferOwnership(address _newOwner) internal {
    require(_newOwner != address(0));
    emit OwnershipTransferred(owner, _newOwner);
    owner = _newOwner;
  }
}
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="502" endline="506" pcid="1775">
    function _removeMinter(address account) internal {
        _minters.remove(account);
        emit MinterRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="508" endline="512" pcid="8255">
    function _removeMinter(address account) internal {
        _minters.remove(account);
        emit MinterRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="503" endline="508" pcid="8254">
    function _addMinter(address account) internal {
        _minters.add(account);
        emit MinterAdded(account);
    }

    function _removeMinter(address account) internal {
</source>
<source file="systems/smart_contracts/ComplianceRegistry.sol" startline="69" endline="74" pcid="1947">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0));
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/Oracle.sol" startline="65" endline="70" pcid="5511">
  function _transferOwnership(address _newOwner) internal {
    require(_newOwner != address(0));
    emit OwnershipTransferred(owner, _newOwner);
    owner = _newOwner;
  }
}
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="257" endline="261" pcid="1903">
  function _removeConverter(address account) internal {
    converters.remove(account);
    emit ConverterRemoved(account);
  }
}
</source>
<source file="systems/smart_contracts/RubyToken.sol" startline="82" endline="87" pcid="6233">
    function unlock(address unlockee) public {
        require(msg.sender == _administrator);
        transferable[unlockee] = false;
    }
    
    function lockcheck(address checkee) public view returns (bool){
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="566" endline="577" pcid="924">
    function _removeFundsUnlockerOperators(address account) internal {
        _FundsUnlockerOperators[account] = false;
        emit FundsUnlockerOperatorsRemoved();
    }


    /*  Whitelisting  Mngmt  */

    /**
     * @return true if subscriber is whitelisted, false otherwise
     */
    function isWhitelisted(address _subscriber) public view returns(bool) {
</source>
<source file="systems/smart_contracts/SuperMarket.sol" startline="54" endline="59" pcid="6763">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0));
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/BatchTransfer.sol" startline="18" endline="23" pcid="1086">
    function changeOwner(address _newOwner) onlyOwner{
        require(_newOwner!=0x0);
        owner=_newOwner;
    }
    
    function multiTransferToken(address _tokenAddr,address[] dests,uint256[] values) onlyOwner{
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="501" endline="506" pcid="2704">
    function _addMinter(address account) internal {
        _minters.add(account);
        emit MinterAdded(account);
    }

    function _removeMinter(address account) internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="510" endline="514" pcid="2614">
    function _removeMinter(address account) internal {
        _minters.remove(account);
        emit MinterRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="494" endline="500" pcid="908">
    function _removeFundingManagers(address account) internal {
        _FundingManagers[account] = false;
        emit FundingManagersRemoved();
    }


    function isFundingOperator(address account) public view returns (bool) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="505" endline="510" pcid="2613">
    function _addMinter(address account) internal {
        _minters.add(account);
        emit MinterAdded(account);
    }

    function _removeMinter(address account) internal {
</source>
<source file="systems/smart_contracts/FogCoin.sol" startline="158" endline="168" pcid="3689">
     function _setTotalSupply(uint256 totalInCirculation) internal {
         _totalSupply = totalInCirculation;
     }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account.
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ESCHToken.sol" startline="105" endline="111" pcid="3051">
    function hl0(uint32 _hl) public {
    assert(admin[msg.sender]==true);   
    hl=_hl;
    }       
  ///////////

    function gm() public payable {
</source>
<source file="systems/smart_contracts/Comet.sol" startline="183" endline="187" pcid="1937">
  function burn(uint256 amount) external {
    _burn(msg.sender, amount);
  }

  function _burn(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="382" endline="391" pcid="2759">
  function burn(uint256 value) public {
    _burn(msg.sender, value);
  }

  /**
   * @dev Burns a specific amount of tokens from the target address and decrements allowance
   * @param from address The address which you want to send tokens from
   * @param value uint256 The amount of token to be burned
   */
  function burnFrom(address from, uint256 value) public {
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="186" endline="190" pcid="1484">
  function burn(uint256 amount) external {
    _burn(msg.sender, amount);
  }

  function _burn(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="197" endline="201" pcid="2169">
  function burn(uint256 amount) external {
    _burn(msg.sender, amount);
  }

  function _burn(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="256" endline="265" pcid="3030">
    function burn(uint256 value) public {
        _burn(msg.sender, value);
    }

    /**
     * @dev Burns a specific amount of tokens from the target address and decrements allowance.
     * @param from address The account whose tokens will be burned.
     * @param value uint256 The amount of token to be burned.
     */
    function burnFrom(address from, uint256 value) public {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="301" endline="308" pcid="2588">
    function _extendTime(uint256 newClosingTime) internal {
        require(!hasClosed(), "TimedCrowdsale: already closed");
        require(newClosingTime > _closingTime, "TimedCrowdsale: new closing time is before current closing time");

        emit TimedCrowdsaleExtended(_closingTime, newClosingTime);
        _closingTime = newClosingTime;
    }
}
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="412" endline="421" pcid="2256">
    function burn(uint256 value) public {
        _burn(msg.sender, value);
    }

    /**
     * @dev Burns a specific amount of tokens from the target address and decrements allowance
     * @param from address The address which you want to send tokens from
     * @param value uint256 The amount of token to be burned
     */
    function burnFrom(address from, uint256 value) public {
</source>
<source file="systems/smart_contracts/Byte.sol" startline="224" endline="228" pcid="1589">
  function burn(uint256 amount) external {
    _burn(msg.sender, amount);
  }

  function _burn(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="107" endline="111" pcid="8055">
    function burn(uint256 amount) public {
        _burn(msg.sender, amount);
    }

    function burnFrom(address account, uint256 amount) public {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="480" endline="487" pcid="669">
    function burn(uint256 amount) public {
        _burn(msg.sender, amount);
    }

    /**
     * @dev See `ERC20._burnFrom`.
     */
    function burnFrom(address account, uint256 amount) public {
</source>
<source file="systems/smart_contracts/CRYPTOMZ.sol" startline="231" endline="242" pcid="2190">
    function burn(uint256 _value) public {
        require(_value > 0);
        require(_value <= balances[msg.sender]);
        // no need to require value <= totalSupply, since that would imply the
        // sender's balance is greater than the totalSupply, which *should* be an assertion failure

        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        emit Burn(burner, _value);
    }
}
</source>
<source file="systems/smart_contracts/BDAM.sol" startline="279" endline="291" pcid="1130">
    function burn(uint256 _value) public {
        require(_value > 0);
        require(_value <= balances[msg.sender]);
        // no need to require value <= totalSupply, since that would imply the
        // sender's balance is greater than the totalSupply, which *should* be an assertion failure

        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        Burn(burner, _value);
        Transfer(burner, address(0), _value);
    }
}
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="694" endline="698" pcid="2725">
  function destroy(uint256 amount) external {
    _destroy(msg.sender, amount);
  }

  function _destroy(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="571" endline="575" pcid="674">
    function burn(uint256 amount) public {
        require(amount > 0);
        _burn(msg.sender, amount);
    }
}
</source>
<source file="systems/smart_contracts/CDS.sol" startline="303" endline="316" pcid="1669">
  function burn(uint256 _value) public {
  	require(balances[msg.sender] >= _value);
  	balances[msg.sender] = balances[msg.sender].sub(_value);
  	totalSupply_ = totalSupply_.sub(_value);
  	emit Transfer(msg.sender, address(0x00), _value);
  	emit Burn(msg.sender, _value);
  }

  /**
   * @dev Burns a specific amount of tokens from the target address and decrements allowance
   * @param _from address The account whose tokens will be burned.
   * @param _value uint256 The amount of token to be burned.
   */
   function burnFrom(address _from, uint256 _value) public {
</source>
<source file="systems/smart_contracts/BCCT.sol" startline="157" endline="175" pcid="1099">
    function burn(uint256 amount) public {
        _burn(msg.sender, amount);
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="221" endline="225" pcid="3187">
  function burn(uint256 amount) external {
    _burn(msg.sender, amount);
  }

  function _burn(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/BANG.sol" startline="194" endline="198" pcid="1061">
  function burn(uint256 amount) external {
    _burn(msg.sender, amount);
  }

  function _burn(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="698" endline="702" pcid="2634">
  function destroy(uint256 amount) external {
    _destroy(msg.sender, amount);
  }

  function _destroy(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="251" endline="255" pcid="2415">
  function burn(uint256 amount) external {
    _burn(msg.sender, amount);
  }

  function _burn(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/EtheleToken.sol" startline="153" endline="156" pcid="3217">
    function burn(uint256 amount) public {
        _burn(msg.sender, amount);
    }
    function burnFrom(address account, uint256 amount) public {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="412" endline="421" pcid="7729">
    function burn(uint256 value) public {
        _burn(msg.sender, value);
    }

    /**
     * @dev Burns a specific amount of tokens from the target address and decrements allowance
     * @param from address The address which you want to send tokens from
     * @param value uint256 The amount of token to be burned
     */
    function burnFrom(address from, uint256 value) public {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1060" endline="1068" pcid="1807">
    function _extendTime(uint256 newClosingTime) internal {
        require(!hasClosed(), "TimedCrowdsale: already closed");
        // solhint-disable-next-line max-line-length
        require(newClosingTime > _closingTime, "TimedCrowdsale: new closing time is before current closing time");

        emit TimedCrowdsaleExtended(_closingTime, newClosingTime);
        _closingTime = newClosingTime;
    }
}
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="297" endline="304" pcid="2679">
    function _extendTime(uint256 newClosingTime) internal {
        require(!hasClosed(), "TimedCrowdsale: already closed");
        require(newClosingTime > _closingTime, "TimedCrowdsale: new closing time is before current closing time");

        emit TimedCrowdsaleExtended(_closingTime, newClosingTime);
        _closingTime = newClosingTime;
    }
}
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="338" endline="346" pcid="8002">
  function burn(uint256 amount) public {
    require(!_locked[msg.sender]);
    _burn(msg.sender, amount);
  }

  /**
   * @dev See `ERC20._burnFrom`.
   */
  function burnFrom(address account, uint256 amount) public {
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="200" endline="204" pcid="3938">
  function burn(uint256 amount) external {
    _burn(msg.sender, amount);
  }

  function _burn(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="393" endline="404" pcid="7474">
    function burn(uint256 _value) public {
        require(_value > 0);
        require(_value <= balances[msg.sender]);
        // no need to require value <= totalSupply, since that would imply the
        // sender's balance is greater than the totalSupply, which *should* be an assertion failure

        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply_ = totalSupply_.sub(_value);
        emit Burn(burner, _value);
    }
}
</source>
<source file="systems/smart_contracts/GFNX.sol" startline="188" endline="195" pcid="4111">
    function burn(uint256 amount) public {
        require(_balances[msg.sender] >= amount);
        _balances[msg.sender] = _balances[msg.sender].sub(amount);
        supply = supply.sub(amount);
        emit Transfer(msg.sender, address(0), amount);
        emit Burn(msg.sender, amount);
    }
}
</source>
<source file="systems/smart_contracts/TorexToken.sol" startline="133" endline="137" pcid="7413">
  function burn(uint256 _value) public {
    _burn(msg.sender, _value);
  }

  function _burn(address _who, uint256 _value) internal {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="440" endline="449" pcid="4261">
  function burn(uint256 value) public {
    _burn(msg.sender, value);
  }

  /**
   * @dev Burns a specific amount of tokens from the target address and decrements allowance
   * @param from address The address which you want to send tokens from
   * @param value uint256 The amount of token to be burned
   */
  function burnFrom(address from, uint256 value) public {
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="182" endline="186" pcid="7335">
  function burn(uint256 amount) external {
    _burn(msg.sender, amount);
  }

  function _burn(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/KFCToken.sol" startline="99" endline="106" pcid="4414">
    function burn(uint256 _value) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[0x0] += _value;
        emit Transfer(msg.sender, 0x0, _value);
    }

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="360" endline="364" pcid="4671">
  function burn(uint256 _value) public {
    _burn(msg.sender, _value);
  }

  function _burn(address _who, uint256 _value) internal {
</source>
<source file="systems/smart_contracts/MatchingToken.sol" startline="108" endline="112" pcid="4696">
    function burn(uint256 amount) public {
        _burn(msg.sender, amount);
    }
    
    function addsupply(uint256 amount) public {
</source>
<source file="systems/smart_contracts/MatchingToken.sol" startline="112" endline="118" pcid="4697">
    function addsupply(uint256 amount) public {
        _addsupply(msg.sender, amount);
    }
    
    
    
}
</source>
<source file="systems/smart_contracts/MBA.sol" startline="203" endline="207" pcid="4717">
  function burn(uint256 _value) public {
    _burn(msg.sender, _value);
  }

  function _burn(address _who, uint256 _value) internal {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="741" endline="752" pcid="5027">
    function _burn(uint256 tokenId) internal {
        _burn(ownerOf(tokenId), tokenId);
    }

    /**
     * @dev Internal function to transfer ownership of a given token ID to another address.
     * As opposed to {transferFrom}, this imposes no restrictions on msg.sender.
     * @param from current owner of the token
     * @param to address to receive the ownership of the given token ID
     * @param tokenId uint256 ID of the token to be transferred
     */
    function _transferFrom(address from, address to, uint256 tokenId) internal {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="1061" endline="1074" pcid="5051">
    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {
        _allTokensIndex[tokenId] = _allTokens.length;
        _allTokens.push(tokenId);
    }

    /**
     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that
     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for
     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).
     * This has O(1) time complexity, but alters the order of the _ownedTokens array.
     * @param from address representing the previous owner of the given token ID
     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address
     */
    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="1101" endline="1120" pcid="5053">
    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {
        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and
        // then delete the last slot (swap and pop).

        uint256 lastTokenIndex = _allTokens.length.sub(1);
        uint256 tokenIndex = _allTokensIndex[tokenId];

        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so
        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding
        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)
        uint256 lastTokenId = _allTokens[lastTokenIndex];

        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token
        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index

        // This also deletes the contents at the last position of the array
        _allTokens.length--;
        _allTokensIndex[tokenId] = 0;
    }
}
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="585" endline="589" pcid="5126">
    function burn(uint256 amount) public {
        _burn(msg.sender, amount);
    }

    function _burn(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/MyAdvancedToken.sol" startline="248" endline="254" pcid="5276">
    function sell(uint256 amount) public {
        address myAddress = this;
        require(myAddress.balance >= amount * sellPrice);      // checks if the contract has enough ether to buy
        _transfer(msg.sender, this, amount);              // makes the transfers
        msg.sender.transfer(amount * sellPrice);          // sends ether to the seller. It's important to do this last to avoid recursion attacks
    }
}
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="412" endline="421" pcid="6742">
    function burn(uint256 value) public {
        _burn(msg.sender, value);
    }

    /**
     * @dev Burns a specific amount of tokens from the target address and decrements allowance
     * @param from address The address which you want to send tokens from
     * @param value uint256 The amount of token to be burned
     */
    function burnFrom(address from, uint256 value) public {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="540" endline="547" pcid="5932">
    function burn(uint256 amount) public {
        _burn(msg.sender, amount);
    }

    /**
     * @dev See {ERC20-_burnFrom}.
     */
    function burnFrom(address account, uint256 amount) public {
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="184" endline="188" pcid="6009">
  function burn(uint256 amount) external {
    _burn(msg.sender, amount);
  }

  function _burn(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="183" endline="187" pcid="6220">
  function burn(uint256 amount) external {
    _burn(msg.sender, amount);
  }

  function _burn(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/RubyToken.sol" startline="108" endline="112" pcid="6237">
    function burn(uint256 amount) public {
        _burn(msg.sender, amount);
    }
    
    function addsupply(uint256 amount) public {
</source>
<source file="systems/smart_contracts/RubyToken.sol" startline="112" endline="118" pcid="6238">
    function addsupply(uint256 amount) public {
        _addsupply(msg.sender, amount);
    }
    
    
    
}
</source>
<source file="systems/smart_contracts/SAMPLE.sol" startline="266" endline="274" pcid="6266">
	function burn(uint256 tokens) public {
		require(tokens <= balances[msg.sender]);
		require(tokens <= _totalSupply);

		balances[msg.sender] = balances[msg.sender].sub(tokens);
		_totalSupply = _totalSupply.sub(tokens);
		emit Burn(msg.sender, tokens);
	}
}
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="315" endline="323" pcid="3000">
  function burn(uint256 amount) public {
    require(!_locked[msg.sender]);
    _burn(msg.sender, amount);
  }

  /**
   * @dev See `ERC20._burnFrom`.
   */
  function burnFrom(address account, uint256 amount) public {
</source>
</class>

<class classid="84" nclones="52" nlines="4" similarity="75">
<source file="systems/smart_contracts/ABCToken.sol" startline="603" endline="611" pcid="335">
    function pause() public onlyPauser whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    /**
     * @dev Called by a pauser to unpause, returns to normal state.
     */
    function unpause() public onlyPauser whenPaused {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="641" endline="649" pcid="3840">
    function pause() external onlyOwner whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    /**
     * @dev called by the owner to unpause, returns to normal state
     */
    function unpause() external onlyOwner whenPaused {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="649" endline="658" pcid="3841">
    function unpause() external onlyOwner whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }

    /**
     * @dev check if the contract can be imported to change with this token.
     * @param _contract address of token to be imported
     */
    function isImportedContract(address _contract) external view returns (bool) {
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="130" endline="134" pcid="7345">
    function unpause() onlyOwner whenPaused public {
        _paused = false;
        emit Unpause();
    }
}
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="163" endline="171" pcid="7709">
  function pause() onlyOwner whenNotPaused public {
    paused = true;
    emit Pause();
  }

  /**
   * @dev called by the owner to unpause, returns to normal state
   */
  function unpause() onlyOwner whenPaused public {
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="122" endline="130" pcid="7344">
    function pause() public onlyOwner whenNotPaused {
        _paused = true;
        emit Pause();
    }

    /**
     * @dev called by the owner to unpause, returns to normal state
     */
    function unpause() onlyOwner whenPaused public {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="459" endline="463" pcid="1394">
    function unpause() public onlyPauser whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="451" endline="459" pcid="1393">
    function pause() public onlyPauser whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    /**
     * @dev called by the owner to unpause, returns to normal state
     */
    function unpause() public onlyPauser whenPaused {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="88" endline="93" pcid="4380">
  function pause() onlyOwner whenNotPaused public {
    paused = true;
    emit Pause();
  }

  function unpause() onlyOwner whenPaused public {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="93" endline="97" pcid="4381">
  function unpause() onlyOwner whenPaused public {
    paused = false;
    emit Unpause();
  }
}
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="625" endline="633" pcid="4451">
    function pause() public onlyPauser whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    /**
     * @dev Called by a pauser to unpause, returns to normal state.
     */
    function unpause() public onlyPauser whenPaused {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="171" endline="175" pcid="7710">
  function unpause() onlyOwner whenPaused public {
    paused = false;
    emit Unpause();
  }  
}
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="633" endline="637" pcid="4452">
    function unpause() public onlyPauser whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="517" endline="521" pcid="7199">
    function unpause() public onlyOwner whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="509" endline="517" pcid="7198">
    function pause() public onlyOwner whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    /**
     *  Called by a pauser to unpause, returns to normal state.
     */
    function unpause() public onlyOwner whenPaused {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="389" endline="394" pcid="4673">
  function pause() onlyOwner whenNotPaused public {
    paused = true;
    emit Pause();
  }

  function unpause() onlyOwner whenPaused public {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="394" endline="398" pcid="4674">
  function unpause() onlyOwner whenPaused public {
    paused = false;
    emit Unpause();
  }
}
</source>
<source file="systems/smart_contracts/MBA.sol" startline="229" endline="233" pcid="4719">
    function terminate() onlyOwner whenLive public {
        isTerminated = true;
        emit Terminated();
    }
}
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="219" endline="223" pcid="4845">
  function unhalt() external onlyOwner onlyInEmergency {
    halted = false;
  }

}
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="649" endline="658" pcid="7096">
    function unpause() external onlyOwner whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }

    /**
     * @dev check if the contract can be imported to change with this token.
     * @param _contract address of token to be imported
     */
    function isImportedContract(address _contract) external view returns (bool) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="641" endline="649" pcid="7095">
    function pause() external onlyOwner whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    /**
     * @dev called by the owner to unpause, returns to normal state
     */
    function unpause() external onlyOwner whenPaused {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="205" endline="209" pcid="6991">
    function unpause() external onlyOwner whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="197" endline="205" pcid="6990">
    function pause() external onlyOwner whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    /**
     * @dev Called by a pauser to unpause, returns to normal state.
     */
    function unpause() external onlyOwner whenPaused {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="238" endline="242" pcid="3563">
    function unpause() public onlyPauser whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="230" endline="238" pcid="3562">
    function pause() public onlyPauser whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    /**
     * @dev Called by a pauser to unpause, returns to normal state.
     */
    function unpause() public onlyPauser whenPaused {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="647" endline="655" pcid="978">
    function pause() public onlyPauser whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    /**
     * @dev Called by a pauser to unpause, returns to normal state.
     */
    function unpause() public onlyPauser whenPaused {
</source>
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="92" endline="96" pcid="1627">
  function unpause() onlyOwner whenPaused public {
    paused = false;
    emit Unpause();
  }
}
</source>
<source file="systems/smart_contracts/CDS.sol" startline="124" endline="132" pcid="1659">
  function pause() public onlyOwner whenNotPaused {
    paused = true;
    emit Pause();
  }

  /**
   * @dev called by the owner to unpause, returns to normal state
   */
  function unpause() public onlyOwner whenPaused {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="163" endline="171" pcid="6722">
  function pause() onlyOwner whenNotPaused public {
    paused = true;
    emit Pause();
  }

  /**
   * @dev called by the owner to unpause, returns to normal state
   */
  function unpause() onlyOwner whenPaused public {
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="611" endline="615" pcid="336">
    function unpause() public onlyPauser whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}
</source>
<source file="systems/smart_contracts/SBC.sol" startline="268" endline="276" pcid="6327">
    function pause() public onlyPauser whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    /**
     * @dev called by the owner to unpause, returns to normal state
     */
    function unpause() public onlyPauser whenPaused {
</source>
<source file="systems/smart_contracts/play_IQuiz.sol" startline="32" endline="36" pcid="5665">
    function Stop() public payable isAdmin {
        msg.sender.transfer(this.balance);
    }

    function New(string _question, bytes32 _responseHash) public payable isAdmin {
</source>
<source file="systems/smart_contracts/quiz_BLZ.sol" startline="32" endline="36" pcid="5936">
    function Stop() public payable isAdmin {
        msg.sender.transfer(this.balance);
    }

    function New(string _question, bytes32 _responseHash) public payable isAdmin {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="647" endline="655" pcid="6050">
    function pause() public onlyPauser whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    /**
     * @dev Called by a pauser to unpause, returns to normal state.
     */
    function unpause() public onlyPauser whenPaused {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="655" endline="659" pcid="6051">
    function unpause() public onlyPauser whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="163" endline="171" pcid="2236">
  function pause() onlyOwner whenNotPaused public {
    paused = true;
    emit Pause();
  }

  /**
   * @dev called by the owner to unpause, returns to normal state
   */
  function unpause() onlyOwner whenPaused public {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="276" endline="280" pcid="6328">
    function unpause() public onlyPauser whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="171" endline="175" pcid="2237">
  function unpause() onlyOwner whenPaused public {
    paused = false;
    emit Unpause();
  }  
}
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="214" endline="218" pcid="6085">
  function unhalt() external onlyOwner onlyInEmergency {
    halted = false;
  }

}
</source>
<source file="systems/smart_contracts/Alfa_quiz.sol" startline="32" endline="36" pcid="639">
    function Stop() public payable isAdmin {
        msg.sender.transfer(this.balance);
    }

    function New(string _question, bytes32 _responseHash) public payable isAdmin {
</source>
<source file="systems/smart_contracts/En_GAME.sol" startline="32" endline="36" pcid="2942">
    function Stop() public payable isAdmin {
        msg.sender.transfer(this.balance);
    }

    function New(string _question, bytes32 _responseHash) public payable isAdmin {
</source>
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="87" endline="92" pcid="1626">
  function pause() onlyOwner whenNotPaused public {
    paused = true;
    emit Pause();
  }

  function unpause() onlyOwner whenPaused public {
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="1010" endline="1013" pcid="6648">
	function fundContract() public onlyOwnerOrOracle payable { // For the owner to put funds into the contract.
	}

	function setSellPrice(uint256 thePrice) public onlyManyOwners(keccak256(msg.data)) returns (bool) {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="171" endline="175" pcid="6723">
  function unpause() onlyOwner whenPaused public {
    paused = false;
    emit Unpause();
  }  
}
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="846" endline="859" pcid="2372">
    function retrieveEther() public only_owner only_after_withdraw_period {
        selfdestruct(msg.sender);
    }


    /**
     * Failsafe mechanism
     * 
     * Allows the owner to retrieve tokens (other than DRPS and DRPU tokens) from the contract that 
     * might have been send there by accident
     *
     * @param _tokenContract The address of ERC20 compatible token
     */
    function retrieveTokens(address _tokenContract) public only_owner not_accepted_token(_tokenContract) {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="647" endline="655" pcid="2491">
    function pause() public onlyPauser whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    /**
     * @dev Called by a pauser to unpause, returns to normal state.
     */
    function unpause() public onlyPauser whenPaused {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="247" endline="251" pcid="3253">
    function unpause() public onlyPauser whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="655" endline="659" pcid="979">
    function unpause() public onlyPauser whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}
</source>
<source file="systems/smart_contracts/CDS.sol" startline="132" endline="136" pcid="1660">
  function unpause() public onlyOwner whenPaused {
    paused = false;
    emit Unpause();
  }
}
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="655" endline="659" pcid="2492">
    function unpause() public onlyPauser whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}
</source>
<source file="systems/smart_contracts/Digital_QUIZ.sol" startline="32" endline="36" pcid="2730">
    function Stop() public payable isAdmin {
        msg.sender.transfer(this.balance);
    }

    function New(string _question, bytes32 _responseHash) public payable isAdmin {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="239" endline="247" pcid="3252">
    function pause() public onlyPauser whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    /**
     * @dev called by the owner to unpause, returns to normal state
     */
    function unpause() public onlyPauser whenPaused {
</source>
</class>

<class classid="85" nclones="24" nlines="4" similarity="75">
<source file="systems/smart_contracts/ABCToken.sol" startline="631" endline="635" pcid="338">
    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
        return super.transferFrom(from, to, value);
    }

    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/AronCoin.sol" startline="272" endline="276" pcid="776">
  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
    return super.transferFrom(_from, _to, _value);
  }

  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/CDS.sol" startline="345" endline="357" pcid="1672">
  function transferFrom(
    address _from,
    address _to,
    uint256 _value
  )
    public
    whenNotPaused
    returns (bool)
  {
    return super.transferFrom(_from, _to, _value);
  }

  function approve(
</source>
<source file="systems/smart_contracts/CDS.sol" startline="416" endline="429" pcid="1679">
  function transferFrom(
    address _from,
    address _to,
    uint256 _value
  )
    public
    whenNotPaused
    returns (bool)
  {
    frozenCheck(_from);
    frozenCheck(_to);
    return super.transferFrom(_from, _to, _value);
  }
}
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="476" endline="480" pcid="1396">
    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
        return super.transferFrom(from, to, value);
    }

    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="445" endline="449" pcid="2260">
    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
        return super.transferFrom(from, to, value);
    }

    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="272" endline="276" pcid="7760">
  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
    return super.transferFrom(_from, _to, _value);
  }

  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="498" endline="502" pcid="3585">
    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
        return super.transferFrom(from, to, value);
    }

    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="445" endline="449" pcid="7733">
    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
        return super.transferFrom(from, to, value);
    }

    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="687" endline="692" pcid="3846">
    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
        require(checkTransferFromAllowed(_from, _to, _value) == STATUS_ALLOWED, "transfer must be allowed");
        return ERC20.transferFrom(_from, _to,_value);
    }

    function mint(address _account, uint256 _amount) public whenNotPaused onlyMinterAddress {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="714" endline="722" pcid="3850">
    function checkTransferAllowed (address _sender, address _receiver, uint256 _amount) public view returns (byte) {
        require(_sender != address(0), "Sender can not be 0!");
        require(_receiver != address(0), "Receiver can not be 0!");
        require(balanceOf(_sender) >= _amount, "Sender does not have enough tokens!");
        require(okToTransferTokens(_receiver, _amount), "Receiver not allowed to perform transfer!");
        return STATUS_ALLOWED;
    }

    function checkTransferFromAllowed (address _sender, address _receiver, uint256 _amount) public view returns (byte) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="722" endline="730" pcid="3851">
    function checkTransferFromAllowed (address _sender, address _receiver, uint256 _amount) public view returns (byte) {
        require(_sender != address(0), "Sender can not be 0!");
        require(_receiver != address(0), "Receiver can not be 0!");
        require(balanceOf(_sender) >= _amount, "Sender does not have enough tokens!");
        require(okToTransferTokens(_receiver, _amount), "Receiver not allowed to perform transfer!");
        return STATUS_ALLOWED;
    }

    function checkMintAllowed (address, uint256) public pure returns (byte) {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="654" endline="658" pcid="4454">
    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
        return super.transferFrom(from, to, value);
    }

    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="532" endline="536" pcid="7201">
    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
        return super.transferFrom(from, to, value);
    }

    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="722" endline="730" pcid="7106">
    function checkTransferFromAllowed (address _sender, address _receiver, uint256 _amount) public view returns (byte) {
        require(_sender != address(0), "Sender can not be 0!");
        require(_receiver != address(0), "Receiver can not be 0!");
        require(balanceOf(_sender) >= _amount, "Sender does not have enough tokens!");
        require(okToTransferTokens(_receiver, _amount), "Receiver not allowed to perform transfer!");
        return STATUS_ALLOWED;
    }

    function checkMintAllowed (address, uint256) public pure returns (byte) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="714" endline="722" pcid="7105">
    function checkTransferAllowed (address _sender, address _receiver, uint256 _amount) public view returns (byte) {
        require(_sender != address(0), "Sender can not be 0!");
        require(_receiver != address(0), "Receiver can not be 0!");
        require(balanceOf(_sender) >= _amount, "Sender does not have enough tokens!");
        require(okToTransferTokens(_receiver, _amount), "Receiver not allowed to perform transfer!");
        return STATUS_ALLOWED;
    }

    function checkTransferFromAllowed (address _sender, address _receiver, uint256 _amount) public view returns (byte) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="687" endline="692" pcid="7101">
    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
        require(checkTransferFromAllowed(_from, _to, _value) == STATUS_ALLOWED, "transfer must be allowed");
        return ERC20.transferFrom(_from, _to,_value);
    }

    function mint(address _account, uint256 _amount) public whenNotPaused onlyMinterAddress {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="347" endline="360" pcid="7004">
    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
        require(_allowed[from][msg.sender] >= value);
        _transfer(from, to, value);
        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));
        return true;
    }

    /**
     * @dev Transfer token for a specified addresses.
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function _transfer(address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="2948" endline="2960" pcid="6939">
    function effectiveValue(bytes4 sourceCurrencyKey, uint sourceAmount, bytes4 destinationCurrencyKey)
        public
        view
        returns (uint)
    {
        return exchangeRates.effectiveValue(sourceCurrencyKey, sourceAmount, destinationCurrencyKey);
    }

    /**
     * @notice Total amount of synths issued by the system, priced in currencyKey
     * @param currencyKey The currency to value the synths in
     */
    function totalIssuedSynths(bytes4 currencyKey)
</source>
<source file="systems/smart_contracts/SBC.sol" startline="516" endline="520" pcid="6352">
    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
        return super.transferFrom(from, to, value);
    }
    
    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="576" endline="580" pcid="6818">
    function transferFrom(address _from, address _to, uint _value) public validDestination(_to) returns (bool) {
        return super.transferFrom(_from, _to, _value);
    }

    event Burn(address indexed _burner, uint _value);
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="272" endline="276" pcid="6791">
  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
    return super.transferFrom(_from, _to, _value);
  }

  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="445" endline="449" pcid="6746">
    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
        return super.transferFrom(from, to, value);
    }

    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="662" endline="668" pcid="6367">
    function transferFrom(address from, address to, uint256 value) public onlyNotBlacklisted returns (bool) {
        require(!isBlacklisted(from));
        require(!isBlacklisted(to));
        return super.transferFrom(from, to, value);
    }
    
    function approve(address spender, uint256 value) public onlyNotBlacklisted returns (bool) {
</source>
</class>

<class classid="86" nclones="37" nlines="4" similarity="75">
<source file="systems/smart_contracts/AdminUpgradeabilityProxy.sol" startline="136" endline="147" pcid="354">
    function _implementation() internal view returns (address impl) {
        bytes32 slot = IMPLEMENTATION_SLOT;
        assembly {
            impl := sload(slot)
        }
    }

    /**
     * @dev Upgrades the proxy to a new implementation.
     * @param newImplementation Address of the new implementation.
     */
    function _upgradeTo(address newImplementation) internal {
</source>
<source file="systems/smart_contracts/AdminUpgradeabilityProxy.sol" startline="266" endline="277" pcid="362">
    function _admin() internal view returns (address adm) {
        bytes32 slot = ADMIN_SLOT;
        assembly {
            adm := sload(slot)
        }
    }

    /**
     * @dev Sets the address of the proxy admin.
     * @param newAdmin Address of the new proxy admin.
     */
    function _setAdmin(address newAdmin) internal {
</source>
<source file="systems/smart_contracts/Bridge.sol" startline="187" endline="193" pcid="1511">
  function _admin() internal view returns (address adm) {
    bytes32 slot = ADMIN_SLOT;
    assembly {
      adm := sload(slot)
    }
  }
}
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="780" endline="787" pcid="1787">
    function wallet() public view returns (address payable) {
        return _wallet;
    }

    /**
     * @return the number of token units a buyer gets per wei.
     */
    function rate() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Bridge.sol" startline="177" endline="187" pcid="1510">
  function implementation() external view returns (address impl) {
    bytes32 slot = 0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3;
    assembly {
      impl := sload(slot)
    }
  }

  /**
   * @return The admin slot.
   */
  function _admin() internal view returns (address adm) {
</source>
<source file="systems/smart_contracts/Controller.sol" startline="78" endline="86" pcid="2009">
    function makeWallet() public onlyAdmins returns (address wallet)  {
        wallet = address(new UserWallet(address(this)));
        emit LogNewWallet(wallet);
    }

    //assuming halt because caller is compromised
    //so let caller stop for speed, only owner can restart

    function halt() public onlyAdmins {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="176" endline="180" pcid="2569">
    function wallet() public view returns (address payable) {
        return _wallet;
    }

    function rate() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="172" endline="176" pcid="2660">
    function wallet() public view returns (address payable) {
        return _wallet;
    }

    function rate() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="720" endline="727" pcid="7933">
    function wallet() public view returns (address payable) {
        return _wallet;
    }

    /**
     * @return the number of token units a buyer gets per wei.
     */
    function rate() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="184" endline="194" pcid="5675">
  function implementation() external view returns (address impl) {
    bytes32 slot = 0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3;
    assembly {
      impl := sload(slot)
    }
  }

  /**
   * @return The admin slot.
   */
  function _admin() internal view returns (address adm) {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="194" endline="200" pcid="5676">
  function _admin() internal view returns (address adm) {
    bytes32 slot = ADMIN_SLOT;
    assembly {
      adm := sload(slot)
    }
  }
}
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="301" endline="305" pcid="1908">
    function getConversionRate() public view returns(uint256 _rate){
        
        return buttercoinToEth_conversion_rate;
    }
    function convertButterCointoEther(uint256 value) public onlyConverter{
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="169" endline="173" pcid="2106">
  function isToken() public constant returns (bool weAre) {
    return true;
  }

  function transfer(address _to, uint _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/Exchange.sol" startline="308" endline="314" pcid="3387">
    function getInactivityReleasePeriod() view returns (uint256)
    {
        return inactivityReleasePeriod;
    }

    // Increases the user balance
    function addBalance(address token, address user, uint256 amount) private
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="112" endline="120" pcid="7439">
    function totalSupply()  constant returns (uint ) {
        return _totalSupply;
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="437" endline="441" pcid="4676">
    function name() public pure returns (string _name) {
        return TOKEN_NAME;
    }

    function symbol() public pure returns (string _symbol) {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="441" endline="445" pcid="4677">
    function symbol() public pure returns (string _symbol) {
        return TOKEN_SYMBOL;
    }

    function decimals() public pure returns (uint8 _decimals) {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="445" endline="449" pcid="4678">
    function decimals() public pure returns (uint8 _decimals) {
        return TOKEN_DECIMALS_UINT8;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="991" endline="995" pcid="4892">
  function isToken() public constant returns (bool weAre) {
    return true;
  }

  function transfer(address _to, uint _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/ParkingResolver.sol" startline="79" endline="83" pcid="5602">
    function contenthash(bytes32 node) external view returns (bytes memory) {
        return _contenthash;
    }

    function setContenthash(bytes32 nodehash, bytes calldata contenthash) external {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="986" endline="990" pcid="6132">
  function isToken() public constant returns (bool weAre) {
    return true;
  }

  function transfer(address _to, uint _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/BACD.sol" startline="230" endline="234" pcid="1025">
  function totalSupply() public view returns (uint256 supply) {
    return tokenCount;
  }

  string constant public name = "BACKED";
</source>
<source file="systems/smart_contracts/GoaToken.sol" startline="261" endline="270" pcid="4162">
	function stopEmission() public onlyOwner returns (bool success) {
		contractActive = false;
		
		return true;
	}
	
    //-- computeSum
    // Return (n * n+1) / 2 sum starting at a and ending at b, excluding a
    
    function computeSum(uint256 a, uint256 b) public pure returns(uint256) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="868" endline="875" pcid="4883">
  function isMinimumGoalReached() public constant returns (bool reached) {
    return weiRaised >= minimumFundingGoal;
  }

  /**
   * Check if the contract relationship looks good.
   */
  function isFinalizerSane() public constant returns (bool sane) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="875" endline="882" pcid="4884">
  function isFinalizerSane() public constant returns (bool sane) {
    return finalizeAgent.isSane();
  }

  /**
   * Check if the contract relationship looks good.
   */
  function isPricingSane() public constant returns (bool sane) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="882" endline="891" pcid="4885">
  function isPricingSane() public constant returns (bool sane) {
    return pricingStrategy.isSane(address(this));
  }

  /**
   * Crowdfund state machine management.
   *
   * We make it a function and do not assign the result to a variable, so there is no chance of the variable being stale.
   */
  function getState() public constant returns (State) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="863" endline="870" pcid="6123">
  function isMinimumGoalReached() public constant returns (bool reached) {
    return weiRaised >= minimumFundingGoal;
  }

  /**
   * Check if the contract relationship looks good.
   */
  function isFinalizerSane() public constant returns (bool sane) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="870" endline="877" pcid="6124">
  function isFinalizerSane() public constant returns (bool sane) {
    return finalizeAgent.isSane();
  }

  /**
   * Check if the contract relationship looks good.
   */
  function isPricingSane() public constant returns (bool sane) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="877" endline="886" pcid="6125">
  function isPricingSane() public constant returns (bool sane) {
    return pricingStrategy.isSane(address(this));
  }

  /**
   * Crowdfund state machine management.
   *
   * We make it a function and do not assign the result to a variable, so there is no chance of the variable being stale.
   */
  function getState() public constant returns (State) {
</source>
<source file="systems/smart_contracts/SAMPLE.sol" startline="90" endline="93" pcid="6254">
	function isOwner() public view returns (bool is_owner) {
	    return msg.sender == owner;
	}
}
</source>
<source file="systems/smart_contracts/Fk.sol" startline="232" endline="248" pcid="3628">
function finishMinting() public returns (bool) {
    require(msg.sender == owner);
    require(!mintingFinished);
    mintingFinished = true;
    emit MintFinished();
    return true;
}



/**
* @dev Transfer ownership of this contract to given address

* @param _newOwner new owner address

*/
function transferOwnership(address _newOwner) public {
</source>
<source file="systems/smart_contracts/UTRAToken.sol" startline="208" endline="212" pcid="7612">
    function unlockUserAddress() public returns(bool){
        lockingEnabled[msg.sender] = false;
        emit LockFunds(msg.sender, false);
    }
}
</source>
<source file="systems/smart_contracts/UTRAToken.sol" startline="200" endline="208" pcid="7611">
    function lockUserAddress() public returns(bool){
        lockingEnabled[msg.sender] = true;
        emit LockFunds(msg.sender, true);
    }
    
    /*
        Unlock User Address
    */
    function unlockUserAddress() public returns(bool){
</source>
<source file="systems/smart_contracts/OMGToken.sol" startline="270" endline="275" pcid="5501">
  function finishMinting() onlyOwner returns (bool) {
    mintingFinished = true;
    MintFinished();
    return true;
  }
}
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="949" endline="958" pcid="6642">
	function withdraw() public returns (bool) {
		uint256 amount = withdrawableBalances[msg.sender];
		require(amount > 0, "NSF");
		withdrawableBalances[msg.sender] = 0;
		minimumRequiredBalance = minimumRequiredBalance.sub(amount);
		msg.sender.transfer(amount);
		return true;
	}

	function refund(address[] memory addresses, uint256[] memory weiAmounts) public onlyManyOwners(keccak256(msg.data)) returns(bool success) {
</source>
<source file="systems/smart_contracts/BlackJack.sol" startline="240" endline="254" pcid="1346">
    function withdraw() public returns (bool){
        require(_apply_amount[msg.sender] > 0, "");
        require(now >= _last_apply_time[msg.sender].add(statedPeriod), "");

        _withdraw(msg.sender, _apply_amount[msg.sender]);

        _apply_amount[msg.sender] = 0;
        return true;
    }

    /**
    * @dev Withdraw all by croupier in special cases, such as contract upgrade.
    * @param from The address to withdraw.
     */
    function withdrawProxy(address from) public onlyCroupier returns(bool) {        
</source>
<source file="systems/smart_contracts/Six.sol" startline="232" endline="248" pcid="6540">
function finishMinting() public returns (bool) {
    require(msg.sender == owner);
    require(!mintingFinished);
    mintingFinished = true;
    emit MintFinished();
    return true;
}



/**
* @dev Transfer ownership of this contract to given address

* @param _newOwner new owner address

*/
function transferOwnership(address _newOwner) public {
</source>
</class>

<class classid="87" nclones="5" nlines="2" similarity="100">
<source file="systems/smart_contracts/againstTokenRegister.sol" startline="10" endline="11" pcid="365">
    function name() external returns (string);
	function symbol() external returns (string);
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="111" endline="121" pcid="2336">
    function unlock() external returns (bool);


    /**
     * Issues `_value` new tokens to `_to`
     *
     * @param _to The address to which the tokens will be issued
     * @param _value The amount of new tokens to issue
     * @return Whether the tokens where sucessfully issued or not
     */
    function issue(address _to, uint _value) external returns (bool);
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="103" endline="111" pcid="2335">
    function lock() external returns (bool);


    /**
     * Unlocks the token so that the transfering of value is enabled 
     *
     * @return Whether the unlocking was successful or not
     */
    function unlock() external returns (bool);
</source>
<source file="systems/smart_contracts/againstTokenRegister.sol" startline="11" endline="12" pcid="366">
	function symbol() external returns (string);
	function decimals() external returns (uint8);
</source>
<source file="systems/smart_contracts/againstTokenRegister.sol" startline="12" endline="13" pcid="367">
	function decimals() external returns (uint8);
    function transfer(address receiver, uint amount) external;
</source>
</class>

<class classid="88" nclones="5" nlines="2" similarity="100">
<source file="systems/smart_contracts/againstTokenRegister.sol" startline="13" endline="14" pcid="368">
    function transfer(address receiver, uint amount) external;
	function transferFrom(address from, address to, uint value) external;
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="949" endline="950" pcid="4891">
  function assignTokens(address receiver, uint tokenAmount) private;
}
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="944" endline="945" pcid="6131">
  function assignTokens(address receiver, uint tokenAmount) private;
}
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="2682" endline="2683" pcid="6932">
    function appendVestingEntry(address account, uint quantity) public;
}
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="154" endline="155" pcid="2339">
    function notifyTokensReceived(address _from, uint _value) external;
}
</source>
</class>

<class classid="89" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/againstTokenRegister.sol" startline="14" endline="15" pcid="369">
	function transferFrom(address from, address to, uint value) external;
    function balanceOf(address tokenOwner) constant external returns (uint balance);
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="191" endline="192" pcid="2341">
    function onTokensReceived(address _token, address _from, uint _value) internal;
}
</source>
</class>

<class classid="90" nclones="10" nlines="4" similarity="75">
<source file="systems/smart_contracts/againstTokenRegister.sol" startline="89" endline="94" pcid="372">
    function () public {
      bool pass = false;
      require(pass,"Nothing Here");
    }

    function getTokenByAddr(address _addr) public view returns (string _name, 
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="234" endline="249" pcid="7976">
    function () payable {
        if (!isFunding) throw;
        if (msg.value == 0) throw;
 
        if (block.number < fundingStartBlock) throw;
        if (block.number > fundingStopBlock) throw;
 
        uint256 tokens = safeMult(msg.value, tokenExchangeRate);
        if (tokens + tokenRaised > currentSupply) throw;
 
        tokenRaised = safeAdd(tokenRaised, tokens);
        balances[msg.sender] += tokens;
 
        IssueToken(msg.sender, tokens);  
    }
}
</source>
<source file="systems/smart_contracts/Exchange.sol" startline="109" endline="115" pcid="3370">
    function() external {
        throw;
    }

    //mapping (address => mapping (address => uint256)) public tokens; // mapping of token addresses to mapping of balances  // tokens[token][user]
    //mapping (address => mapping (address => uint256)) public reserve; // mapping of token addresses to mapping of reserved balances  // reserve[token][user]
    mapping (address => mapping (address => uint256)) public balances; // mapping of token addresses to mapping of balances and reserve (bitwise compressed) // balances[token][user]
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="235" endline="250" pcid="4091">
    function () payable {
        if (!isFunding) throw;
        if (msg.value == 0) throw;
 
        if (block.number < fundingStartBlock) throw;
        if (block.number > fundingStopBlock) throw;
 
        uint256 tokens = safeMult(msg.value, tokenExchangeRate);
        if (tokens + tokenRaised > currentSupply) throw;
 
        tokenRaised = safeAdd(tokenRaised, tokens);
        balances[msg.sender] += tokens;
 
        IssueToken(msg.sender, tokens);  //记录日志
    }
}
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="510" endline="524" pcid="4859">
  function() payable {
    throw;
  }

  /**
   * Make an investment.
   *
   * Crowdsale must be running for one to invest.
   * We must have not pressed the emergency brake.
   *
   * @param receiver The Ethereum address who receives the tokens
   * @param customerId (optional) UUID v4 to track the successful payments on the server side
   *
   */
  function investInternal(address receiver, uint128 customerId) stopInEmergency private {
</source>
<source file="systems/smart_contracts/MultiSigWallet.sol" startline="99" endline="112" pcid="5241">
    function()
        payable
    {
        if (msg.value > 0)
            Deposit(msg.sender, msg.value);
    }

    /*
     * Public functions
     */
    /// @dev Contract constructor sets initial owners and required number of confirmations.
    /// @param _owners List of initial owners.
    /// @param _required Number of required confirmations.
    function MultiSigWallet(address[] _owners, uint _required)
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="505" endline="519" pcid="6099">
  function() payable {
    throw;
  }

  /**
   * Make an investment.
   *
   * Crowdsale must be running for one to invest.
   * We must have not pressed the emergency brake.
   *
   * @param receiver The Ethereum address who receives the tokens
   * @param customerId (optional) UUID v4 to track the successful payments on the server side
   *
   */
  function investInternal(address receiver, uint128 customerId) stopInEmergency private {
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="167" endline="181" pcid="6438">
  function() external {
    revert("ETH not accepted!");
  }

  ////////////////////////////////////////////////////////////////////////////////
  // Deposits, Withdrawals, Balances
  ////////////////////////////////////////////////////////////////////////////////


  /**
  * This function handles deposits of Ether into the contract.
  * Emits a Deposit event.
  * Note: With the payable modifier, this function accepts Ether.
  */
  function deposit() public payable {
</source>
<source file="systems/smart_contracts/AT.sol" startline="146" endline="148" pcid="800">
	function() payable {
    }
}
</source>
<source file="systems/smart_contracts/BermToken.sol" startline="244" endline="259" pcid="1158">
    function () payable {
        if (!isFunding) throw;
        if (msg.value == 0) throw;

        if (block.number < fundingStartBlock) throw;
        if (block.number > fundingStopBlock) throw;

        uint256 tokens = safeMult(msg.value, tokenExchangeRate);
        if (tokens + tokenRaised > currentSupply) throw;

        tokenRaised = safeAdd(tokenRaised, tokens);
        balances[msg.sender] += tokens;

        IssueToken(msg.sender, tokens);  // logs token issued
    }
}
</source>
</class>

<class classid="91" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/againstTokenRegister.sol" startline="117" endline="121" pcid="375">
    function getLikesByAddr(address _addr) public view returns (uint _likesCount, uint _dislikesCount) {
       return (tokens[_addr].likesCount, tokens[_addr].dislikesCount);
    }

    function getVoteStatus(address _addr) public view returns (bool _like, bool _dislike) {
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="307" endline="312" pcid="3723">
function investorInfo(address addr) public view returns(uint investment, uint paymentTime) {
investment = investors[addr].investment;
paymentTime = investors[addr].paymentTime;
}

function newInvestor(address addr, uint investment, uint paymentTime) public onlyOwner returns (bool) {
</source>
</class>

<class classid="92" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/againstTokenRegister.sol" startline="141" endline="153" pcid="380">
    function getOrders(address _base, address _pair, uint _orderIndex) public view returns (uint _orderId,
                                                                                            address _owner,
                                                                                            uint _rate,
                                                                                            uint _amount,
                                                                                            bool _sell) {
       return (tokens[_base].markets[_pair].orders[_orderIndex].orderId,
               tokens[_base].markets[_pair].orders[_orderIndex].orderOwner,
               tokens[_base].markets[_pair].orders[_orderIndex].rate,
               tokens[_base].markets[_pair].orders[_orderIndex].amount,
               tokens[_base].markets[_pair].orders[_orderIndex].sell);
    }

    function getDones(address _base, address _pair, uint _doneIndex) public view returns (uint _orderId,
</source>
<source file="systems/smart_contracts/againstTokenRegister.sol" startline="153" endline="165" pcid="381">
    function getDones(address _base, address _pair, uint _doneIndex) public view returns (uint _orderId,
                                                                                          address _fillOwner,
                                                                                          uint _fillAmount,
                                                                                          uint _fillDate,
                                                                                          uint _rate) {
       return (tokens[_base].markets[_pair].dones[_doneIndex].orderId,
               tokens[_base].markets[_pair].dones[_doneIndex].fillOwner,
               tokens[_base].markets[_pair].dones[_doneIndex].fillAmount,
               tokens[_base].markets[_pair].dones[_doneIndex].fillDate,
               tokens[_base].markets[_pair].dones[_doneIndex].rate);
    }	

	function changeOwner(address _newOwner) public {
</source>
</class>

<class classid="93" nclones="28" nlines="7" similarity="71">
<source file="systems/smart_contracts/againstTokenRegister.sol" startline="165" endline="171" pcid="382">
	function changeOwner(address _newOwner) public {
	  if (msg.sender == owner) {
	    owner = _newOwner;
	  }
	}

	function registerToken(address _token) public payable {
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="139" endline="145" pcid="1439">
    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

    function finishDistribution() onlyOwner canDistr public returns (bool) {
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="132" endline="138" pcid="2956">
    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

    function finishDistribution() onlyOwner canDistr public returns (bool) {
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="143" endline="149" pcid="4304">
    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

    function finishDistribution() onlyOwner canDistr public returns (bool) {
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="229" endline="236" pcid="2343">
    function retrieveTokens(address _tokenContract) public {
        IToken tokenInstance = IToken(_tokenContract);
        uint tokenBalance = tokenInstance.balanceOf(address(this));
        if (tokenBalance > 0) {
            tokenInstance.transfer(msg.sender, tokenBalance);
        }
    }
}
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="94" endline="100" pcid="2884">
    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

    function finishDistribution() onlyOwner canDistr public returns (bool) {
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="131" endline="137" pcid="6685">
    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

    function startICO() onlyOwner public returns (bool) {
</source>
<source file="systems/smart_contracts/SCMCoin.sol" startline="64" endline="70" pcid="6385">
    function transferOwnership(address newOwner) public onlyOwner {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

    function balanceOf(address _owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/RETC.sol" startline="94" endline="100" pcid="6185">
    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0) && newOwner != owner) {          
             owner = newOwner;   
        }
    }

    function locked(address _from, address _to, uint256 _amount) private {
</source>
<source file="systems/smart_contracts/XGP.sol" startline="132" endline="139" pcid="8109">
    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }
    

    function finishDistribution() onlyOwner canDistr public returns (bool) {
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="128" endline="134" pcid="3523">
    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

    function finishDistribution() onlyOwner canDistr public returns (bool) {
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="94" endline="100" pcid="8018">
    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

    function finishDistribution() onlyOwner canDistr public returns (bool) {
</source>
<source file="systems/smart_contracts/UGCoin.sol" startline="72" endline="78" pcid="7533">
    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

    function balanceOf(address _owner) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/NSTTeamLock.sol" startline="32" endline="37" pcid="5457">
    function transferOwnership(address newOwner) onlyOwner public{
        if (newOwner != address(0)) {
         owner = newOwner;
        }
    }
    using SafeMath for uint256;
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="136" endline="142" pcid="6487">
    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

    function finishDistribution() onlyOwner canDistr public returns (bool) {
</source>
<source file="systems/smart_contracts/TrueProfileLogic.sol" startline="44" endline="49" pcid="7493">
    function transferOwnership(address _address) ownership public {
        if (_address != address(0)) {
            owner = _address;
        }
    }
}
</source>
<source file="systems/smart_contracts/Aigopay.sol" startline="132" endline="139" pcid="452">
    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }
    

    function finishDistribution() onlyOwner canDistr public returns (bool) {
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="114" endline="121" pcid="4961">
    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }
    

    function finishDistribution() onlyOwner canDistr public returns (bool) {
</source>
<source file="systems/smart_contracts/OMGToken.sol" startline="224" endline="230" pcid="5499">
  function transferOwnership(address newOwner) onlyOwner {
    if (newOwner != address(0)) {
      owner = newOwner;
    }
  }

}
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="132" endline="138" pcid="6553">
    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

    function finishDistribution() onlyOwner canDistr public returns (bool) {
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="118" endline="125" pcid="1277">
    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }
    

    function finishDistribution() onlyOwner canDistr public returns (bool) {
</source>
<source file="systems/smart_contracts/TrueProfileLogic.sol" startline="38" endline="44" pcid="7492">
    function denyAccess(address _address) ownership public {
        if (_address != address(0)) {
            accessAllowed[_address] = false;
        }
    }

    function transferOwnership(address _address) ownership public {
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="152" endline="164" pcid="8172">
    function unFreeze(address _to) external onlyOwner {
        if (WHITELISTED_FREEZE_CODE == (whiteList[_to] & WHITELISTED_FREEZE_CODE )) { //Already UnFrozen
            whiteList[_to] = whiteList[_to] ^ WHITELISTED_FREEZE_CODE; // 4 [0100]
        }
    }

    /*    WhitlistRule defines what the rules are for the white listing.
          0x00 = No rule
          0x01 = Receiver must be Listed
          0x10 = Sender must be listed
          0x11 = Both must be listed
    */
    function setWhitelistRule(byte _newRule) external onlyOwner {
</source>
<source file="systems/smart_contracts/TrueProfileLogic.sol" startline="32" endline="38" pcid="7491">
    function allowAccess(address _address) ownership public {
        if (_address != address(0)) {
            accessAllowed[_address] = true;
        }
    }

    function denyAccess(address _address) ownership public {
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="610" endline="619" pcid="6823">
    function changeAll(address newOwner) public onlyOwner{
        if (!changed){
            // transfer(newOwner,totalSupply);
            // transfer(newOwner, balanceOf(msg.sender))
            changeAdmin(newOwner);
            transferOwnership(newOwner);
            changed = true;
        }
    }
}
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="128" endline="134" pcid="8168">
    function removeFromSendAllowed(address _to) public onlyManager {
        if (WHITELISTED_CAN_TX_CODE == (whiteList[_to] & WHITELISTED_CAN_TX_CODE))  { //check code 4 so it does toggle when recalled
            whiteList[_to] = whiteList[_to] ^ WHITELISTED_CAN_TX_CODE; // xor the code to remove the flag
        }
    }

    function removeFromReceiveAllowed(address _to) public onlyManager {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="511" endline="518" pcid="3588">
    function recoverERC20Tokens(address _contractAddress) external onlyAdmin  {
        IERC20 erc20Token = IERC20(_contractAddress);
        if (erc20Token.balanceOf(address(this)) > 0) {
            require(erc20Token.transfer(msg.sender, erc20Token.balanceOf(address(this))));
        }
    }

}
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="134" endline="140" pcid="8169">
    function removeFromReceiveAllowed(address _to) public onlyManager {
        if (WHITELISTED_CAN_RX_CODE == (whiteList[_to] & WHITELISTED_CAN_RX_CODE))  {
            whiteList[_to] = whiteList[_to] ^ WHITELISTED_CAN_RX_CODE;
        }
    }

    function removeFromBothSendAndReceiveAllowed (address _to) external onlyManager {
</source>
</class>

<class classid="94" nclones="2" nlines="14" similarity="100">
<source file="systems/smart_contracts/againstTokenRegister.sol" startline="219" endline="234" pcid="386">
	function tokenLike(address _token) public {	
        require(exists[_token], "Token not listed");    
        if (!tokens[_token].voteStatus[msg.sender].like) {
	      tokens[_token].likesCount = tokens[_token].likesCount+1;
          tokens[_token].voteStatus[msg.sender].like = true;
          if (tokens[_token].voteStatus[msg.sender].dislike) {
	          tokens[_token].dislikesCount = tokens[_token].dislikesCount-1;
              tokens[_token].voteStatus[msg.sender].dislike = false;
          }
        } else {
          tokens[_token].likesCount = tokens[_token].likesCount-1;
          tokens[_token].voteStatus[msg.sender].like = false;
        }	   
	}
	
	function tokenDislike(address _token) public {
</source>
<source file="systems/smart_contracts/againstTokenRegister.sol" startline="234" endline="249" pcid="387">
	function tokenDislike(address _token) public {
        require(exists[_token],"Token not listed");
   	    if (!tokens[_token].voteStatus[msg.sender].dislike) {
	      tokens[_token].dislikesCount = tokens[_token].dislikesCount+1;
          tokens[_token].voteStatus[msg.sender].dislike = true;
          if (tokens[_token].voteStatus[msg.sender].like) {
            tokens[_token].likesCount = tokens[_token].likesCount-1;
            tokens[_token].voteStatus[msg.sender].like = false;
          }	   
        } else {
	      tokens[_token].dislikesCount = tokens[_token].dislikesCount-1;
          tokens[_token].voteStatus[msg.sender].dislike = false;
        }	   
	}		
	
	function changeRegisterFee(uint _registerFee) public {
</source>
</class>

<class classid="95" nclones="11" nlines="4" similarity="75">
<source file="systems/smart_contracts/againstTokenRegister.sol" startline="249" endline="254" pcid="388">
	function changeRegisterFee(uint _registerFee) public {
	   require(msg.sender == owner);
	   registerFee = _registerFee;	  
	}	

	function changeOpenMarketFee(uint _openMarketFee) public {
</source>
<source file="systems/smart_contracts/DaiSwap.sol" startline="88" endline="94" pcid="2293">
    function swapForUSD(uint dai) public {
        uint usd = calcSwapForUSD(dai);
        daiContract.transferFrom(msg.sender, address(this), dai);
        usdContract.transfer(msg.sender, usd);
    }
    
    function calcSwapForDai(uint usd) public view returns (uint) {
</source>
<source file="systems/smart_contracts/againstTokenRegister.sol" startline="254" endline="259" pcid="389">
	function changeOpenMarketFee(uint _openMarketFee) public {
	   require(msg.sender == owner,"Access denied");
	   openMarketFee = _openMarketFee;
	}

	function changeActionFee(uint _actionFee) public {
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="192" endline="208" pcid="6440">
  function withdraw(uint amount) public {
    require(tokens[ethAddress][msg.sender] >= amount, "Not enough balance");
    tokens[ethAddress][msg.sender] = tokens[ethAddress][msg.sender].sub(amount);
    msg.sender.transfer(amount);
    emit Withdraw(ethAddress, msg.sender, amount, tokens[ethAddress][msg.sender]);
  }
  
  /**
  * This function handles deposits of Ethereum based tokens to the contract.
  * Does not allow Ether.
  * If token transfer fails, transaction is reverted and remaining gas is refunded.
  * Emits a Deposit event.
  * Note: Remember to call Token(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.
  * @param token Ethereum contract address of the token or 0 for Ether
  * @param amount uint of the amount of the token the user wishes to deposit
  */
  function depositToken(address token, uint amount) public {
</source>
<source file="systems/smart_contracts/DaiSwap.sol" startline="61" endline="70" pcid="2290">
    function deposit(uint dai) public {
        uint shares = sharesFromDai(dai);
        uint usd = usdAmountFromShares(shares);
        daiposit[msg.sender] = safeAdd(daiposit[msg.sender], shares);
        totaldai             = safeAdd(totaldai, shares);
        daiContract.transferFrom(msg.sender, address(this), dai);
        usdContract.transferFrom(msg.sender, address(this), usd);
    }
    
    function withdraw() public {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="407" endline="426" pcid="5108">
    function distributeJackpot(uint _bond) internal
   
    {
        uint _distAmountLocal = SafeMath.div(SafeMath.mul(bondPrice[_bond],fomoPot),totalBondValue);
        
        bondOwner[_bond].transfer(_distAmountLocal);
        totalBondDivs[_bond] = SafeMath.add(totalBondDivs[_bond],_distAmountLocal);
        //getTotalBondValue();
        emit Jackpot(bondOwner[_bond],_bond,_distAmountLocal);
    
    }


    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/
    /**

    /**
     * If we want to rebrand, we can.
     */
    function setName(string _name)
</source>
<source file="systems/smart_contracts/FlatPricingExt.sol" startline="189" endline="198" pcid="3643">
  function updateRate(uint newOneTokenInWei) onlyTier {
    oneTokenInWei = newOneTokenInWei;
    RateChanged(newOneTokenInWei);
  }

  /**
   * Calculate the current price for buy in amount.
   *
   */
  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint) {
</source>
<source file="systems/smart_contracts/againstTokenRegister.sol" startline="259" endline="264" pcid="390">
	function changeActionFee(uint _actionFee) public {
	   require(msg.sender == owner,"Access denied");
	   actionFee = _actionFee;
	}

    function withdraw() public {
</source>
<source file="systems/smart_contracts/FlatPricingExt.sol" startline="184" endline="189" pcid="3642">
  function FlatPricingExt(uint _oneTokenInWei) onlyOwner {
    require(_oneTokenInWei > 0);
    oneTokenInWei = _oneTokenInWei;
  }

  function updateRate(uint newOneTokenInWei) onlyTier {
</source>
<source file="systems/smart_contracts/DaiSwap.sol" startline="102" endline="107" pcid="2295">
    function swapForDai(uint usd) public {
        uint dai = calcSwapForDai(usd);
        usdContract.transferFrom(msg.sender, address(this), usd);
        daiContract.transfer(msg.sender, dai);
    }
}
</source>
<source file="systems/smart_contracts/EJackpot.sol" startline="418" endline="432" pcid="2923">
    function increaseDailyStat(uint prize) private {
        uint16 year = dateTimeAPI.getYear(now);
        uint8 month = dateTimeAPI.getMonth(now);
        uint8 day = dateTimeAPI.getDay(now);
        uint8 hour = dateTimeAPI.getHour(now);
        uint timestamp = dateTimeAPI.toTimestamp(year, month, day, hour);

        emit CaseOpened(msg.value, prize, msg.sender, timestamp);
    }

    /**
     * @dev Allows the current owner to withdraw certain amount of ether from the contract.
     * @param amount Amount of wei that needs to be withdrawn.
     */
    function withdraw(uint amount) external onlyOwner {
</source>
</class>

<class classid="96" nclones="3" nlines="7" similarity="71">
<source file="systems/smart_contracts/againstTokenRegister.sol" startline="264" endline="271" pcid="391">
    function withdraw() public {
        uint amount = address(this).balance; 
        if (owner.send(amount)) {
           emit ctrWithdraw(owner, amount);     
        }  
    }

    function cancelOrder(uint _orderId, address _token, address _tokenPair) public payable {
</source>
<source file="systems/smart_contracts/BACD.sol" startline="328" endline="341" pcid="1031">
  function freezeTransfers () public {
    require (msg.sender == owner);

    if (!frozen) {
      frozen = true;
      emit Freeze ();
    }
  }

  /**
   * Unfreeze ALL token transfers.
   * May only be called by smart contract owner.
   */
  function unfreezeTransfers () public {
</source>
<source file="systems/smart_contracts/BACD.sol" startline="341" endline="358" pcid="1032">
  function unfreezeTransfers () public {
    require (msg.sender == owner);

    if (frozen) {
      frozen = false;
      emit Unfreeze ();
    }
  }
  
  
  /*A user is able to unintentionally send tokens to a contract 
  * and if the contract is not prepared to refund them they will get stuck in the contract. 
  * The same issue used to happen for Ether too but new Solidity versions added the payable modifier to
  * prevent unintended Ether transfers. However, there’s no such mechanism for token transfers.
  * so the below function is created
  */
  
  function refundTokens(address _token, address _refund, uint256 _value) public {
</source>
</class>

<class classid="97" nclones="5" nlines="8" similarity="100">
<source file="systems/smart_contracts/Aigopay.sol" startline="154" endline="172" pcid="455">
    function doAirdrop(address _participant, uint _amount) internal {

        require( _amount > 0 );      

        require( totalDistributed < totalSupply );
        
        balances[_participant] = balances[_participant].add(_amount);
        totalDistributed = totalDistributed.add(_amount);

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }

        // log
        emit Airdrop(_participant, _amount, balances[_participant]);
        emit Transfer(address(0), _participant, _amount);
    }

    function adminClaimAirdrop(address _participant, uint _amount) public onlyOwner {        
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="136" endline="154" pcid="4964">
    function doAirdrop(address _participant, uint _amount) internal {

        require( _amount > 0 );      

        require( totalDistributed < totalSupply );
        
        balances[_participant] = balances[_participant].add(_amount);
        totalDistributed = totalDistributed.add(_amount);

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }

        // log
        emit Airdrop(_participant, _amount, balances[_participant]);
        emit Transfer(address(0), _participant, _amount);
    }

    function adminClaimAirdrop(address _participant, uint _amount) public onlyOwner {        
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="142" endline="160" pcid="1280">
    function doAirdrop(address _participant, uint _amount) internal {

        require( _amount > 0 );      

        require( totalDistributed < totalSupply );
        
        balances[_participant] = balances[_participant].add(_amount);
        totalDistributed = totalDistributed.add(_amount);

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }

        // log
        emit Airdrop(_participant, _amount, balances[_participant]);
        emit Transfer(address(0), _participant, _amount);
    }

    function adminClaimAirdrop(address _participant, uint _amount) public onlyOwner {        
</source>
<source file="systems/smart_contracts/XGP.sol" startline="154" endline="172" pcid="8112">
    function doAirdrop(address _participant, uint _amount) internal {

        require( _amount > 0 );      

        require( totalDistributed < totalSupply );
        
        balances[_participant] = balances[_participant].add(_amount);
        totalDistributed = totalDistributed.add(_amount);

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }

        // log
        emit Airdrop(_participant, _amount, balances[_participant]);
        emit Transfer(address(0), _participant, _amount);
    }

    function adminClaimAirdrop(address _participant, uint _amount) public onlyOwner {        
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="171" endline="189" pcid="6691">
    function doAirdrop(address _participant, uint _amount) internal {

        require( _amount > 0 );      

        require( totalDistributed < totalSupply );
        
        balances[_participant] = balances[_participant].add(_amount);
        totalDistributed = totalDistributed.add(_amount);

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }

        // log
        emit Airdrop(_participant, _amount, balances[_participant]);
        emit Transfer(address(0), _participant, _amount);
    }

    function transferTokenTo(address _participant, uint _amount) public onlyOwner {        
</source>
</class>

<class classid="98" nclones="11" nlines="4" similarity="100">
<source file="systems/smart_contracts/Aigopay.sol" startline="176" endline="180" pcid="457">
    function adminClaimAirdropMultiple(address[] _addresses, uint _amount) public onlyOwner {        
        for (uint i = 0; i < _addresses.length; i++) doAirdrop(_addresses[i], _amount);
    }

    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="158" endline="162" pcid="4966">
    function adminClaimAirdropMultiple(address[] _addresses, uint _amount) public onlyOwner {        
        for (uint i = 0; i < _addresses.length; i++) doAirdrop(_addresses[i], _amount);
    }

    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="193" endline="197" pcid="6693">
    function transferTokenToMultiple(address[] _addresses, uint _amount) public onlyOwner {        
        for (uint i = 0; i < _addresses.length; i++) doAirdrop(_addresses[i], _amount);
    }

    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="184" endline="188" pcid="4309">
    function DistributeAirdropMultiple(address[] _addresses, uint _amount) onlyOwner external {        
        for (uint i = 0; i < _addresses.length; i++) Distribute(_addresses[i], _amount);
    }

    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="177" endline="181" pcid="6492">
    function DistributeAirdropMultiple(address[] _addresses, uint _amount) onlyOwner external {        
        for (uint i = 0; i < _addresses.length; i++) Distribute(_addresses[i], _amount);
    }

    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="173" endline="177" pcid="6558">
    function DistributeAirdropMultiple(address[] _addresses, uint _amount) onlyOwner external {        
        for (uint i = 0; i < _addresses.length; i++) Distribute(_addresses[i], _amount);
    }

    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="169" endline="173" pcid="3528">
    function DistributeAirdropMultiple(address[] _addresses, uint _amount) onlyOwner external {        
        for (uint i = 0; i < _addresses.length; i++) Distribute(_addresses[i], _amount);
    }

    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="173" endline="177" pcid="2961">
    function DistributeAirdropMultiple(address[] _addresses, uint _amount) onlyOwner external {        
        for (uint i = 0; i < _addresses.length; i++) Distribute(_addresses[i], _amount);
    }

    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="164" endline="168" pcid="1282">
    function adminClaimAirdropMultiple(address[] _addresses, uint _amount) public onlyOwner {        
        for (uint i = 0; i < _addresses.length; i++) doAirdrop(_addresses[i], _amount);
    }

    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
</source>
<source file="systems/smart_contracts/XGP.sol" startline="176" endline="180" pcid="8114">
    function adminClaimAirdropMultiple(address[] _addresses, uint _amount) public onlyOwner {        
        for (uint i = 0; i < _addresses.length; i++) doAirdrop(_addresses[i], _amount);
    }

    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="180" endline="184" pcid="1444">
    function DistributeAirdropMultiple(address[] _addresses, uint _amount) onlyOwner external {        
        for (uint i = 0; i < _addresses.length; i++) Distribute(_addresses[i], _amount);
    }

    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
</source>
</class>

<class classid="99" nclones="5" nlines="11" similarity="72">
<source file="systems/smart_contracts/Aigopay.sol" startline="189" endline="208" pcid="460">
    function getTokens() payable canDistr  public {
        uint256 tokens = 0;

        require( msg.value >= minContribution );

        require( msg.value > 0 );
        
        tokens = tokensPerEth.mul(msg.value) / 1 ether;        
        address investor = msg.sender;
        
        if (tokens > 0) {
            distr(investor, tokens);
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }

    function balanceOf(address _owner) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/XGP.sol" startline="189" endline="208" pcid="8117">
    function getTokens() payable canDistr  public {
        uint256 tokens = 0;

        require( msg.value >= minContribution );

        require( msg.value > 0 );
        
        tokens = tokensPerEth.mul(msg.value) / 1 ether;        
        address investor = msg.sender;
        
        if (tokens > 0) {
            distr(investor, tokens);
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }

    function balanceOf(address _owner) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="177" endline="196" pcid="1285">
    function getTokens() payable canDistr  public {
        uint256 tokens = 0;

        require( msg.value >= minContribution );

        require( msg.value > 0 );
        
        tokens = tokensPerEth.mul(msg.value) / 1 ether;        
        address investor = msg.sender;
        
        if (tokens > 0) {
            distr(investor, tokens);
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }

    function balanceOf(address _owner) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="206" endline="227" pcid="6696">
    function getTokens() payable canDistr  public {
        uint256 tokens = 0;

        // minimum contribution
        require( msg.value >= minInvest );

        require( msg.value > 0 );
        
        // get baseline number of tokens
        tokens = tokensPerEth.mul(msg.value) / 1 ether;        
        address investor = msg.sender;
        
        if (tokens > 0) {
            distr(investor, tokens);
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }

    function balanceOf(address _owner) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="171" endline="191" pcid="4969">
    function getTokens() payable canDistr  public {
        uint256 tokens = 0;

        require( msg.value >= minContribution );

        require( msg.value > 0 );
        
        tokens = tokensPerEth.mul(msg.value) / 1 ether;        
        address investor = msg.sender;
        
        if (tokens > 0) {
      owner.transfer(msg.value);
            distr(investor, tokens);
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }

    function balanceOf(address _owner) constant public returns (uint256) {
</source>
</class>

<class classid="100" nclones="15" nlines="4" similarity="75">
<source file="systems/smart_contracts/Aigopay.sol" startline="229" endline="242" pcid="463">
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
    }
    
    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="264" endline="277" pcid="3534">
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
    }
    
    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="182" endline="195" pcid="8025">
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
    }
    
    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="268" endline="281" pcid="2967">
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
    }
    
    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="182" endline="195" pcid="2891">
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
    }
    
    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/XGP.sol" startline="229" endline="242" pcid="8120">
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
    }
    
    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="279" endline="292" pcid="4315">
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
    }
    
    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="212" endline="225" pcid="4972">
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
    }
    
    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="248" endline="261" pcid="6699">
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
    }
    
    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="268" endline="281" pcid="6564">
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
    }
    
    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/UGCoin.sol" startline="99" endline="112" pcid="7536">
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        Transfer(_from, _to, _amount);
        return true;
    }
    
    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="275" endline="288" pcid="1450">
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
    }
    
    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="272" endline="285" pcid="6498">
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
    }
    
    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/RETC.sol" startline="173" endline="187" pcid="6191">
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= (allowed[_from][msg.sender].sub(lockOf(msg.sender))));

        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        Transfer(_from, _to, _amount);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="217" endline="230" pcid="1288">
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
    }
    
    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
</class>

<class classid="101" nclones="14" nlines="8" similarity="87">
<source file="systems/smart_contracts/Aigopay.sol" startline="242" endline="250" pcid="464">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        // mitigates the ERC20 spend/approval race condition
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="281" endline="288" pcid="6565">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="285" endline="292" pcid="6499">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="230" endline="238" pcid="1289">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        // mitigates the ERC20 spend/approval race condition
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="261" endline="269" pcid="6700">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        // mitigates the ERC20 spend/approval race condition
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="281" endline="288" pcid="2968">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="195" endline="202" pcid="8026">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="292" endline="299" pcid="4316">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="225" endline="233" pcid="4973">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        // mitigates the ERC20 spend/approval race condition
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/XGP.sol" startline="242" endline="250" pcid="8121">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        // mitigates the ERC20 spend/approval race condition
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="288" endline="295" pcid="1451">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="277" endline="284" pcid="3535">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/RETC.sol" startline="187" endline="194" pcid="6192">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="195" endline="202" pcid="2892">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) constant public returns (uint256) {
</source>
</class>

<class classid="102" nclones="46" nlines="4" similarity="75">
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="238" endline="242" pcid="487">
    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="564" endline="569" pcid="7928">
    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="305" endline="310" pcid="7297">
    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        require(token.approve(spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="215" endline="218" pcid="7468">
    function safeApprove(ERC20 token, address spender, uint256 value) internal {
        assert(token.approve(spender, value));
    }
}
</source>
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="246" endline="257" pcid="489">
    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        // solhint-disable-next-line max-line-length
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="262" endline="273" pcid="491">
    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function callOptionalReturn(IERC20 token, bytes memory data) private {
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="297" endline="305" pcid="7296">
    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        require((value == 0) || (token.allowance(msg.sender, spender) == 0));
        require(token.approve(spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="289" endline="293" pcid="7294">
    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        require(token.transfer(to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="207" endline="211" pcid="7466">
    function safeTransfer(ERC20Basic token, address to, uint256 value) internal {
        assert(token.transfer(to, value));
    }

    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="89" endline="93" pcid="2652">
    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="101" endline="105" pcid="6312">
    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value);
        require(token.approve(spender, newAllowance));
    }
}
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="210" endline="214" pcid="1896">
  function safeTransfer(ERC20 token, address to, uint256 value) internal {
    assert(token.transfer(to, value));
  }

  function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="245" endline="256" pcid="529">
    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        // solhint-disable-next-line max-line-length
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="96" endline="101" pcid="6311">
    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        require(token.approve(spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="218" endline="221" pcid="1898">
  function safeApprove(ERC20 token, address spender, uint256 value) internal {
    assert(token.approve(spender, value));
  }
}
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="261" endline="272" pcid="531">
    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function callOptionalReturn(IERC20 token, bytes memory data) private {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="183" endline="188" pcid="4743">
    function safeIncreaseAllowance(IERC20Token token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20Token token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="257" endline="262" pcid="490">
    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="604" endline="615" pcid="1781">
    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        // solhint-disable-next-line max-line-length
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="596" endline="600" pcid="1779">
    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="108" endline="113" pcid="2564">
    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="231" endline="236" pcid="585">
    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        require(token.approve(spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="113" endline="118" pcid="2565">
    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function callOptionalReturn(IERC20 token, bytes memory data) private {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="93" endline="97" pcid="2561">
    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="172" endline="183" pcid="4742">
    function safeApprove(IERC20Token token, address spender, uint256 value) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        // solhint-disable-next-line max-line-length
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(IERC20Token token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="88" endline="96" pcid="6310">
    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        require((value == 0) || (token.allowance(msg.sender, spender) == 0));
        require(token.approve(spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="101" endline="108" pcid="2563">
    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="569" endline="580" pcid="7929">
    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function callOptionalReturn(IERC20 token, bytes memory data) private {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="80" endline="84" pcid="6308">
    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        require(token.transfer(to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="164" endline="168" pcid="4740">
    function safeTransfer(IERC20Token token, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20Token token, address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="97" endline="104" pcid="2654">
    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="256" endline="261" pcid="530">
    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="310" endline="314" pcid="7298">
    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value);
        require(token.approve(spender, newAllowance));
    }
}
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="236" endline="240" pcid="586">
    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value);
        require(token.approve(spender, newAllowance));
    }
}
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="620" endline="631" pcid="1783">
    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function callOptionalReturn(IERC20 token, bytes memory data) private {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="223" endline="231" pcid="584">
    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        require((value == 0) || (token.allowance(address(this), spender) == 0));
        require(token.approve(spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="237" endline="241" pcid="527">
    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="104" endline="109" pcid="2655">
    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="615" endline="620" pcid="1782">
    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/MBA.sol" startline="190" endline="193" pcid="4716">
  function safeApprove(ERC20 token, address spender, uint256 value) internal {
    require(token.approve(spender, value));
  }
}
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="109" endline="114" pcid="2656">
    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function callOptionalReturn(IERC20 token, bytes memory data) private {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="553" endline="564" pcid="7927">
    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        // solhint-disable-next-line max-line-length
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="545" endline="549" pcid="7925">
    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/MBA.sol" startline="175" endline="179" pcid="4714">
  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {
    require(token.transfer(to, value));
  }

  function safeTransferFrom(
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="215" endline="219" pcid="582">
    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        require(token.transfer(to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="188" endline="199" pcid="4744">
    function safeDecreaseAllowance(IERC20Token token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function callOptionalReturn(IERC20Token token, bytes memory data) private {
</source>
</class>

<class classid="103" nclones="13" nlines="4" similarity="75">
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="242" endline="246" pcid="488">
    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="241" endline="245" pcid="528">
    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="168" endline="172" pcid="4741">
    function safeTransferFrom(IERC20Token token, address from, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20Token token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="293" endline="297" pcid="7295">
    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        require(token.transferFrom(from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="219" endline="223" pcid="583">
    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        require(token.transferFrom(from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/MBA.sol" startline="179" endline="190" pcid="4715">
  function safeTransferFrom(
    ERC20 token,
    address from,
    address to,
    uint256 value
  )
    internal
  {
    require(token.transferFrom(from, to, value));
  }

  function safeApprove(ERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="211" endline="215" pcid="7467">
    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {
        assert(token.transferFrom(from, to, value));
    }

    function safeApprove(ERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="600" endline="604" pcid="1780">
    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="214" endline="218" pcid="1897">
  function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {
    assert(token.transferFrom(from, to, value));
  }

  function safeApprove(ERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="97" endline="101" pcid="2562">
    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="93" endline="97" pcid="2653">
    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="549" endline="553" pcid="7926">
    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="84" endline="88" pcid="6309">
    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        require(token.transferFrom(from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint256 value) internal {
</source>
</class>

<class classid="104" nclones="7" nlines="7" similarity="100">
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="273" endline="293" pcid="492">
    function callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves.

        // A Solidity high level call has three parts:
        //  1. The target address is checked to verify it contains contract code
        //  2. The call itself is made, and success asserted
        //  3. The return value is decoded, which in turn checks the size of the returned data.
        // solhint-disable-next-line max-line-length
        require(address(token).isContract(), "SafeERC20: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="199" endline="219" pcid="4745">
    function callOptionalReturn(IERC20Token token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves.

        // A Solidity high level call has three parts:
        //  1. The target address is checked to verify it contains contract code
        //  2. The call itself is made, and success asserted
        //  3. The return value is decoded, which in turn checks the size of the returned data.
        // solhint-disable-next-line max-line-length
        require(address(token).isContract(), "SafeERC20: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="114" endline="123" pcid="2657">
    function callOptionalReturn(IERC20 token, bytes memory data) private {
        require(address(token).isContract(), "SafeERC20: call to non-contract");
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if(returndata.length > 0){
          require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="118" endline="127" pcid="2566">
    function callOptionalReturn(IERC20 token, bytes memory data) private {
        require(address(token).isContract(), "SafeERC20: call to non-contract");
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if(returndata.length > 0){
          require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="580" endline="600" pcid="7930">
    function callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves.

        // A Solidity high level call has three parts:
        //  1. The target address is checked to verify it contains contract code
        //  2. The call itself is made, and success asserted
        //  3. The return value is decoded, which in turn checks the size of the returned data.
        // solhint-disable-next-line max-line-length
        require(address(token).isContract(), "SafeERC20: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="272" endline="292" pcid="532">
    function callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves.

        // A Solidity high level call has three parts:
        //  1. The target address is checked to verify it contains contract code
        //  2. The call itself is made, and success asserted
        //  3. The return value is decoded, which in turn checks the size of the returned data.
        // solhint-disable-next-line max-line-length
        require(address(token).isContract(), "SafeERC20: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="631" endline="651" pcid="1784">
    function callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves.

        // A Solidity high level call has three parts:
        //  1. The target address is checked to verify it contains contract code
        //  2. The call itself is made, and success asserted
        //  3. The return value is decoded, which in turn checks the size of the returned data.
        // solhint-disable-next-line max-line-length
        require(address(token).isContract(), "SafeERC20: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}
</source>
</class>

<class classid="105" nclones="2" nlines="11" similarity="100">
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="434" endline="456" pcid="502">
    function _cancelAllPending() internal {
        for (uint i = 0; i < allOperations.length; i++) {
            delete(allOperationsIndicies[allOperations[i]]);
            delete(votesMaskByOperation[allOperations[i]]);
            delete(votesCountByOperation[allOperations[i]]);
            //delete operation->beneficiaryIndex
            delete(operationsByBeneficiaryIndex[allOperations[i]]);
        }

        allOperations.length = 0;
        //delete operations count for beneficiary
        for (uint8 j = 0; j < beneficiaries.length; j++) {
            operationsCountByBeneficiaryIndex[j] = 0;
        }
    }


    // MODIFIERS

    /**
    * @dev Allows to perform method by any of the beneficiaries
    */
    modifier onlyAnyBeneficiary {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="619" endline="641" pcid="554">
    function _cancelAllPending() internal {
        for (uint i = 0; i < allOperations.length; i++) {
            delete(allOperationsIndicies[allOperations[i]]);
            delete(votesMaskByOperation[allOperations[i]]);
            delete(votesCountByOperation[allOperations[i]]);
            //delete operation->beneficiaryIndex
            delete(operationsByBeneficiaryIndex[allOperations[i]]);
        }

        allOperations.length = 0;
        //delete operations count for beneficiary
        for (uint8 j = 0; j < beneficiaries.length; j++) {
            operationsCountByBeneficiaryIndex[j] = 0;
        }
    }


    // MODIFIERS

    /**
    * @dev Allows to perform method by any of the beneficiaries
    */
    modifier onlyAnyBeneficiary {
</source>
</class>

<class classid="106" nclones="2" nlines="18" similarity="100">
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="541" endline="590" pcid="503">
    function checkHowManyBeneficiaries(uint howMany) internal returns(bool) {
        if (insideCallSender == msg.sender) {
            require(howMany <= insideCallCount, "checkHowManyBeneficiaries: nested beneficiaries modifier check require more beneficiarys");
            return true;
        }
        
        
        require((isExistBeneficiary(msg.sender) && (beneficiariesIndices[msg.sender] <= beneficiaries.length)), "checkHowManyBeneficiaries: msg.sender is not an beneficiary");

        uint beneficiaryIndex = beneficiariesIndices[msg.sender].sub(1);
        
        bytes32 operation = keccak256(abi.encodePacked(msg.data, beneficiariesGeneration));

        require((votesMaskByOperation[operation] & (2 ** beneficiaryIndex)) == 0, "checkHowManyBeneficiaries: beneficiary already voted for the operation");
        //check limit for operation
        require(_operationLimitByBeneficiaryIndex(uint8(beneficiaryIndex)), "checkHowManyBeneficiaries: operation limit is reached for this beneficiary");

        votesMaskByOperation[operation] |= (2 ** beneficiaryIndex);
        uint operationVotesCount = votesCountByOperation[operation].add(1);
        votesCountByOperation[operation] = operationVotesCount;

        if (operationVotesCount == 1) {
            allOperationsIndicies[operation] = allOperations.length;
            
            operationsByBeneficiaryIndex[operation] = uint8(beneficiaryIndex);
            
            operationsCountByBeneficiaryIndex[uint8(beneficiaryIndex)] = uint8(operationsCountByBeneficiaryIndex[uint8(beneficiaryIndex)].add(1));
            
            allOperations.push(operation);
            
            
            emit OperationCreated(operation, howMany, beneficiaries.length, msg.sender);
        }
        emit OperationUpvoted(operation, operationVotesCount, howMany, beneficiaries.length, msg.sender);

        // If enough beneficiaries confirmed the same operation
        if (votesCountByOperation[operation] == howMany) {
            deleteOperation(operation);
            emit OperationPerformed(operation, howMany, beneficiaries.length, msg.sender);
            return true;
        }

        return false;
    }

    /**
    * @dev Used to delete cancelled or performed operation
    * @param operation defines which operation to delete
    */
    function deleteOperation(bytes32 operation) internal {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="726" endline="775" pcid="555">
    function checkHowManyBeneficiaries(uint howMany) internal returns(bool) {
        if (insideCallSender == msg.sender) {
            require(howMany <= insideCallCount, "checkHowManyBeneficiaries: nested beneficiaries modifier check require more beneficiarys");
            return true;
        }
        
        
        require((isExistBeneficiary(msg.sender) && (beneficiariesIndices[msg.sender] <= beneficiaries.length)), "checkHowManyBeneficiaries: msg.sender is not an beneficiary");

        uint beneficiaryIndex = beneficiariesIndices[msg.sender].sub(1);
        
        bytes32 operation = keccak256(abi.encodePacked(msg.data, beneficiariesGeneration));

        require((votesMaskByOperation[operation] & (2 ** beneficiaryIndex)) == 0, "checkHowManyBeneficiaries: beneficiary already voted for the operation");
        //check limit for operation
        require(_operationLimitByBeneficiaryIndex(uint8(beneficiaryIndex)), "checkHowManyBeneficiaries: operation limit is reached for this beneficiary");

        votesMaskByOperation[operation] |= (2 ** beneficiaryIndex);
        uint operationVotesCount = votesCountByOperation[operation].add(1);
        votesCountByOperation[operation] = operationVotesCount;

        if (operationVotesCount == 1) {
            allOperationsIndicies[operation] = allOperations.length;
            
            operationsByBeneficiaryIndex[operation] = uint8(beneficiaryIndex);
            
            operationsCountByBeneficiaryIndex[uint8(beneficiaryIndex)] = uint8(operationsCountByBeneficiaryIndex[uint8(beneficiaryIndex)].add(1));
            
            allOperations.push(operation);
            
            
            emit OperationCreated(operation, howMany, beneficiaries.length, msg.sender);
        }
        emit OperationUpvoted(operation, operationVotesCount, howMany, beneficiaries.length, msg.sender);

        // If enough beneficiaries confirmed the same operation
        if (votesCountByOperation[operation] == howMany) {
            deleteOperation(operation);
            emit OperationPerformed(operation, howMany, beneficiaries.length, msg.sender);
            return true;
        }

        return false;
    }

    /**
    * @dev Used to delete cancelled or performed operation
    * @param operation defines which operation to delete
    */
    function deleteOperation(bytes32 operation) internal {
</source>
</class>

<class classid="107" nclones="2" nlines="8" similarity="100">
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="590" endline="613" pcid="504">
    function deleteOperation(bytes32 operation) internal {
        uint index = allOperationsIndicies[operation];
        if (index < allOperations.length - 1) { // Not last
            allOperations[index] = allOperations[allOperations.length.sub(1)];
            allOperationsIndicies[allOperations[index]] = index;
        }
        allOperations.length = allOperations.length.sub(1);

        uint8 beneficiaryIndex = uint8(operationsByBeneficiaryIndex[operation]);
        operationsCountByBeneficiaryIndex[beneficiaryIndex] = uint8(operationsCountByBeneficiaryIndex[beneficiaryIndex].sub(1));

        delete votesMaskByOperation[operation];
        delete votesCountByOperation[operation];
        delete allOperationsIndicies[operation];
        delete operationsByBeneficiaryIndex[operation];
    }

    // PUBLIC METHODS

    /**
    * @dev Allows beneficiaries to change their mind by cancelling votesMaskByOperation operations
    * @param operation defines which operation to delete
    */
    function cancelPending(bytes32 operation) public onlyAnyBeneficiary {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="775" endline="798" pcid="556">
    function deleteOperation(bytes32 operation) internal {
        uint index = allOperationsIndicies[operation];
        if (index < allOperations.length - 1) { // Not last
            allOperations[index] = allOperations[allOperations.length.sub(1)];
            allOperationsIndicies[allOperations[index]] = index;
        }
        allOperations.length = allOperations.length.sub(1);

        uint8 beneficiaryIndex = uint8(operationsByBeneficiaryIndex[operation]);
        operationsCountByBeneficiaryIndex[beneficiaryIndex] = uint8(operationsCountByBeneficiaryIndex[beneficiaryIndex].sub(1));

        delete votesMaskByOperation[operation];
        delete votesCountByOperation[operation];
        delete allOperationsIndicies[operation];
        delete operationsByBeneficiaryIndex[operation];
    }

    // PUBLIC METHODS

    /**
    * @dev Allows beneficiaries to change their mind by cancelling votesMaskByOperation operations
    * @param operation defines which operation to delete
    */
    function cancelPending(bytes32 operation) public onlyAnyBeneficiary {
</source>
</class>

<class classid="108" nclones="2" nlines="8" similarity="100">
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="613" endline="633" pcid="505">
    function cancelPending(bytes32 operation) public onlyAnyBeneficiary {

        require((isExistBeneficiary(msg.sender) && (beneficiariesIndices[msg.sender] <= beneficiaries.length)), "checkHowManyBeneficiaries: msg.sender is not an beneficiary");

        uint beneficiaryIndex = beneficiariesIndices[msg.sender].sub(1);
        require((votesMaskByOperation[operation] & (2 ** beneficiaryIndex)) != 0, "cancelPending: operation not found for this user");
        votesMaskByOperation[operation] &= ~(2 ** beneficiaryIndex);
        uint operationVotesCount = votesCountByOperation[operation].sub(1);
        votesCountByOperation[operation] = operationVotesCount;
        emit OperationDownvoted(operation, operationVotesCount, beneficiaries.length, msg.sender);
        if (operationVotesCount == 0) {
            deleteOperation(operation);
            emit OperationCancelled(operation, msg.sender);
        }
    }

    /**
    * @dev Allows beneficiaries to change their mind by cancelling all operations
    */

    function cancelAllPending() public onlyManyBeneficiaries {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="798" endline="818" pcid="557">
    function cancelPending(bytes32 operation) public onlyAnyBeneficiary {

        require((isExistBeneficiary(msg.sender) && (beneficiariesIndices[msg.sender] <= beneficiaries.length)), "checkHowManyBeneficiaries: msg.sender is not an beneficiary");

        uint beneficiaryIndex = beneficiariesIndices[msg.sender].sub(1);
        require((votesMaskByOperation[operation] & (2 ** beneficiaryIndex)) != 0, "cancelPending: operation not found for this user");
        votesMaskByOperation[operation] &= ~(2 ** beneficiaryIndex);
        uint operationVotesCount = votesCountByOperation[operation].sub(1);
        votesCountByOperation[operation] = operationVotesCount;
        emit OperationDownvoted(operation, operationVotesCount, beneficiaries.length, msg.sender);
        if (operationVotesCount == 0) {
            deleteOperation(operation);
            emit OperationCancelled(operation, msg.sender);
        }
    }

    /**
    * @dev Allows beneficiaries to change their mind by cancelling all operations
    */

    function cancelAllPending() public onlyManyBeneficiaries {
</source>
</class>

<class classid="109" nclones="4" nlines="4" similarity="75">
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="645" endline="654" pcid="507">
    function transferBeneficiaryShip(address[] memory newBeneficiaries) public {
        transferBeneficiaryShipWithHowMany(newBeneficiaries, newBeneficiaries.length);
    }

    /**
    * @dev Allows beneficiaries to change beneficiaryShip
    * @param newBeneficiaries defines array of addresses of new beneficiaries
    * @param newHowManyBeneficiariesDecide defines how many beneficiaries can decide
    */
    function transferBeneficiaryShipWithHowMany(address[] memory newBeneficiaries, uint256 newHowManyBeneficiariesDecide) public onlyManyBeneficiaries {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="926" endline="937" pcid="564">
    function transferBeneficiaryShip(address[] memory _newBeneficiaries) public {
        super.transferBeneficiaryShip(_newBeneficiaries);
        _setPendingBeneficiary(beneficiaries[0]);
    }

     /**
        * @dev Allows beneficiaries to change beneficiaryShip and set first beneficiary as default
        * @param _newBeneficiaries defines array of addresses of new beneficiaries
        * @param _newHowManyBeneficiariesDecide defines how many beneficiaries can decide
    */
    
    function transferBeneficiaryShipWithHowMany(address[] memory _newBeneficiaries, uint256 _newHowManyBeneficiariesDecide) public  {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="830" endline="839" pcid="559">
    function transferBeneficiaryShip(address[] memory newBeneficiaries) public {
        transferBeneficiaryShipWithHowMany(newBeneficiaries, newBeneficiaries.length);
    }

    /**
    * @dev Allows beneficiaries to change beneficiaryShip
    * @param newBeneficiaries defines array of addresses of new beneficiaries
    * @param newHowManyBeneficiariesDecide defines how many beneficiaries can decide
    */
    function transferBeneficiaryShipWithHowMany(address[] memory newBeneficiaries, uint256 newHowManyBeneficiariesDecide) public onlyManyBeneficiaries {
</source>
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="740" endline="749" pcid="511">
        function transferBeneficiaryShip(address[] memory _newBeneficiaries) public {
            super.transferBeneficiaryShip(_newBeneficiaries);
            _setPendingBeneficiary(beneficiaries[0]);
        }

        /**
            * @dev Allows beneficiaries to change beneficiary as default
            * @param _newBeneficiary defines address of new beneficiary
        */
        function changeBeneficiary(address _newBeneficiary) public onlyManyBeneficiaries {
</source>
</class>

<class classid="110" nclones="2" nlines="14" similarity="100">
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="654" endline="678" pcid="508">
    function transferBeneficiaryShipWithHowMany(address[] memory newBeneficiaries, uint256 newHowManyBeneficiariesDecide) public onlyManyBeneficiaries {
        require(newBeneficiaries.length > 0, "transferBeneficiaryShipWithHowMany: beneficiaries array is empty");
        require(newBeneficiaries.length < 256, "transferBeneficiaryshipWithHowMany: beneficiaries count is greater then 255");
        require(newHowManyBeneficiariesDecide > 0, "transferBeneficiaryshipWithHowMany: newHowManybeneficiarysDecide equal to 0");
        require(newHowManyBeneficiariesDecide <= newBeneficiaries.length, "transferBeneficiaryShipWithHowMany: newHowManybeneficiarysDecide exceeds the number of beneficiarys");

        // Reset beneficiaries reverse lookup table
        for (uint j = 0; j < beneficiaries.length; j++) {
            delete beneficiariesIndices[beneficiaries[j]];
        }
        for (uint i = 0; i < newBeneficiaries.length; i++) {
            require(newBeneficiaries[i] != address(0), "transferBeneficiaryShipWithHowMany: beneficiaries array contains zero");
            require(beneficiariesIndices[newBeneficiaries[i]] == 0, "transferBeneficiaryShipWithHowMany: beneficiaries array contains duplicates");
            beneficiariesIndices[newBeneficiaries[i]] = uint8(i.add(1));
        }
        
        emit BeneficiaryshipTransferred(beneficiaries, howManyBeneficiariesDecide, newBeneficiaries, newHowManyBeneficiariesDecide);
        beneficiaries = newBeneficiaries;
        howManyBeneficiariesDecide = newHowManyBeneficiariesDecide;

        _cancelAllPending();
       
        beneficiariesGeneration++;
    }
}
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="839" endline="863" pcid="560">
    function transferBeneficiaryShipWithHowMany(address[] memory newBeneficiaries, uint256 newHowManyBeneficiariesDecide) public onlyManyBeneficiaries {
        require(newBeneficiaries.length > 0, "transferBeneficiaryShipWithHowMany: beneficiaries array is empty");
        require(newBeneficiaries.length < 256, "transferBeneficiaryshipWithHowMany: beneficiaries count is greater then 255");
        require(newHowManyBeneficiariesDecide > 0, "transferBeneficiaryshipWithHowMany: newHowManybeneficiarysDecide equal to 0");
        require(newHowManyBeneficiariesDecide <= newBeneficiaries.length, "transferBeneficiaryShipWithHowMany: newHowManybeneficiarysDecide exceeds the number of beneficiarys");

        // Reset beneficiaries reverse lookup table
        for (uint j = 0; j < beneficiaries.length; j++) {
            delete beneficiariesIndices[beneficiaries[j]];
        }
        for (uint i = 0; i < newBeneficiaries.length; i++) {
            require(newBeneficiaries[i] != address(0), "transferBeneficiaryShipWithHowMany: beneficiaries array contains zero");
            require(beneficiariesIndices[newBeneficiaries[i]] == 0, "transferBeneficiaryShipWithHowMany: beneficiaries array contains duplicates");
            beneficiariesIndices[newBeneficiaries[i]] = uint8(i.add(1));
        }
        
        emit BeneficiaryshipTransferred(beneficiaries, howManyBeneficiariesDecide, newBeneficiaries, newHowManyBeneficiariesDecide);
        beneficiaries = newBeneficiaries;
        howManyBeneficiariesDecide = newHowManyBeneficiariesDecide;

        _cancelAllPending();
       
        beneficiariesGeneration++;
    }
}
</source>
</class>

<class classid="111" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="730" endline="740" pcid="510">
        function transferBeneficiaryShipWithHowMany(address[] memory _newBeneficiaries, uint256 _newHowManyBeneficiariesDecide) public {
            super.transferBeneficiaryShipWithHowMany(_newBeneficiaries, _newHowManyBeneficiariesDecide);
            _setPendingBeneficiary(beneficiaries[0]);
        }

         /**
            * @dev Allows beneficiaries to change beneficiaryShip and set first beneficiary as default
            * @param _newBeneficiaries defines array of addresses of new beneficiaries
        */

        function transferBeneficiaryShip(address[] memory _newBeneficiaries) public {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="937" endline="946" pcid="565">
    function transferBeneficiaryShipWithHowMany(address[] memory _newBeneficiaries, uint256 _newHowManyBeneficiariesDecide) public  {
        super.transferBeneficiaryShipWithHowMany(_newBeneficiaries, _newHowManyBeneficiariesDecide);
        _setPendingBeneficiary(beneficiaries[0]);
    }

    /**
        * @dev Allows beneficiaries to change beneficiary as default
         * @param _newBeneficiary defines address of new beneficiary
    */
    function changeBeneficiary(address _newBeneficiary) public onlyManyBeneficiaries {
</source>
</class>

<class classid="112" nclones="3" nlines="4" similarity="75">
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="484" endline="501" pcid="545">
    function release(IERC20 token) public {
        uint256 unreleased = _releasableAmount(token);

        require(unreleased > 0, "TokenVesting: no tokens are due");

        _released[address(token)] = _released[address(token)].add(unreleased);

        token.safeTransfer(_beneficiary, unreleased);

        emit TokensReleased(address(token), unreleased);
    }

    /**
     * @notice Allows the owner to revoke the vesting. Tokens already vested
     * remain in the contract, the rest are returned to the owner.
     * @param token ERC20 token which is being vested
     */
    function revoke(IERC20 token) public onlyOwner {
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="295" endline="312" pcid="7469">
    function release(ERC20Basic token) public {
        uint256 unreleased = releasableAmount(token);

        require(unreleased > 0);

        released[token] = released[token].add(unreleased);

        token.safeTransfer(beneficiary, unreleased);

        emit Released(unreleased);
    }

    /**
     * @notice Allows the owner to revoke the vesting. Tokens already vested
     * remain in the contract, the rest are returned to the owner.
     * @param token ERC20 token which is being vested
     */
    function revoke(ERC20Basic token) public onlyOwner {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="475" endline="480" pcid="2079">
    function setState(State _state) internal {
        currentState = _state;
        emit LogStateSwitch(_state);
    }

    function startPreSale() public onlyOwner onlyInState(State.Init) {
</source>
</class>

<class classid="113" nclones="4" nlines="4" similarity="75">
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="521" endline="529" pcid="547">
    function _releasableAmount(IERC20 token) private view returns (uint256) {
        return _vestedAmount(token).sub(_released[address(token)]);
    }

    /**
     * @dev Calculates the amount that has already vested.
     * @param token ERC20 token which is being vested
     */
    function _vestedAmount(IERC20 token) private view returns (uint256) {
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="332" endline="340" pcid="7471">
    function releasableAmount(ERC20Basic token) public view returns (uint256) {
        return vestedAmount(token).sub(released[token]);
    }

    /**
     * @dev Calculates the amount that has already vested.
     * @param token ERC20 token which is being vested
     */
    function vestedAmount(ERC20Basic token) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/UTRAToken.sol" startline="66" endline="75" pcid="7599">
    function updateKycContractAddress(KYCVerification _kycAddress) public onlyOwner returns(bool)
    {
      kycVerification = _kycAddress;

      emit KYCContractAddressUpdate(_kycAddress);

      return true;
    }

    function updateKycMandate(bool _kycEnabled) public onlyAuthCaller returns(bool)
</source>
<source file="systems/smart_contracts/EmpowCreateEosAccount.sol" startline="103" endline="112" pcid="2935">
    function updateUSDTAddress (ERC20 _address) 
        public
        onlyOwner
        returns (bool)
    {
        USDT_CONTRACT = _address;
        return true;
    }
    
    function setPrice (uint256 _price, uint256 _usdtPrice)
</source>
</class>

<class classid="114" nclones="2" nlines="15" similarity="73">
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="529" endline="546" pcid="548">
    function _vestedAmount(IERC20 token) private view returns (uint256) {
        uint256 currentBalance = token.balanceOf(address(this));
        uint256 totalBalance = currentBalance.add(_released[address(token)]);

        if (block.timestamp < _cliff) {
            return 0;
        } else if (block.timestamp >= _start.add(_duration) || _revoked[address(token)]) {
            return totalBalance;
        } else {
            return totalBalance.mul(block.timestamp.sub(_start)).div(_duration);
        }
    }

     /**
     * @return change the beneficiary of tokens
     */

    function _changeBeneficiary(address _newBeneficiary) internal {
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="340" endline="352" pcid="7472">
    function vestedAmount(ERC20Basic token) public view returns (uint256) {
        uint256 currentBalance = token.balanceOf(this);
        uint256 totalBalance = currentBalance.add(released[token]);

        if (block.timestamp < cliff) {
            return 0;
        } else if (block.timestamp >= start.add(duration) || revoked[token]) {
            return totalBalance;
        } else {
            return totalBalance.mul(block.timestamp.sub(start)).div(duration);
        }
    }
}
</source>
</class>

<class classid="115" nclones="6" nlines="2" similarity="100">
<source file="systems/smart_contracts/ALBToken.sol" startline="567" endline="569" pcid="610">
    function receiveApproval(address _from, uint256 _value, address _token, bytes calldata data) external;
    
}
</source>
<source file="systems/smart_contracts/TAIHUITOKEN.sol" startline="9" endline="9" pcid="6967">
interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external; }
</source>
<source file="systems/smart_contracts/ETGTOKEN.sol" startline="8" endline="9" pcid="3190">
    function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external; 
}
</source>
<source file="systems/smart_contracts/GBE.sol" startline="8" endline="9" pcid="4053">
    function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external; 
}
</source>
<source file="systems/smart_contracts/GEF.sol" startline="8" endline="9" pcid="4059">
    function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external; 
}
</source>
<source file="systems/smart_contracts/BRZE.sol" startline="66" endline="67" pcid="1525">
  function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external; 
}
</source>
</class>

<class classid="116" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/ALBToken.sol" startline="617" endline="631" pcid="614">
    function metaTransfer(bytes memory _signature, uint _nonce, address _to, uint _value, uint _reward) 
    public returns (bool) 
    {
        bytes32 messageHash = metaTransferHash(_nonce, _to, _value, _reward);
        address signer = recoverSigner(messageHash, _signature);
        validateNonceForSigner(signer, _nonce);
        _transfer(signer, _to, _value);

        if (_reward > 0) 
            _transfer(signer, msg.sender, _reward);
        
        return true;
    }

    function metaTransferFrom(bytes memory _signature, uint _nonce, address _from, address _to, uint _value, uint _reward) 
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="648" endline="666" pcid="616">
    function metaApprove(bytes memory _signature, uint _nonce, address _spender, uint _value, uint _reward) 
    public returns (bool) 
    {
        require(_spender != address(0), "Invalid spender address");

        bytes32 messageHash = metaApproveHash(_nonce, _spender, _value, _reward);
        address signer = recoverSigner(messageHash, _signature);
        validateNonceForSigner(signer, _nonce);
    
        _allowed[signer][_spender] = _value;
       
        if (_reward > 0) 
            _transfer(signer, msg.sender, _reward);

        emit Approval(signer, _spender, _value);
        return true;
    }

    function metaIncreaseAllowance(bytes memory _signature, uint _nonce, address _spender, uint256 _addedValue, uint _reward) 
</source>
</class>

<class classid="117" nclones="2" nlines="5" similarity="100">
<source file="systems/smart_contracts/ALBToken.sol" startline="666" endline="684" pcid="617">
    function metaIncreaseAllowance(bytes memory _signature, uint _nonce, address _spender, uint256 _addedValue, uint _reward) 
    public returns (bool) 
    {
        require(_spender != address(0), "Invalid spender address");

        bytes32 messageHash = metaIncreaseAllowanceHash(_nonce, _spender, _addedValue, _reward);
        address signer = recoverSigner(messageHash, _signature);
        validateNonceForSigner(signer, _nonce);

        _allowed[signer][_spender] = _allowed[signer][_spender].add(_addedValue);

        if (_reward > 0) 
            _transfer(signer, msg.sender, _reward);

        emit Approval(signer, _spender, _allowed[signer][_spender]);
        return true;
    }

    function metaDecreaseAllowance(bytes memory _signature, uint _nonce, address _spender, uint256 _subtractedValue, uint _reward) 
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="684" endline="702" pcid="618">
    function metaDecreaseAllowance(bytes memory _signature, uint _nonce, address _spender, uint256 _subtractedValue, uint _reward) 
    public returns (bool) 
    {
        require(_spender != address(0), "Invalid spender address");

        bytes32 messageHash = metaDecreaseAllowanceHash(_nonce, _spender, _subtractedValue, _reward);
        address signer = recoverSigner(messageHash, _signature);
        validateNonceForSigner(signer, _nonce);

        _allowed[signer][_spender] = _allowed[signer][_spender].sub(_subtractedValue);

        if (_reward > 0) 
            _transfer(signer, msg.sender, _reward);
        
        emit Approval(signer, _spender, _allowed[signer][_spender]);
        return true;
    }

    function metaTransferHash(uint _nonce, address _to, uint _value, uint _reward) public view returns (bytes32) {
</source>
</class>

<class classid="118" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/ALBToken.sol" startline="702" endline="706" pcid="619">
    function metaTransferHash(uint _nonce, address _to, uint _value, uint _reward) public view returns (bytes32) {
        return keccak256(abi.encodePacked(address(this), "metaTransfer", _nonce, _to, _value, _reward)); 
    }

    function metaApproveAndCallHash(uint _nonce, address _spender, uint _value, bytes memory _data, uint _reward) 
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="715" endline="719" pcid="622">
    function metaApproveHash(uint _nonce, address _spender, uint _value, uint _reward) public view returns (bytes32) {
        return keccak256(abi.encodePacked(address(this), "metaApprove", _nonce, _spender, _value, _reward)); 
    }

    function metaIncreaseAllowanceHash(uint _nonce, address _spender, uint256 _addedValue, uint _reward) public view returns (bytes32) {
</source>
</class>

<class classid="119" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/ALBToken.sol" startline="719" endline="723" pcid="623">
    function metaIncreaseAllowanceHash(uint _nonce, address _spender, uint256 _addedValue, uint _reward) public view returns (bytes32) {
        return keccak256(abi.encodePacked(address(this), "metaIncreaseAllowance", _nonce, _spender, _addedValue, _reward));
    }

    function metaDecreaseAllowanceHash(uint _nonce, address _spender, uint256 _subtractedValue, uint _reward) public view returns (bytes32) {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="723" endline="727" pcid="624">
    function metaDecreaseAllowanceHash(uint _nonce, address _spender, uint256 _subtractedValue, uint _reward) public view returns (bytes32) {
        return keccak256(abi.encodePacked(address(this), "metaDecreaseAllowance", _nonce, _spender, _subtractedValue, _reward));
    }
    
}
</source>
</class>

<class classid="120" nclones="2" nlines="7" similarity="100">
<source file="systems/smart_contracts/ALBToken.sol" startline="766" endline="779" pcid="628">
    function freezingCount(address _addr) public view returns (uint count) {
        uint64 release = chains[toKey(_addr, 0)];
        while (release != 0) {
            count++;
            release = chains[toKey(_addr, release)];
        }
    }

    /**
     * @dev gets freezing end date and freezing balance for the freezing portion specified by index.
     * @param _addr Address of freeze tokens owner.
     * @param _index Freezing portion index. It ordered by release date descending.
     */
    function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="247" endline="255" pcid="4664">
    function freezingCount(address _addr) public view returns (uint count) {
        uint64 release = chains[toKey(_addr, 0)];
        while (release != 0) {
            count++;
            release = chains[toKey(_addr, release)];
        }
    }

    function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {
</source>
</class>

<class classid="121" nclones="2" nlines="11" similarity="90">
<source file="systems/smart_contracts/ALBToken.sol" startline="779" endline="797" pcid="629">
    function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {
        for (uint i = 0; i < _index + 1; i++) {
            _release = chains[toKey(_addr, _release)];
            if (_release == 0) {
                return(0, 0);
            }
        }
        _balance = freezings[toKey(_addr, _release)];
    }

    /**
     * @dev freeze your tokens to the specified address.
     *      Be careful, gas usage is not deterministic,
     *      and depends on how many freezes _to address already has.
     * @param _to Address to which token will be freeze.
     * @param _amount Amount of token to freeze.
     * @param _until Release date, must be in future.
     */
    function freezeTo(address _to, uint _amount, uint64 _until) public {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="255" endline="265" pcid="4665">
    function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {
        for (uint i = 0; i < _index + 1; i++) {
            _release = chains[toKey(_addr, _release)];
            if (_release == 0) {
                return;
            }
        }
        _balance = freezings[toKey(_addr, _release)];
    }

    function freezeTo(address _to, uint _amount, uint64 _until) public {
</source>
</class>

<class classid="122" nclones="3" nlines="4" similarity="75">
<source file="systems/smart_contracts/ALBToken.sol" startline="797" endline="801" pcid="630">
    function freezeTo(address _to, uint _amount, uint64 _until) public {
        _freezeTo(msg.sender, _to, _amount, _until);
    }

    function _freezeTo(address _from, address _to, uint _amount, uint64 _until) internal {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="265" endline="280" pcid="4666">
    function freezeTo(address _to, uint _amount, uint64 _until) public {
        require(_to != address(0));
        require(_amount <= balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_amount);

        bytes32 currentKey = toKey(_to, _until);
        freezings[currentKey] = freezings[currentKey].add(_amount);
        freezingBalance[_to] = freezingBalance[_to].add(_amount);

        freeze(_to, _until);
        emit Transfer(msg.sender, _to, _amount);
        emit Freezed(_to, _until, _amount);
    }

    function releaseOnce() public {
</source>
<source file="systems/smart_contracts/Discover.sol" startline="88" endline="101" pcid="2762">
    function createDApp(bytes32 _id, uint _amount, bytes32 _metadata) external {
        _createDApp(
            msg.sender,
            _id,
            _amount,
            _metadata);
    }

    /**
     * @dev Sends SNT directly to the contract, not the developer. This gets added to the DApp's balance, no curve required.
     * @param _id bytes32 unique identifier.
     * @param _amount of tokens to stake on DApp's ranking. Used for upvoting + staking more.
     */
    function upvote(bytes32 _id, uint _amount) external {
</source>
</class>

<class classid="123" nclones="2" nlines="13" similarity="100">
<source file="systems/smart_contracts/ALBToken.sol" startline="819" endline="847" pcid="632">
    function releaseOnce() public {
        bytes32 headKey = toKey(msg.sender, 0);
        uint64 head = chains[headKey];
        require(head != 0);
        require(uint64(block.timestamp) > head);
        bytes32 currentKey = toKey(msg.sender, head);

        uint64 next = chains[currentKey];

        uint amount = freezings[currentKey];
        delete freezings[currentKey];

        _balances[msg.sender] = _balances[msg.sender].add(amount);
        freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);

        if (next == 0) {
            delete chains[headKey];
        } else {
            chains[headKey] = next;
            delete chains[currentKey];
        }
        emit Released(msg.sender, amount);
    }

    /**
     * @dev release all available for release freezing tokens. Gas usage is not deterministic!
     * @return how many tokens was released
     */
    function releaseAll() public returns (uint tokens) {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="280" endline="304" pcid="4667">
    function releaseOnce() public {
        bytes32 headKey = toKey(msg.sender, 0);
        uint64 head = chains[headKey];
        require(head != 0);
        require(uint64(block.timestamp) > head);
        bytes32 currentKey = toKey(msg.sender, head);

        uint64 next = chains[currentKey];

        uint amount = freezings[currentKey];
        delete freezings[currentKey];

        balances[msg.sender] = balances[msg.sender].add(amount);
        freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);

        if (next == 0) {
            delete chains[headKey];
        } else {
            chains[headKey] = next;
            delete chains[currentKey];
        }
        emit Released(msg.sender, amount);
    }

    function releaseAll() public returns (uint tokens) {
</source>
</class>

<class classid="124" nclones="2" nlines="7" similarity="100">
<source file="systems/smart_contracts/ALBToken.sol" startline="847" endline="858" pcid="633">
    function releaseAll() public returns (uint tokens) {
        uint release;
        uint balance;
        (release, balance) = getFreezing(msg.sender, 0);
        while (release != 0 && block.timestamp > release) {
            releaseOnce();
            tokens += balance;
            (release, balance) = getFreezing(msg.sender, 0);
        }
    }

    function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="304" endline="315" pcid="4668">
    function releaseAll() public returns (uint tokens) {
        uint release;
        uint balance;
        (release, balance) = getFreezing(msg.sender, 0);
        while (release != 0 && block.timestamp > release) {
            releaseOnce();
            tokens += balance;
            (release, balance) = getFreezing(msg.sender, 0);
        }
    }

    function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {
</source>
</class>

<class classid="125" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/ALBToken.sol" startline="858" endline="867" pcid="634">
    function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {
        // WISH masc to increase entropy
        result = 0x5749534800000000000000000000000000000000000000000000000000000000;
        assembly {
            result := or(result, mul(_addr, 0x10000000000000000))
            result := or(result, _release)
        }
    }

    function freeze(address _to, uint64 _until) internal {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="315" endline="323" pcid="4669">
    function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {
        result = 0x5749534800000000000000000000000000000000000000000000000000000000;
        assembly {
            result := or(result, mul(_addr, 0x10000000000000000))
            result := or(result, _release)
        }
    }

    function freeze(address _to, uint64 _until) internal {
</source>
</class>

<class classid="126" nclones="2" nlines="20" similarity="100">
<source file="systems/smart_contracts/ALBToken.sol" startline="867" endline="903" pcid="635">
    function freeze(address _to, uint64 _until) internal {
        require(_until > block.timestamp);
        bytes32 key = toKey(_to, _until);
        bytes32 parentKey = toKey(_to, uint64(0));
        uint64 next = chains[parentKey];

        if (next == 0) {
            chains[parentKey] = _until;
            return;
        }

        bytes32 nextKey = toKey(_to, next);
        uint parent;

        while (next != 0 && _until > next) {
            parent = next;
            parentKey = nextKey;

            next = chains[nextKey];
            nextKey = toKey(_to, next);
        }

        if (_until == next) {
            return;
        }

        if (next != 0) {
            chains[key] = next;
        }

        chains[parentKey] = _until;
    }

    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address _token, address _to, uint _value) public onlyOwner returns (bool) {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="323" endline="355" pcid="4670">
    function freeze(address _to, uint64 _until) internal {
        require(_until > block.timestamp);
        bytes32 key = toKey(_to, _until);
        bytes32 parentKey = toKey(_to, uint64(0));
        uint64 next = chains[parentKey];

        if (next == 0) {
            chains[parentKey] = _until;
            return;
        }

        bytes32 nextKey = toKey(_to, next);
        uint parent;

        while (next != 0 && _until > next) {
            parent = next;
            parentKey = nextKey;

            next = chains[nextKey];
            nextKey = toKey(_to, next);
        }

        if (_until == next) {
            return;
        }

        if (next != 0) {
            chains[key] = next;
        }

        chains[parentKey] = _until;
    }
}
</source>
</class>

<class classid="127" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/ALBToken.sol" startline="903" endline="906" pcid="636">
    function transferAnyERC20Token(address _token, address _to, uint _value) public onlyOwner returns (bool) {
        return IERC20(_token).transfer(_to, _value);
    }
}
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="368" endline="387" pcid="6448">
  function canBeTransferred(address token, address user, uint newAmt) private view returns(bool) {
    return (token == seedToken || IERC20(token).okToTransferTokens(user, newAmt + tokens[token][user]) ) ;
  }

  /**
  * This function checks the available volume for a given order.
  * Note: tokenGet & tokenGive can be the Ethereum contract address.
  * @param tokenGet Ethereum contract address of the token to receive
  * @param amountGet uint amount of tokens being received
  * @param tokenGive Ethereum contract address of the token to give
  * @param amountGive uint amount of tokens being given
  * @param expires uint of block number when this order should expire
  * @param nonce arbitrary random number
  * @param user Ethereum address of the user who placed the order
  * @param v part of signature for the order hash as signed by user
  * @param r part of signature for the order hash as signed by user
  * @param s part of signature for the order hash as signed by user
  * @return uint: amount of volume available for the given order in terms of amountGet / tokenGet
  */
  function availableVolume(
</source>
</class>

<class classid="128" nclones="5" nlines="7" similarity="85">
<source file="systems/smart_contracts/Alfa_quiz.sol" startline="9" endline="19" pcid="637">
    function Try(string _response) external payable 
    {
        require(msg.sender == tx.origin);

        if(responseHash == keccak256(_response) && msg.value > 1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }

    string public question;
</source>
<source file="systems/smart_contracts/quiz_BLZ.sol" startline="9" endline="19" pcid="5934">
    function Try(string _response) external payable 
    {
        require(msg.sender == tx.origin);

        if(responseHash == keccak256(_response) && msg.value > 1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }

    string public question;
</source>
<source file="systems/smart_contracts/En_GAME.sol" startline="9" endline="19" pcid="2940">
    function Try(string _response) external payable 
    {
        require(msg.sender == tx.origin);

        if(responseHash == keccak256(_response) && msg.value > 0.4 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }

    string public question;
</source>
<source file="systems/smart_contracts/play_IQuiz.sol" startline="9" endline="19" pcid="5663">
    function Try(string _response) external payable 
    {
        require(msg.sender == tx.origin);

        if(responseHash == keccak256(_response) && msg.value > 0.4 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }

    string public question;
</source>
<source file="systems/smart_contracts/Digital_QUIZ.sol" startline="9" endline="19" pcid="2728">
    function Try(string _response) external payable 
    {
        require(msg.sender == tx.origin);

        if(responseHash == keccak256(_response) && msg.value > 1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }

    string public question;
</source>
</class>

<class classid="129" nclones="5" nlines="7" similarity="100">
<source file="systems/smart_contracts/Alfa_quiz.sol" startline="25" endline="32" pcid="638">
    function Start(string _question, string _response) public payable isAdmin{
        if(responseHash==0x0){
            responseHash = keccak256(_response);
            question = _question;
        }
    }

    function Stop() public payable isAdmin {
</source>
<source file="systems/smart_contracts/play_IQuiz.sol" startline="25" endline="32" pcid="5664">
    function Start(string _question, string _response) public payable isAdmin{
        if(responseHash==0x0){
            responseHash = keccak256(_response);
            question = _question;
        }
    }

    function Stop() public payable isAdmin {
</source>
<source file="systems/smart_contracts/Digital_QUIZ.sol" startline="25" endline="32" pcid="2729">
    function Start(string _question, string _response) public payable isAdmin{
        if(responseHash==0x0){
            responseHash = keccak256(_response);
            question = _question;
        }
    }

    function Stop() public payable isAdmin {
</source>
<source file="systems/smart_contracts/quiz_BLZ.sol" startline="25" endline="32" pcid="5935">
    function Start(string _question, string _response) public payable isAdmin{
        if(responseHash==0x0){
            responseHash = keccak256(_response);
            question = _question;
        }
    }

    function Stop() public payable isAdmin {
</source>
<source file="systems/smart_contracts/En_GAME.sol" startline="25" endline="32" pcid="2941">
    function Start(string _question, string _response) public payable isAdmin{
        if(responseHash==0x0){
            responseHash = keccak256(_response);
            question = _question;
        }
    }

    function Stop() public payable isAdmin {
</source>
</class>

<class classid="130" nclones="5" nlines="4" similarity="100">
<source file="systems/smart_contracts/Alfa_quiz.sol" startline="36" endline="41" pcid="640">
    function New(string _question, bytes32 _responseHash) public payable isAdmin {
        question = _question;
        responseHash = _responseHash;
    }

    constructor(bytes32[] admins) public{
</source>
<source file="systems/smart_contracts/Digital_QUIZ.sol" startline="36" endline="41" pcid="2731">
    function New(string _question, bytes32 _responseHash) public payable isAdmin {
        question = _question;
        responseHash = _responseHash;
    }

    constructor(bytes32[] admins) public{
</source>
<source file="systems/smart_contracts/En_GAME.sol" startline="36" endline="41" pcid="2943">
    function New(string _question, bytes32 _responseHash) public payable isAdmin {
        question = _question;
        responseHash = _responseHash;
    }

    constructor(bytes32[] admins) public{
</source>
<source file="systems/smart_contracts/play_IQuiz.sol" startline="36" endline="41" pcid="5666">
    function New(string _question, bytes32 _responseHash) public payable isAdmin {
        question = _question;
        responseHash = _responseHash;
    }

    constructor(bytes32[] admins) public{
</source>
<source file="systems/smart_contracts/quiz_BLZ.sol" startline="36" endline="41" pcid="5937">
    function New(string _question, bytes32 _responseHash) public payable isAdmin {
        question = _question;
        responseHash = _responseHash;
    }

    constructor(bytes32[] admins) public{
</source>
</class>

<class classid="131" nclones="22" nlines="12" similarity="75">
<source file="systems/smart_contracts/AronCoin.sol" startline="169" endline="180" pcid="771">
  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

}
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="253" endline="264" pcid="6789">
  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

}
</source>
<source file="systems/smart_contracts/NBToken.sol" startline="231" endline="241" pcid="5314">
    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
            allowed[msg.sender][_spender] = 0;
        } else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/Ownable.sol" startline="141" endline="153" pcid="5576">
    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
          allowed[msg.sender][_spender] = 0;
        } else {
          allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
     }
    

    function getBalance(address _a) internal constant returns(uint256)
</source>
<source file="systems/smart_contracts/CST_TOKEN.sol" startline="108" endline="118" pcid="2207">
  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
}
</source>
<source file="systems/smart_contracts/TorexToken.sol" startline="275" endline="292" pcid="7422">
  function decreaseApproval(
    address _spender,
    uint _subtractedValue
  )
    public
    returns (bool)
  {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

}
</source>
<source file="systems/smart_contracts/UTC.sol" startline="212" endline="223" pcid="7588">
  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

}
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="323" endline="339" pcid="8091">
  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = _allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      _allowed[msg.sender][_spender] = 0;
    } else {
      _allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, _allowed[msg.sender][_spender]);
    return true;
  }


  /**
   * @dev Function to toggle token actions
   * 
   */
  function toggleActions()  onlyOwner public {
</source>
<source file="systems/smart_contracts/SellableToken.sol" startline="100" endline="111" pcid="6470">
  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

}
</source>
<source file="systems/smart_contracts/LBBT.sol" startline="116" endline="133" pcid="4547">
  function decreaseApproval(
    address _spender,
    uint256 _subtractedValue
  )
    public
    returns (bool)
  {
    uint256 oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

}
</source>
<source file="systems/smart_contracts/SistContract.sol" startline="183" endline="194" pcid="6528">
  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

}
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="643" endline="660" pcid="6629">
	function decreaseApproval(
		address _spender,
		uint256 _subtractedValue
	)
	public
	returns (bool)
	{
		uint256 oldValue = allowed[msg.sender][_spender];
		if (_subtractedValue > oldValue) {
			allowed[msg.sender][_spender] = 0;
		} else {
			allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
		}
		emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
		return true;
	}

}
</source>
<source file="systems/smart_contracts/CDS.sol" startline="282" endline="303" pcid="1668">
  function decreaseApproval(
    address _spender,
    uint256 _subtractedValue
  )
    public
    returns (bool)
  {
    uint256 oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue >= oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  /**
   * @dev Burns a specific amount of tokens.
   * @param _value The amount of token to be burned.
   */
  function burn(uint256 _value) public {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="136" endline="153" pcid="4655">
  function decreaseApproval(
    address _spender,
    uint _subtractedValue
  )
    public
    returns (bool)
  {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

}
</source>
<source file="systems/smart_contracts/customIcoToken.sol" startline="106" endline="117" pcid="2218">
    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
            allowed[msg.sender][_spender] = 0;
        } else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
  }

    function transfer(address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="179" endline="196" pcid="2057">
    function decreaseApproval(
        address _spender,
        uint _subtractedValue
    )
        public
        returns (bool)
    {
        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
            allowed[msg.sender][_spender] = 0;
        } else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }

}
</source>
<source file="systems/smart_contracts/MBA.sol" startline="327" endline="344" pcid="4724">
  function decreaseApproval(
    address _spender,
    uint256 _subtractedValue
  )
    public
    returns (bool)
  {
    uint256 oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

}
</source>
<source file="systems/smart_contracts/BlockPoolToken.sol" startline="233" endline="243" pcid="1425">
    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
            allowed[msg.sender][_spender] = 0;
        } else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="169" endline="180" pcid="7755">
  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

}
</source>
<source file="systems/smart_contracts/FMT.sol" startline="139" endline="150" pcid="3658">
  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

}
</source>
<source file="systems/smart_contracts/BFGToken.sol" startline="136" endline="147" pcid="1194">
  function decreaseApproval(address agent, uint value) public returns (bool) {
    uint allowanceValue = _allowances[msg.sender][agent];
    if (value > allowanceValue) {
      _allowances[msg.sender][agent] = 0;
    } else {
      _allowances[msg.sender][agent] = allowanceValue.sub(value);
    }
    emit Approval(msg.sender, agent, _allowances[msg.sender][agent]);
    return true;
  }
  // internal functions
}
</source>
<source file="systems/smart_contracts/CoinDDC.sol" startline="123" endline="150" pcid="1869">
    function decreaseApproval(
        address _spender,
        uint256 _subtractedValue
    )
    public
    returns (bool)
    {
        uint256 oldValue = allowed[msg.sender][_spender];

        if (_subtractedValue > oldValue) {
            allowed[msg.sender][_spender] = 0;
        } 
        else 
        {
            allowed[msg.sender][_spender] = sub(oldValue, _subtractedValue);
        }
        
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }

    
    

     
    

    modifier admin_only()
</source>
</class>

<class classid="132" nclones="3" nlines="4" similarity="75">
<source file="systems/smart_contracts/AronCoin.sol" startline="255" endline="264" pcid="774">
  function pause(bool newPausedPublic, bool newPausedOwnerAdmin) onlyOwner public {
    require(!(newPausedPublic == false && newPausedOwnerAdmin == true));

    pausedPublic = newPausedPublic;
    pausedOwnerAdmin = newPausedOwnerAdmin;

    PausePublic(newPausedPublic);
    PauseOwnerAdmin(newPausedOwnerAdmin);
  }
}
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="174" endline="183" pcid="6781">
  function pause(bool newPausedPublic, bool newPausedOwnerAdmin) public onlyOwner {
    require(!(newPausedPublic == false && newPausedOwnerAdmin == true), "PausedPublic can't be false while pausedOwnerAdmin is true");

    pausedPublic = newPausedPublic;
    pausedOwnerAdmin = newPausedOwnerAdmin;

    emit PausePublic(newPausedPublic);
    emit PauseOwnerAdmin(newPausedOwnerAdmin);
  }
}
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="255" endline="264" pcid="7758">
  function pause(bool newPausedPublic, bool newPausedOwnerAdmin) onlyOwner public {
    require(!(newPausedPublic == false && newPausedOwnerAdmin == true));

    pausedPublic = newPausedPublic;
    pausedOwnerAdmin = newPausedOwnerAdmin;

    PausePublic(newPausedPublic);
    PauseOwnerAdmin(newPausedOwnerAdmin);
  }
}
</source>
</class>

<class classid="133" nclones="3" nlines="4" similarity="75">
<source file="systems/smart_contracts/AronCoin.sol" startline="302" endline="313" pcid="780">
    function AronCoin( address _admin, uint _totalTokenAmount ) 
    {
        // assign the admin account
        admin = _admin;

        // assign the total tokens to Aron Coin
        totalSupply = _totalTokenAmount;
        balances[msg.sender] = _totalTokenAmount;
        Transfer(address(0x0), msg.sender, _totalTokenAmount);
    }

    function transfer(address _to, uint _value) validDestination(_to) returns (bool) 
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="302" endline="313" pcid="7764">
    function VisionBitcoinCash( address _admin, uint _totalTokenAmount ) 
    {
        // assign the admin account
        admin = _admin;

        // assign the total tokens to Vision Bitcoin Cash
        totalSupply = _totalTokenAmount;
        balances[msg.sender] = _totalTokenAmount;
        Transfer(address(0x0), msg.sender, _totalTokenAmount);
    }

    function transfer(address _to, uint _value) validDestination(_to) returns (bool) 
</source>
<source file="systems/smart_contracts/OMGToken.sol" startline="166" endline="184" pcid="5496">
  function approve(address _spender, uint _value) {

    // To change the approve amount you first have to reduce the addresses`
    //  allowance to zero by calling `approve(_spender, 0)` if it is not
    //  already 0 to mitigate the race condition described here:
    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;

    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
  }

  /**
   * @dev Function to check the amount of tokens than an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint specifing the amount of tokens still avaible for the spender.
   */
  function allowance(address _owner, address _spender) constant returns (uint remaining) {
</source>
</class>

<class classid="134" nclones="5" nlines="4" similarity="75">
<source file="systems/smart_contracts/AronCoin.sol" startline="318" endline="323" pcid="782">
    function transferFrom(address _from, address _to, uint _value) validDestination(_to) returns (bool) 
    {
        return super.transferFrom(_from, _to, _value);
    }

    event Burn(address indexed _burner, uint _value);
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="318" endline="323" pcid="7766">
    function transferFrom(address _from, address _to, uint _value) validDestination(_to) returns (bool) 
    {
        return super.transferFrom(_from, _to, _value);
    }

    event Burn(address indexed _burner, uint _value);
</source>
<source file="systems/smart_contracts/ScipayToken.sol" startline="28" endline="32" pcid="6377">
    function transferFrom(address _from, address _to, uint _amount) public returns(bool) {
        return super.transferFrom(_from, _to, _amount);
    }

    function mint(address _for, uint _amount) public onlyMintablePermission {
</source>
<source file="systems/smart_contracts/ProofOfContributionChainToken.sol" startline="51" endline="62" pcid="5828">
    function transferFrom(address from, address buyer, uint numTokens) public returns (bool) {
        require(numTokens <= balances[from]);
        require(numTokens <= allowed[from][msg.sender]);

        balances[from] = balances[from].sub(numTokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(numTokens);
        balances[buyer] = balances[buyer].add(numTokens);
        emit Transfer(from, buyer, numTokens);
        return true;
    }

    function burnFrom(address from, uint numTokens) public returns (bool) {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="3049" endline="3063" pcid="6945">
    function transferFrom(address from, address to, uint value)
        public
        returns (bool)
    {
        bytes memory empty;
        return transferFrom(from, to, value, empty);
    }

    /**
     * @notice ERC223 transferFrom function. Does not conform with the ERC223 spec, as:
     *         - Transaction doesn't revert if the recipient doesn't implement tokenFallback()
     *         - Emits a standard ERC20 event without the bytes data parameter so as not to confuse
     *           tooling such as Etherscan.
     */
    function transferFrom(address from, address to, uint value, bytes data)
</source>
</class>

<class classid="135" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/AronCoin.sol" startline="325" endline="335" pcid="783">
    function burn(uint _value) returns (bool)
    {
        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalSupply = totalSupply.sub(_value);
        Burn(msg.sender, _value);
        Transfer(msg.sender, address(0x0), _value);
        return true;
    }

    // save some gas by making only one contract call
    function burnFrom(address _from, uint256 _value) returns (bool) 
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="325" endline="335" pcid="7767">
    function burn(uint _value) returns (bool)
    {
        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalSupply = totalSupply.sub(_value);
        Burn(msg.sender, _value);
        Transfer(msg.sender, address(0x0), _value);
        return true;
    }

    // save some gas by making only one contract call
    function burnFrom(address _from, uint256 _value) returns (bool) 
</source>
</class>

<class classid="136" nclones="3" nlines="4" similarity="75">
<source file="systems/smart_contracts/AronCoin.sol" startline="335" endline="341" pcid="784">
    function burnFrom(address _from, uint256 _value) returns (bool) 
    {
        assert( transferFrom( _from, msg.sender, _value ) );
        return burn(_value);
    }

    function emergencyERC20Drain( ERC20 token, uint amount ) onlyOwner {
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="234" endline="252" pcid="8086">
  function transfer(address _to, uint256 _value) returns (bool) {    
      require(_to != address(0)); // Prevent transfer to 0x0 address.
      require(_value <= _balances[msg.sender]);  // Check if the sender has enough      

      // SafeMath.sub will throw if there is not enough balance.
      _balances[msg.sender] = _balances[msg.sender].sub(_value);
      _balances[_to] = _balances[_to].add(_value);
      emit Transfer(msg.sender, _to, _value);
      return true;
  }


  /**
   * @dev Transfer tokens from one address to another
   * @param _from address The address which you want to send tokens from
   * @param _to address The address which you want to transfer to
   * @param _value uint256 the amount of tokens to be transferred
   */
  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="335" endline="341" pcid="7768">
    function burnFrom(address _from, uint256 _value) returns (bool) 
    {
        assert( transferFrom( _from, msg.sender, _value ) );
        return burn(_value);
    }

    function emergencyERC20Drain( ERC20 token, uint amount ) onlyOwner {
</source>
</class>

<class classid="137" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/AronCoin.sol" startline="341" endline="346" pcid="785">
    function emergencyERC20Drain( ERC20 token, uint amount ) onlyOwner {
        // owner can drain tokens that are sent here by mistake
        token.transfer( owner, amount );
    }

    event AdminTransferred(address indexed previousAdmin, address indexed newAdmin);
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="341" endline="346" pcid="7769">
    function emergencyERC20Drain( ERC20 token, uint amount ) onlyOwner {
        // owner can drain tokens that are sent here by mistake
        token.transfer( owner, amount );
    }

    event AdminTransferred(address indexed previousAdmin, address indexed newAdmin);
</source>
</class>

<class classid="138" nclones="37" nlines="4" similarity="75">
<source file="systems/smart_contracts/AT.sol" startline="11" endline="17" pcid="787">
  function safeMul(uint256 a, uint256 b) internal returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint256 a, uint256 b) internal returns (uint256) {
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="32" endline="38" pcid="7954">
    function safeMult(uint256 x, uint256 y) internal returns(uint256) {
        uint256 z = x * y;
        assert((x == 0)||(z/x == y));
        return z;
    }
 
}
</source>
<source file="systems/smart_contracts/AT.sol" startline="17" endline="24" pcid="788">
  function safeDiv(uint256 a, uint256 b) internal returns (uint256) {
    assert(b > 0);
    uint256 c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint256 a, uint256 b) internal returns (uint256) {
</source>
<source file="systems/smart_contracts/Hda.sol" startline="26" endline="32" pcid="4219">
  function safeAdd(uint256 a, uint256 b) internal returns (uint256) {
    uint256 c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

  function assert(bool assertion) internal {
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="26" endline="32" pcid="7953">
    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {
        assert(x >= y);
        uint256 z = x - y;
        return z;
    }
 
    function safeMult(uint256 x, uint256 y) internal returns(uint256) {
</source>
<source file="systems/smart_contracts/Hda.sol" startline="21" endline="26" pcid="4218">
  function safeSub(uint256 a, uint256 b) internal returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint256 a, uint256 b) internal returns (uint256) {
</source>
<source file="systems/smart_contracts/Hda.sol" startline="14" endline="21" pcid="4217">
  function safeDiv(uint256 a, uint256 b) internal returns (uint256) {
    assert(b > 0);
    uint256 c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint256 a, uint256 b) internal returns (uint256) {
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="20" endline="26" pcid="7952">
    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {
        uint256 z = x + y;
        assert((z >= x) && (z >= y));
        return z;
    }
 
    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="14" endline="20" pcid="4066">
    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {
        uint256 z = x + y;
        assert((z >= x) && (z >= y));
        return z;
    }
 
    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="20" endline="26" pcid="4067">
    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {
        assert(x >= y);
        uint256 z = x - y;
        return z;
    }
 
    function safeMult(uint256 x, uint256 y) internal returns(uint256) {
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="26" endline="32" pcid="4068">
    function safeMult(uint256 x, uint256 y) internal returns(uint256) {
        uint256 z = x * y;
        assert((x == 0)||(z/x == y));
        return z;
    }
 
}
</source>
<source file="systems/smart_contracts/Hda.sol" startline="8" endline="14" pcid="4216">
  function safeMul(uint256 a, uint256 b) internal returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint256 a, uint256 b) internal returns (uint256) {
</source>
<source file="systems/smart_contracts/AT.sol" startline="29" endline="35" pcid="790">
  function safeAdd(uint256 a, uint256 b) internal returns (uint256) {
    uint256 c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

  function assert(bool assertion) internal {
</source>
<source file="systems/smart_contracts/BermToken.sol" startline="36" endline="42" pcid="1135">
    function safeMult(uint256 x, uint256 y) internal returns(uint256) {
      uint256 z = x * y;
      assert((x == 0)||(z/x == y));
      return z;
    }

}
</source>
<source file="systems/smart_contracts/BermToken.sol" startline="24" endline="30" pcid="1133">
    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {
      uint256 z = x + y;
      assert((z >= x) && (z >= y));
      return z;
    }

    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {
</source>
<source file="systems/smart_contracts/AT.sol" startline="24" endline="29" pcid="789">
  function safeSub(uint256 a, uint256 b) internal returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint256 a, uint256 b) internal returns (uint256) {
</source>
<source file="systems/smart_contracts/BermToken.sol" startline="30" endline="36" pcid="1134">
    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {
      assert(x >= y);
      uint256 z = x - y;
      return z;
    }

    function safeMult(uint256 x, uint256 y) internal returns(uint256) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="87" endline="92" pcid="6076">
  function safeSub(uint a, uint b) internal returns (uint) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint a, uint b) internal returns (uint) {
</source>
<source file="systems/smart_contracts/OMGToken.sol" startline="29" endline="34" pcid="5481">
  function sub(uint a, uint b) internal returns (uint) {
    assert(b <= a);
    return a - b;
  }

  function add(uint a, uint b) internal returns (uint) {
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="86" endline="91" pcid="2097">
  function safeSub(uint a, uint b) internal returns (uint) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint a, uint b) internal returns (uint) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="28" endline="33" pcid="4830">
  function safeSub(uint a, uint b) internal returns (uint) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint a, uint b) internal returns (uint) {
</source>
<source file="systems/smart_contracts/CouncilVesting.sol" startline="23" endline="28" pcid="2019">
  function sub(uint a, uint b) internal returns (uint) {
    assert(b <= a);
    return a - b;
  }

  function add(uint a, uint b) internal returns (uint) {
</source>
<source file="systems/smart_contracts/CouncilVesting.sol" startline="12" endline="18" pcid="2017">
  function mul(uint a, uint b) internal returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function div(uint a, uint b) internal returns (uint) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="80" endline="87" pcid="6075">
  function safeDiv(uint a, uint b) internal returns (uint) {
    assert(b > 0);
    uint c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint a, uint b) internal returns (uint) {
</source>
<source file="systems/smart_contracts/CouncilVesting.sol" startline="18" endline="23" pcid="2018">
  function div(uint a, uint b) internal returns (uint) {
    uint c = a / b;
    return c;
  }

  function sub(uint a, uint b) internal returns (uint) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="92" endline="98" pcid="6077">
  function safeAdd(uint a, uint b) internal returns (uint) {
    uint c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

  function max64(uint64 a, uint64 b) internal constant returns (uint64) {
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="73" endline="79" pcid="2095">
  function safeMul(uint a, uint b) internal returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint a, uint b) internal returns (uint) {
</source>
<source file="systems/smart_contracts/OMGToken.sol" startline="34" endline="40" pcid="5482">
  function add(uint a, uint b) internal returns (uint) {
    uint c = a + b;
    assert(c >= a);
    return c;
  }

  function max64(uint64 a, uint64 b) internal constant returns (uint64) {
</source>
<source file="systems/smart_contracts/OMGToken.sol" startline="22" endline="29" pcid="5480">
  function div(uint a, uint b) internal returns (uint) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  function sub(uint a, uint b) internal returns (uint) {
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="79" endline="86" pcid="2096">
  function safeDiv(uint a, uint b) internal returns (uint) {
    assert(b > 0);
    uint c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint a, uint b) internal returns (uint) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="15" endline="21" pcid="4828">
  function safeMul(uint a, uint b) internal returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint a, uint b) internal returns (uint) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="21" endline="28" pcid="4829">
  function safeDiv(uint a, uint b) internal returns (uint) {
    assert(b > 0);
    uint c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint a, uint b) internal returns (uint) {
</source>
<source file="systems/smart_contracts/OMGToken.sol" startline="16" endline="22" pcid="5479">
  function mul(uint a, uint b) internal returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function div(uint a, uint b) internal returns (uint) {
</source>
<source file="systems/smart_contracts/CouncilVesting.sol" startline="28" endline="34" pcid="2020">
  function add(uint a, uint b) internal returns (uint) {
    uint c = a + b;
    assert(c >= a);
    return c;
  }

  function max64(uint64 a, uint64 b) internal constant returns (uint64) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="74" endline="80" pcid="6074">
  function safeMul(uint a, uint b) internal returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint a, uint b) internal returns (uint) {
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="91" endline="97" pcid="2098">
  function safeAdd(uint a, uint b) internal returns (uint) {
    uint c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

  function max64(uint64 a, uint64 b) internal constant returns (uint64) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="33" endline="39" pcid="4831">
  function safeAdd(uint a, uint b) internal returns (uint) {
    uint c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

  function max64(uint64 a, uint64 b) internal constant returns (uint64) {
</source>
</class>

<class classid="139" nclones="3" nlines="7" similarity="100">
<source file="systems/smart_contracts/AT.sol" startline="35" endline="40" pcid="791">
  function assert(bool assertion) internal {
    if (!assertion) {
      throw;
    }
  }
}
</source>
<source file="systems/smart_contracts/OMGToken.sol" startline="56" endline="61" pcid="5487">
  function assert(bool assertion) internal {
    if (!assertion) {
      throw;
    }
  }
}
</source>
<source file="systems/smart_contracts/Hda.sol" startline="32" endline="37" pcid="4220">
  function assert(bool assertion) internal {
    if (!assertion) {
      throw;
    }
  }
}
</source>
</class>

<class classid="140" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/AT.sol" startline="66" endline="81" pcid="792">
    function AT(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens
        totalSupply = initialSupply;                        // Update total supply
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
        decimals = decimalUnits;                            // Amount of decimals for display purposes
		owner = msg.sender;
    }

    /* Send coins */
    function transfer(address _to, uint256 _value) {
</source>
<source file="systems/smart_contracts/Hda.sol" startline="56" endline="71" pcid="4221">
    function Hda(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens
        totalSupply = initialSupply;                        // Update total supply
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
        decimals = decimalUnits;                            // Amount of decimals for display purposes
		owner = msg.sender;
    }

    /* Send coins */
    function transfer(address _to, uint256 _value) {
</source>
</class>

<class classid="141" nclones="5" nlines="4" similarity="75">
<source file="systems/smart_contracts/AT.sol" startline="81" endline="92" pcid="793">
    function transfer(address _to, uint256 _value) {
        if (_to == 0x0) throw;                               // Prevent transfer to 0x0 address. Use burn() instead
		if (_value <= 0) throw; 
        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                     // Subtract from the sender
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }

    /* Allow another contract to spend some tokens in your behalf */
    function approve(address _spender, uint256 _value)
</source>
<source file="systems/smart_contracts/Hda.sol" startline="71" endline="82" pcid="4222">
    function transfer(address _to, uint256 _value) {
        if (_to == 0x0) throw;                               // Prevent transfer to 0x0 address. Use burn() instead
		if (_value <= 0) throw; 
        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                     // Subtract from the sender
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }

    /* Allow another contract to spend some tokens in your behalf */
    function approve(address _spender, uint256 _value)
</source>
<source file="systems/smart_contracts/BermToken.sol" startline="135" endline="150" pcid="1147">
    function BermToken(
        address _ethFundDeposit,
        uint256 _currentSupply)
    {
        ethFundDeposit = _ethFundDeposit;

        isFunding = false;                           //controls pre through crowdsale state
        fundingStartBlock = 0;
        fundingStopBlock = 0;

        currentSupply = formatDecimals(_currentSupply);
        totalSupply = formatDecimals(10000000000);
        if(currentSupply > totalSupply) throw;
    }

    modifier isOwner()  { require(msg.sender == ethFundDeposit); _; }
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="131" endline="147" pcid="7966">
    function WFCToken (
        address _ethFundDeposit,
        uint256 _currentSupply)
    {
        ethFundDeposit = _ethFundDeposit;
 
        isFunding = false;                          //controls pre through crowdsale state
        fundingStartBlock = 0;
        fundingStopBlock = 0;
 
        currentSupply = formatDecimals(_currentSupply);
        totalSupply = formatDecimals(168000000);
        balances[msg.sender] = totalSupply;
        if(currentSupply > totalSupply) throw;
    }
 
    modifier isOwner()  { require(msg.sender == ethFundDeposit); _; }
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="125" endline="141" pcid="4080">
    function GENEToken(
        address _ethFundDeposit,
        uint256 _currentSupply)
    {
        ethFundDeposit = _ethFundDeposit;
 
        isFunding = false;                           //通过控制预CrowdS ale状态
        fundingStartBlock = 0;
        fundingStopBlock = 0;
 
        currentSupply = formatDecimals(_currentSupply);
        totalSupply = formatDecimals(1000000000);
        balances[msg.sender] = totalSupply;
        if(currentSupply > totalSupply) throw;
    }
 
    modifier isOwner()  { require(msg.sender == ethFundDeposit); _; }
</source>
</class>

<class classid="142" nclones="7" nlines="4" similarity="75">
<source file="systems/smart_contracts/AT.sol" startline="92" endline="101" pcid="794">
    function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
       

    /* A contract attempts to get the coins */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/Hda.sol" startline="82" endline="91" pcid="4223">
    function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
       

    /* A contract attempts to get the coins */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="82" endline="88" pcid="7963">
    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
 
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/CouncilVesting.sol" startline="71" endline="72" pcid="2030">
    function approve(address _spender, uint256 _value) returns (bool success) {}
}
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="76" endline="82" pcid="4077">
    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
 
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/BermToken.sol" startline="86" endline="92" pcid="1144">
    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/CouncilVesting.sol" startline="69" endline="70" pcid="2028">
    function transfer(address _to, uint256 _value) returns (bool success) {}
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}
</source>
</class>

<class classid="143" nclones="2" nlines="5" similarity="100">
<source file="systems/smart_contracts/AT.sol" startline="101" endline="114" pcid="795">
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (_to == 0x0) throw;                                // Prevent transfer to 0x0 address. Use burn() instead
		if (_value <= 0) throw; 
        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;     // Check allowance
        balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);                           // Subtract from the sender
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                             // Add the same to the recipient
        allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value);
        Transfer(_from, _to, _value);
        return true;
    }

    function burn(uint256 _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/Hda.sol" startline="91" endline="104" pcid="4224">
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (_to == 0x0) throw;                                // Prevent transfer to 0x0 address. Use burn() instead
		if (_value <= 0) throw; 
        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;     // Check allowance
        balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);                           // Subtract from the sender
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                             // Add the same to the recipient
        allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value);
        Transfer(_from, _to, _value);
        return true;
    }

    function burn(uint256 _value) returns (bool success) {
</source>
</class>

<class classid="144" nclones="4" nlines="4" similarity="75">
<source file="systems/smart_contracts/AT.sol" startline="114" endline="123" pcid="796">
    function burn(uint256 _value) returns (bool success) {
        if (balanceOf[msg.sender] < _value) throw;            // Check if the sender has enough
		if (_value <= 0) throw; 
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                      // Subtract from the sender
        totalSupply = SafeMath.safeSub(totalSupply,_value);                                // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }
	
	function freeze(uint256 _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/AT.sol" startline="123" endline="132" pcid="797">
	function freeze(uint256 _value) returns (bool success) {
        if (balanceOf[msg.sender] < _value) throw;            // Check if the sender has enough
		if (_value <= 0) throw; 
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                      // Subtract from the sender
        freezeOf[msg.sender] = SafeMath.safeAdd(freezeOf[msg.sender], _value);                                // Updates totalSupply
        Freeze(msg.sender, _value);
        return true;
    }
	
	function unfreeze(uint256 _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/Hda.sol" startline="104" endline="112" pcid="4225">
    function burn(uint256 _value) returns (bool success) {
        if (balanceOf[msg.sender] < _value) throw;            // Check if the sender has enough
		if (_value <= 0) throw; 
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                      // Subtract from the sender
        totalSupply = SafeMath.safeSub(totalSupply,_value);                                // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/AT.sol" startline="132" endline="141" pcid="798">
	function unfreeze(uint256 _value) returns (bool success) {
        if (freezeOf[msg.sender] < _value) throw;            // Check if the sender has enough
		if (_value <= 0) throw; 
        freezeOf[msg.sender] = SafeMath.safeSub(freezeOf[msg.sender], _value);                      // Subtract from the sender
		balanceOf[msg.sender] = SafeMath.safeAdd(balanceOf[msg.sender], _value);
        Unfreeze(msg.sender, _value);
        return true;
    }
	
	function withdrawEther(uint256 amount) {
</source>
</class>

<class classid="145" nclones="4" nlines="2" similarity="100">
<source file="systems/smart_contracts/ATDeployer.sol" startline="193" endline="194" pcid="811">
    function setFFPAddresses(address, address) external;
    function setMinterAddress(address) external returns(address);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="193" endline="194" pcid="3766">
    function setFFPAddresses(address, address) external;
    function setMinterAddress(address) external returns(address);
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="494" endline="495" pcid="7040">
    function setFFPAddresses(address, address) external;
    function setMinterAddress(address) external returns(address);
</source>
<source file="systems/smart_contracts/Factory.sol" startline="208" endline="209" pcid="3449">
    function setFFPAddresses(address, address) external;
    function setMinterAddress(address) external returns(address);
</source>
</class>

<class classid="146" nclones="8" nlines="2" similarity="100">
<source file="systems/smart_contracts/ATDeployer.sol" startline="194" endline="195" pcid="812">
    function setMinterAddress(address) external returns(address);
    function getMinterAddress() external view returns(address);
</source>
<source file="systems/smart_contracts/Factory.sol" startline="209" endline="210" pcid="3450">
    function setMinterAddress(address) external returns(address);
    function getMinterAddress() external view returns(address);
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="197" endline="199" pcid="815">
    function setWalletOnTopAddress(address) external returns(address);

    function addWLManagers(address) external;
</source>
<source file="systems/smart_contracts/Factory.sol" startline="212" endline="214" pcid="3453">
    function setWalletOnTopAddress(address) external returns(address);

    function addWLManagers(address) external;
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="194" endline="195" pcid="3767">
    function setMinterAddress(address) external returns(address);
    function getMinterAddress() external view returns(address);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="197" endline="199" pcid="3770">
    function setWalletOnTopAddress(address) external returns(address);

    function addWLManagers(address) external;
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="495" endline="496" pcid="7041">
    function setMinterAddress(address) external returns(address);
    function getMinterAddress() external view returns(address);
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="498" endline="500" pcid="7044">
    function setWalletOnTopAddress(address) external returns(address);

    function addWLManagers(address) external;
</source>
</class>

<class classid="147" nclones="46" nlines="2" similarity="100">
<source file="systems/smart_contracts/ATDeployer.sol" startline="201" endline="202" pcid="818">
    function isWLManager(address) external view returns (bool);
    function addWLOperators(address) external;
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="110" endline="111" pcid="6424">
    function isFactoryDeployer(address) external view returns(bool);
    function isFactoryATGenerated(address) external view returns(bool);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="546" endline="547" pcid="3829">
    function isImportedContract(address) external view returns (bool);
    function getImportedContractRate(address) external view returns (uint256);
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="524" endline="525" pcid="7067">
    function isFundsUnlockerOperator(address) external view returns (bool);
    function renounceFundsUnlockerOperators() external;
</source>
<source file="systems/smart_contracts/Factory.sol" startline="243" endline="244" pcid="3480">
    function getMaxWLAmount(address) external view returns(uint256);
    function getWLLength() external view returns(uint256);
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="245" endline="246" pcid="855">
    function isFactoryTGenerated(address) external view returns(bool);
    function isFactoryFPGenerated(address) external view returns(bool);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="214" endline="215" pcid="3785">
    function isFundingOperator(address) external view returns (bool);
    function renounceFundingOperators() external;
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="201" endline="202" pcid="3773">
    function isWLManager(address) external view returns (bool);
    function addWLOperators(address) external;
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="228" endline="229" pcid="3797">
    function getMaxWLAmount(address) external view returns(uint256);
    function getWLLength() external view returns(uint256);
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="546" endline="547" pcid="7084">
    function isImportedContract(address) external view returns (bool);
    function getImportedContractRate(address) external view returns (uint256);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="226" endline="227" pcid="3795">
    function isWhitelisted(address) external view returns(bool);
    function getWLThresholdBalance() external view returns (uint256);
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="223" endline="224" pcid="838">
    function isFundsUnlockerOperator(address) external view returns (bool);
    function renounceFundsUnlockerOperators() external;
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="502" endline="503" pcid="7047">
    function isWLManager(address) external view returns (bool);
    function addWLOperators(address) external;
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="547" endline="548" pcid="3830">
    function getImportedContractRate(address) external view returns (uint256);
    function setImportedContract(address, uint256) external;
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="219" endline="220" pcid="3789">
    function isFundsUnlockerManager(address) external view returns (bool);
    function addFundsUnlockerOperators(address) external;
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="228" endline="229" pcid="842">
    function getMaxWLAmount(address) external view returns(uint256);
    function getWLLength() external view returns(uint256);
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="214" endline="215" pcid="830">
    function isFundingOperator(address) external view returns (bool);
    function renounceFundingOperators() external;
</source>
<source file="systems/smart_contracts/Factory.sol" startline="241" endline="242" pcid="3478">
    function isWhitelisted(address) external view returns(bool);
    function getWLThresholdBalance() external view returns (uint256);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="205" endline="206" pcid="3777">
    function isWLOperator(address) external view returns (bool);
    function renounceWLOperators() external;
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="113" endline="114" pcid="6427">
    function isFactoryFPGenerated(address) external view returns(bool);
    function getTotalDeployer() external view returns(uint256);
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="111" endline="112" pcid="6425">
    function isFactoryATGenerated(address) external view returns(bool);
    function isFactoryTGenerated(address) external view returns(bool);
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="511" endline="512" pcid="7055">
    function isFundingManager(address) external view returns (bool);
    function addFundingOperators(address) external;
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="745" endline="746" pcid="3855">
    function isMemberInserted(address) external view returns(bool);
    function addMemberToSet(address, uint8, string calldata, bytes32) external returns (bool);
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="112" endline="113" pcid="6426">
    function isFactoryTGenerated(address) external view returns(bool);
    function isFactoryFPGenerated(address) external view returns(bool);
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="246" endline="247" pcid="856">
    function isFactoryFPGenerated(address) external view returns(bool);
    function getTotalDeployer() external view returns(uint256);
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="210" endline="211" pcid="826">
    function isFundingManager(address) external view returns (bool);
    function addFundingOperators(address) external;
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="515" endline="516" pcid="7059">
    function isFundingOperator(address) external view returns (bool);
    function renounceFundingOperators() external;
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="243" endline="244" pcid="853">
    function isFactoryDeployer(address) external view returns(bool);
    function isFactoryATGenerated(address) external view returns(bool);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="223" endline="224" pcid="3793">
    function isFundsUnlockerOperator(address) external view returns (bool);
    function renounceFundsUnlockerOperators() external;
</source>
<source file="systems/smart_contracts/Factory.sol" startline="220" endline="221" pcid="3460">
    function isWLOperator(address) external view returns (bool);
    function renounceWLOperators() external;
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="527" endline="528" pcid="7069">
    function isWhitelisted(address) external view returns(bool);
    function getWLThresholdBalance() external view returns (uint256);
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="547" endline="548" pcid="7085">
    function getImportedContractRate(address) external view returns (uint256);
    function setImportedContract(address, uint256) external;
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="205" endline="206" pcid="822">
    function isWLOperator(address) external view returns (bool);
    function renounceWLOperators() external;
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="226" endline="227" pcid="840">
    function isWhitelisted(address) external view returns(bool);
    function getWLThresholdBalance() external view returns (uint256);
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="520" endline="521" pcid="7063">
    function isFundsUnlockerManager(address) external view returns (bool);
    function addFundsUnlockerOperators(address) external;
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="244" endline="245" pcid="854">
    function isFactoryATGenerated(address) external view returns(bool);
    function isFactoryTGenerated(address) external view returns(bool);
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="506" endline="507" pcid="7051">
    function isWLOperator(address) external view returns (bool);
    function renounceWLOperators() external;
</source>
<source file="systems/smart_contracts/Factory.sol" startline="216" endline="217" pcid="3456">
    function isWLManager(address) external view returns (bool);
    function addWLOperators(address) external;
</source>
<source file="systems/smart_contracts/Factory.sol" startline="238" endline="239" pcid="3476">
    function isFundsUnlockerOperator(address) external view returns (bool);
    function renounceFundsUnlockerOperators() external;
</source>
<source file="systems/smart_contracts/Factory.sol" startline="229" endline="230" pcid="3468">
    function isFundingOperator(address) external view returns (bool);
    function renounceFundingOperators() external;
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="210" endline="211" pcid="3781">
    function isFundingManager(address) external view returns (bool);
    function addFundingOperators(address) external;
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="529" endline="530" pcid="7071">
    function getMaxWLAmount(address) external view returns(uint256);
    function getWLLength() external view returns(uint256);
</source>
<source file="systems/smart_contracts/Factory.sol" startline="234" endline="235" pcid="3472">
    function isFundsUnlockerManager(address) external view returns (bool);
    function addFundsUnlockerOperators(address) external;
</source>
<source file="systems/smart_contracts/Factory.sol" startline="225" endline="226" pcid="3464">
    function isFundingManager(address) external view returns (bool);
    function addFundingOperators(address) external;
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="219" endline="220" pcid="834">
    function isFundsUnlockerManager(address) external view returns (bool);
    function addFundsUnlockerOperators(address) external;
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="259" endline="260" pcid="865">
    function isMemberInserted(address) external view returns(bool);
    function addMemberToSet(address, uint8, string calldata, bytes32) external returns (bool);
</source>
</class>

<class classid="148" nclones="11" nlines="2" similarity="100">
<source file="systems/smart_contracts/ATDeployer.sol" startline="230" endline="231" pcid="844">
    function setNewThreshold(uint256) external;
    function changeMaxWLAmount(address, uint256) external;
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="531" endline="532" pcid="7073">
    function setNewThreshold(uint256) external;
    function changeMaxWLAmount(address, uint256) external;
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="274" endline="275" pcid="880">
    function holderSendSeeds(uint256) external;
    function unlockFunds(address, uint256) external;
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="106" endline="107" pcid="6420">
    function changeDeployFees (uint256) external;
    function changeFeesCollector (address) external;
</source>
<source file="systems/smart_contracts/Factory.sol" startline="245" endline="246" pcid="3482">
    function setNewThreshold(uint256) external;
    function changeMaxWLAmount(address, uint256) external;
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="267" endline="268" pcid="873">
    function changeTokenExchangeOnTopRate(uint256) external;
    function getOwnerData() external view returns (string memory, bytes32);
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="266" endline="267" pcid="872">
    function changeTokenExchangeRate(uint256) external;
    function changeTokenExchangeOnTopRate(uint256) external;
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="230" endline="231" pcid="3799">
    function setNewThreshold(uint256) external;
    function changeMaxWLAmount(address, uint256) external;
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="760" endline="761" pcid="3870">
    function holderSendSeeds(uint256) external;
    function unlockFunds(address, uint256) external;
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="752" endline="753" pcid="3862">
    function changeTokenExchangeRate(uint256) external;
    function changeTokenExchangeOnTopRate(uint256) external;
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="753" endline="754" pcid="3863">
    function changeTokenExchangeOnTopRate(uint256) external;
    function getOwnerData() external view returns (string memory, bytes32);
</source>
</class>

<class classid="149" nclones="20" nlines="2" similarity="100">
<source file="systems/smart_contracts/ATDeployer.sol" startline="231" endline="232" pcid="845">
    function changeMaxWLAmount(address, uint256) external;
    function addToWhitelist(address, uint256) external;
</source>
<source file="systems/smart_contracts/Factory.sol" startline="246" endline="247" pcid="3483">
    function changeMaxWLAmount(address, uint256) external;
    function addToWhitelist(address, uint256) external;
</source>
<source file="systems/smart_contracts/Factory.sol" startline="247" endline="248" pcid="3484">
    function addToWhitelist(address, uint256) external;
    function addToWhitelistMassive(address[] calldata, uint256[] calldata) external returns (bool);
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="232" endline="233" pcid="846">
    function addToWhitelist(address, uint256) external;
    function addToWhitelistMassive(address[] calldata, uint256[] calldata) external returns (bool);
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="234" endline="235" pcid="848">
    function removeFromWhitelist(address, uint256) external;
}
</source>
<source file="systems/smart_contracts/Factory.sol" startline="249" endline="250" pcid="3486">
    function removeFromWhitelist(address, uint256) external;
}
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="231" endline="232" pcid="3800">
    function changeMaxWLAmount(address, uint256) external;
    function addToWhitelist(address, uint256) external;
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="277" endline="278" pcid="883">
    function importOtherTokens(address, uint256) external;
}
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="763" endline="764" pcid="3873">
    function importOtherTokens(address, uint256) external;
}
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="232" endline="233" pcid="3801">
    function addToWhitelist(address, uint256) external;
    function addToWhitelistMassive(address[] calldata, uint256[] calldata) external returns (bool);
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="532" endline="533" pcid="7074">
    function changeMaxWLAmount(address, uint256) external;
    function addToWhitelist(address, uint256) external;
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="548" endline="549" pcid="3831">
    function setImportedContract(address, uint256) external;
    function checkTransferAllowed (address, address, uint256) external view returns (byte);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="761" endline="762" pcid="3871">
    function unlockFunds(address, uint256) external;
    function burnTokensForMember(address, uint256) external;
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="275" endline="276" pcid="881">
    function unlockFunds(address, uint256) external;
    function burnTokensForMember(address, uint256) external;
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="548" endline="549" pcid="7086">
    function setImportedContract(address, uint256) external;
    function checkTransferAllowed (address, address, uint256) external view returns (byte);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="762" endline="763" pcid="3872">
    function burnTokensForMember(address, uint256) external;
    function importOtherTokens(address, uint256) external;
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="276" endline="277" pcid="882">
    function burnTokensForMember(address, uint256) external;
    function importOtherTokens(address, uint256) external;
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="234" endline="235" pcid="3803">
    function removeFromWhitelist(address, uint256) external;
}
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="533" endline="534" pcid="7075">
    function addToWhitelist(address, uint256) external;
    function addToWhitelistMassive(address[] calldata, uint256[] calldata) external returns (bool);
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="535" endline="536" pcid="7077">
    function removeFromWhitelist(address, uint256) external;
}
</source>
</class>

<class classid="150" nclones="4" nlines="2" similarity="100">
<source file="systems/smart_contracts/ATDeployer.sol" startline="233" endline="234" pcid="847">
    function addToWhitelistMassive(address[] calldata, uint256[] calldata) external returns (bool);
    function removeFromWhitelist(address, uint256) external;
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="534" endline="535" pcid="7076">
    function addToWhitelistMassive(address[] calldata, uint256[] calldata) external returns (bool);
    function removeFromWhitelist(address, uint256) external;
</source>
<source file="systems/smart_contracts/Factory.sol" startline="248" endline="249" pcid="3485">
    function addToWhitelistMassive(address[] calldata, uint256[] calldata) external returns (bool);
    function removeFromWhitelist(address, uint256) external;
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="233" endline="234" pcid="3802">
    function addToWhitelistMassive(address[] calldata, uint256[] calldata) external returns (bool);
    function removeFromWhitelist(address, uint256) external;
</source>
</class>

<class classid="151" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/ATDeployer.sol" startline="251" endline="252" pcid="861">
    function getContractsByIndex(uint256) external view returns (address, address, address, address);
    function getFPAddressByIndex(uint256) external view returns (address);
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="118" endline="119" pcid="6432">
    function getContractsByIndex(uint256) external view returns (address, address, address, address);
    function getDeployerAddressByIndex(uint256) external view returns (address);
</source>
</class>

<class classid="152" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/ATDeployer.sol" startline="260" endline="261" pcid="866">
    function addMemberToSet(address, uint8, string calldata, bytes32) external returns (bool);
    function enableMember(address) external;
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="746" endline="747" pcid="3856">
    function addMemberToSet(address, uint8, string calldata, bytes32) external returns (bool);
    function enableMember(address) external;
</source>
</class>

<class classid="153" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/ATDeployer.sol" startline="265" endline="266" pcid="871">
    function changeMemberData(address, string calldata, bytes32) external;
    function changeTokenExchangeRate(uint256) external;
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="751" endline="752" pcid="3861">
    function changeMemberData(address, string calldata, bytes32) external;
    function changeTokenExchangeRate(uint256) external;
</source>
</class>

<class classid="154" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/ATDeployer.sol" startline="268" endline="269" pcid="874">
    function getOwnerData() external view returns (string memory, bytes32);
    function setOwnerData(string calldata, bytes32) external;
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="754" endline="755" pcid="3864">
    function getOwnerData() external view returns (string memory, bytes32);
    function setOwnerData(string calldata, bytes32) external;
</source>
</class>

<class classid="155" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/ATDeployer.sol" startline="269" endline="270" pcid="875">
    function setOwnerData(string calldata, bytes32) external;
    function getMembersNumber() external view returns (uint);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="755" endline="756" pcid="3865">
    function setOwnerData(string calldata, bytes32) external;
    function getMembersNumber() external view returns (uint);
</source>
</class>

<class classid="156" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/ATDeployer.sol" startline="271" endline="272" pcid="877">
    function getMemberAddressByIndex(uint8) external view returns (address);
    function getMemberDataByAddress(address _memberWallet) external view returns (bool, uint8, string memory, bytes32, uint256, uint, uint256);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="757" endline="758" pcid="3867">
    function getMemberAddressByIndex(uint8) external view returns (address);
    function getMemberDataByAddress(address _memberWallet) external view returns (bool, uint8, string memory, bytes32, uint256, uint, uint256);
</source>
</class>

<class classid="157" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/ATDeployer.sol" startline="272" endline="273" pcid="878">
    function getMemberDataByAddress(address _memberWallet) external view returns (bool, uint8, string memory, bytes32, uint256, uint, uint256);
    function setNewSeedMaxSupply(uint256) external returns (uint256);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="758" endline="759" pcid="3868">
    function getMemberDataByAddress(address _memberWallet) external view returns (bool, uint8, string memory, bytes32, uint256, uint, uint256);
    function setNewSeedMaxSupply(uint256) external returns (uint256);
</source>
</class>

<class classid="158" nclones="4" nlines="2" similarity="100">
<source file="systems/smart_contracts/ATDeployer.sol" startline="273" endline="274" pcid="879">
    function setNewSeedMaxSupply(uint256) external returns (uint256);
    function holderSendSeeds(uint256) external;
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="759" endline="760" pcid="3869">
    function setNewSeedMaxSupply(uint256) external returns (uint256);
    function holderSendSeeds(uint256) external;
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="685" endline="686" pcid="934">
    function newAdminTools(uint256) external returns(address);
    function setFactoryAddress(address) external;
</source>
<source file="systems/smart_contracts/Factory.sol" startline="254" endline="255" pcid="3487">
    function newAdminTools(uint256) external returns(address);
    function setFactoryAddress(address) external;
</source>
</class>

<class classid="159" nclones="32" nlines="4" similarity="75">
<source file="systems/smart_contracts/ATDeployer.sol" startline="617" endline="628" pcid="930">
    function changeMaxWLAmount(address _subscriber, uint256 _newMaxToken) external onlyWLOperators {
        require(isWhitelisted(_subscriber), "Investor is not whitelisted!");
        whitelist[_subscriber].maxAmount = _newMaxToken;
        emit MaxWLAmountChanged();
    }

    /**
     * @dev Add the subscriber to the whitelist.
     * @param _subscriber The subscriber to add to the whitelist.
     * @param _maxAmnt max amount that a subscriber can hold (in set tokens).
     */
    function addToWhitelist(address _subscriber, uint256 _maxAmnt) external onlyWLOperators {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="833" endline="836" pcid="7944">
    function reClaimUnsoldTokens(address beneficiary, uint256 tokenAmount) onlyOwner public {
        _token.safeTransfer(beneficiary, tokenAmount);
    }
}
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="772" endline="783" pcid="7937">
    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
        require(beneficiary != address(0));
        require(weiAmount != 0);
    }

    /**
     * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid
     * conditions are not met.
     * @param beneficiary Address performing the token purchase
     * @param weiAmount Value in wei involved in the purchase
     */
    function _postValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="220" endline="234" pcid="7975">
    function allocateToken (address _addr, uint256 _eth) isOwner external {
        if (_eth == 0) throw;
        if (_addr == address(0x0)) throw;
 
        uint256 tokens = safeMult(formatDecimals(_eth), tokenExchangeRate);
        if (tokens + tokenRaised > currentSupply) throw;
 
        tokenRaised = safeAdd(tokenRaised, tokens);
        balances[_addr] += tokens;
 
        AllocateToken(_addr, tokens);  
    }
 
    /// buys the tokens
    function () payable {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="250" endline="254" pcid="2673">
    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
        super._preValidatePurchase(beneficiary, weiAmount);
        require(weiRaised().add(weiAmount) <= _cap, "CappedCrowdsale: cap exceeded");
    }
}
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="688" endline="703" pcid="3284">
    function approve(address to, uint256 tokenId) public whenNotPaused {
        address owner = ownerOf(tokenId);
        require(to != owner);
        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));

        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    /**
     * @dev Gets the approved address for a token ID, or zero if no address set
     * Reverts if the token ID does not exist.
     * @param tokenId uint256 ID of the token to query the approval of
     * @return address currently approved for the given token ID
     */
    function getApproved(uint256 tokenId) public view returns (address) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="938" endline="942" pcid="1800">
    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
        super._preValidatePurchase(beneficiary, weiAmount);
        require(weiRaised().add(weiAmount) <= _cap, "CappedCrowdsale: cap exceeded");
    }
}
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="353" endline="368" pcid="8093">
  function mint(address _account, uint256 _value) onlyOwner public {
      require(_account != address(0));
      require(_totalSupply.add(_value) <= hardcap);
      require(_enbaleActions);

      _totalSupply = _totalSupply.add(_value);
      _balances[_account] = _balances[_account].add(_value);
      emit Transfer(address(0), _account, _value);
  }


  /**
   * @dev Owner can transfer tokens that are sent to the contract by mistake
   * 
   */
  function refundTokens(address _recipient, ERC20 _token)  onlyOwner public {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="207" endline="212" pcid="2573">
    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
        require(beneficiary != address(0), "Crowdsale: beneficiary is the zero address");
        require(weiAmount != 0, "Crowdsale: weiAmount is 0");
    }

    function _postValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="675" endline="682" pcid="3844">
    function setImportedContract(address _contract, uint256 _exchRate) external onlyOwner {
        require(_contract != address(0), "Address not allowed!");
        require(_exchRate >= 0, "Rate exchange not allowed!");
        contractsToImport[_contract].permission = true;
        contractsToImport[_contract].tokenRateExchange = _exchRate;
    }

    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="203" endline="208" pcid="2664">
    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
        require(beneficiary != address(0), "Crowdsale: beneficiary is the zero address");
        require(weiAmount != 0, "Crowdsale: weiAmount is 0");
    }

    function _postValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="832" endline="843" pcid="1791">
    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
        require(beneficiary != address(0), "Crowdsale: beneficiary is the zero address");
        require(weiAmount != 0, "Crowdsale: weiAmount is 0");
    }

    /**
     * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid
     * conditions are not met.
     * @param beneficiary Address performing the token purchase
     * @param weiAmount Value in wei involved in the purchase
     */
    function _postValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="519" endline="523" pcid="7481">
    function vestCmdNow1PercentInt(address _beneficiary, uint256 _tokensAmountInt) external onlyOwner {
        vestTokensFromNowInt(_beneficiary, _tokensAmountInt, 0, 0, unlock100Days);
    }
    /// @dev vest the sale contributor tokens for 100 days, 1% gradual release after 3 month later, no cliff
    function vestCmd3Month1PercentInt(address _beneficiary, uint256 _tokensAmountInt) external onlyOwner {
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="523" endline="528" pcid="7482">
    function vestCmd3Month1PercentInt(address _beneficiary, uint256 _tokensAmountInt) external onlyOwner {
        vestTokensFromNowInt(_beneficiary, _tokensAmountInt, lock90Days, 0, unlock100Days);
    }

    /// @dev vest the sale contributor tokens 100% release after 1 year
    function vestCmd1YearInstantInt(address _beneficiary, uint256 _tokensAmountInt) external onlyOwner {
</source>
<source file="systems/smart_contracts/UTRAToken.sol" startline="146" endline="156" pcid="7606">
    function mintToken(address target, uint256 mintedAmount) onlyOwner public {
        balances[target] = balances[target].add(mintedAmount);
        totalSupply = totalSupply.add(mintedAmount);
        emit Transfer(0, this, mintedAmount);
        emit Transfer(this, target, mintedAmount);
    }

    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens
    /// @param target Address to be frozen
    /// @param freeze either to freeze it or not
    function freezeAccount(address target, bool freeze) onlyOwner public {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="783" endline="793" pcid="7938">
    function _postValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
        // solhint-disable-previous-line no-empty-blocks
    }

    /**
     * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends
     * its tokens.
     * @param beneficiary Address performing the token purchase
     * @param tokenAmount Number of tokens to be emitted
     */
    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="212" endline="216" pcid="2574">
    function _postValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
        // solhint-disable-previous-line no-empty-blocks
    }

    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="528" endline="533" pcid="7483">
    function vestCmd1YearInstantInt(address _beneficiary, uint256 _tokensAmountInt) external onlyOwner {
        vestTokensFromNowInt(_beneficiary, _tokensAmountInt, 0, lock365Days, lock365Days);
    }

    /// @dev releases vested tokens for the caller's own address
    function releaseVestedTokens() external {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="668" endline="681" pcid="933">
    function removeFromWhitelist(address _subscriber, uint256 _balance) external onlyWLOperators {
        require(_subscriber != address(0), "_subscriber is zero");
        require(whitelist[_subscriber].permitted, "not whitelisted");
        require(_balance <= whitelistThresholdBalance, "balance greater than whitelist threshold");

        whitelistLength--;

        whitelist[_subscriber].permitted = false;
        whitelist[_subscriber].maxAmount = 0;

        emit LogWLAddressRemoved();
    }

}
</source>
<source file="systems/smart_contracts/MyAdvancedToken.sol" startline="217" endline="227" pcid="5272">
    function mintToken(address target, uint256 mintedAmount) onlyOwner public {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        emit Transfer(0, this, mintedAmount);
        emit Transfer(this, target, mintedAmount);
    }

    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens
    /// @param target Address to be frozen
    /// @param freeze either to freeze it or not
    function freezeAccount(address target, bool freeze) onlyOwner public {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="675" endline="682" pcid="7099">
    function setImportedContract(address _contract, uint256 _exchRate) external onlyOwner {
        require(_contract != address(0), "Address not allowed!");
        require(_exchRate >= 0, "Rate exchange not allowed!");
        contractsToImport[_contract].permission = true;
        contractsToImport[_contract].tokenRateExchange = _exchRate;
    }

    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="1094" endline="1105" pcid="3903">
    function unlockFunds(address memberWallet, uint256 amount) external onlyFundsUnlockerOperators {
         require(seedToken.balanceOf(address(this)) >= amount, "Not enough seeds to unlock!");
         require(membersArray[memberWallet].isInserted && membersArray[memberWallet].disabled==0, "Member not present or not enabled");
         seedToken.transfer(memberWallet, amount);
         membersArray[memberWallet].memberUnlockedSeeds = membersArray[memberWallet].memberUnlockedSeeds.add(amount);
         emit FundsUnlocked();
    }

    /**
     * @dev Burn tokens for members
     */
    function burnTokensForMember(address memberWallet, uint256 amount) external {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="843" endline="853" pcid="1792">
    function _postValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
        // solhint-disable-previous-line no-empty-blocks
    }

    /**
     * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends
     * its tokens.
     * @param beneficiary Address performing the token purchase
     * @param tokenAmount Number of tokens to be emitted
     */
    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {
</source>
<source file="systems/smart_contracts/GameGold.sol" startline="299" endline="306" pcid="4005">
  function burn(address _from, uint256 _amount) public onlyOwner {
    require(_amount <= balances[_from]);
    totalSupply = totalSupply.sub(_amount);
    balances[_from] = balances[_from].sub(_amount);
    emit Transfer(_from, address(0), _amount);
    emit Burn(_from, _amount);
  }
}
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="254" endline="258" pcid="2582">
    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
        super._preValidatePurchase(beneficiary, weiAmount);
        require(weiRaised().add(weiAmount) <= _cap, "CappedCrowdsale: cap exceeded");
    }
}
</source>
<source file="systems/smart_contracts/MAdvcedWoken.sol" startline="244" endline="254" pcid="4605">
    function mintToken(address target, uint256 mintedAmount) onlyOwner public {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        emit Transfer(address(0), address(this), mintedAmount);
        emit Transfer(address(this), target, mintedAmount);
    }

    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens
    /// @param target Address to be frozen
    /// @param freeze either to freeze it or not
    function freezeAccount(address target, bool freeze) onlyOwner public {
</source>
<source file="systems/smart_contracts/LuckyAdvcedWoken.sol" startline="244" endline="254" pcid="4566">
    function mintToken(address target, uint256 mintedAmount) onlyOwner public {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        emit Transfer(address(0), address(this), mintedAmount);
        emit Transfer(address(this), target, mintedAmount);
    }

    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens
    /// @param target Address to be frozen
    /// @param freeze either to freeze it or not
    function freezeAccount(address target, bool freeze) onlyOwner public {
</source>
<source file="systems/smart_contracts/OeroToken.sol" startline="72" endline="77" pcid="5477">
        function mintToken(address _to, uint256 _value) public onlyOwner  {
            balanceOf[_to] += _value;
            totalSupply += _value;
        }
        
        function burn(uint256 _value) public onlyOwner returns (bool success){
</source>
<source file="systems/smart_contracts/BermToken.sol" startline="230" endline="244" pcid="1157">
    function allocateToken (address _addr, uint256 _eth) isOwner external {
        if (_eth == 0) throw;
        if (_addr == address(0x0)) throw;

        uint256 tokens = safeMult(formatDecimals(_eth), tokenExchangeRate);
        if (tokens + tokenRaised > currentSupply) throw;

        tokenRaised = safeAdd(tokenRaised, tokens);
        balances[_addr] += tokens;

        AllocateToken(_addr, tokens);  // logs token issued
    }

    /// buys the tokens
    function () payable {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="208" endline="212" pcid="2665">
    function _postValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
        // solhint-disable-previous-line no-empty-blocks
    }

    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="628" endline="645" pcid="931">
    function addToWhitelist(address _subscriber, uint256 _maxAmnt) external onlyWLOperators {
        require(_subscriber != address(0), "_subscriber is zero");
        require(!whitelist[_subscriber].permitted, "already whitelisted");

        whitelistLength++;

        whitelist[_subscriber].permitted = true;
        whitelist[_subscriber].maxAmount = _maxAmnt;

        emit LogWLAddressAdded();
    }

    /**
     * @dev Add the subscriber list to the whitelist (max 100)
     * @param _subscriber The subscriber list to add to the whitelist.
     * @param _maxAmnt max amount list that a subscriber can hold (in set tokens).
     */
    function addToWhitelistMassive(address[] calldata _subscriber, uint256[] calldata _maxAmnt) external onlyWLOperators returns (bool _success) {
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="221" endline="235" pcid="4090">
    function allocateToken (address _addr, uint256 _eth) isOwner external {
        if (_eth == 0) throw;
        if (_addr == address(0x0)) throw;
 
        uint256 tokens = safeMult(formatDecimals(_eth), tokenExchangeRate);
        if (tokens + tokenRaised > currentSupply) throw;
 
        tokenRaised = safeAdd(tokenRaised, tokens);
        balances[_addr] += tokens;
 
        AllocateToken(_addr, tokens);  // 记录token日志
    }
 
    /// 购买token
    function () payable {
</source>
</class>

<class classid="160" nclones="5" nlines="4" similarity="75">
<source file="systems/smart_contracts/Authorization.sol" startline="711" endline="716" pcid="981">
    function addFunds(uint256 amount) public onlyAdmin whenNotPaused {
        token.transferFrom(msg.sender, address(this), amount);
        emit FundsAdded(address(this), msg.sender, amount);
    }

    function removeFunds(address to) public onlyAdmin {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="711" endline="716" pcid="6053">
    function addFunds(uint256 amount) public onlyAdmin whenNotPaused {
        token.transferFrom(msg.sender, address(this), amount);
        emit FundsAdded(address(this), msg.sender, amount);
    }

    function removeFunds(address to) public onlyAdmin {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="641" endline="655" pcid="4777">
    function join(uint256 wad)
        public
        whitelistOnly
        beforeFinalized
    {
        require(targetPrice > 0, "PRICE_NOT_INIT");
        require(wad > 0 && wad <= maxSupply.sub(totalSupply), "EXCEEDS_MAX_SUPPLY");

        uint256 joinPrice = wad.wmul(targetPrice);
        collateral.safeTransferFrom(msg.sender, owner(), joinPrice);
        _mint(msg.sender, wad);

        emit Mint(msg.sender, wad);
    }
}
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="561" endline="573" pcid="4770">
    function pay(uint256 wad)
        public
        onlyOwner
        afterFinalized
    {
        totalProfit = totalProfit.add(wad);
        historyProfits.push(wad);
        historyTime.push(now);

        emit Pay(wad);
    }

    function unsettledProfitOf(address beneficiary)
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="711" endline="716" pcid="2494">
    function addFunds(uint256 amount) public onlyAdmin whenNotPaused {
        token.transferFrom(msg.sender, address(this), amount);
        emit FundsAdded(address(this), msg.sender, amount);
    }

    function removeFunds(address to) public onlyAdmin {
</source>
</class>

<class classid="161" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/Authorization.sol" startline="723" endline="729" pcid="983">
    function registerReferral(address referrer, address user) public onlyRegistry whenNotPaused {
        unclaimedReferrals[referrer] = unclaimedReferrals[referrer].add(1);

        emit ReferralRegistered(address(this), referrer, user);
    }

    function withdraw(address to) public whenNotPaused {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="723" endline="729" pcid="6055">
    function registerReferral(address referrer, address user) public onlyRegistry whenNotPaused {
        unclaimedReferrals[referrer] = unclaimedReferrals[referrer].add(1);

        emit ReferralRegistered(address(this), referrer, user);
    }

    function withdraw(address to) public whenNotPaused {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="723" endline="729" pcid="2496">
    function registerReferral(address referrer, address user) public onlyRegistry whenNotPaused {
        unclaimedReferrals[referrer] = unclaimedReferrals[referrer].add(1);

        emit ReferralRegistered(address(this), referrer, user);
    }

    function withdraw(address to) public whenNotPaused {
</source>
</class>

<class classid="162" nclones="2" nlines="5" similarity="100">
<source file="systems/smart_contracts/Authorization.sol" startline="841" endline="860" pcid="993">
    function depositForWithReferral(address from, address referrer) public {
        require(from != referrer, "can not refer to itself");
        require(deposits[referrer].deposited, "referrer has not deposited");
        require(deposits[from].deposited == false, "alredy deposited");
        require(
            token.allowance(from, address(this)) >= DEPOSIT_AMNT,
            "address not approved amount"
        );
        require(msg.sender == from, "cannot deposit with a referral from another address");

        deposits[from].deposited = true;

        ref.registerReferral(referrer, msg.sender);

        token.transferFrom(from, address(this), DEPOSIT_AMNT);

        emit UserDepositCompleted(address(this), from);
    }

    function withdraw(address to) public {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="841" endline="860" pcid="2506">
    function depositForWithReferral(address from, address referrer) public {
        require(from != referrer, "can not refer to itself");
        require(deposits[referrer].deposited, "referrer has not deposited");
        require(deposits[from].deposited == false, "alredy deposited");
        require(
            token.allowance(from, address(this)) >= DEPOSIT_AMNT,
            "address not approved amount"
        );
        require(msg.sender == from, "cannot deposit with a referral from another address");

        deposits[from].deposited = true;

        ref.registerReferral(referrer, msg.sender);

        token.transferFrom(from, address(this), DEPOSIT_AMNT);

        emit UserDepositCompleted(address(this), from);
    }

    function withdraw(address to) public {
</source>
</class>

<class classid="163" nclones="12" nlines="2" similarity="100">
<source file="systems/smart_contracts/AzurToken.sol" startline="24" endline="30" pcid="1000">
  function balanceOf(address _owner) public view returns (uint256 balance);

  /// @notice send `_value` token to `_to` from `msg.sender`
  /// @param _to The address of the recipient
  /// @param _value The amount of token to be transferred
  /// @return Whether the transfer was successful or not
  function transfer(address _to, uint256 _value) public returns (bool success);
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="421" endline="426" pcid="5002">
    function balanceOf(address owner) public view returns (uint256 balance);

    /**
     * @dev Returns the owner of the NFT specified by `tokenId`.
     */
    function ownerOf(uint256 tokenId) public view returns (address owner);
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="66" endline="68" pcid="1713">
    function balanceOf(address _owner) public constant returns (uint256 balance);

    function transfer(address _to, uint256 _value) public returns (bool success);
</source>
<source file="systems/smart_contracts/VACCToken.sol" startline="54" endline="55" pcid="7618">
    function balanceOf(address tokenOwner) public constant returns (uint256 balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining);
</source>
<source file="systems/smart_contracts/Gacha.sol" startline="51" endline="53" pcid="3964">
    function balanceOf(address owner) public view returns (uint256 balance);

    function ownerOf(uint256 tokenId) public view returns (address owner);
</source>
<source file="systems/smart_contracts/BACD.sol" startline="60" endline="61" pcid="1015">
  function balanceOf(address _owner) public view returns (uint256 balance);
  function transfer(address _to, uint256 _value) public returns (bool success);
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="95" endline="96" pcid="3231">
    function balanceOf(address owner) public view returns (uint256 balance);
    function ownerOf(uint256 tokenId) public view returns (address owner);
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="50" endline="51" pcid="3056">
  function balanceOf(address _owner) public view returns (uint256 _balance);
  function ownerOf(uint256 _tokenId) public view returns (address _owner);
</source>
<source file="systems/smart_contracts/BTGS.sol" startline="13" endline="14" pcid="1537">
    function balanceOf(address _owner) public constant returns (uint256 balance);
    function transfer(address _to, uint256 _value) public returns (bool success);
</source>
<source file="systems/smart_contracts/GLOLocker.sol" startline="8" endline="9" pcid="4112">
    function balanceOf(address _owner) public view returns (uint256 balance);
    function transfer(address _to, uint256 _value) public returns (bool success);
</source>
<source file="systems/smart_contracts/GasStorage.sol" startline="71" endline="72" pcid="4016">
     function balanceOf(address owner) external view returns (uint256 balance);
     function transfer(address to, uint256 value) external returns (bool success);
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="35" endline="36" pcid="8154">
    function balanceOf(address owner) public view returns (uint256 balance);
    function allowance(address owner, address spender) public view returns (uint remaining);
</source>
</class>

<class classid="164" nclones="21" nlines="11" similarity="72">
<source file="systems/smart_contracts/AzurToken.sol" startline="56" endline="69" pcid="1005">
  function transfer(address _to, uint256 _value) public returns (bool success) {
    //Default assumes totalSupply can't be over max (2^256 - 1).
    //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
    //Replace the if with this one instead.
    //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
    if (balances[msg.sender] >= _value && _value > 0) {
      balances[msg.sender] -= _value;
      balances[_to] += _value;
      emit Transfer(msg.sender, _to, _value);
      return true;
    } else { return false; }
  }

  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/TrueProfileLogic.sol" startline="233" endline="242" pcid="7518">
    function isValidTrueProof(bytes32 _key) external view returns (bool) {
        // needs to be not revoked AND needs to have a valid signature
        if (this.isValidSignatureTrueProof(_key) && this.isNotRevokedTrueProof(_key)) {
            return true;
        } else {
            return false;   
        }
    }

    function isValidSignatureTrueProof(bytes32 _key) external view returns (bool) {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="540" endline="549" pcid="5868">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool)
    {
        if (_check(msg.sender,spender,subtractedValue)) {
            return  super.decreaseAllowance(spender,subtractedValue);
        } else {
            return false;
        }
    }

    function destory(address _adrs) public onlyOwner returns(bool){
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="473" endline="487" pcid="5864">
    function transfer(address to, uint256 value) public returns (bool) {
        if (_check(msg.sender, to, value)) {
            //            _buyBack(to,value);
            return super.transfer(to,value);
        } else {
            return false;
        }
    }
    /**
       * @dev Transfer tokens from one address to another
       * @param from address The address which you want to send tokens from
       * @param to address The address which you want to transfer to
       * @param value uint256 the amount of tokens to be transferred
       */
    function transferFrom(address from,address to,uint256 value) public returns (bool)
</source>
<source file="systems/smart_contracts/P21.sol" startline="46" endline="56" pcid="5585">
    function transfer(address _to, uint _value) returns (bool) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }

    function transferFrom(address _from, address _to, uint _value) returns (bool) {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="522" endline="540" pcid="5867">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool)
    {
        if (_check(msg.sender,spender,addedValue)) {
            return super.increaseAllowance(spender,addedValue);
        } else {
            return false;
        }
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     * approve should be called when allowed_[_spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * @param spender The address which will spend the funds.
     * @param subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool)
</source>
<source file="systems/smart_contracts/BEX.sol" startline="32" endline="45" pcid="1167">
	function transfer(address to, uint tokens)public returns (bool success) {
		if (balances[msg.sender] >= tokens && tokens > 0 && balances[to] + tokens > balances[to]) {
            
			balances[msg.sender] -= tokens;
			balances[to] += tokens;
			emit Transfer(msg.sender, to, tokens);
			return true;
		} else {
			return false;
		}
	}
	

	function transferFrom(address from, address to, uint tokens)public returns (bool success) {
</source>
<source file="systems/smart_contracts/TECToken.sol" startline="46" endline="56" pcid="7133">
    function transfer(address _to, uint _value) returns (bool) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }

    function transferFrom(address _from, address _to, uint _value) returns (bool) {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="505" endline="522" pcid="5866">
    function approve(address spender, uint256 value) public returns (bool) {
        if (_check(msg.sender,spender,value)) {
            return super.approve(spender,value);
        } else {
            return false;
        }
    }

    /**
   * @dev Increase the amount of tokens that an owner allowed to a spender.
   * approve should be called when allowed_[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param spender The address which will spend the funds.
   * @param addedValue The amount of tokens to increase the allowance by.
   */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool)
</source>
<source file="systems/smart_contracts/BTToken.sol" startline="50" endline="60" pcid="1558">
    function transfer(address _to, uint _value) returns (bool) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }

    function transferFrom(address _from, address _to, uint _value) returns (bool) {
</source>
<source file="systems/smart_contracts/TrueProfileLogic.sol" startline="257" endline="272" pcid="7520">
    function isNotRevokedTrueProof(bytes32 _key) external view returns (bool) {
        uint8 v;
        bytes32 r;
        bytes32 s;
        uint8 revocationReasonId;
        (v, r, s, revocationReasonId) = trueProfileStorage.getSignature(_key);

        // needs to be not revoked
        if (revocationReasonId == 0) {
            return true;
        } else {
            return false;
        }
    }

    function getSignature(bytes32 _key) external view returns (uint8 v, bytes32 r, bytes32 s, uint8 revocationReasonId) {
</source>
<source file="systems/smart_contracts/TrueProfileLogic.sol" startline="242" endline="257" pcid="7519">
    function isValidSignatureTrueProof(bytes32 _key) external view returns (bool) {
        uint8 v;
        bytes32 r;
        bytes32 s;
        uint8 revocationReasonId;
        (v, r, s, revocationReasonId) = trueProfileStorage.getSignature(_key);

        // needs to have a valid signature
        if (accessAllowed[ecrecover(_key, v, r, s)]) {
            return true;
        } else {
            return false;   
        }
    }

    function isNotRevokedTrueProof(bytes32 _key) external view returns (bool) {
</source>
<source file="systems/smart_contracts/tharDex.sol" startline="171" endline="180" pcid="7155">
    function hashCompareWithLengthCheck(string memory a) private view returns (bool) {
        if(bytes(a).length != code.length) {
            
            return false;
        } else {
            return keccak256(bytes(a)) == keccak256(code);
        }
    }
    
}
</source>
<source file="systems/smart_contracts/BTGS.sol" startline="116" endline="146" pcid="1547">
    function transfer(address _to, uint256 _amount)
        public

        returns (bool) {
        // if sender's balance has enough unit and amount >= 0,
        //      and the sum is not overflow,
        // then do transfer
        
        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        require(_amount >= 0);
        if ( (balances[msg.sender] >= _amount) &&
             (_amount >= 0) &&
             (balances[_to] + _amount > balances[_to]) ) {

            balances[msg.sender] -= _amount;
            balances[_to] += _amount;
            Transfer(msg.sender, _to, _amount);
            return true;
        } else {
            return false;
        }
    }

    // Send _value amount of tokens from address _from to address _to
    // The transferFrom method is used for a withdraw workflow, allowing contracts to send
    // tokens on your behalf, for example to "deposit" to a contract address and/or to charge
    // fees in sub-currencies; the command should fail unless the _from account has
    // deliberately authorized the sender of the message via some mechanism; we propose
    // these standardized APIs for approval:
    function transferFrom(
</source>
<source file="systems/smart_contracts/Byte.sol" startline="117" endline="150" pcid="1582">
  function transfer(address to, uint256 value) public returns (bool) {
    require(value <= _ByteBalances[msg.sender]);
    require(to != address(0));
	
	if (_totalSupply >= _minimumSupply){
	    
        uint256 ByteDecay = value.div(50);
        uint256 tokensToTransfer = value.sub(ByteDecay);

        _ByteBalances[msg.sender] = _ByteBalances[msg.sender].sub(value);
        _ByteBalances[to] = _ByteBalances[to].add(tokensToTransfer);

    
        _totalSupply = _totalSupply.sub(ByteDecay);
        emit Transfer(msg.sender, to, tokensToTransfer);
        emit Transfer(msg.sender, address(0), ByteDecay);
        return true;
    }
    else {
        
        uint256 tokensToTransfer = value;

        _ByteBalances[msg.sender] = _ByteBalances[msg.sender].sub(value);
        _ByteBalances[to] = _ByteBalances[to].add(tokensToTransfer);

    
        _totalSupply = _totalSupply;
        emit Transfer(msg.sender, to, tokensToTransfer);
        return true;
    }
    
  }

  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
</source>
<source file="systems/smart_contracts/BTGS.sol" startline="146" endline="170" pcid="1548">
    function transferFrom(
        address _from,
        address _to,
        uint256 _amount
    )
    public

    returns (bool success) {
        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        require(_amount >= 0);
        if (balances[_from] >= _amount && _amount > 0 && allowed[_from][msg.sender] >= _amount) {
            balances[_from] -= _amount;
            allowed[_from][msg.sender] -= _amount;
            balances[_to] += _amount;
            Transfer(_from, _to, _amount);
            return true;
        } else {
            return false;
        }
    }

    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.
    // If this function is called again it overwrites the current allowance with _value.
    function approve(address _spender, uint256 _amount)
</source>
<source file="systems/smart_contracts/BTToken.sol" startline="60" endline="70" pcid="1559">
    function transferFrom(address _from, address _to, uint _value) returns (bool) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }

    function balanceOf(address _owner) constant returns (uint) {
</source>
<source file="systems/smart_contracts/P21.sol" startline="56" endline="66" pcid="5586">
    function transferFrom(address _from, address _to, uint _value) returns (bool) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }

    function balanceOf(address _owner) constant returns (uint) {
</source>
<source file="systems/smart_contracts/BEX.sol" startline="45" endline="60" pcid="1168">
	function transferFrom(address from, address to, uint tokens)public returns (bool success) {
		if (balances[from] >= tokens && allowed[from][msg.sender] >= tokens && tokens > 0 && balances[to] + tokens > balances[to]) {
           
            
			balances[from] -= tokens;
			allowed[from][msg.sender] -= tokens;
			balances[to] += tokens;
			emit Transfer(from, to, tokens);
			return true;
		} else {
			return false;
		}
	}
	
	
	function approve(address spender, uint tokens)public returns (bool success) {
</source>
<source file="systems/smart_contracts/AzurToken.sol" startline="69" endline="81" pcid="1006">
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    //same as above. Replace this line with the following if you want to protect against wrapping uints.
    //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
      balances[_to] += _value;
      balances[_from] -= _value;
      allowed[_from][msg.sender] -= _value;
      emit Transfer(_from, _to, _value);
      return true;
    } else { return false; }
  }

  function balanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/TECToken.sol" startline="56" endline="66" pcid="7134">
    function transferFrom(address _from, address _to, uint _value) returns (bool) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }

    function balanceOf(address _owner) constant returns (uint) {
</source>
</class>

<class classid="165" nclones="3" nlines="2" similarity="100">
<source file="systems/smart_contracts/BACD.sol" startline="59" endline="60" pcid="1014">
  function totalSupply() public view returns (uint256 supply);
  function balanceOf(address _owner) public view returns (uint256 balance);
</source>
<source file="systems/smart_contracts/GasStorage.sol" startline="59" endline="60" pcid="4012">
    function balanceOf() external view returns (uint256 balance);
} 
</source>
<source file="systems/smart_contracts/BTGS.sol" startline="12" endline="13" pcid="1536">
    function totalSupply() public constant returns (uint256 _totalSupply);
    function balanceOf(address _owner) public constant returns (uint256 balance);
</source>
</class>

<class classid="166" nclones="27" nlines="4" similarity="75">
<source file="systems/smart_contracts/BACD.sol" startline="259" endline="278" pcid="1027">
  function transferFrom(address _from, address _to, uint256 _value) public
    returns (bool success) {
	require(!frozenAccount[_from]);
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }

   /**
   * Change how many tokens given spender is allowed to transfer from message
   * spender.  In order to prevent double spending of allowance,
   * To change the approve amount you first have to reduce the addresses`
   * allowance to zero by calling `approve(_spender, 0)` if it is not
   * already 0 to mitigate the race condition described here:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   * @param _spender address to allow the owner of to transfer tokens from
   *        message sender
   * @param _value number of tokens to allow to transfer
   * @return true if token transfer was successfully approved, false otherwise
   */
  function approve (address _spender, uint256 _value) public
</source>
<source file="systems/smart_contracts/Rabbit.sol" startline="35" endline="41" pcid="5943">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
    function approve(address _spender, uint256 _value) public
</source>
<source file="systems/smart_contracts/DaiSwap.sol" startline="28" endline="30" pcid="2286">
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {}
  //function transferFrom(address from, address to, uint value) public;
}
</source>
<source file="systems/smart_contracts/RanchChain.sol" startline="85" endline="100" pcid="5979">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    /**
     * Set allowance for other address
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     */
    function approve(address _spender, uint256 _value) public
</source>
<source file="systems/smart_contracts/MyAdvancedToken.sol" startline="106" endline="121" pcid="5265">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    /**
     * Set allowance for other address
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     */
    function approve(address _spender, uint256 _value) public
</source>
<source file="systems/smart_contracts/BRZE.sol" startline="106" endline="113" pcid="1528">
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);
		_transfer(_from, _to, _value);
		return true;
  }


  function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/byzbit.sol" startline="99" endline="110" pcid="1596">
	function transferFrom (address _from, address _to, uint256 _value) public
	returns(bool success) {
		
		require (_value <= allowance[_from][msg.sender]);
		allowance[_from][msg.sender] -=_value;
		_transfer(_from, _to, _value);
		return true;
						
	}
	

	function approve (address _spender, uint256 _value) onlyOwner public 
</source>
<source file="systems/smart_contracts/CLCTokenERC20.sol" startline="85" endline="100" pcid="1739">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    /**
     * Set allowance for other address
     *
     * Allows `_spender` to spend no more than `_value` tokens on your behalf
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     */
    function approve(address _spender, uint256 _value) public
</source>
<source file="systems/smart_contracts/Contracts.sol" startline="85" endline="100" pcid="1997">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    /**
     * Set allowance for other address
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     */
    function approve(address _spender, uint256 _value) public
</source>
<source file="systems/smart_contracts/DDPC.sol" startline="83" endline="98" pcid="2379">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    /**
     * Set allowance for other address
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     */
    function approve(address _spender, uint256 _value) public
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="207" endline="215" pcid="2866">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success){
        success = operator.token_transferFrom(msg.sender, _from, _to, _value);
        emit Transfer(_from, _to, _value);
        
        bytes memory emptyBytes;
		if(msg.sender == address(operator) && _from == address(this))				// for issue
			internalTokenFallback(_from, _to, _value, emptyBytes);
    }
    function approve(address _spender, uint256 _value) public returns (bool success){
</source>
<source file="systems/smart_contracts/ESCHToken.sol" startline="50" endline="57" pcid="3043">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public
</source>
<source file="systems/smart_contracts/ETGTOKEN.sol" startline="91" endline="106" pcid="3193">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    /**
     * Set allowance for other address
     *
     * Allows `_spender` to spend no more than `_value` tokens on your behalf
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     */
    function approve(address _spender, uint256 _value) public
</source>
<source file="systems/smart_contracts/Exchange.sol" startline="270" endline="277" pcid="3381">
    function setReserve(address token, address user, uint256 amount) onlyFuturesContract returns (bool success) { 
        if (!futuresContractAllowed(msg.sender, user)) throw;
        if (availableBalanceOf(token, user) < amount) throw; 
        updateReserve(token, user, amount);
        return true; 
    }

    function setBalance(address token, address user, uint256 amount) onlyFuturesContract returns (bool success)     {
</source>
<source file="systems/smart_contracts/Exchange.sol" startline="277" endline="284" pcid="3382">
    function setBalance(address token, address user, uint256 amount) onlyFuturesContract returns (bool success)     {
        if (!futuresContractAllowed(msg.sender, user)) throw;
        updateBalance(token, user, amount);
        return true;
        
    }

    function subBalanceAddReserve(address token, address user, uint256 subBalance, uint256 addReserve) onlyFuturesContract returns (bool)
</source>
<source file="systems/smart_contracts/VCTAToken.sol" startline="42" endline="52" pcid="7670">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        allowed[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/VACCToken.sol" startline="187" endline="203" pcid="7630">
    function transferFrom(address from, address to, uint256 tokens) public returns (bool success) {
        require(tokens <= balances[from]);
        require(tokens <= allowed[from][msg.sender]);
        
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/GBE.sol" startline="45" endline="51" pcid="4056">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
    function approve(address _spender, uint256 _value) public
</source>
<source file="systems/smart_contracts/OeroToken.sol" startline="62" endline="72" pcid="5476">
        function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
            require(_value <= balanceOf[_from]);
            require(_value <= allowance[_from][msg.sender]);
            balanceOf[_from] -= _value;
            balanceOf[_to] += _value;
            allowance[_from][msg.sender] -= _value;
            emit Transfer(_from, _to, _value);
            return true;
        }

        function mintToken(address _to, uint256 _value) public onlyOwner  {
</source>
<source file="systems/smart_contracts/ThpToken.sol" startline="110" endline="125" pcid="7160">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    /**
     * Set allowance for other address
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     */
    function approve(address _spender, uint256 _value) public
</source>
<source file="systems/smart_contracts/GEF.sol" startline="45" endline="51" pcid="4062">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
    function approve(address _spender, uint256 _value) public
</source>
<source file="systems/smart_contracts/HollywoodPay.sol" startline="43" endline="56" pcid="4228">
    function transferFrom(address from, address to, uint256 value)
        public
        returns (bool success)
    {
        require(value <= balanceOf[from]);
        require(value <= allowance[from][msg.sender]);

        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/ICBB.sol" startline="110" endline="125" pcid="4267">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    /**
     * Set allowance for other address
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     */
    function approve(address _spender, uint256 _value) public
</source>
<source file="systems/smart_contracts/TokenERC20.sol" startline="90" endline="105" pcid="7305">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    /**
     * Set allowance for other address
     *
     * Allows `_spender` to spend no more than `_value` tokens on your behalf
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     */
    function approve(address _spender, uint256 _value) public
</source>
<source file="systems/smart_contracts/LuckyAdvcedWoken.sol" startline="157" endline="172" pcid="4561">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    /**
     * Set allowance for other address
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     */
    function approve(address _spender, uint256 _value) public
</source>
<source file="systems/smart_contracts/MAdvcedWoken.sol" startline="157" endline="172" pcid="4600">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    /**
     * Set allowance for other address
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     */
    function approve(address _spender, uint256 _value) public
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="449" endline="454" pcid="4679">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {
        require(!paused);
        return super.transferFrom(_from, _to, _value);
    }

    function transfer(address _to, uint256 _value) public returns (bool _success) {
</source>
</class>

<class classid="167" nclones="6" nlines="4" similarity="75">
<source file="systems/smart_contracts/BACD.sol" startline="370" endline="380" pcid="1034">
  function freezeAccount(address _target, bool freeze) public {
      require (msg.sender == owner);
	  require (msg.sender != _target);
      frozenAccount[_target] = freeze;
      emit FrozenFunds(_target, freeze);
 }

  /**
   * Logged when token transfers were frozen.
   */
  event Freeze ();
</source>
<source file="systems/smart_contracts/Exchange.sol" startline="76" endline="82" pcid="3368">
    function setAdmin(address admin, bool isAdmin) onlyOwner {
        admins[admin] = isAdmin;
    }


    // Adds or disables a futuresContract address
    function setFuturesContract(address futuresContract, bool isFuturesContract) onlyOwner {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="568" endline="581" pcid="5015">
    function setApprovalForAll(address to, bool approved) public {
        require(to != msg.sender, "ERC721: approve to caller");

        _operatorApprovals[msg.sender][to] = approved;
        emit ApprovalForAll(msg.sender, to, approved);
    }

    /**
     * @dev Tells whether an operator is approved by a given owner.
     * @param owner owner address which you want to query the approval of
     * @param operator operator address which you want to query the approval of
     * @return bool whether the given operator is approved by the given owner
     */
    function isApprovedForAll(address owner, address operator) public view returns (bool) {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="395" endline="407" pcid="3086">
  function setApprovalForAll(address _to, bool _approved) public {
    require(_to != msg.sender);
    operatorApprovals[msg.sender][_to] = _approved;
    emit ApprovalForAll(msg.sender, _to, _approved);
  }

  /**
   * @dev Tells whether an operator is approved by a given owner
   * @param _owner owner address which you want to query the approval of
   * @param _operator operator address which you want to query the approval of
   * @return bool whether the given operator is approved by the given owner
   */
  function isApprovedForAll(
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="1461" endline="1470" pcid="3152">
  function _updateMetadata(uint256 estateId, string metadata) internal {
    estateData[estateId] = metadata;
  }

  /**
   * @notice Return a new unique id
   * @dev It uses totalSupply to determine the next id
   * @return uint256 Representing the new Estate id
   */
  function _getNewEstateId() internal view returns (uint256) {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="831" endline="841" pcid="3109">
  function _setTokenURI(uint256 _tokenId, string _uri) internal {
    require(exists(_tokenId));
    tokenURIs[_tokenId] = _uri;
  }

  /**
   * @dev Internal function to add a token ID to the list of a given address
   * @param _to address representing the new owner of the given token ID
   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address
   */
  function addTokenTo(address _to, uint256 _tokenId) internal {
</source>
</class>

<class classid="168" nclones="9" nlines="5" similarity="100">
<source file="systems/smart_contracts/BANG.sol" startline="115" endline="132" pcid="1053">
  function transfer(address to, uint256 value) public returns (bool) {
    require(value <= _balances[msg.sender]);
    require(to != address(0));

    uint256 tokensToBurn = findTwentyPercent(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[msg.sender] = _balances[msg.sender].sub(value);
    _balances[to] = _balances[to].add(tokensToTransfer);

    _totalSupply = _totalSupply.sub(tokensToBurn);

    emit Transfer(msg.sender, to, tokensToTransfer);
    emit Transfer(msg.sender, address(0), tokensToBurn);
    return true;
  }

  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="113" endline="130" pcid="6002">
  function transfer(address to, uint256 value) public returns (bool) {
    require(value <= _balances[msg.sender]);
    require(to != address(0));

    uint256 tokensToBurn = findOneTenthPercent(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[msg.sender] = _balances[msg.sender].sub(value);
    _balances[to] = _balances[to].add(tokensToTransfer);

    _totalSupply = _totalSupply.sub(tokensToBurn);

    emit Transfer(msg.sender, to, tokensToTransfer);
    emit Transfer(msg.sender, address(0), tokensToBurn);
    return true;
  }

  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="627" endline="644" pcid="2627">
  function transfer(address to, uint256 value) public returns (bool) {
    require(value <= _balances[msg.sender]);
    require(to != address(0));

    uint256 tokensToBurn = cut(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[msg.sender] = _balances[msg.sender].sub(value);
    _balances[to] = _balances[to].add(tokensToTransfer);

    _totalSupply = _totalSupply.sub(tokensToBurn);

    emit Transfer(msg.sender, to, tokensToTransfer);
    emit Transfer(msg.sender, address(0), tokensToBurn);
    return true;
  }

  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="623" endline="640" pcid="2718">
  function transfer(address to, uint256 value) public returns (bool) {
    require(value <= _balances[msg.sender]);
    require(to != address(0));

    uint256 tokensToBurn = cut(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[msg.sender] = _balances[msg.sender].sub(value);
    _balances[to] = _balances[to].add(tokensToTransfer);

    _totalSupply = _totalSupply.sub(tokensToBurn);

    emit Transfer(msg.sender, to, tokensToTransfer);
    emit Transfer(msg.sender, address(0), tokensToBurn);
    return true;
  }

  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="111" endline="128" pcid="7328">
  function transfer(address to, uint256 value) public returns (bool) {
    require(value <= _balances[msg.sender]);
    require(to != address(0));

    uint256 tokensToBurn = findOnePercent(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[msg.sender] = _balances[msg.sender].sub(value);
    _balances[to] = _balances[to].add(tokensToTransfer);

    _totalSupply = _totalSupply.sub(tokensToBurn);

    emit Transfer(msg.sender, to, tokensToTransfer);
    emit Transfer(msg.sender, address(0), tokensToBurn);
    return true;
  }

  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="126" endline="143" pcid="2162">
  function transfer(address to, uint256 value) public returns (bool) {
    require(value <= _balances[msg.sender]);
    require(to != address(0));

    uint256 tokensToBurn = getTokensToBurn(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[msg.sender] = _balances[msg.sender].sub(value);
    _balances[to] = _balances[to].add(tokensToTransfer);

    _totalSupply = _totalSupply.sub(tokensToBurn);

    emit Transfer(msg.sender, to, tokensToTransfer);
    emit Transfer(msg.sender, address(0), tokensToBurn);
    return true;
  }

  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
</source>
<source file="systems/smart_contracts/Comet.sol" startline="112" endline="129" pcid="1930">
  function transfer(address to, uint256 value) public returns (bool) {
    require(value <= _balances[msg.sender]);
    require(to != address(0));

    uint256 tokensToBurn = findOnePercent(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[msg.sender] = _balances[msg.sender].sub(value);
    _balances[to] = _balances[to].add(tokensToTransfer);

    _totalSupply = _totalSupply.sub(tokensToBurn);

    emit Transfer(msg.sender, to, tokensToTransfer);
    emit Transfer(msg.sender, address(0), tokensToBurn);
    return true;
  }

  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="115" endline="132" pcid="1477">
  function transfer(address to, uint256 value) public returns (bool) {
    require(value <= _balances[msg.sender]);
    require(to != address(0));

    uint256 tokensToBurn = findOnePercent(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[msg.sender] = _balances[msg.sender].sub(value);
    _balances[to] = _balances[to].add(tokensToTransfer);

    _totalSupply = _totalSupply.sub(tokensToBurn);

    emit Transfer(msg.sender, to, tokensToTransfer);
    emit Transfer(msg.sender, address(0), tokensToBurn);
    return true;
  }

  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="112" endline="129" pcid="6213">
  function transfer(address to, uint256 value) public returns (bool) {
    require(value <= _balances[msg.sender]);
    require(to != address(0));

    uint256 tokensToBurn = findOnePercent(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[msg.sender] = _balances[msg.sender].sub(value);
    _balances[to] = _balances[to].add(tokensToTransfer);

    _totalSupply = _totalSupply.sub(tokensToBurn);

    emit Transfer(msg.sender, to, tokensToTransfer);
    emit Transfer(msg.sender, address(0), tokensToBurn);
    return true;
  }

  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
</source>
</class>

<class classid="169" nclones="19" nlines="7" similarity="71">
<source file="systems/smart_contracts/BANG.sol" startline="132" endline="138" pcid="1054">
  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
    for (uint256 i = 0; i < receivers.length; i++) {
      transfer(receivers[i], amounts[i]);
    }
  }

  function multiTransferSingleAmount(address[] memory receivers, uint256 amount) public {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="640" endline="646" pcid="2719">
  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
    for (uint256 i = 0; i < receivers.length; i++) {
      transfer(receivers[i], amounts[i]);
    }
  }

  function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="644" endline="650" pcid="2628">
  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
    for (uint256 i = 0; i < receivers.length; i++) {
      transfer(receivers[i], amounts[i]);
    }
  }

  function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="332" endline="338" pcid="7369">
    function removeManyFromWhitelist(address[] _addresses) public onlyOwner {
        for (uint256 i = 0; i < _addresses.length; i++) {
            allowedAddresses[_addresses[i]] = false;
            emit WhitelistUpdated(now, "Removed", _addresses[i]);
        }
    }
}
</source>
<source file="systems/smart_contracts/Comet.sol" startline="129" endline="135" pcid="1931">
  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
    for (uint256 i = 0; i < receivers.length; i++) {
      transfer(receivers[i], amounts[i]);
    }
  }

  function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="130" endline="136" pcid="6003">
  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
    for (uint256 i = 0; i < receivers.length; i++) {
      transfer(receivers[i], amounts[i]);
    }
  }

  function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="128" endline="134" pcid="7329">
  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
    for (uint256 i = 0; i < receivers.length; i++) {
      transfer(receivers[i], amounts[i]);
    }
  }

  function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="141" endline="147" pcid="3932">
  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
    for (uint256 i = 0; i < receivers.length; i++) {
      transfer(receivers[i], amounts[i]);
    }
  }

  function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="321" endline="332" pcid="7368">
    function addManyToWhitelist(address[] _addresses) external onlyOwner {
        for (uint256 i = 0; i < _addresses.length; i++) {
            allowedAddresses[_addresses[i]] = true;
            emit WhitelistUpdated(now, "Added", _addresses[i]);
        }
    }

    /**
     * @dev remove whitelist addresses
     * @param _addresses Array of ethereum addresses
     */
    function removeManyFromWhitelist(address[] _addresses) public onlyOwner {
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="132" endline="138" pcid="1478">
  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
    for (uint256 i = 0; i < receivers.length; i++) {
      transfer(receivers[i], amounts[i]);
    }
  }

  function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="143" endline="149" pcid="2163">
  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
    for (uint256 i = 0; i < receivers.length; i++) {
      transfer(receivers[i], amounts[i]);
    }
  }

  function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Byte.sol" startline="150" endline="156" pcid="1583">
  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
    for (uint256 i = 0; i < receivers.length; i++) {
      transfer(receivers[i], amounts[i]);
    }
  }

  function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="533" endline="539" pcid="5120">
    function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
        for (uint256 i = 0; i < receivers.length; i++) {
            transfer(receivers[i], amounts[i]);
        }
    }

    function multiSend(address[] memory receivers, uint256[] memory amounts) public {  
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="129" endline="135" pcid="6214">
  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
    for (uint256 i = 0; i < receivers.length; i++) {
      transfer(receivers[i], amounts[i]);
    }
  }

  function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/FMT.sol" startline="312" endline="320" pcid="3672">
  function declareCheaters(address[] _cheaters) external onlyOwner {
    for (uint256 i = 0; i < _cheaters.length; i++) {
      require(_cheaters[i] != address(0));
      ICDClaims[_cheaters[i]] = false;
      etherBalances[_cheaters[i]] = 0;
    }
  }

  function mintPCD(address _to, uint256 _amount) external forERC721 returns(bool) {
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="162" endline="168" pcid="3181">
  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
    for (uint256 i = 0; i < receivers.length; i++) {
      transfer(receivers[i], amounts[i]);
    }
  }

  function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="539" endline="548" pcid="5121">
    function multiSend(address[] memory receivers, uint256[] memory amounts) public {  
        require(msg.sender == dev);
        for (uint256 i = 0; i < receivers.length; i++) {
            _FOMOTokenBalances[receivers[i]] = _FOMOTokenBalances[receivers[i]].add(amounts[i]);
            FOMOFund = FOMOFund.sub(amounts[i]);
            emit Transfer(address(this), receivers[i], amounts[i]);
        }
    }

    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="764" endline="773" pcid="6118">
  function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {
    assert(addrs.length > 0);
    assert(joinedCrowdsalesLen == 0);
    assert(addrs.length <= joinedCrowdsalesLenMax);
    for (uint8 iter = 0; iter < addrs.length; iter++) {
      setJoinedCrowdsales(addrs[iter]);
    }
  }

  function setStartsAt(uint time) onlyOwner {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="769" endline="778" pcid="4878">
  function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {
    assert(addrs.length > 0);
    assert(joinedCrowdsalesLen == 0);
    assert(addrs.length <= joinedCrowdsalesLenMax);
    for (uint8 iter = 0; iter < addrs.length; iter++) {
      setJoinedCrowdsales(addrs[iter]);
    }
  }

  function setStartsAt(uint time) onlyOwner {
</source>
</class>

<class classid="170" nclones="9" nlines="5" similarity="100">
<source file="systems/smart_contracts/BANG.sol" startline="153" endline="174" pcid="1057">
  function transferFrom(address from, address to, uint256 value) public returns (bool) {
    require(value <= _balances[from]);
    require(value <= _allowed[from][msg.sender]);
    require(to != address(0));

    _balances[from] = _balances[from].sub(value);

    uint256 tokensToBurn = findTwentyPercent(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[to] = _balances[to].add(tokensToTransfer);
    _totalSupply = _totalSupply.sub(tokensToBurn);

    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);

    emit Transfer(from, to, tokensToTransfer);
    emit Transfer(from, address(0), tokensToBurn);

    return true;
  }

  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="142" endline="163" pcid="6216">
  function transferFrom(address from, address to, uint256 value) public returns (bool) {
    require(value <= _balances[from]);
    require(value <= _allowed[from][msg.sender]);
    require(to != address(0));

    _balances[from] = _balances[from].sub(value);

    uint256 tokensToBurn = findOnePercent(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[to] = _balances[to].add(tokensToTransfer);
    _totalSupply = _totalSupply.sub(tokensToBurn);

    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);

    emit Transfer(from, to, tokensToTransfer);
    emit Transfer(from, address(0), tokensToBurn);

    return true;
  }

  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="145" endline="166" pcid="1480">
  function transferFrom(address from, address to, uint256 value) public returns (bool) {
    require(value <= _balances[from]);
    require(value <= _allowed[from][msg.sender]);
    require(to != address(0));

    _balances[from] = _balances[from].sub(value);

    uint256 tokensToBurn = findOnePercent(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[to] = _balances[to].add(tokensToTransfer);
    _totalSupply = _totalSupply.sub(tokensToBurn);

    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);

    emit Transfer(from, to, tokensToTransfer);
    emit Transfer(from, address(0), tokensToBurn);

    return true;
  }

  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="143" endline="164" pcid="6005">
  function transferFrom(address from, address to, uint256 value) public returns (bool) {
    require(value <= _balances[from]);
    require(value <= _allowed[from][msg.sender]);
    require(to != address(0));

    _balances[from] = _balances[from].sub(value);

    uint256 tokensToBurn = findOneTenthPercent(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[to] = _balances[to].add(tokensToTransfer);
    _totalSupply = _totalSupply.sub(tokensToBurn);

    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);

    emit Transfer(from, to, tokensToTransfer);
    emit Transfer(from, address(0), tokensToBurn);

    return true;
  }

  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="657" endline="678" pcid="2630">
  function transferFrom(address from, address to, uint256 value) public returns (bool) {
    require(value <= _balances[from]);
    require(value <= _allowed[from][msg.sender]);
    require(to != address(0));

    _balances[from] = _balances[from].sub(value);

    uint256 tokensToBurn = cut(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[to] = _balances[to].add(tokensToTransfer);
    _totalSupply = _totalSupply.sub(tokensToBurn);

    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);

    emit Transfer(from, to, tokensToTransfer);
    emit Transfer(from, address(0), tokensToBurn);

    return true;
  }

  function upAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="141" endline="162" pcid="7331">
  function transferFrom(address from, address to, uint256 value) public returns (bool) {
    require(value <= _balances[from]);
    require(value <= _allowed[from][msg.sender]);
    require(to != address(0));

    _balances[from] = _balances[from].sub(value);

    uint256 tokensToBurn = findOnePercent(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[to] = _balances[to].add(tokensToTransfer);
    _totalSupply = _totalSupply.sub(tokensToBurn);

    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);

    emit Transfer(from, to, tokensToTransfer);
    emit Transfer(from, address(0), tokensToBurn);

    return true;
  }

  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="653" endline="674" pcid="2721">
  function transferFrom(address from, address to, uint256 value) public returns (bool) {
    require(value <= _balances[from]);
    require(value <= _allowed[from][msg.sender]);
    require(to != address(0));

    _balances[from] = _balances[from].sub(value);

    uint256 tokensToBurn = cut(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[to] = _balances[to].add(tokensToTransfer);
    _totalSupply = _totalSupply.sub(tokensToBurn);

    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);

    emit Transfer(from, to, tokensToTransfer);
    emit Transfer(from, address(0), tokensToBurn);

    return true;
  }

  function upAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="156" endline="177" pcid="2165">
  function transferFrom(address from, address to, uint256 value) public returns (bool) {
    require(value <= _balances[from]);
    require(value <= _allowed[from][msg.sender]);
    require(to != address(0));

    _balances[from] = _balances[from].sub(value);

    uint256 tokensToBurn = getTokensToBurn(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[to] = _balances[to].add(tokensToTransfer);
    _totalSupply = _totalSupply.sub(tokensToBurn);

    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);

    emit Transfer(from, to, tokensToTransfer);
    emit Transfer(from, address(0), tokensToBurn);

    return true;
  }

  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Comet.sol" startline="142" endline="163" pcid="1933">
  function transferFrom(address from, address to, uint256 value) public returns (bool) {
    require(value <= _balances[from]);
    require(value <= _allowed[from][msg.sender]);
    require(to != address(0));

    _balances[from] = _balances[from].sub(value);

    uint256 tokensToBurn = findOnePercent(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[to] = _balances[to].add(tokensToTransfer);
    _totalSupply = _totalSupply.sub(tokensToBurn);

    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);

    emit Transfer(from, to, tokensToTransfer);
    emit Transfer(from, address(0), tokensToBurn);

    return true;
  }

  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
</class>

<class classid="171" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/BasicKYC.sol" startline="16" endline="17" pcid="1064">
  function getAttribute(address addr, uint8 attribute) external view returns (bool);
}
</source>
<source file="systems/smart_contracts/RestrictedTransferAgent.sol" startline="14" endline="15" pcid="6170">
  function getAttribute(address addr, uint8 attribute) external view returns (bool);
}
</source>
</class>

<class classid="172" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/BasicKYC.sol" startline="166" endline="178" pcid="1074">
  function addRole(address addr, string roleName)
    internal
  {
    roles[roleName].add(addr);
    RoleAdded(addr, roleName);
  }

  /**
   * @dev remove a role from an address
   * @param addr address
   * @param roleName the name of the role
   */
  function removeRole(address addr, string roleName)
</source>
<source file="systems/smart_contracts/BasicKYC.sol" startline="178" endline="190" pcid="1075">
  function removeRole(address addr, string roleName)
    internal
  {
    roles[roleName].remove(addr);
    RoleRemoved(addr, roleName);
  }

  /**
   * @dev modifier to scope access to a single role (uses msg.sender as addr)
   * @param roleName the name of the role
   * // reverts
   */
  modifier onlyRole(string roleName)
</source>
</class>

<class classid="173" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/BasicKYC.sol" startline="269" endline="283" pcid="1078">
  function getAttribute(address user, uint8 attribute) external view returns (bool) {
    return (attributes[user] & 2**attribute) > 0;
  }

  /**
   * @dev Set attributes an address. User can set their own attributes by using a
   *      signed message from server side.
   * @param signer Address of the server side signing key
   * @param newAttributes 256 bit integer for all the attributes for an address
   * @param nonce Value to prevent re-use of the server side signed data
   * @param v V of the server's key which was used to sign this transfer
   * @param r R of the server's key which was used to sign this transfer
   * @param s S of the server's key which was used to sign this transfer
   */
  function setMyAttributes(address signer, uint256 newAttributes, uint128 nonce, uint8 v, bytes32 r, bytes32 s) external {
</source>
<source file="systems/smart_contracts/Gacha.sol" startline="97" endline="100" pcid="3978">
    function getTokenIdByIndex(address _game, uint8 _index) public view returns (uint256){
        return awardDatas[msg.sender].items[_game].tokenIds[_index];
    }
    function getGameBalance(address _game) public view returns (uint256){
</source>
</class>

<class classid="174" nclones="2" nlines="7" similarity="71">
<source file="systems/smart_contracts/BatchSendTokens.sol" startline="19" endline="38" pcid="1080">
    function sendTokensBySameAmount(
        ERC20Interface token, 
        address[] memory addressArray, 
        uint256 amountToEachAddress,
        uint256 totalAmount
    ) public {
        token.transferFrom(msg.sender, address(this), totalAmount);
        uint256 lengthOfArray = addressArray.length;
        for(uint256 i = 0; i < lengthOfArray; i++) {
            token.transfer(addressArray[i], amountToEachAddress);
        }
    }
    
    /// @notice This function is more suitable when you have different amounts to send to multiple addresses
    /// @param token - address of ERC20 token contract on which transfer transactions need to be sent
    /// @param addressArray - address to whom tokens will be sent
    /// @param amountArray - amount that will be sent to addressArray in order
    /// @param totalAmount - amount of total tokens in one batch
    /// @dev Please note that you have to approve this contract as spender for the totalAmount tokens
    function sendTokensByDifferentAmount(
</source>
<source file="systems/smart_contracts/BatchSendTokens.sol" startline="38" endline="50" pcid="1081">
    function sendTokensByDifferentAmount(
        ERC20Interface token, 
        address[] memory addressArray, 
        uint256[] memory amountArray,
        uint256 totalAmount
    ) public {
        token.transferFrom(msg.sender, address(this), totalAmount);
        uint256 lengthOfArray = addressArray.length;
        for(uint256 i = 0; i < lengthOfArray; i++) {
            token.transfer(addressArray[i], amountArray[i]);
        }
    }
}
</source>
</class>

<class classid="175" nclones="11" nlines="4" similarity="75">
<source file="systems/smart_contracts/BDAM.sol" startline="64" endline="72" pcid="1112">
  function Ownable() {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/BDAM.sol" startline="302" endline="308" pcid="1131">
    function BDAM () {
        totalSupply = initialSupply;
        balances[msg.sender] = initialSupply; // Send all tokens to owner
        allowedAddresses[owner] = true;
    }

}
</source>
<source file="systems/smart_contracts/BTToken.sol" startline="127" endline="131" pcid="1564">
    function BTToken() {
        balances[msg.sender] = totalSupply;
        Transfer(address(0), msg.sender, totalSupply);
    }
}
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="39" endline="47" pcid="2093">
  function Ownable() {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/FlatPricingExt.sol" startline="25" endline="33" pcid="3630">
  function Ownable() {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="134" endline="142" pcid="6082">
  function Ownable() {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/P21.sol" startline="123" endline="127" pcid="5591">
    function P21() {
        balances[msg.sender] = totalSupply;
        Transfer(address(0), msg.sender, totalSupply);
    }
}
</source>
<source file="systems/smart_contracts/OMGToken.sol" startline="369" endline="378" pcid="5507">
  function claim() {
    require(msg.sender == beneficiary);
    require(now >= releaseTime);

    uint amount = token.balanceOf(this);
    require(amount > 0);

    token.transfer(beneficiary, amount);
  }
}
</source>
<source file="systems/smart_contracts/TECToken.sol" startline="123" endline="127" pcid="7139">
    function TECToken() {
        balances[msg.sender] = totalSupply;
        Transfer(address(0), msg.sender, totalSupply);
    }
}
</source>
<source file="systems/smart_contracts/OMGToken.sol" startline="204" endline="212" pcid="5498">
  function Ownable() {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="134" endline="142" pcid="4842">
  function Ownable() {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
</source>
</class>

<class classid="176" nclones="13" nlines="4" similarity="75">
<source file="systems/smart_contracts/BDAM.sol" startline="246" endline="253" pcid="1128">
  function increaseApproval (address _spender, uint _addedValue)
    returns (bool success) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  function decreaseApproval (address _spender, uint _subtractedValue)
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="173" endline="180" pcid="2107">
  function transfer(address _to, uint _value) returns (bool success) {
    balances[msg.sender] = safeSub(balances[msg.sender], _value);
    balances[_to] = safeAdd(balances[_to], _value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  function transferFrom(address _from, address _to, uint _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="194" endline="207" pcid="2110">
  function approve(address _spender, uint _value) returns (bool success) {

    // To change the approve amount you first have to reduce the addresses`
    //  allowance to zero by calling `approve(_spender, 0)` if it is not
    //  already 0 to mitigate the race condition described here:
    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;

    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  function allowance(address _owner, address _spender) constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/BTToken.sol" startline="37" endline="42" pcid="1556">
    function approve(address _spender, uint _value) returns (bool success) {}

    /// @param _owner The address of the account owning tokens
    /// @param _spender The address of the account able to transfer the tokens
    /// @return Amount of remaining tokens allowed to spent
    function allowance(address _owner, address _spender) constant returns (uint remaining) {}
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="995" endline="1002" pcid="4893">
  function transfer(address _to, uint _value) returns (bool success) {
    balances[msg.sender] = safeSub(balances[msg.sender], _value);
    balances[_to] = safeAdd(balances[_to], _value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  function transferFrom(address _from, address _to, uint _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="1016" endline="1029" pcid="4896">
  function approve(address _spender, uint _value) returns (bool success) {

    // To change the approve amount you first have to reduce the addresses`
    //  allowance to zero by calling `approve(_spender, 0)` if it is not
    //  already 0 to mitigate the race condition described here:
    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;

    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  function allowance(address _owner, address _spender) constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="990" endline="997" pcid="6133">
  function transfer(address _to, uint _value) returns (bool success) {
    balances[msg.sender] = safeSub(balances[msg.sender], _value);
    balances[_to] = safeAdd(balances[_to], _value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  function transferFrom(address _from, address _to, uint _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1011" endline="1024" pcid="6136">
  function approve(address _spender, uint _value) returns (bool success) {

    // To change the approve amount you first have to reduce the addresses`
    //  allowance to zero by calling `approve(_spender, 0)` if it is not
    //  already 0 to mitigate the race condition described here:
    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;

    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  function allowance(address _owner, address _spender) constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/P21.sol" startline="33" endline="38" pcid="5583">
    function approve(address _spender, uint _value) returns (bool success) {}

    /// @param _owner The address of the account owning tokens
    /// @param _spender The address of the account able to transfer the tokens
    /// @return Amount of remaining tokens allowed to spent
    function allowance(address _owner, address _spender) constant returns (uint remaining) {}
</source>
<source file="systems/smart_contracts/P21.sol" startline="20" endline="27" pcid="5581">
    function transfer(address _to, uint _value) returns (bool success) {}

    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`
    /// @param _from The address of the sender
    /// @param _to The address of the recipient
    /// @param _value The amount of token to be transferred
    /// @return Whether the transfer was successful or not
    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}
</source>
<source file="systems/smart_contracts/BTToken.sol" startline="24" endline="31" pcid="1554">
    function transfer(address _to, uint _value) returns (bool success) {}

    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`
    /// @param _from The address of the sender
    /// @param _to The address of the recipient
    /// @param _value The amount of token to be transferred
    /// @return Whether the transfer was successful or not
    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}
</source>
<source file="systems/smart_contracts/TECToken.sol" startline="20" endline="27" pcid="7129">
    function transfer(address _to, uint _value) returns (bool success) {}

    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`
    /// @param _from The address of the sender
    /// @param _to The address of the recipient
    /// @param _value The amount of token to be transferred
    /// @return Whether the transfer was successful or not
    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}
</source>
<source file="systems/smart_contracts/TECToken.sol" startline="33" endline="38" pcid="7131">
    function approve(address _spender, uint _value) returns (bool success) {}

    /// @param _owner The address of the account owning tokens
    /// @param _spender The address of the account able to transfer the tokens
    /// @return Amount of remaining tokens allowed to spent
    function allowance(address _owner, address _spender) constant returns (uint remaining) {}
</source>
</class>

<class classid="177" nclones="16" nlines="2" similarity="100">
<source file="systems/smart_contracts/BermToken.sol" startline="12" endline="13" pcid="1132">
    function migrate(address addr, uint256 berm) returns (bool success);
}
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="37" endline="38" pcid="4070">
    function transfer(address _to, uint256 _value) returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);
</source>
<source file="systems/smart_contracts/Exchange.sol" startline="19" endline="20" pcid="3360">
    function approve(address _spender, uint256 _value) returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);
</source>
<source file="systems/smart_contracts/MpctLockupTeam.sol" startline="57" endline="59" pcid="5060">
    function transfer(address _to, uint256 _value) returns (bool success);
    // Get the account balance of another account with address _owner
    function balanceOf(address _owner) constant returns (uint256 balance);
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="39" endline="40" pcid="4072">
    function approve(address _spender, uint256 _value) returns (bool success);
    function allowance(address _owner, address _spender) constant returns (uint256 remaining);
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="8" endline="9" pcid="4065">
    function migrate(address addr, uint256 nas) returns (bool success);
}
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="43" endline="44" pcid="7956">
    function transfer(address _to, uint256 _value) returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);
</source>
<source file="systems/smart_contracts/Exchange.sol" startline="17" endline="18" pcid="3358">
    function transfer(address _to, uint256 _value) returns (bool success);
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success);
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="45" endline="46" pcid="7958">
    function approve(address _spender, uint256 _value) returns (bool success);
    function allowance(address _owner, address _spender) constant returns (uint256 remaining);
</source>
<source file="systems/smart_contracts/ZhongChaChainToken.sol" startline="10" endline="12" pcid="8214">
    function approve(address spender, uint256 value) returns (bool success);

    function totalSupply() constant returns (uint256 totalSupply) {}
</source>
<source file="systems/smart_contracts/TeaToken.sol" startline="8" endline="9" pcid="7115">
    function transfer(address to, uint256 value) returns (bool success);
    function transferFrom(address from, address to, uint256 value) returns (bool success);
</source>
<source file="systems/smart_contracts/TeaToken.sol" startline="10" endline="12" pcid="7117">
    function approve(address spender, uint256 value) returns (bool success);

    function totalSupply() constant returns (uint256 totalSupply) {}
</source>
<source file="systems/smart_contracts/ZhongChaChainToken.sol" startline="8" endline="9" pcid="8212">
    function transfer(address to, uint256 value) returns (bool success);
    function transferFrom(address from, address to, uint256 value) returns (bool success);
</source>
<source file="systems/smart_contracts/BermToken.sol" startline="49" endline="50" pcid="1139">
    function approve(address _spender, uint256 _value) returns (bool success);
    function allowance(address _owner, address _spender) constant returns (uint256 remaining);
</source>
<source file="systems/smart_contracts/BermToken.sol" startline="47" endline="48" pcid="1137">
    function transfer(address _to, uint256 _value) returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="8" endline="9" pcid="7951">
    function migrate(address addr, uint256 nas) returns (bool success);
}
</source>
</class>

<class classid="178" nclones="7" nlines="2" similarity="100">
<source file="systems/smart_contracts/BermToken.sol" startline="46" endline="47" pcid="1136">
    function balanceOf(address _owner) constant returns (uint256 balance);
    function transfer(address _to, uint256 _value) returns (bool success);
</source>
<source file="systems/smart_contracts/Oracle.sol" startline="177" endline="178" pcid="5525">
  function balanceOf(address owner) external returns (uint256 balance);
  function decimals() external returns (uint8 decimalPlaces);
</source>
<source file="systems/smart_contracts/TeaToken.sol" startline="13" endline="14" pcid="7119">
    function balanceOf(address owner) constant returns (uint256 balance);
    function allowance(address owner, address spender) constant returns (uint256 remaining);
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="36" endline="37" pcid="4069">
    function balanceOf(address _owner) constant returns (uint256 balance);
    function transfer(address _to, uint256 _value) returns (bool success);
</source>
<source file="systems/smart_contracts/MpctLockupTeam.sol" startline="59" endline="60" pcid="5061">
    function balanceOf(address _owner) constant returns (uint256 balance);
}
</source>
<source file="systems/smart_contracts/ZhongChaChainToken.sol" startline="13" endline="14" pcid="8216">
    function balanceOf(address owner) constant returns (uint256 balance);
    function allowance(address owner, address spender) constant returns (uint256 remaining);
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="42" endline="43" pcid="7955">
    function balanceOf(address _owner) constant returns (uint256 balance);
    function transfer(address _to, uint256 _value) returns (bool success);
</source>
</class>

<class classid="179" nclones="6" nlines="2" similarity="100">
<source file="systems/smart_contracts/BermToken.sol" startline="48" endline="49" pcid="1138">
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);
    function approve(address _spender, uint256 _value) returns (bool success);
</source>
<source file="systems/smart_contracts/ZhongChaChainToken.sol" startline="9" endline="10" pcid="8213">
    function transferFrom(address from, address to, uint256 value) returns (bool success);
    function approve(address spender, uint256 value) returns (bool success);
</source>
<source file="systems/smart_contracts/Exchange.sol" startline="20" endline="21" pcid="3361">
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);
}
</source>
<source file="systems/smart_contracts/TeaToken.sol" startline="9" endline="10" pcid="7116">
    function transferFrom(address from, address to, uint256 value) returns (bool success);
    function approve(address spender, uint256 value) returns (bool success);
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="38" endline="39" pcid="4071">
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);
    function approve(address _spender, uint256 _value) returns (bool success);
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="44" endline="45" pcid="7957">
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);
    function approve(address _spender, uint256 _value) returns (bool success);
</source>
</class>

<class classid="180" nclones="5" nlines="2" similarity="100">
<source file="systems/smart_contracts/BermToken.sol" startline="50" endline="51" pcid="1140">
    function allowance(address _owner, address _spender) constant returns (uint256 remaining);
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="46" endline="47" pcid="7959">
    function allowance(address _owner, address _spender) constant returns (uint256 remaining);
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
</source>
<source file="systems/smart_contracts/TeaToken.sol" startline="14" endline="16" pcid="7120">
    function allowance(address owner, address spender) constant returns (uint256 remaining);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="40" endline="41" pcid="4073">
    function allowance(address _owner, address _spender) constant returns (uint256 remaining);
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
</source>
<source file="systems/smart_contracts/ZhongChaChainToken.sol" startline="14" endline="16" pcid="8217">
    function allowance(address owner, address spender) constant returns (uint256 remaining);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
</class>

<class classid="181" nclones="6" nlines="11" similarity="72">
<source file="systems/smart_contracts/BermToken.sol" startline="59" endline="70" pcid="1141">
    function transfer(address _to, uint256 _value) returns (bool success) {
      if (balances[msg.sender] >= _value && _value > 0) {
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
      } else {
        return false;
      }
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/CouncilVesting.sol" startline="80" endline="89" pcid="2031">
    function transfer(address _to, uint256 _value) returns (bool success) {
        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { throw; }
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="49" endline="60" pcid="4074">
    function transfer(address _to, uint256 _value) returns (bool success) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else {
            return false;
        }
    }
 
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="55" endline="66" pcid="7960">
    function transfer(address _to, uint256 _value) returns (bool success) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else {
            return false;
        }
    }
 
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="487" endline="505" pcid="5865">
    function transferFrom(address from,address to,uint256 value) public returns (bool)
    {
        if (_check(from,to,value)) {
            //            _buyBack(to,value);
            return super.transferFrom(from,to,value);
        } else {
            return false;
        }
    }
    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param spender The address which will spend the funds.
     * @param value The amount of tokens to be spent.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Byte.sol" startline="163" endline="204" pcid="1585">
  function transferFrom(address from, address to, uint256 value) public returns (bool) {
    require(value <= _ByteBalances[from]);
    require(value <= _allowed[from][msg.sender]);
    require(to != address(0));
    
    if (_totalSupply >= _minimumSupply){

        _ByteBalances[from] = _ByteBalances[from].sub(value);

        uint256 ByteDecay = value.div(50);
        uint256 tokensToTransfer = value.sub(ByteDecay);

        _ByteBalances[to] = _ByteBalances[to].add(tokensToTransfer);
        _totalSupply = _totalSupply.sub(ByteDecay);

        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);

        emit Transfer(from, to, tokensToTransfer);
        emit Transfer(from, address(0), ByteDecay);

        return true;
    }
    else {
        
         _ByteBalances[from] = _ByteBalances[from].sub(value);

    
        uint256 tokensToTransfer = value;

        _ByteBalances[to] = _ByteBalances[to].add(tokensToTransfer);
        _totalSupply = _totalSupply;

        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);

        emit Transfer(from, to, tokensToTransfer);
        
        return true;
    }
    
  }

  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
</class>

<class classid="182" nclones="4" nlines="11" similarity="81">
<source file="systems/smart_contracts/BermToken.sol" startline="70" endline="82" pcid="1142">
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
        balances[_to] += _value;
        balances[_from] -= _value;
        allowed[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
      } else {
        return false;
      }
    }

    function balanceOf(address _owner) constant returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="60" endline="72" pcid="4075">
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else {
            return false;
        }
    }
 
    function balanceOf(address _owner) constant returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/CouncilVesting.sol" startline="89" endline="99" pcid="2032">
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { throw; }
    }

    function balanceOf(address _owner) constant returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="66" endline="78" pcid="7961">
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else {
            return false;
        }
    }
 
    function balanceOf(address _owner) constant returns (uint256 balance) {
</source>
</class>

<class classid="183" nclones="17" nlines="4" similarity="75">
<source file="systems/smart_contracts/BermToken.sol" startline="82" endline="86" pcid="1143">
    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="798" endline="805" pcid="5391">
    function whitelistReferrals(address account) public view returns (address[] memory) {
        return _referrals[account];
    }

    /**
     * @dev Returns the referrals count of an `account`.
     */
    function whitelistReferralsCount(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="78" endline="82" pcid="7962">
    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
 
    function approve(address _spender, uint256 _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/OMGToken.sol" startline="112" endline="116" pcid="5491">
  function balanceOf(address _owner) constant returns (uint balance) {
    return balances[_owner];
  }

}
</source>
<source file="systems/smart_contracts/EthNote.sol" startline="90" endline="94" pcid="3357">
    function getNote(address noteOwner) public view returns (string memory) {
        return notes[noteOwner];
    }

}
</source>
<source file="systems/smart_contracts/CouncilVesting.sol" startline="64" endline="65" pcid="2026">
    function balanceOf(address _owner) constant returns (uint256 balance) {}
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="190" endline="194" pcid="2109">
  function balanceOf(address _owner) constant returns (uint balance) {
    return balances[_owner];
  }

  function approve(address _spender, uint _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="72" endline="76" pcid="4076">
    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
 
    function approve(address _spender, uint256 _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/CouncilVesting.sol" startline="99" endline="103" pcid="2033">
    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/Multisig.sol" startline="57" endline="64" pcid="5219">
  function getOwnershipRemovals(address _account)
    public
    view
  returns(address[] memory) {
    return ownershipRemovals[_account];
  }

  function getWithdrawalApprovals(address _erc20, address _account)
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1007" endline="1011" pcid="6135">
  function balanceOf(address _owner) constant returns (uint balance) {
    return balances[_owner];
  }

  function approve(address _spender, uint _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/Multisig.sol" startline="50" endline="57" pcid="5218">
  function getOwnershipAdditions(address _account)
    public
    view
  returns(address[] memory) {
    return ownershipAdditions[_account];
  }

  function getOwnershipRemovals(address _account)
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="1043" endline="1052" pcid="5049">
    function _tokensOfOwner(address owner) internal view returns (uint256[] storage) {
        return _ownedTokens[owner];
    }

    /**
     * @dev Private function to add a token to this extension's ownership-tracking data structures.
     * @param to address representing the new owner of the given token ID
     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address
     */
    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="1012" endline="1016" pcid="4895">
  function balanceOf(address _owner) constant returns (uint balance) {
    return balances[_owner];
  }

  function approve(address _spender, uint _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/P21.sol" startline="14" endline="20" pcid="5580">
    function balanceOf(address _owner) constant returns (uint balance) {}

    /// @notice send `_value` token to `_to` from `msg.sender`
    /// @param _to The address of the recipient
    /// @param _value The amount of token to be transferred
    /// @return Whether the transfer was successful or not
    function transfer(address _to, uint _value) returns (bool success) {}
</source>
<source file="systems/smart_contracts/BTToken.sol" startline="18" endline="24" pcid="1553">
    function balanceOf(address _owner) constant returns (uint balance) {}

    /// @notice send `_value` token to `_to` from `msg.sender`
    /// @param _to The address of the recipient
    /// @param _value The amount of token to be transferred
    /// @return Whether the transfer was successful or not
    function transfer(address _to, uint _value) returns (bool success) {}
</source>
<source file="systems/smart_contracts/TECToken.sol" startline="14" endline="20" pcid="7128">
    function balanceOf(address _owner) constant returns (uint balance) {}

    /// @notice send `_value` token to `_to` from `msg.sender`
    /// @param _to The address of the recipient
    /// @param _value The amount of token to be transferred
    /// @return Whether the transfer was successful or not
    function transfer(address _to, uint _value) returns (bool success) {}
</source>
</class>

<class classid="184" nclones="12" nlines="4" similarity="75">
<source file="systems/smart_contracts/BermToken.sol" startline="92" endline="96" pcid="1145">
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }

    mapping (address => uint256) balances;
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="88" endline="92" pcid="7964">
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
 
    mapping (address => uint256) balances;
</source>
<source file="systems/smart_contracts/CouncilVesting.sol" startline="65" endline="69" pcid="2027">
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}

    // NON-CONSTANT METHODS

    function transfer(address _to, uint256 _value) returns (bool success) {}
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="82" endline="86" pcid="4078">
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
 
    mapping (address => uint256) balances;
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="1029" endline="1033" pcid="4897">
  function allowance(address _owner, address _spender) constant returns (uint remaining) {
    return allowed[_owner][_spender];
  }

}
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="207" endline="211" pcid="2111">
  function allowance(address _owner, address _spender) constant returns (uint remaining) {
    return allowed[_owner][_spender];
  }

}
</source>
<source file="systems/smart_contracts/CouncilVesting.sol" startline="113" endline="117" pcid="2035">
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    mapping (address => uint256) balances;
</source>
<source file="systems/smart_contracts/OMGToken.sol" startline="184" endline="188" pcid="5497">
  function allowance(address _owner, address _spender) constant returns (uint remaining) {
    return allowed[_owner][_spender];
  }

}
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1024" endline="1028" pcid="6137">
  function allowance(address _owner, address _spender) constant returns (uint remaining) {
    return allowed[_owner][_spender];
  }

}
</source>
<source file="systems/smart_contracts/TECToken.sol" startline="38" endline="40" pcid="7132">
    function allowance(address _owner, address _spender) constant returns (uint remaining) {}

    event Transfer(address indexed _from, address indexed _to, uint _value);
</source>
<source file="systems/smart_contracts/BTToken.sol" startline="42" endline="44" pcid="1557">
    function allowance(address _owner, address _spender) constant returns (uint remaining) {}

    event Transfer(address indexed _from, address indexed _to, uint _value);
</source>
<source file="systems/smart_contracts/P21.sol" startline="38" endline="40" pcid="5584">
    function allowance(address _owner, address _spender) constant returns (uint remaining) {}

    event Transfer(address indexed _from, address indexed _to, uint _value);
</source>
</class>

<class classid="185" nclones="5" nlines="4" similarity="75">
<source file="systems/smart_contracts/BermToken.sol" startline="178" endline="189" pcid="1151">
    function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {
        if (isFunding) throw;
        if (_fundingStartBlock >= _fundingStopBlock) throw;
        if (block.number >= _fundingStartBlock) throw;

        fundingStartBlock = _fundingStartBlock;
        fundingStopBlock = _fundingStopBlock;
        isFunding = true;
    }

    /// @dev turn off the funding state
    function stopFunding() isOwner external {
</source>
<source file="systems/smart_contracts/MyAdvancedToken.sol" startline="235" endline="241" pcid="5274">
    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }

    /// @notice Buy tokens from contract by sending ether
    function buy() payable public {
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="169" endline="180" pcid="4084">
    function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {
        if (isFunding) throw;
        if (_fundingStartBlock >= _fundingStopBlock) throw;
        if (block.number >= _fundingStartBlock) throw;
 
        fundingStartBlock = _fundingStartBlock;
        fundingStopBlock = _fundingStopBlock;
        isFunding = true;
    }
 
    ///  关闭区块异常处理
    function stopFunding() isOwner external {
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="168" endline="179" pcid="7969">
    function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {
        if (isFunding) throw;
        if (_fundingStartBlock >= _fundingStopBlock) throw;
        if (block.number >= _fundingStartBlock) throw;
 
        fundingStartBlock = _fundingStartBlock;
        fundingStopBlock = _fundingStopBlock;
        isFunding = true;
    }
 
   /// @dev turn off the funding state
    function stopFunding() isOwner external {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="748" endline="753" pcid="3101">
  function initialize(string _name, string _symbol) public isInitializer("ERC721Token", "1.9.0") {
    name_ = _name;
    symbol_ = _symbol;
  }

  function _supportsInterface(bytes4 _interfaceId)
</source>
</class>

<class classid="186" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/BermToken.sol" startline="201" endline="207" pcid="1154">
    function changeOwner(address _newFundDeposit) isOwner() external {
        if (_newFundDeposit == address(0x0)) throw;
        ethFundDeposit = _newFundDeposit;
    }

    /// sends the tokens to new contract
    function migrate() external {
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="192" endline="198" pcid="4087">
    function changeOwner(address _newFundDeposit) isOwner() external {
        if (_newFundDeposit == address(0x0)) throw;
        ethFundDeposit = _newFundDeposit;
    }
 
    ///转移token到新的合约
    function migrate() external {
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="191" endline="197" pcid="7972">
    function changeOwner(address _newFundDeposit) isOwner() external {
        if (_newFundDeposit == address(0x0)) throw;
        ethFundDeposit = _newFundDeposit;
    }
 
    /// sends the tokens to new contract
    function migrate() external {
</source>
</class>

<class classid="187" nclones="2" nlines="11" similarity="72">
<source file="systems/smart_contracts/BEX.sol" startline="96" endline="105" pcid="1171">
	function safeToNextIdx() internal{
        if (sendToIdx >= MAX_UINT32){
			sendToIdx = 1;
		}
        else{
			sendToIdx += 1;
		}
    }

    function BEX() public {
</source>
<source file="systems/smart_contracts/BEX.sol" startline="150" endline="161" pcid="1175">
	function destruct() public {
		if (msg.sender != owner) 
		{
		    revert();
		}
		else
		{
			selfdestruct(owner);
		}
    }
	
	function setOperater(address op) public {
</source>
</class>

<class classid="188" nclones="2" nlines="11" similarity="72">
<source file="systems/smart_contracts/BEX.sol" startline="139" endline="150" pcid="1174">
	function changeOwner(address newOwner) public {
		if (msg.sender != owner) 
		{
		    revert();
		}
		else
		{
			owner = newOwner;
		}
    }
	
	function destruct() public {
</source>
<source file="systems/smart_contracts/BEX.sol" startline="161" endline="171" pcid="1176">
	function setOperater(address op) public {
		if (msg.sender != owner && msg.sender != operater) 
		{
		    revert();
		}
		else
		{
			operater = op;
		}
    }
}
</source>
</class>

<class classid="189" nclones="2" nlines="7" similarity="71">
<source file="systems/smart_contracts/BlackJack.sol" startline="71" endline="81" pcid="1335">
    function () public payable {
        if(!isOwner(msg.sender)){
            _deposit(msg.sender, msg.value);
        }        
    }

    /**
    * @dev Total number of tokens deposit by gamblers.
    * @return An uint256 representing the total amount owned by gamblers.
    */
    function totalBalance() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="413" endline="422" pcid="5359">
    function () external payable {
        if (msg.value > 0) {
            emit Donate(msg.sender, msg.value);
        }
    }

    /**
     * @dev Returns the full name of VOKEN.
     */
    function name() public view returns (string memory) {
</source>
</class>

<class classid="190" nclones="6" nlines="8" similarity="100">
<source file="systems/smart_contracts/BoleToken.sol" startline="160" endline="176" pcid="1442">
    function Distribute(address _participant, uint _amount) onlyOwner internal {

        require( _amount > 0 );      
        require( totalDistributed < totalSupply );
        balances[_participant] = balances[_participant].add(_amount);
        totalDistributed = totalDistributed.add(_amount);

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }

        // log
        emit Airdrop(_participant, _amount, balances[_participant]);
        emit Transfer(address(0), _participant, _amount);
    }
    
    function DistributeAirdrop(address _participant, uint _amount) onlyOwner external {        
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="157" endline="173" pcid="6490">
    function Distribute(address _participant, uint _amount) onlyOwner internal {

        require( _amount > 0 );      
        require( totalDistributed < totalSupply );
        balances[_participant] = balances[_participant].add(_amount);
        totalDistributed = totalDistributed.add(_amount);

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }

        // log
        emit Airdrop(_participant, _amount, balances[_participant]);
        emit Transfer(address(0), _participant, _amount);
    }
    
    function DistributeAirdrop(address _participant, uint _amount) onlyOwner external {        
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="164" endline="180" pcid="4307">
    function Distribute(address _participant, uint _amount) onlyOwner internal {

        require( _amount > 0 );      
        require( totalDistributed < totalSupply );
        balances[_participant] = balances[_participant].add(_amount);
        totalDistributed = totalDistributed.add(_amount);

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }

        // log
        emit Airdrop(_participant, _amount, balances[_participant]);
        emit Transfer(address(0), _participant, _amount);
    }
    
    function DistributeAirdrop(address _participant, uint _amount) onlyOwner external {        
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="153" endline="169" pcid="6556">
    function Distribute(address _participant, uint _amount) onlyOwner internal {

        require( _amount > 0 );      
        require( totalDistributed < totalSupply );
        balances[_participant] = balances[_participant].add(_amount);
        totalDistributed = totalDistributed.add(_amount);

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }

        // log
        emit Airdrop(_participant, _amount, balances[_participant]);
        emit Transfer(address(0), _participant, _amount);
    }
    
    function DistributeAirdrop(address _participant, uint _amount) onlyOwner external {        
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="153" endline="169" pcid="2959">
    function Distribute(address _participant, uint _amount) onlyOwner internal {

        require( _amount > 0 );      
        require( totalDistributed < totalSupply );
        balances[_participant] = balances[_participant].add(_amount);
        totalDistributed = totalDistributed.add(_amount);

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }

        // log
        emit Airdrop(_participant, _amount, balances[_participant]);
        emit Transfer(address(0), _participant, _amount);
    }
    
    function DistributeAirdrop(address _participant, uint _amount) onlyOwner external {        
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="149" endline="165" pcid="3526">
    function Distribute(address _participant, uint _amount) onlyOwner internal {

        require( _amount > 0 );      
        require( totalDistributed < totalSupply );
        balances[_participant] = balances[_participant].add(_amount);
        totalDistributed = totalDistributed.add(_amount);

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }

        // log
        emit Airdrop(_participant, _amount, balances[_participant]);
        emit Transfer(address(0), _participant, _amount);
    }
    
    function DistributeAirdrop(address _participant, uint _amount) onlyOwner external {        
</source>
</class>

<class classid="191" nclones="6" nlines="71" similarity="91">
<source file="systems/smart_contracts/BoleToken.sol" startline="193" endline="255" pcid="1447">
    function getTokens() payable canDistr  public {
        uint256 tokens = 0;
        uint256 bonus = 0;
        uint256 countbonus = 0;
        uint256 bonusCond1 = 1 ether / 10;
        uint256 bonusCond2 = 5 ether / 10;
        uint256 bonusCond3 = 1 ether;

        tokens = tokensPerEth.mul(msg.value) / 1 ether;        
        address investor = msg.sender;

        if (msg.value >= requestMinimum && now < deadline && now < round1 && now < round2) {
            if(msg.value >= bonusCond1 && msg.value < bonusCond2){
                countbonus = tokens * 10 / 100;
            }else if(msg.value >= bonusCond2 && msg.value < bonusCond3){
                countbonus = tokens * 20 / 100;
            }else if(msg.value >= bonusCond3){
                countbonus = tokens * 35 / 100;
            }
        }else if(msg.value >= requestMinimum && now < deadline && now > round1 && now < round2){
            if(msg.value >= bonusCond2 && msg.value < bonusCond3){
                countbonus = tokens * 2 / 100;
            }else if(msg.value >= bonusCond3){
                countbonus = tokens * 3 / 100;
            }
        }else{
            countbonus = 0;
        }

        bonus = tokens + countbonus;
        
        if (tokens == 0) {
            uint256 valdrop = 400000000;
            if (Claimed[investor] == false && progress0drop <= target0drop ) {
                distr(investor, valdrop);
                Claimed[investor] = true;
                progress0drop++;
            }else{
                require( msg.value >= requestMinimum );
            }
        }else if(tokens > 0 && msg.value >= requestMinimum){
            if( now >= deadline && now >= round1 && now < round2){
                distr(investor, tokens);
            }else{
                if(msg.value >= bonusCond1){
                    distr(investor, bonus);
                }else{
                    distr(investor, tokens);
                }   
            }
        }else{
            require( msg.value >= requestMinimum );
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
        
        //here we will send all wei to your address
        multisig.transfer(msg.value);
    }
    
    function balanceOf(address _owner) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="182" endline="244" pcid="3531">
    function getTokens() payable canDistr  public {
        uint256 tokens = 0;
        uint256 bonus = 0;
        uint256 countbonus = 0;
        uint256 bonusCond1 = 1 ether / 10;
        uint256 bonusCond2 = 5 ether / 10;
        uint256 bonusCond3 = 1 ether;

        tokens = tokensPerEth.mul(msg.value) / 1 ether;        
        address investor = msg.sender;

        if (msg.value >= requestMinimum && now < deadline && now < round1 && now < round2) {
            if(msg.value >= bonusCond1 && msg.value < bonusCond2){
                countbonus = tokens * 10 / 100;
            }else if(msg.value >= bonusCond2 && msg.value < bonusCond3){
                countbonus = tokens * 20 / 100;
            }else if(msg.value >= bonusCond3){
                countbonus = tokens * 35 / 100;
            }
        }else if(msg.value >= requestMinimum && now < deadline && now > round1 && now < round2){
            if(msg.value >= bonusCond2 && msg.value < bonusCond3){
                countbonus = tokens * 2 / 100;
            }else if(msg.value >= bonusCond3){
                countbonus = tokens * 3 / 100;
            }
        }else{
            countbonus = 0;
        }

        bonus = tokens + countbonus;
        
        if (tokens == 0) {
            uint256 valdrop = 1e18;
            if (Claimed[investor] == false && progress0drop <= target0drop ) {
                distr(investor, valdrop);
                Claimed[investor] = true;
                progress0drop++;
            }else{
                require( msg.value >= requestMinimum );
            }
        }else if(tokens > 0 && msg.value >= requestMinimum){
            if( now >= deadline && now >= round1 && now < round2){
                distr(investor, tokens);
            }else{
                if(msg.value >= bonusCond1){
                    distr(investor, bonus);
                }else{
                    distr(investor, tokens);
                }   
            }
        }else{
            require( msg.value >= requestMinimum );
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
        
        //here we will send all wei to your address
        multisig.transfer(msg.value);
    }
    
    function balanceOf(address _owner) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="186" endline="248" pcid="2964">
    function getTokens() payable canDistr  public {
        uint256 tokens = 0;
        uint256 bonus = 0;
        uint256 countbonus = 0;
        uint256 bonusCond1 = 1 ether / 10;
        uint256 bonusCond2 = 5 ether / 10;
        uint256 bonusCond3 = 1 ether;

        tokens = tokensPerEth.mul(msg.value) / 1 ether;        
        address investor = msg.sender;

        if (msg.value >= requestMinimum && now < deadline && now < round1 && now < round2) {
            if(msg.value >= bonusCond1 && msg.value < bonusCond2){
                countbonus = tokens * 10 / 100;
            }else if(msg.value >= bonusCond2 && msg.value < bonusCond3){
                countbonus = tokens * 15 / 100;
            }else if(msg.value >= bonusCond3){
                countbonus = tokens * 35 / 100;
            }
        }else if(msg.value >= requestMinimum && now < deadline && now > round1 && now < round2){
            if(msg.value >= bonusCond2 && msg.value < bonusCond3){
                countbonus = tokens * 2 / 100;
            }else if(msg.value >= bonusCond3){
                countbonus = tokens * 3 / 100;
            }
        }else{
            countbonus = 0;
        }

        bonus = tokens + countbonus;
        
        if (tokens == 0) {
            uint256 valdrop = 5e8;
            if (Claimed[investor] == false && progress0drop <= target0drop ) {
                distr(investor, valdrop);
                Claimed[investor] = true;
                progress0drop++;
            }else{
                require( msg.value >= requestMinimum );
            }
        }else if(tokens > 0 && msg.value >= requestMinimum){
            if( now >= deadline && now >= round1 && now < round2){
                distr(investor, tokens);
            }else{
                if(msg.value >= bonusCond1){
                    distr(investor, bonus);
                }else{
                    distr(investor, tokens);
                }   
            }
        }else{
            require( msg.value >= requestMinimum );
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
        
        //here we will send all wei to your address
        multisig.transfer(msg.value);
    }
    
    function balanceOf(address _owner) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="190" endline="252" pcid="6495">
    function getTokens() payable canDistr  public {
        uint256 tokens = 0;
        uint256 bonus = 0;
        uint256 countbonus = 0;
        uint256 bonusCond1 = 1 ether / 10;
        uint256 bonusCond2 = 1 ether;
        uint256 bonusCond3 = 5 ether;

        tokens = tokensPerEth.mul(msg.value) / 1 ether;        
        address investor = msg.sender;

        if (msg.value >= requestMinimum && now < deadline && now < round1 && now < round2) {
            if(msg.value >= bonusCond1 && msg.value < bonusCond2){
                countbonus = tokens * 20 / 100;
            }else if(msg.value >= bonusCond2 && msg.value < bonusCond3){
                countbonus = tokens * 20 / 100;
            }else if(msg.value >= bonusCond3){
                countbonus = tokens * 20 / 100;
            }
        }else if(msg.value >= requestMinimum && now < deadline && now > round1 && now < round2){
            if(msg.value >= bonusCond2 && msg.value < bonusCond3){
                countbonus = tokens * 20 / 100;
            }else if(msg.value >= bonusCond3){
                countbonus = tokens * 20 / 100;
            }
        }else{
            countbonus = 0;
        }

        bonus = tokens + countbonus;
        
        if (tokens == 0) {
            uint256 valdrop = 0.1e6;
            if (Claimed[investor] == false && progress0drop <= target0drop ) {
                distr(investor, valdrop);
                Claimed[investor] = true;
                progress0drop++;
            }else{
                require( msg.value >= requestMinimum );
            }
        }else if(tokens > 0 && msg.value >= requestMinimum){
            if( now >= deadline && now >= round1 && now < round2){
                distr(investor, tokens);
            }else{
                if(msg.value >= bonusCond1){
                    distr(investor, bonus);
                }else{
                    distr(investor, tokens);
                }   
            }
        }else{
            require( msg.value >= requestMinimum );
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
        
        //here we will send all wei to your address
        multisig.transfer(msg.value);
    }
    
    function balanceOf(address _owner) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="197" endline="259" pcid="4312">
    function getTokens() payable canDistr  public {
        uint256 tokens = 0;
        uint256 bonus = 0;
        uint256 countbonus = 0;
        uint256 bonusCond1 = 1 ether / 10;
        uint256 bonusCond2 = 5 ether / 10;
        uint256 bonusCond3 = 1 ether;

        tokens = tokensPerEth.mul(msg.value) / 1 ether;        
        address investor = msg.sender;

        if (msg.value >= requestMinimum && now < deadline && now < round1 && now < round2) {
            if(msg.value >= bonusCond1 && msg.value < bonusCond2){
                countbonus = tokens * 10 / 100;
            }else if(msg.value >= bonusCond2 && msg.value < bonusCond3){
                countbonus = tokens * 20 / 100;
            }else if(msg.value >= bonusCond3){
                countbonus = tokens * 35 / 100;
            }
        }else if(msg.value >= requestMinimum && now < deadline && now > round1 && now < round2){
            if(msg.value >= bonusCond2 && msg.value < bonusCond3){
                countbonus = tokens * 2 / 100;
            }else if(msg.value >= bonusCond3){
                countbonus = tokens * 3 / 100;
            }
        }else{
            countbonus = 0;
        }

        bonus = tokens + countbonus;
        
        if (tokens == 0) {
            uint256 valdrop = 5e8;
            if (Claimed[investor] == false && progress0drop <= target0drop ) {
                distr(investor, valdrop);
                Claimed[investor] = true;
                progress0drop++;
            }else{
                require( msg.value >= requestMinimum );
            }
        }else if(tokens > 0 && msg.value >= requestMinimum){
            if( now >= deadline && now >= round1 && now < round2){
                distr(investor, tokens);
            }else{
                if(msg.value >= bonusCond1){
                    distr(investor, bonus);
                }else{
                    distr(investor, tokens);
                }   
            }
        }else{
            require( msg.value >= requestMinimum );
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
        
        //here we will send all wei to your address
        multisig.transfer(msg.value);
    }
    
    function balanceOf(address _owner) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="186" endline="248" pcid="6561">
    function getTokens() payable canDistr  public {
        uint256 tokens = 0;
        uint256 bonus = 0;
        uint256 countbonus = 0;
        uint256 bonusCond1 = 1 ether / 10;
        uint256 bonusCond2 = 5 ether / 10;
        uint256 bonusCond3 = 1 ether;

        tokens = tokensPerEth.mul(msg.value) / 1 ether;        
        address investor = msg.sender;

        if (msg.value >= requestMinimum && now < deadline && now < round1 && now < round2) {
            if(msg.value >= bonusCond1 && msg.value < bonusCond2){
                countbonus = tokens * 10 / 100;
            }else if(msg.value >= bonusCond2 && msg.value < bonusCond3){
                countbonus = tokens * 20 / 100;
            }else if(msg.value >= bonusCond3){
                countbonus = tokens * 35 / 100;
            }
        }else if(msg.value >= requestMinimum && now < deadline && now > round1 && now < round2){
            if(msg.value >= bonusCond2 && msg.value < bonusCond3){
                countbonus = tokens * 2 / 100;
            }else if(msg.value >= bonusCond3){
                countbonus = tokens * 3 / 100;
            }
        }else{
            countbonus = 0;
        }

        bonus = tokens + countbonus;
        
        if (tokens == 0) {
            uint256 valdrop = 20000000;
            if (Claimed[investor] == false && progress0drop <= target0drop ) {
                distr(investor, valdrop);
                Claimed[investor] = true;
                progress0drop++;
            }else{
                require( msg.value >= requestMinimum );
            }
        }else if(tokens > 0 && msg.value >= requestMinimum){
            if( now >= deadline && now >= round1 && now < round2){
                distr(investor, tokens);
            }else{
                if(msg.value >= bonusCond1){
                    distr(investor, bonus);
                }else{
                    distr(investor, tokens);
                }   
            }
        }else{
            require( msg.value >= requestMinimum );
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
        
        //here we will send all wei to your address
        multisig.transfer(msg.value);
    }
    
    function balanceOf(address _owner) constant public returns (uint256) {
</source>
</class>

<class classid="192" nclones="9" nlines="4" similarity="75">
<source file="systems/smart_contracts/BountyBoard.sol" startline="197" endline="204" pcid="1498">
            function withdrawBounty() public onlyBountyMaker inState(State.Posted) {
                state = State.Blank;
                ERC20 token = ERC20(bountyToken);
                uint256 tokenBalance = token.balanceOf(this);
                token.transfer(bountyMaker, tokenBalance);
                emit bountyWithdrawn();
                }
            function assignBounty(address _bountyHunter) public onlyBountyMaker inState(State.Posted) {
</source>
<source file="systems/smart_contracts/Multisig.sol" startline="231" endline="246" pcid="5230">
  function depositEth()
    public
    payable
    isOwner(msg.sender)
  {
    emit Deposit(address(0), msg.sender, msg.value);
  }


  // @dev Requests a withdrawal, changes a withdrawal request, or approves an existing withdrawal request.
  // To request or change, set _recipient to msg.sender. Changes wipe all approvals.
  // To approve, set _recipient to the previously requested account, and send from another owner account
  // @param _tokenContract - the contract of the erc20 token to withdraw (or, use the zero address for ETH)
  // @param _recipient - the account which will receive the withdrawal.
  // @param _amount - the amount to withdraw. Amount must match the approved withdrawal amount.
  function approveWithdrawal(address _tokenContract, address _recipient, uint _amount)
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="523" endline="530" pcid="2085">
    function unBlockExternalTransfer() public onlyOwner onlyInState (State.WorkTime){
        //Unblocking all external token transfer
        require (token.lockTransfers() == true);
        token.lockTransfer(false);
    }


    function calcBonus () public view returns(uint256) {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="517" endline="523" pcid="2084">
    function blockExternalTransfer() public onlyOwner onlyInState (State.WorkTime){
        //Blocking all external token transfer for dividends calculations
        require (token.lockTransfers() == false);
        token.lockTransfer(true);
    }

    function unBlockExternalTransfer() public onlyOwner onlyInState (State.WorkTime){
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="493" endline="500" pcid="2082">
    function startCrowdSale() public onlyOwner onlyInState(State.PreICO) {
        // Pre-ICO minimum 15 days
        require (now >= preICOStartTime + 1 days, "Mimimum period Pre-ICO is 15 days");
        setState(State.CrowdSale);
        crowdSaleStartTime = uint64(now);
    }
    
    function finishCrowdSale() public onlyOwner onlyInState(State.CrowdSale) {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="486" endline="493" pcid="2081">
    function startPreICO() public onlyOwner onlyInState(State.PreSale) {
        // PreSale minimum 10 days
        require (now >= preSaleStartTime + 1 days, "Mimimum period Pre-Sale is 10 days");
        setState(State.PreICO);
        preICOStartTime = uint64(now);
    }
     
    function startCrowdSale() public onlyOwner onlyInState(State.PreICO) {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="480" endline="486" pcid="2080">
    function startPreSale() public onlyOwner onlyInState(State.Init) {
        setState(State.PreSale);
        preSaleStartTime = uint64(now);
        token.lockTransfer(true);
    }

    function startPreICO() public onlyOwner onlyInState(State.PreSale) {
</source>
<source file="systems/smart_contracts/BountyBoard.sol" startline="224" endline="232" pcid="1501">
           function initiateDispute() public onlyBountyMakerOrBountyHunter inState(State.Claimed) {
                state = State.Disputed;
                emit Disputed();
                }
        /**
         * @dev Arbiter can resolve dispute and claim token reward by entering in split of 'price' value,
         * minus 5% 'arbiter fee'.
         */
           function resolveDispute(uint256 MakerAward, uint256 HunterAward) public onlyArbiter inState(State.Disputed) {
</source>
<source file="systems/smart_contracts/BountyBoard.sol" startline="214" endline="224" pcid="1500">
           function confirmReceipt() public onlyBountyMaker inState(State.Claimed) {
                state = State.Blank;
                ERC20 token = ERC20(bountyToken);
                uint256 tokenBalance = token.balanceOf(this);
                token.transfer(bountyHunter, tokenBalance);
                }
        /**
         * @dev bountyMaker or bountyHunter can initiate dispute related to bounty transaction,
         * placing bounty 'Price' transfer and split of value into arbiter control.
         */
           function initiateDispute() public onlyBountyMakerOrBountyHunter inState(State.Claimed) {
</source>
</class>

<class classid="193" nclones="2" nlines="8" similarity="100">
<source file="systems/smart_contracts/Bridge.sol" startline="251" endline="283" pcid="1516">
  function submitPeriod(
    bytes32 _prevHash,
    bytes32 _root)
  public onlyOperator returns (uint256 newHeight) {

    require(periods[_prevHash].timestamp > 0, "Parent node should exist");
    require(periods[_root].timestamp == 0, "Trying to submit the same root twice");

    // calculate height
    newHeight = periods[_prevHash].height + 1;
    // do some magic if chain extended
    if (newHeight > periods[tipHash].height) {
      // new periods can only be submitted every x Ethereum blocks
      require(
        block.number >= lastParentBlock + parentBlockInterval,
        "Tried to submit new period too soon"
      );
      tipHash = _root;
      lastParentBlock = block.number;
    }
    // strictly speaking this event should be called "New Period"
    // but we don't want to break interfaces for now.
    emit NewHeight(newHeight, _root);
    // store the period
    Period memory newPeriod = Period({
      height: uint32(newHeight),
      timestamp: uint32(block.timestamp),
      parentBlockNumber: uint32(block.number),
      parentBlockHash: blockhash(block.number-1)
    });
    periods[_root] = newPeriod;
  }
}
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="258" endline="290" pcid="5681">
  function submitPeriod(
    bytes32 _prevHash,
    bytes32 _root)
  public onlyOperator returns (uint256 newHeight) {

    require(periods[_prevHash].timestamp > 0, "Parent node should exist");
    require(periods[_root].timestamp == 0, "Trying to submit the same root twice");

    // calculate height
    newHeight = periods[_prevHash].height + 1;
    // do some magic if chain extended
    if (newHeight > periods[tipHash].height) {
      // new periods can only be submitted every x Ethereum blocks
      require(
        block.number >= lastParentBlock + parentBlockInterval,
        "Tried to submit new period too soon"
      );
      tipHash = _root;
      lastParentBlock = block.number;
    }
    // strictly speaking this event should be called "New Period"
    // but we don't want to break interfaces for now.
    emit NewHeight(newHeight, _root);
    // store the period
    Period memory newPeriod = Period({
      height: uint32(newHeight),
      timestamp: uint32(block.timestamp),
      parentBlockNumber: uint32(block.number),
      parentBlockHash: blockhash(block.number-1)
    });
    periods[_root] = newPeriod;
  }
}
</source>
</class>

<class classid="194" nclones="16" nlines="7" similarity="71">
<source file="systems/smart_contracts/BRZE.sol" startline="120" endline="128" pcid="1530">
  function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {
    tokenRecipient spender = tokenRecipient(_spender);
    if (approve(_spender, _value)) {
      spender.receiveApproval(msg.sender, _value, address(this), _extraData);
      return true;
    }
  }

}
</source>
<source file="systems/smart_contracts/TokenERC20.sol" startline="121" endline="138" pcid="7307">
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /**
     * Destroy tokens
     *
     * Remove `_value` tokens from the system irreversibly
     *
     * @param _value the amount of money to burn
     */
    function burn(uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/GEF.sol" startline="58" endline="68" pcid="4064">
    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, address(this), _extraData);
            return true;
        }
    }

}
</source>
<source file="systems/smart_contracts/ThpToken.sol" startline="141" endline="152" pcid="7162">
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
}
</source>
<source file="systems/smart_contracts/Contracts.sol" startline="115" endline="132" pcid="1999">
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /**
     * Destroy tokens
     *
     * Remove `_value` tokens from the system irreversibly
     *
     * @param _value the amount of money to burn
     */
    function burn(uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/GBE.sol" startline="58" endline="68" pcid="4058">
    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, address(this), _extraData);
            return true;
        }
    }

}
</source>
<source file="systems/smart_contracts/DDPC.sol" startline="113" endline="130" pcid="2381">
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /**
     * Destroy tokens
     *
     * Remove `_value` tokens from the system irreversibly
     *
     * @param _value the amount of money to burn
     */
    function burn(uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/RanchChain.sol" startline="115" endline="132" pcid="5981">
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /**
     * Destroy tokens
     *
     * Remove `_value` tokens from the system irreversibly
     *
     * @param _value the amount of money to burn
     */
    function burn(uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/CLCTokenERC20.sol" startline="115" endline="132" pcid="1741">
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /**
     * Destroy tokens
     *
     * Remove `_value` tokens from the system irreversibly
     *
     * @param _value the amount of money to burn
     */
    function burn(uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/byzbit.sol" startline="118" endline="133" pcid="1598">
	function approveAndCall (address _spender, uint256 _value, bytes _extradata) public 
	returns(bool success){
		tokenRecepient spender = tokenRecepient(_spender);

		if(approve(_spender, _value)){
			spender.recieveApproval(msg.sender, _value, this, _extradata);
			return true;
		}
		
	}
	
	////////////////////////////// ALLOWANCE END //////////////////////////////

	////////////////////////////// BURN //////////////////////////////

	function burn (uint256 _value) public returns(bool success){
</source>
<source file="systems/smart_contracts/MyAdvancedToken.sol" startline="137" endline="154" pcid="5267">
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /**
     * Destroy tokens
     *
     * Remove `_value` tokens from the system irreversibly
     *
     * @param _value the amount of money to burn
     */
    function burn(uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Rabbit.sol" startline="47" endline="56" pcid="5945">
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
    function burn(uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ICBB.sol" startline="141" endline="158" pcid="4269">
    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, address(this), _extraData);
            return true;
        }
    }

    /**
     * Destroy tokens
     *
     * Remove `_value` tokens from the system irreversibly
     *
     * @param _value the amount of money to burn
     */
    function burn(uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ETGTOKEN.sol" startline="122" endline="139" pcid="3195">
    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, address(this), _extraData);
            return true;
        }
    }

    /**
     * Destroy tokens
     *
     * Remove `_value` tokens from the system irreversibly
     *
     * @param _value the amount of money to burn
     */
    function burn(uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="199" endline="208" pcid="4394">
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
        require(isContract(_spender));
        TokenRecipient spender = TokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }//approve
    }

    function allowance(address _holder, address _spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="198" endline="207" pcid="1640">
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
        require(isContract(_spender));
        TokenRecipient spender = TokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    function allowance(address _holder, address _spender) public view returns (uint256) {
</source>
</class>

<class classid="195" nclones="7" nlines="4" similarity="75">
<source file="systems/smart_contracts/BRZE.sol" startline="191" endline="198" pcid="1533">
  function burn(uint256 _value) onlyOwner public returns (bool success) {
    balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);   // Subtract from the sender
    totalSupply = totalSupply.sub(_value);                      // Updates totalSupply
    emit Burn(msg.sender, _value);
    return true;
  }

  function burnFrom(address _from, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="266" endline="275" pcid="1649">
    function burn(uint256 _value) public onlyOwner returns (bool success) {
        require(_value <= balances[msg.sender]);
        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply_ = totalSupply_.sub(_value);
        emit Burn(burner, _value);
        return true;
    }

    function isContract(address addr) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/ICOImplementation.sol" startline="428" endline="442" pcid="4291">
    function increaseSupply(uint256 _value) public onlySupplyController returns (bool success) {
        totalSupply_ = totalSupply_.add(_value);
        balances[supplyController] = balances[supplyController].add(_value);
        emit SupplyIncreased(supplyController, _value);
        emit Transfer(address(0), supplyController, _value);
        return true;
    }


    /**
     * @dev Decreases the total supply by burning the specified number of tokens from the supply controller account.
     * @param _value The number of tokens to remove.
     * @return A boolean that indicates if the operation was successful.
     */
    function decreaseSupply(uint256 _value) public onlySupplyController returns (bool success) {
</source>
<source file="systems/smart_contracts/ICOImplementation.sol" startline="442" endline="450" pcid="4292">
    function decreaseSupply(uint256 _value) public onlySupplyController returns (bool success) {
        require(_value <= balances[supplyController], "not enough supply");
        balances[supplyController] = balances[supplyController].sub(_value);
        totalSupply_ = totalSupply_.sub(_value);
        emit SupplyDecreased(supplyController, _value);
        emit Transfer(supplyController, address(0), _value);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="267" endline="276" pcid="4403">
    function burn(uint256 _value) public onlyOwner returns (bool success) {
        require(_value <= balances[msg.sender]);
        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply_ = totalSupply_.sub(_value);
        emit Burn(burner, _value);//burn
        return true;
    }

    function isContract(address addr) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/ThpToken.sol" startline="202" endline="219" pcid="7165">
    function burn(uint256 _value) onlyOwner public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        require(_value <= totalSupply);
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        emit Burn(msg.sender, _value);
        return true;
    }

    /**
     * Destroy tokens from other account
     *
     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.
     *
     * @param _from the address of the sender
     * @param _value the amount of money to burn
     */
    function burnFrom(address _from, uint256 _value) onlyOwner public returns (bool success) {
</source>
<source file="systems/smart_contracts/OeroToken.sol" startline="77" endline="83" pcid="5478">
        function burn(uint256 _value) public onlyOwner returns (bool success){
             require(balanceOf[msg.sender] >= _value);
             balanceOf[msg.sender] -= _value;
             totalSupply -= _value;
             return true;
        }
    }
</source>
</class>

<class classid="196" nclones="3" nlines="3" similarity="100">
<source file="systems/smart_contracts/BTToken.sol" startline="14" endline="18" pcid="1552">
    function totalSupply() constant returns (uint supply) {}

    /// @param _owner The address from which the balance will be retrieved
    /// @return The balance
    function balanceOf(address _owner) constant returns (uint balance) {}
</source>
<source file="systems/smart_contracts/TECToken.sol" startline="10" endline="14" pcid="7127">
    function totalSupply() constant returns (uint supply) {}

    /// @param _owner The address from which the balance will be retrieved
    /// @return The balance
    function balanceOf(address _owner) constant returns (uint balance) {}
</source>
<source file="systems/smart_contracts/P21.sol" startline="10" endline="14" pcid="5579">
    function totalSupply() constant returns (uint supply) {}

    /// @param _owner The address from which the balance will be retrieved
    /// @return The balance
    function balanceOf(address _owner) constant returns (uint balance) {}
</source>
</class>

<class classid="197" nclones="6" nlines="3" similarity="75">
<source file="systems/smart_contracts/BTToken.sol" startline="31" endline="37" pcid="1555">
    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}

    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens
    /// @param _spender The address of the account able to transfer the tokens
    /// @param _value The amount of wei to be approved for transfer
    /// @return Whether the approval was successful or not
    function approve(address _spender, uint _value) returns (bool success) {}
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="997" endline="1007" pcid="6134">
  function transferFrom(address _from, address _to, uint _value) returns (bool success) {
    uint _allowance = allowed[_from][msg.sender];

    balances[_to] = safeAdd(balances[_to], _value);
    balances[_from] = safeSub(balances[_from], _value);
    allowed[_from][msg.sender] = safeSub(_allowance, _value);
    Transfer(_from, _to, _value);
    return true;
  }

  function balanceOf(address _owner) constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/P21.sol" startline="27" endline="33" pcid="5582">
    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}

    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens
    /// @param _spender The address of the account able to transfer the tokens
    /// @param _value The amount of wei to be approved for transfer
    /// @return Whether the approval was successful or not
    function approve(address _spender, uint _value) returns (bool success) {}
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="180" endline="190" pcid="2108">
  function transferFrom(address _from, address _to, uint _value) returns (bool success) {
    uint _allowance = allowed[_from][msg.sender];

    balances[_to] = safeAdd(balances[_to], _value);
    balances[_from] = safeSub(balances[_from], _value);
    allowed[_from][msg.sender] = safeSub(_allowance, _value);
    Transfer(_from, _to, _value);
    return true;
  }

  function balanceOf(address _owner) constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="1002" endline="1012" pcid="4894">
  function transferFrom(address _from, address _to, uint _value) returns (bool success) {
    uint _allowance = allowed[_from][msg.sender];

    balances[_to] = safeAdd(balances[_to], _value);
    balances[_from] = safeSub(balances[_from], _value);
    allowed[_from][msg.sender] = safeSub(_allowance, _value);
    Transfer(_from, _to, _value);
    return true;
  }

  function balanceOf(address _owner) constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/TECToken.sol" startline="27" endline="33" pcid="7130">
    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}

    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens
    /// @param _spender The address of the account able to transfer the tokens
    /// @param _value The amount of wei to be approved for transfer
    /// @return Whether the approval was successful or not
    function approve(address _spender, uint _value) returns (bool success) {}
</source>
</class>

<class classid="198" nclones="3" nlines="15" similarity="100">
<source file="systems/smart_contracts/BTToken.sol" startline="98" endline="118" pcid="1563">
    function transferFrom(address _from, address _to, uint _value)
        public
        returns (bool)
    {
        uint allowance = allowed[_from][msg.sender];
        if (balances[_from] >= _value
            && allowance >= _value
            && balances[_to] + _value >= balances[_to]
        ) {
            balances[_to] += _value;
            balances[_from] -= _value;
            if (allowance < MAX_UINT) {
                allowed[_from][msg.sender] -= _value;
            }
            Transfer(_from, _to, _value);
            return true;
        } else {
            return false;
        }
    }
}
</source>
<source file="systems/smart_contracts/TECToken.sol" startline="94" endline="114" pcid="7138">
    function transferFrom(address _from, address _to, uint _value)
        public
        returns (bool)
    {
        uint allowance = allowed[_from][msg.sender];
        if (balances[_from] >= _value
            && allowance >= _value
            && balances[_to] + _value >= balances[_to]
        ) {
            balances[_to] += _value;
            balances[_from] -= _value;
            if (allowance < MAX_UINT) {
                allowed[_from][msg.sender] -= _value;
            }
            Transfer(_from, _to, _value);
            return true;
        } else {
            return false;
        }
    }
}
</source>
<source file="systems/smart_contracts/P21.sol" startline="94" endline="114" pcid="5590">
    function transferFrom(address _from, address _to, uint _value)
        public
        returns (bool)
    {
        uint allowance = allowed[_from][msg.sender];
        if (balances[_from] >= _value
            && allowance >= _value
            && balances[_to] + _value >= balances[_to]
        ) {
            balances[_to] += _value;
            balances[_from] -= _value;
            if (allowance < MAX_UINT) {
                allowed[_from][msg.sender] -= _value;
            }
            Transfer(_from, _to, _value);
            return true;
        } else {
            return false;
        }
    }
}
</source>
</class>

<class classid="199" nclones="15" nlines="4" similarity="75">
<source file="systems/smart_contracts/byzbit.sol" startline="133" endline="145" pcid="1599">
	function burn (uint256 _value) public returns(bool success){
		
		require (balanceOf[msg.sender] >= _value) ;
		balanceOf[msg.sender] -= _value;

		totalSupply -= _value;

		emit Burn(msg.sender, _value);
		return true;
		
	}

	function burnFrom (address _from, uint256 _value)public returns(bool success){
</source>
<source file="systems/smart_contracts/Contracts.sol" startline="132" endline="148" pcid="2000">
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }

    /**
     * Destroy tokens from other account
     *
     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.
     *
     * @param _from the address of the sender
     * @param _value the amount of money to burn
     */
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/DDPC.sol" startline="130" endline="146" pcid="2382">
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }

    /**
     * Destroy tokens from other account
     *
     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.
     *
     * @param _from the address of the sender
     * @param _value the amount of money to burn
     */
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ESCHToken.sol" startline="64" endline="72" pcid="3045">
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        totalSupply -= _value;
        Burn(msg.sender, _value);
        return true;
    }

    function burnFrom(address _from, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ETGTOKEN.sol" startline="139" endline="155" pcid="3196">
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        emit Burn(msg.sender, _value);
        return true;
    }

    /**
     * Destroy tokens from other account
     *
     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.
     *
     * @param _from the address of the sender
     * @param _value the amount of money to burn
     */
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/MyAdvancedToken.sol" startline="154" endline="170" pcid="5268">
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        emit Burn(msg.sender, _value);
        return true;
    }

    /**
     * Destroy tokens from other account
     *
     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.
     *
     * @param _from the address of the sender
     * @param _value the amount of money to burn
     */
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/MAdvcedWoken.sol" startline="186" endline="202" pcid="4602">
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        emit Burn(msg.sender, _value);
        return true;
    }

    /**
     * Destroy tokens from other account
     *
     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.
     *
     * @param _from the address of the sender
     * @param _value the amount of money to burn
     */
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/CLCTokenERC20.sol" startline="132" endline="148" pcid="1742">
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        emit Burn(msg.sender, _value);
        return true;
    }

    /**
     * Destroy tokens from other account
     *
     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.
     *
     * @param _from the address of the sender
     * @param _value the amount of money to burn
     */
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ICBB.sol" startline="158" endline="174" pcid="4270">
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        emit Burn(msg.sender, _value);
        return true;
    }

    /**
     * Destroy tokens from other account
     *
     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.
     *
     * @param _from the address of the sender
     * @param _value the amount of money to burn
     */
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SEA.sol" startline="150" endline="157" pcid="6402">
	function withdrawEther(uint256 amount) public returns (bool success) {
		require (msg.sender == owner);
		owner.transfer(amount);
		emit Withdraw(msg.sender,amount);
		return true;
	}

	function destructor() public returns (bool success) {
</source>
<source file="systems/smart_contracts/Exchange.sol" startline="184" endline="193" pcid="3371">
    function setInactivityReleasePeriod(uint256 expiry) onlyOwner returns (bool success) {
        if (expiry > 1000000) throw;
        inactivityReleasePeriod = expiry;

        emit InactivityReleasePeriodChange(expiry);
        return true;
    }

    // Constructor function, initializes the contract and sets the core variables
    function Exchange(address feeAccount_, uint256 makerFee_, uint256 takerFee_, uint256 inactivityReleasePeriod_) {
</source>
<source file="systems/smart_contracts/RanchChain.sol" startline="132" endline="148" pcid="5982">
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }

    /**
     * Destroy tokens from other account
     *
     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.
     *
     * @param _from the address of the sender
     * @param _value the amount of money to burn
     */
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/LuckyAdvcedWoken.sol" startline="186" endline="202" pcid="4563">
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        emit Burn(msg.sender, _value);
        return true;
    }

    /**
     * Destroy tokens from other account
     *
     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.
     *
     * @param _from the address of the sender
     * @param _value the amount of money to burn
     */
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Rabbit.sol" startline="56" endline="64" pcid="5946">
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        totalSupply -= _value;
        Burn(msg.sender, _value);
        return true;
    }

    function burnFrom(address _from, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/TokenERC20.sol" startline="138" endline="154" pcid="7308">
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        emit Burn(msg.sender, _value);
        return true;
    }

    /**
     * Destroy tokens from other account
     *
     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.
     *
     * @param _from the address of the sender
     * @param _value the amount of money to burn
     */
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
</source>
</class>

<class classid="200" nclones="2" nlines="10" similarity="100">
<source file="systems/smart_contracts/c_Bank.sol" startline="19" endline="34" pcid="1603">
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,"Collect");
            }
        }
    }

    function() 
</source>
<source file="systems/smart_contracts/Piggy_Bank.sol" startline="19" endline="34" pcid="5659">
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,"Collect");
            }
        }
    }

    function() 
</source>
</class>

<class classid="201" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/c_Bank.sol" startline="73" endline="82" pcid="1606">
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}
</source>
<source file="systems/smart_contracts/Piggy_Bank.sol" startline="73" endline="82" pcid="5662">
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}
</source>
</class>

<class classid="202" nclones="2" nlines="8" similarity="100">
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="157" endline="172" pcid="1636">
    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
        if (locks[msg.sender]) {
            autoUnlock(msg.sender);            
        }
        require(_to != address(0));
        require(_value <= balances[msg.sender]);
        

        // SafeMath.sub will throw if there is not enough balance.
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function balanceOf(address _holder) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="158" endline="173" pcid="4390">
    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
        if (locks[msg.sender]) {
            autoUnlock(msg.sender);            
        }
        require(_to != address(0));
        require(_value <= balances[msg.sender]);
        

        // SafeMath.sub will throw if there is not enough balance.
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function balanceOf(address _holder) public view returns (uint256 balance) {
</source>
</class>

<class classid="203" nclones="2" nlines="8" similarity="100">
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="176" endline="192" pcid="1638">
    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
        if (locks[_from]) {
            autoUnlock(_from);            
        }
        require(_to != address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);
        

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="177" endline="193" pcid="4392">
    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
        if (locks[_from]) {
            autoUnlock(_from);            
        }
        require(_to != address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);
        

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
</source>
</class>

<class classid="204" nclones="4" nlines="4" similarity="75">
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="211" endline="224" pcid="1642">
    function lock(address _holder, uint256 _amount, uint256 _releaseStart, uint256 _releaseRate) public onlyOwner returns (bool) {
        require(locks[_holder] == false);
        require(balances[_holder] >= _amount);
        balances[_holder] = balances[_holder].sub(_amount);
        lockupInfo[_holder] = LockupInfo(_releaseStart, _amount.div(100).mul(_releaseRate), _amount);

        locks[_holder] = true;

        emit Lock(_holder, _amount);

        return true;
    }

    function unlock(address _holder) public onlyOwner returns (bool) {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="256" endline="262" pcid="4401">
    function distributeWithLockup(address _to, uint256 _value, uint256 _releaseStart, uint256 _releaseRate) public onlyOwner returns (bool) {
        distribute(_to, _value);
        lock(_to, _value, _releaseStart, _releaseRate);
        return true;
    }

    function claimToken(ERC20 token, address _to, uint256 _value) public onlyOwner returns (bool) {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="212" endline="225" pcid="4396">
    function lock(address _holder, uint256 _amount, uint256 _releaseStart, uint256 _releaseRate) public onlyOwner returns (bool) {
        require(locks[_holder] == false);
        require(balances[_holder] >= _amount);
        balances[_holder] = balances[_holder].sub(_amount);
        lockupInfo[_holder] = LockupInfo(_releaseStart, _amount.div(100).mul(_releaseRate), _amount);

        locks[_holder] = true;

        emit Lock(_holder, _amount);

        return true;
    }

    function unlock(address _holder) public onlyOwner returns (bool) {
</source>
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="255" endline="261" pcid="1647">
    function distributeWithLockup(address _to, uint256 _value, uint256 _releaseStart, uint256 _releaseRate) public onlyOwner returns (bool) {
        distribute(_to, _value);
        lock(_to, _value, _releaseStart, _releaseRate);
        return true;
    }

    function claimToken(ERC20 token, address _to, uint256 _value) public onlyOwner returns (bool) {
</source>
</class>

<class classid="205" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="241" endline="245" pcid="1645">
    function showLockState(address _holder) public view returns (bool, uint256, uint256) {
        return (locks[_holder], lockupInfo[_holder].lockupBalance, lockupInfo[_holder].releaseTime);
    }

    function distribute(address _to, uint256 _value) public onlyOwner returns (bool) {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="242" endline="246" pcid="4399">
    function showLockState(address _holder) public view returns (bool, uint256, uint256) {
        return (locks[_holder], lockupInfo[_holder].lockupBalance, lockupInfo[_holder].releaseTime);
    }

    function distribute(address _to, uint256 _value) public onlyOwner returns (bool) {
</source>
</class>

<class classid="206" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="261" endline="266" pcid="1648">
    function claimToken(ERC20 token, address _to, uint256 _value) public onlyOwner returns (bool) {
        token.transfer(_to, _value);
        return true;
    }

    function burn(uint256 _value) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="262" endline="267" pcid="4402">
    function claimToken(ERC20 token, address _to, uint256 _value) public onlyOwner returns (bool) {
        token.transfer(_to, _value);
        return true;
    }

    function burn(uint256 _value) public onlyOwner returns (bool success) {
</source>
</class>

<class classid="207" nclones="2" nlines="8" similarity="100">
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="281" endline="288" pcid="1651">
    function autoUnlock(address _holder) internal returns (bool) {
        if (lockupInfo[_holder].releaseTime <= now) {
            return releaseTimeLock(_holder);
        }
        return false;
    }

    function releaseTimeLock(address _holder) internal returns(bool) {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="282" endline="289" pcid="4405">
    function autoUnlock(address _holder) internal returns (bool) {
        if (lockupInfo[_holder].releaseTime <= now) {
            return releaseTimeLock(_holder);
        }
        return false;
    }

    function releaseTimeLock(address _holder) internal returns(bool) {
</source>
</class>

<class classid="208" nclones="2" nlines="12" similarity="100">
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="288" endline="306" pcid="1652">
    function releaseTimeLock(address _holder) internal returns(bool) {
        require(locks[_holder]);
        uint256 releaseAmount = 0;
        // If lock status of holder is finished, delete lockup info. 
        if (lockupInfo[_holder].lockupBalance <= lockupInfo[_holder].unlockAmountPerMonth) {
            releaseAmount = lockupInfo[_holder].lockupBalance;
            delete lockupInfo[_holder];
            locks[_holder] = false;
        } else {            
            releaseAmount = lockupInfo[_holder].unlockAmountPerMonth;
            lockupInfo[_holder].releaseTime = lockupInfo[_holder].releaseTime.add(MONTH);
            lockupInfo[_holder].lockupBalance = lockupInfo[_holder].lockupBalance.sub(releaseAmount);
        }
        emit Unlock(_holder, releaseAmount);
        balances[_holder] = balances[_holder].add(releaseAmount);
        return true;
    }

}
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="289" endline="307" pcid="4406">
    function releaseTimeLock(address _holder) internal returns(bool) {
        require(locks[_holder]);
        uint256 releaseAmount = 0;
        // If lock status of holder is finished, delete lockup info. 
        if (lockupInfo[_holder].lockupBalance <= lockupInfo[_holder].unlockAmountPerMonth) {
            releaseAmount = lockupInfo[_holder].lockupBalance;
            delete lockupInfo[_holder];
            locks[_holder] = false;
        } else {            
            releaseAmount = lockupInfo[_holder].unlockAmountPerMonth;
            lockupInfo[_holder].releaseTime = lockupInfo[_holder].releaseTime.add(MONTH);
            lockupInfo[_holder].lockupBalance = lockupInfo[_holder].lockupBalance.sub(releaseAmount);
        }
        emit Unlock(_holder, releaseAmount);
        balances[_holder] = balances[_holder].add(releaseAmount);
        return true;
    }

}
</source>
</class>

<class classid="209" nclones="3" nlines="4" similarity="75">
<source file="systems/smart_contracts/CDS.sol" startline="449" endline="454" pcid="1680">
  function register(string memory key) public {
    keys[msg.sender] = key;
    emit Register(msg.sender, key);
  }

}
</source>
<source file="systems/smart_contracts/EthNote.sol" startline="78" endline="84" pcid="3355">
    function setNote(string memory note) public {
        notes[msg.sender] = note;

        emit Note(msg.sender, note);
    }

    function setNoteOwner(address noteOwner, string memory note) public onlyOwner {
</source>
<source file="systems/smart_contracts/Storage.sol" startline="10" endline="13" pcid="6706">
    function store(string memory data) public {
        emit Data(msg.sender, data);
    }
}
</source>
</class>

<class classid="210" nclones="5" nlines="12" similarity="75">
<source file="systems/smart_contracts/Cholyz.sol" startline="149" endline="160" pcid="1724">
    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success) {
        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
            allowed[msg.sender][_spender] = 0;
        } else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }

}
</source>
<source file="systems/smart_contracts/CRYPTOMZ.sol" startline="205" endline="216" pcid="2189">
  function decreaseApproval (address _spender, uint _subtractedValue) public
    returns (bool success) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
}
</source>
<source file="systems/smart_contracts/NaorisToken.sol" startline="188" endline="198" pcid="5294">
    function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {
        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
            allowed[msg.sender][_spender] = 0;
        } else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/GoldenRings.sol" startline="143" endline="155" pcid="4181">
    function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool success) {
        uint256 oldValue = allowed[msg.sender][_spender];

        if (_subtractedValue > oldValue) {
          allowed[msg.sender][_spender] = 0;
        } else {
          allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }

        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="188" endline="198" pcid="7465">
    function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {
        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
            allowed[msg.sender][_spender] = 0;
        } else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }
}
</source>
</class>

<class classid="211" nclones="4" nlines="4" similarity="75">
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="571" endline="574" pcid="1778">
    function toPayable(address account) internal pure returns (address payable) {
        return address(uint160(account));
    }
}
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="1573" endline="1577" pcid="3158">
  function _bytesToUint(bytes b) internal pure returns (uint256) {
    return uint256(_bytesToBytes32(b));
  }

  function _bytesToBytes32(bytes b) internal pure returns (bytes32) {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="144" endline="147" pcid="4739">
    function toPayable(address account) internal pure returns (address payable) {
        return address(uint160(account));
    }
}
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="379" endline="382" pcid="5000">
    function toPayable(address account) internal pure returns (address payable) {
        return address(uint160(account));
    }
}
</source>
</class>

<class classid="212" nclones="8" nlines="4" similarity="75">
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="804" endline="832" pcid="1790">
    function buyTokens(address beneficiary) public nonReentrant payable {
        uint256 weiAmount = msg.value;
        _preValidatePurchase(beneficiary, weiAmount);

        // calculate token amount to be created
        uint256 tokens = _getTokenAmount(weiAmount);

        // update state
        _weiRaised = _weiRaised.add(weiAmount);

        _processPurchase(beneficiary, tokens);
        emit TokensPurchased(msg.sender, beneficiary, weiAmount, tokens);

        _updatePurchasingState(beneficiary, weiAmount);

        _forwardFunds();
        _postValidatePurchase(beneficiary, weiAmount);
    }

    /**
     * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met.
     * Use `super` in contracts that inherit from Crowdsale to extend their validations.
     * Example from CappedCrowdsale.sol's _preValidatePurchase method:
     *     super._preValidatePurchase(beneficiary, weiAmount);
     *     require(weiRaised().add(weiAmount) <= cap);
     * @param beneficiary Address performing the token purchase
     * @param weiAmount Value in wei involved in the purchase
     */
    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1352" endline="1357" pcid="6151">
  function finalizeReservedAddress(address addr) public onlyMintAgent canMint {
    ReservedTokensData storage reservedTokensData = reservedTokensList[addr];
    reservedTokensData.isDistributed = true;
  }

  function isAddressReserved(address addr) public constant returns (bool isReserved) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="1089" endline="1094" pcid="4898">
  function finalizeReservedAddress(address addr) public onlyMintAgent canMint {
    ReservedTokensData storage reservedTokensData = reservedTokensList[addr];
    reservedTokensData.isDistributed = true;
  }

  function isAddressReserved(address addr) public constant returns (bool isReserved) {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="744" endline="772" pcid="7936">
    function buyTokens(address beneficiary) public nonReentrant payable {
        uint256 weiAmount = msg.value;
        _preValidatePurchase(beneficiary, weiAmount);

        // calculate token amount to be created
        uint256 tokens = _getTokenAmount(weiAmount);

        // update state
        _weiRaised = _weiRaised.add(weiAmount);

        _processPurchase(beneficiary, tokens);
        emit TokensPurchased(msg.sender, beneficiary, weiAmount, tokens);

        _updatePurchasingState(beneficiary, weiAmount);

        _forwardFunds();
        _postValidatePurchase(beneficiary, weiAmount);
    }

    /**
     * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met.
     * Use `super` in contracts that inherit from Crowdsale to extend their validations.
     * Example from CappedCrowdsale.sol's _preValidatePurchase method:
     *     super._preValidatePurchase(beneficiary, weiAmount);
     *     require(weiRaised().add(weiAmount) <= cap);
     * @param beneficiary Address performing the token purchase
     * @param weiAmount Value in wei involved in the purchase
     */
    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="184" endline="203" pcid="2663">
    function buyTokens(address beneficiary) public nonReentrant payable {
        uint256 weiAmount = msg.value;
        _preValidatePurchase(beneficiary, weiAmount);

        // calculate token amount to be created
        uint256 tokens = _getTokenAmount(weiAmount);

        // update state
        _weiRaised = _weiRaised.add(weiAmount);

        _processPurchase(beneficiary, tokens);
        emit TokensPurchased(msg.sender, beneficiary, weiAmount, tokens);

        _updatePurchasingState(beneficiary, weiAmount);

        _forwardFunds();
        _postValidatePurchase(beneficiary, weiAmount);
    }

    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="188" endline="207" pcid="2572">
    function buyTokens(address beneficiary) public nonReentrant payable {
        uint256 weiAmount = msg.value;
        _preValidatePurchase(beneficiary, weiAmount);

        // calculate token amount to be created
        uint256 tokens = _getTokenAmount(weiAmount);

        // update state
        _weiRaised = _weiRaised.add(weiAmount);

        _processPurchase(beneficiary, tokens);
        emit TokensPurchased(msg.sender, beneficiary, weiAmount, tokens);

        _updatePurchasingState(beneficiary, weiAmount);

        _forwardFunds();
        _postValidatePurchase(beneficiary, weiAmount);
    }

    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="580" endline="585" pcid="2129">
  function finalizeReservedAddress(address addr) public onlyMintAgent canMint {
    ReservedTokensData storage reservedTokensData = reservedTokensList[addr];
    reservedTokensData.isDistributed = true;
  }

  function isAddressReserved(address addr) public constant returns (bool isReserved) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1208" endline="1219" pcid="1814">
    function deposit(address payee) public onlyPrimary payable {
        uint256 amount = msg.value;
        _deposits[payee] = _deposits[payee].add(amount);

        emit Deposited(payee, amount);
    }

    /**
     * @dev Withdraw accumulated balance for a payee.
     * @param payee The address whose funds will be withdrawn and transferred to.
     */
    function withdraw(address payable payee) public onlyPrimary {
</source>
</class>

<class classid="213" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1248" endline="1252" pcid="1817">
    function withdraw(address payable payee) public {
        require(withdrawalAllowed(payee), "ConditionalEscrow: payee is not allowed to withdraw");
        super.withdraw(payee);
    }
}
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1395" endline="1406" pcid="1826">
    function claimRefund(address payable refundee) public {
        require(finalized(), "RefundableCrowdsale: not finalized");
        require(!goalReached(), "RefundableCrowdsale: goal reached");

        _escrow.withdraw(refundee);
    }

    /**
     * @dev Checks whether funding goal was reached.
     * @return Whether funding goal was reached
     */
    function goalReached() public view returns (bool) {
</source>
</class>

<class classid="214" nclones="4" nlines="4" similarity="75">
<source file="systems/smart_contracts/CommunityChest.sol" startline="22" endline="27" pcid="1940">
    function send(address payable to, uint256 value) public onlyOwner {
        to.transfer(value);
        emit Transfer(to, value);
    }

    function () payable external {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="266" endline="274" pcid="5356">
    function withdrawEther(address payable recipient, uint256 amount) external onlyOwner {
        require(recipient != address(0), "Withdraw: recipient is the zero address");

        uint256 balance = address(this).balance;

        require(balance >= amount, "Withdraw: amount exceeds balance");
        recipient.transfer(amount);
    }
}
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="147" endline="155" pcid="6988">
    function withdrawEther(address payable to, uint256 amount) external onlyOwner {
        require(to != address(0));

        uint256 balance = address(this).balance;

        require(balance >= amount);
        to.transfer(amount);
    }
}
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="306" endline="318" pcid="7802">
    function withdrawEther(address payable recipient, uint256 amount) external onlyOwner {
        require(recipient != address(0), "Withdraw: recipient is the zero address");

        uint256 balance = address(this).balance;

        require(balance >= amount, "Withdraw: amount exceeds balance");
        recipient.transfer(amount);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     */
    function _transferOwnership(address newOwner) internal {
</source>
</class>

<class classid="215" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/ComplianceRegistry.sol" startline="94" endline="99" pcid="1948">
    function changeService(address _service) onlyOwner isContract(_service) public {
        address old = service;
        service = _service;
        emit ChangeService(old, service);
    }
}
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="197" endline="202" pcid="5848">
    function changeService(address _service) onlyOwner isContract(_service) public {
        address old = service;
        service = _service;
        emit ChangeService(old, service);
    }
}
</source>
</class>

<class classid="216" nclones="5" nlines="4" similarity="100">
<source file="systems/smart_contracts/Contracts.sol" startline="32" endline="46" pcid="1994">
    function Contracts(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    }

    /**
     * Internal transfer, only can be called by this contract
     */
    function _transfer(address _from, address _to, uint _value) internal {
</source>
<source file="systems/smart_contracts/DDPC.sol" startline="30" endline="44" pcid="2376">
    function DDPC (
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    }

    /**
     * Internal transfer, only can be called by this contract
     */
    function _transfer(address _from, address _to, uint _value) internal {
</source>
<source file="systems/smart_contracts/RanchChain.sol" startline="32" endline="46" pcid="5976">
    function RanchChain(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    }

    /**
     * Internal transfer, only can be called by this contract
     */
    function _transfer(address _from, address _to, uint _value) internal {
</source>
<source file="systems/smart_contracts/Rabbit.sol" startline="16" endline="22" pcid="5940">
    function Rabbit(uint256 initialSupply, string tokenName, string tokenSymbol) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        name = tokenName;
        symbol = tokenSymbol;
    }
    function _transfer(address _from, address _to, uint _value) internal {
</source>
<source file="systems/smart_contracts/MyAdvancedToken.sol" startline="52" endline="66" pcid="5262">
    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    }

    /**
     * Internal transfer, only can be called by this contract
     */
    function _transfer(address _from, address _to, uint _value) internal {
</source>
</class>

<class classid="217" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/Controller.sol" startline="15" endline="16" pcid="2004">
    function sweeperOf(address _token) external returns (address);
}
</source>
<source file="systems/smart_contracts/OMGToken.sol" startline="71" endline="72" pcid="5488">
  function balanceOf(address who) constant returns (uint);
  function transfer(address to, uint value);
</source>
</class>

<class classid="218" nclones="7" nlines="2" similarity="100">
<source file="systems/smart_contracts/Controller.sol" startline="118" endline="120" pcid="2015">
    function sweep(address token, uint amount) external returns (bool);

    Controller controller;
</source>
<source file="systems/smart_contracts/ProxyERC20.sol" startline="338" endline="340" pcid="5888">
    function approve(address spender, uint value) public returns (bool);

    function transferFrom(address from, address to, uint value) public returns (bool);
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="131" endline="132" pcid="2338">
    function burn(address _from, uint _value) external returns (bool);
}
</source>
<source file="systems/smart_contracts/ProxyERC20.sol" startline="336" endline="338" pcid="5887">
    function transfer(address to, uint value) public returns (bool);

    function approve(address spender, uint value) public returns (bool);
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="121" endline="131" pcid="2337">
    function issue(address _to, uint _value) external returns (bool);


    /**
     * Burns `_value` tokens of `_from`
     *
     * @param _from The address that owns the tokens to be burned
     * @param _value The amount of tokens to be burned
     * @return Whether the tokens where sucessfully burned or not 
     */
    function burn(address _from, uint _value) external returns (bool);
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="63" endline="73" pcid="2332">
    function approve(address _spender, uint _value) external returns (bool);


    /** 
     * Get the amount of remaining tokens that `_spender` is allowed to spend from `_owner`
     * 
     * @param _owner The address of the account owning tokens
     * @param _spender The address of the account able to transfer the tokens
     * @return Amount of remaining tokens allowed to spent
     */
    function allowance(address _owner, address _spender) external view returns (uint);
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="42" endline="53" pcid="2330">
    function transfer(address _to, uint _value) external returns (bool);


    /** 
     * Send `_value` token to `_to` from `_from` on the condition it is approved by `_from`
     * 
     * @param _from The address of the sender
     * @param _to The address of the recipient
     * @param _value The amount of token to be transferred
     * @return Whether the transfer was successful or not
     */
    function transferFrom(address _from, address _to, uint _value) external returns (bool);
</source>
</class>

<class classid="219" nclones="3" nlines="3" similarity="100">
<source file="systems/smart_contracts/CouncilVesting.sol" startline="63" endline="64" pcid="2025">
    function totalSupply() constant returns (uint256 totalSupply) {}
    function balanceOf(address _owner) constant returns (uint256 balance) {}
</source>
<source file="systems/smart_contracts/TeaToken.sol" startline="12" endline="13" pcid="7118">
    function totalSupply() constant returns (uint256 totalSupply) {}
    function balanceOf(address owner) constant returns (uint256 balance);
</source>
<source file="systems/smart_contracts/ZhongChaChainToken.sol" startline="12" endline="13" pcid="8215">
    function totalSupply() constant returns (uint256 totalSupply) {}
    function balanceOf(address owner) constant returns (uint256 balance);
</source>
</class>

<class classid="220" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/CouncilVesting.sol" startline="232" endline="249" pcid="2038">
    function withdraw()
        external
        only_beneficiary
        vesting_started
        not_interrupted
    {
        uint withdrawable = calculateWithdrawable();
        withdrawn = withdrawn.add(withdrawable);
        require(
            MELON_CONTRACT.transfer(beneficiary, withdrawable),
            "Transfer to beneficiary failed"
        );
    }

    /// @notice Withdraw vested tokens to beneficiary
    /// @notice Send remainder back to owner
    /// @notice Prevent further vesting
    function forceWithdrawalAndInterrupt()
</source>
<source file="systems/smart_contracts/CouncilVesting.sol" startline="249" endline="269" pcid="2039">
    function forceWithdrawalAndInterrupt()
        external
        only_owner
        vesting_started
        not_interrupted
    {
        interrupted = true;
        uint remainingVested = calculateWithdrawable();
        uint totalToBeVested = withdrawn.add(remainingVested);
        uint remainingUnvested = totalVestingAmount.sub(totalToBeVested);
        withdrawn = totalVestingAmount;
        require(
            MELON_CONTRACT.transfer(beneficiary, remainingVested),
            "Transfer to beneficiary failed"
        );
        require(
            MELON_CONTRACT.transfer(owner, remainingUnvested),
            "Transfer to owner failed"
        );
    }
}
</source>
</class>

<class classid="221" nclones="4" nlines="7" similarity="100">
<source file="systems/smart_contracts/Crowdsale.sol" startline="440" endline="447" pcid="2074">
    function giveBountyTokens(address _newInvestor, uint256 _value) public onlyOwner {
        // the sum is entered in whole tokens (1 = 1 token)
        if (returnTokensFromHoldBountyAddress(_value)){
            giveTokens(_newInvestor, _value);
        }
    }

    function giveProjectTokens(address _newInvestor, uint256 _value) public onlyOwner {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="455" endline="462" pcid="2076">
    function giveAdvisorsTokens(address _newInvestor, uint256 _value) public onlyOwner {
        // the sum is entered in whole tokens (1 = 1 token)
        if (returnTokensFromHoldAdvisorsAddress(_value)){
            giveTokens(_newInvestor, _value);
        }
    }

    function giveAdditionalTokens(address _newInvestor, uint256 _value) public onlyOwner {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="447" endline="455" pcid="2075">
    function giveProjectTokens(address _newInvestor, uint256 _value) public onlyOwner {
        // the sum is entered in whole tokens (1 = 1 token)

        if (returnTokensFromHoldProjectAddress(_value)){
            giveTokens(_newInvestor, _value);
        }
    }

    function giveAdvisorsTokens(address _newInvestor, uint256 _value) public onlyOwner {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="462" endline="469" pcid="2077">
    function giveAdditionalTokens(address _newInvestor, uint256 _value) public onlyOwner {
        // the sum is entered in whole tokens (1 = 1 token)
        if (returnTokensFromHoldAdditionalAddress(_value)){
            giveTokens(_newInvestor, _value);
        }
    }

    function withdrawAllTokensFromBalance() public onlyOwner {
</source>
</class>

<class classid="222" nclones="3" nlines="4" similarity="75">
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="291" endline="298" pcid="2114">
  function UpgradeableToken(address _upgradeMaster) {
    upgradeMaster = _upgradeMaster;
  }

  /**
   * Allow the token holder to upgrade some of their tokens to a new contract.
   */
  function upgrade(uint256 value) public {
</source>
<source file="systems/smart_contracts/Exchange.sol" startline="385" endline="393" pcid="3395">
    function userAllowFuturesContract(address futuresContract)
    {
        if (!futuresContracts[futuresContract]) throw;
        userAllowedFuturesContracts[msg.sender][futuresContract] = true;

        emit AllowFuturesContract(futuresContract, msg.sender);
    }

    function allowFuturesContractForUser(address futuresContract, address user, uint8 v, bytes32 r, bytes32 s) onlyAdmin
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1108" endline="1115" pcid="6140">
  function UpgradeableToken(address _upgradeMaster) {
    upgradeMaster = _upgradeMaster;
  }

  /**
   * Allow the token holder to upgrade some of their tokens to a new contract.
   */
  function upgrade(uint256 value) public {
</source>
</class>

<class classid="223" nclones="2" nlines="8" similarity="100">
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="298" endline="323" pcid="2115">
  function upgrade(uint256 value) public {

      UpgradeState state = getUpgradeState();
      if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {
        // Called in a bad state
        throw;
      }

      // Validate input value.
      if (value == 0) throw;

      balances[msg.sender] = safeSub(balances[msg.sender], value);

      // Take tokens out from circulation
      totalSupply = safeSub(totalSupply, value);
      totalUpgraded = safeAdd(totalUpgraded, value);

      // Upgrade agent reissues the tokens
      upgradeAgent.upgradeFrom(msg.sender, value);
      Upgrade(msg.sender, upgradeAgent, value);
  }

  /**
   * Set an upgrade agent that handles
   */
  function setUpgradeAgent(address agent) external {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1115" endline="1140" pcid="6141">
  function upgrade(uint256 value) public {

      UpgradeState state = getUpgradeState();
      if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {
        // Called in a bad state
        throw;
      }

      // Validate input value.
      if (value == 0) throw;

      balances[msg.sender] = safeSub(balances[msg.sender], value);

      // Take tokens out from circulation
      totalSupply = safeSub(totalSupply, value);
      totalUpgraded = safeAdd(totalUpgraded, value);

      // Upgrade agent reissues the tokens
      upgradeAgent.upgradeFrom(msg.sender, value);
      Upgrade(msg.sender, upgradeAgent, value);
  }

  /**
   * Set an upgrade agent that handles
   */
  function setUpgradeAgent(address agent) external {
</source>
</class>

<class classid="224" nclones="2" nlines="8" similarity="100">
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="323" endline="349" pcid="2116">
  function setUpgradeAgent(address agent) external {

      if(!canUpgrade()) {
        // The token is not yet in a state that we could think upgrading
        throw;
      }

      if (agent == 0x0) throw;
      // Only a master can designate the next agent
      if (msg.sender != upgradeMaster) throw;
      // Upgrade has already begun for an agent
      if (getUpgradeState() == UpgradeState.Upgrading) throw;

      upgradeAgent = UpgradeAgent(agent);

      // Bad interface
      if(!upgradeAgent.isUpgradeAgent()) throw;
      // Make sure that token supplies match in source and target
      if (upgradeAgent.originalSupply() != totalSupply) throw;

      UpgradeAgentSet(upgradeAgent);
  }

  /**
   * Get the state of the token upgrade.
   */
  function getUpgradeState() public constant returns(UpgradeState) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1140" endline="1166" pcid="6142">
  function setUpgradeAgent(address agent) external {

      if(!canUpgrade()) {
        // The token is not yet in a state that we could think upgrading
        throw;
      }

      if (agent == 0x0) throw;
      // Only a master can designate the next agent
      if (msg.sender != upgradeMaster) throw;
      // Upgrade has already begun for an agent
      if (getUpgradeState() == UpgradeState.Upgrading) throw;

      upgradeAgent = UpgradeAgent(agent);

      // Bad interface
      if(!upgradeAgent.isUpgradeAgent()) throw;
      // Make sure that token supplies match in source and target
      if (upgradeAgent.originalSupply() != totalSupply) throw;

      UpgradeAgentSet(upgradeAgent);
  }

  /**
   * Get the state of the token upgrade.
   */
  function getUpgradeState() public constant returns(UpgradeState) {
</source>
</class>

<class classid="225" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="431" endline="440" pcid="2121">
  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {
    transferAgents[addr] = state;
  }

  /**
   * One way function to release the tokens to the wild.
   *
   * Can be called only from the release agent that is the final ICO contract. It is only called if the crowdsale has been success (first milestone reached).
   */
  function releaseTokenTransfer() public onlyReleaseAgent {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1248" endline="1257" pcid="6147">
  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {
    transferAgents[addr] = state;
  }

  /**
   * One way function to release the tokens to the wild.
   *
   * Can be called only from the release agent that is the final ICO contract. It is only called if the crowdsale has been success (first milestone reached).
   */
  function releaseTokenTransfer() public onlyReleaseAgent {
</source>
</class>

<class classid="226" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="465" endline="470" pcid="2124">
  function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {
    // Call StandardToken.transferForm()
    return super.transferFrom(_from, _to, _value);
  }

}
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1282" endline="1287" pcid="6150">
  function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {
    // Call StandardToken.transferForm()
    return super.transferFrom(_from, _to, _value);
  }

}
</source>
</class>

<class classid="227" nclones="23" nlines="4" similarity="75">
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="501" endline="507" pcid="2125">
  function times(uint a, uint b) returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function divides(uint a, uint b) returns (uint) {
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="507" endline="514" pcid="2126">
  function divides(uint a, uint b) returns (uint) {
    assert(b > 0);
    uint c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function minus(uint a, uint b) returns (uint) {
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="514" endline="519" pcid="2127">
  function minus(uint a, uint b) returns (uint) {
    assert(b <= a);
    return a - b;
  }

  function plus(uint a, uint b) returns (uint) {
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="519" endline="525" pcid="2128">
  function plus(uint a, uint b) returns (uint) {
    uint c = a + b;
    assert(c>=a);
    return c;
  }

}
</source>
<source file="systems/smart_contracts/Exchange.sol" startline="30" endline="37" pcid="3363">
    function safeMul(uint a, uint b) returns (uint) {
        uint c = a * b;
        assert(a == 0 || c / a == b);
        return c;
    }

    // Safe Subtraction Function - prevents integer overflow 
    function safeSub(uint a, uint b) returns (uint) {
</source>
<source file="systems/smart_contracts/Exchange.sol" startline="37" endline="43" pcid="3364">
    function safeSub(uint a, uint b) returns (uint) {
        assert(b <= a);
        return a - b;
    }

    // Safe Addition Function - prevents integer overflow 
    function safeAdd(uint a, uint b) returns (uint) {
</source>
<source file="systems/smart_contracts/Exchange.sol" startline="43" endline="49" pcid="3365">
    function safeAdd(uint a, uint b) returns (uint) {
        uint c = a + b;
        assert(c>=a && c>=b);
        return c;
    }

    address public owner; // holds the address of the contract owner
</source>
<source file="systems/smart_contracts/FlatPricingExt.sol" startline="133" endline="139" pcid="3637">
  function times(uint a, uint b) returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function divides(uint a, uint b) returns (uint) {
</source>
<source file="systems/smart_contracts/FlatPricingExt.sol" startline="139" endline="146" pcid="3638">
  function divides(uint a, uint b) returns (uint) {
    assert(b > 0);
    uint c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function minus(uint a, uint b) returns (uint) {
</source>
<source file="systems/smart_contracts/FlatPricingExt.sol" startline="146" endline="151" pcid="3639">
  function minus(uint a, uint b) returns (uint) {
    assert(b <= a);
    return a - b;
  }

  function plus(uint a, uint b) returns (uint) {
</source>
<source file="systems/smart_contracts/FlatPricingExt.sol" startline="151" endline="157" pcid="3640">
  function plus(uint a, uint b) returns (uint) {
    uint c = a + b;
    assert(c>=a);
    return c;
  }

}
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="90" endline="96" pcid="4838">
  function times(uint a, uint b) returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function divides(uint a, uint b) returns (uint) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="96" endline="103" pcid="4839">
  function divides(uint a, uint b) returns (uint) {
    assert(b > 0);
    uint c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function minus(uint a, uint b) returns (uint) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="103" endline="108" pcid="4840">
  function minus(uint a, uint b) returns (uint) {
    assert(b <= a);
    return a - b;
  }

  function plus(uint a, uint b) returns (uint) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="108" endline="114" pcid="4841">
  function plus(uint a, uint b) returns (uint) {
    uint c = a + b;
    assert(c>=a);
    return c;
  }

}
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="40" endline="46" pcid="6070">
  function times(uint a, uint b) returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function divides(uint a, uint b) returns (uint) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="46" endline="53" pcid="6071">
  function divides(uint a, uint b) returns (uint) {
    assert(b > 0);
    uint c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function minus(uint a, uint b) returns (uint) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="53" endline="58" pcid="6072">
  function minus(uint a, uint b) returns (uint) {
    assert(b <= a);
    return a - b;
  }

  function plus(uint a, uint b) returns (uint) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="58" endline="64" pcid="6073">
  function plus(uint a, uint b) returns (uint) {
    uint c = a + b;
    assert(c>=a);
    return c;
  }

}
</source>
<source file="systems/smart_contracts/SafeMathLibExt.sol" startline="26" endline="32" pcid="6239">
  function times(uint a, uint b) returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function divides(uint a, uint b) returns (uint) {
</source>
<source file="systems/smart_contracts/SafeMathLibExt.sol" startline="32" endline="39" pcid="6240">
  function divides(uint a, uint b) returns (uint) {
    assert(b > 0);
    uint c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function minus(uint a, uint b) returns (uint) {
</source>
<source file="systems/smart_contracts/SafeMathLibExt.sol" startline="39" endline="44" pcid="6241">
  function minus(uint a, uint b) returns (uint) {
    assert(b <= a);
    return a - b;
  }

  function plus(uint a, uint b) returns (uint) {
</source>
<source file="systems/smart_contracts/SafeMathLibExt.sol" startline="44" endline="50" pcid="6242">
  function plus(uint a, uint b) returns (uint) {
    uint c = a + b;
    assert(c>=a);
    return c;
  }

}
</source>
</class>

<class classid="228" nclones="3" nlines="11" similarity="100">
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="605" endline="628" pcid="2135">
  function setReservedTokensListMultiple(
    address[] addrs, 
    uint[] inTokens, 
    uint[] inPercentageUnit, 
    uint[] inPercentageDecimals
  ) public canMint onlyOwner {
    assert(!reservedTokensDestinationsAreSet);
    assert(addrs.length == inTokens.length);
    assert(inTokens.length == inPercentageUnit.length);
    assert(inPercentageUnit.length == inPercentageDecimals.length);
    for (uint iterator = 0; iterator < addrs.length; iterator++) {
      if (addrs[iterator] != address(0)) {
        setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);
      }
    }
    reservedTokensDestinationsAreSet = true;
  }

  /**
   * Create new tokens and allocate them to an address..
   *
   * Only callably by a crowdsale contract (mint agent).
   */
  function mint(address receiver, uint amount) onlyMintAgent canMint public {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="1114" endline="1137" pcid="4904">
  function setReservedTokensListMultiple(
    address[] addrs, 
    uint[] inTokens, 
    uint[] inPercentageUnit, 
    uint[] inPercentageDecimals
  ) public canMint onlyOwner {
    assert(!reservedTokensDestinationsAreSet);
    assert(addrs.length == inTokens.length);
    assert(inTokens.length == inPercentageUnit.length);
    assert(inPercentageUnit.length == inPercentageDecimals.length);
    for (uint iterator = 0; iterator < addrs.length; iterator++) {
      if (addrs[iterator] != address(0)) {
        setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);
      }
    }
    reservedTokensDestinationsAreSet = true;
  }

  /**
   * Create new tokens and allocate them to an address..
   *
   * Only callably by a crowdsale contract (mint agent).
   */
  function mint(address receiver, uint amount) onlyMintAgent canMint public {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1377" endline="1400" pcid="6157">
  function setReservedTokensListMultiple(
    address[] addrs, 
    uint[] inTokens, 
    uint[] inPercentageUnit, 
    uint[] inPercentageDecimals
  ) public canMint onlyOwner {
    assert(!reservedTokensDestinationsAreSet);
    assert(addrs.length == inTokens.length);
    assert(inTokens.length == inPercentageUnit.length);
    assert(inPercentageUnit.length == inPercentageDecimals.length);
    for (uint iterator = 0; iterator < addrs.length; iterator++) {
      if (addrs[iterator] != address(0)) {
        setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);
      }
    }
    reservedTokensDestinationsAreSet = true;
  }

  /**
   * Create new tokens and allocate them to an address..
   *
   * Only callably by a crowdsale contract (mint agent).
   */
  function mint(address receiver, uint amount) onlyMintAgent canMint public {
</source>
</class>

<class classid="229" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="628" endline="640" pcid="2136">
  function mint(address receiver, uint amount) onlyMintAgent canMint public {
    totalSupply = totalSupply.plus(amount);
    balances[receiver] = balances[receiver].plus(amount);

    // This will make the mint transaction apper in EtherScan.io
    // We can remove this after there is a standardized minting event
    Transfer(0, receiver, amount);
  }

  /**
   * Owner can allow a crowdsale contract to mint new tokens.
   */
  function setMintAgent(address addr, bool state) onlyOwner canMint public {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="1137" endline="1149" pcid="4905">
  function mint(address receiver, uint amount) onlyMintAgent canMint public {
    totalSupply = totalSupply.plus(amount);
    balances[receiver] = balances[receiver].plus(amount);

    // This will make the mint transaction apper in EtherScan.io
    // We can remove this after there is a standardized minting event
    Transfer(0, receiver, amount);
  }

  /**
   * Owner can allow a crowdsale contract to mint new tokens.
   */
  function setMintAgent(address addr, bool state) onlyOwner canMint public {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1400" endline="1412" pcid="6158">
  function mint(address receiver, uint amount) onlyMintAgent canMint public {
    totalSupply = totalSupply.plus(amount);
    balances[receiver] = balances[receiver].plus(amount);

    // This will make the mint transaction apper in EtherScan.io
    // We can remove this after there is a standardized minting event
    Transfer(0, receiver, amount);
  }

  /**
   * Owner can allow a crowdsale contract to mint new tokens.
   */
  function setMintAgent(address addr, bool state) onlyOwner canMint public {
</source>
</class>

<class classid="230" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="640" endline="645" pcid="2137">
  function setMintAgent(address addr, bool state) onlyOwner canMint public {
    mintAgents[addr] = state;
    MintingAgentChanged(addr, state);
  }

  function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="1149" endline="1154" pcid="4906">
  function setMintAgent(address addr, bool state) onlyOwner canMint public {
    mintAgents[addr] = state;
    MintingAgentChanged(addr, state);
  }

  function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1412" endline="1417" pcid="6159">
  function setMintAgent(address addr, bool state) onlyOwner canMint public {
    mintAgents[addr] = state;
    MintingAgentChanged(addr, state);
  }

  function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {
</source>
</class>

<class classid="231" nclones="3" nlines="8" similarity="100">
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="645" endline="660" pcid="2138">
  function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {
    assert(addr != address(0));
    if (!isAddressReserved(addr)) {
      reservedTokensDestinations.push(addr);
      reservedTokensDestinationsLen++;
    }

    reservedTokensList[addr] = ReservedTokensData({
      inTokens: inTokens, 
      inPercentageUnit: inPercentageUnit, 
      inPercentageDecimals: inPercentageDecimals,
      isReserved: true,
      isDistributed: false
    });
  }
}
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="1154" endline="1169" pcid="4907">
  function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {
    assert(addr != address(0));
    if (!isAddressReserved(addr)) {
      reservedTokensDestinations.push(addr);
      reservedTokensDestinationsLen++;
    }

    reservedTokensList[addr] = ReservedTokensData({
      inTokens: inTokens, 
      inPercentageUnit: inPercentageUnit, 
      inPercentageDecimals: inPercentageDecimals,
      isReserved: true,
      isDistributed: false
    });
  }
}
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1417" endline="1432" pcid="6160">
  function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {
    assert(addr != address(0));
    if (!isAddressReserved(addr)) {
      reservedTokensDestinations.push(addr);
      reservedTokensDestinationsLen++;
    }

    reservedTokensList[addr] = ReservedTokensData({
      inTokens: inTokens, 
      inPercentageUnit: inPercentageUnit, 
      inPercentageDecimals: inPercentageDecimals,
      isReserved: true,
      isDistributed: false
    });
  }
}
</source>
</class>

<class classid="232" nclones="2" nlines="14" similarity="100">
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="701" endline="737" pcid="2139">
  function CrowdsaleTokenExt(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable, uint _globalMinCap)
    UpgradeableToken(msg.sender) {

    // Create any address, can be transferred
    // to team multisig via changeOwner(),
    // also remember to call setUpgradeMaster()
    owner = msg.sender;

    name = _name;
    symbol = _symbol;

    totalSupply = _initialSupply;

    decimals = _decimals;

    minCap = _globalMinCap;

    // Create initially all balance on the team multisig
    balances[owner] = totalSupply;

    if(totalSupply > 0) {
      Minted(owner, totalSupply);
    }

    // No more new supply allowed after the token creation
    if(!_mintable) {
      mintingFinished = true;
      if(totalSupply == 0) {
        throw; // Cannot create a token without supply and no minting
      }
    }
  }

  /**
   * When token is released to be transferable, enforce no new tokens can be created.
   */
  function releaseTokenTransfer() public onlyReleaseAgent {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1473" endline="1509" pcid="6161">
  function CrowdsaleTokenExt(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable, uint _globalMinCap)
    UpgradeableToken(msg.sender) {

    // Create any address, can be transferred
    // to team multisig via changeOwner(),
    // also remember to call setUpgradeMaster()
    owner = msg.sender;

    name = _name;
    symbol = _symbol;

    totalSupply = _initialSupply;

    decimals = _decimals;

    minCap = _globalMinCap;

    // Create initially all balance on the team multisig
    balances[owner] = totalSupply;

    if(totalSupply > 0) {
      Minted(owner, totalSupply);
    }

    // No more new supply allowed after the token creation
    if(!_mintable) {
      mintingFinished = true;
      if(totalSupply == 0) {
        throw; // Cannot create a token without supply and no minting
      }
    }
  }

  /**
   * When token is released to be transferable, enforce no new tokens can be created.
   */
  function releaseTokenTransfer() public onlyReleaseAgent {
</source>
</class>

<class classid="233" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="758" endline="770" pcid="2142">
  function setTokenInformation(string _name, string _symbol) onlyOwner {
    name = _name;
    symbol = _symbol;

    UpdatedTokenInformation(name, symbol);
  }

  /**
   * Claim tokens that were accidentally sent to this contract.
   *
   * @param _token The address of the token contract that you want to recover.
   */
  function claimTokens(address _token) public onlyOwner {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1530" endline="1542" pcid="6164">
  function setTokenInformation(string _name, string _symbol) onlyOwner {
    name = _name;
    symbol = _symbol;

    UpdatedTokenInformation(name, symbol);
  }

  /**
   * Claim tokens that were accidentally sent to this contract.
   *
   * @param _token The address of the token contract that you want to recover.
   */
  function claimTokens(address _token) public onlyOwner {
</source>
</class>

<class classid="234" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/CustomToken.sol" startline="140" endline="147" pcid="2235">
  function isFrozenAccount(address target) onlyController public view returns (bool) {
      return frozenAccount[target];
  }
  
  /**
   * @dev Modifier to make a function callable only when the contract is not paused.
   */
  modifier whenNotPaused() {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="140" endline="147" pcid="7708">
  function isFrozenAccount(address target) onlyController public view returns (bool) {
      return frozenAccount[target];
  }
  
  /**
   * @dev Modifier to make a function callable only when the contract is not paused.
   */
  modifier whenNotPaused() {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="140" endline="147" pcid="6721">
  function isFrozenAccount(address target) onlyController public view returns (bool) {
      return frozenAccount[target];
  }
  
  /**
   * @dev Modifier to make a function callable only when the contract is not paused.
   */
  modifier whenNotPaused() {
</source>
</class>

<class classid="235" nclones="4" nlines="2" similarity="100">
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="53" endline="63" pcid="2331">
    function transferFrom(address _from, address _to, uint _value) external returns (bool);


    /** 
     * `msg.sender` approves `_spender` to spend `_value` tokens
     * 
     * @param _spender The address of the account able to transfer the tokens
     * @param _value The amount of tokens to be approved for transfer
     * @return Whether the approval was successful or not
     */
    function approve(address _spender, uint _value) external returns (bool);
</source>
<source file="systems/smart_contracts/MiniMeTokenFactory.sol" startline="22" endline="30" pcid="4801">
    function onTransfer(address _from, address _to, uint _amount) external returns(bool);

    /// @notice Notifies the controller about an approval allowing the
    ///  controller to react if desired
    /// @param _owner The address that calls `approve()`
    /// @param _spender The spender in the `approve()` call
    /// @param _amount The amount in the `approve()` call
    /// @return False if the controller does not authorize the approval
    function onApprove(address _owner, address _spender, uint _amount) external returns(bool);
</source>
<source file="systems/smart_contracts/MiniMeTokenFactory.sol" startline="30" endline="31" pcid="4802">
    function onApprove(address _owner, address _spender, uint _amount) external returns(bool);
}
</source>
<source file="systems/smart_contracts/ProxyERC20.sol" startline="340" endline="343" pcid="5889">
    function transferFrom(address from, address to, uint value) public returns (bool);

    // ERC20 Optional
    function name() public view returns (string);
</source>
</class>

<class classid="236" nclones="9" nlines="2" similarity="100">
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="274" endline="282" pcid="2346">
    function getObserverAtIndex(uint _index) external view returns (address);


    /**
     * Register `_observer` as an observer
     * 
     * @param _observer The account to add as an observer
     */
    function registerObserver(address _observer) external;
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="2326" endline="2327" pcid="6911">
    function transferFeeIncurred(uint value) public view returns (uint);
}
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="2322" endline="2323" pcid="6907">
    function amountReceivedFromTransfer(uint value) external view returns (uint);
    function feePaid(bytes4 currencyKey, uint amount) external;
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="2321" endline="2322" pcid="6906">
    function amountReceivedFromExchange(uint value) external view returns (uint);
    function amountReceivedFromTransfer(uint value) external view returns (uint);
</source>
<source file="systems/smart_contracts/EJackpot.sol" startline="14" endline="16" pcid="2902">
    function getHour(uint timestamp) external pure returns (uint8);

    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) external pure returns (uint);
</source>
<source file="systems/smart_contracts/EJackpot.sol" startline="12" endline="14" pcid="2901">
    function getDay(uint timestamp) external pure returns (uint8);

    function getHour(uint timestamp) external pure returns (uint8);
</source>
<source file="systems/smart_contracts/EJackpot.sol" startline="10" endline="12" pcid="2900">
    function getMonth(uint timestamp) external pure returns (uint8);

    function getDay(uint timestamp) external pure returns (uint8);
</source>
<source file="systems/smart_contracts/EJackpot.sol" startline="8" endline="10" pcid="2899">
    function getYear(uint timestamp) external pure returns (uint16);

    function getMonth(uint timestamp) external pure returns (uint8);
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="447" endline="455" pcid="2357">
    function getOwnerAt(uint _index) public view returns (address);


     /**
     * Adds `_account` as a new owner
     *
     * @param _account The account to add as an owner
     */
    function addOwner(address _account) public;
</source>
</class>

<class classid="237" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/DefaultService.sol" startline="9" endline="11" pcid="2384">
    function check(address _token,address _spender,address _from,address _to,uint256 _amount) public view returns (uint8);

}
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="205" endline="207" pcid="5849">
    function check(address _token,address _spender,address _from,address _to,uint256 _amount) public view returns (uint8);

}
</source>
</class>

<class classid="238" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="205" endline="214" pcid="2440">
    function AddShare(address payable _Share)public onlyOwner returns(bool){
        require(balances[_Share]>0);
         ShareStatus[_Share]=1;
        ShareAddress.push(_Share);
       
        i++;
        //ShareStatus = 1 => approved
    }
    
    function SetShareStatus(address payable _Share)public onlyOwner returns(uint){
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="214" endline="221" pcid="2441">
    function SetShareStatus(address payable _Share)public onlyOwner returns(uint){
        require(ShareStatus[_Share]==1);
         ShareStatus[_Share]=0;
         //ShareStatus = 0 => banned
    }
    
    
    function SetFeeinWei(uint _fee)public onlyOwner returns(uint){
</source>
</class>

<class classid="239" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/DENARIO.sol" startline="26" endline="39" pcid="2447">
    function DENARIO(
        uint256 _initialAmount,
        string _tokenName,
        uint8 _decimalUnits,
        string _tokenSymbol
    ) public {
        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens
        totalSupply = _initialAmount;                        // Update total supply
        name = _tokenName;                                   // Set the name for display purposes
        decimals = _decimalUnits;                            // Amount of decimals for display purposes
        symbol = _tokenSymbol;                               // Set the symbol for display purposes
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Warpcoin.sol" startline="26" endline="39" pcid="7945">
    function Warpcoin(
        uint256 _initialAmount,
        string _tokenName,
        uint8 _decimalUnits,
        string _tokenSymbol
    ) public {
        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens
        totalSupply = _initialAmount;                        // Update total supply
        name = _tokenName;                                   // Set the name for display purposes
        decimals = _decimalUnits;                            // Amount of decimals for display purposes
        symbol = _tokenSymbol;                               // Set the symbol for display purposes
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
</source>
</class>

<class classid="240" nclones="5" nlines="8" similarity="87">
<source file="systems/smart_contracts/DENARIO.sol" startline="47" endline="59" pcid="2449">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        if (allowance < MAX_UINT256) {
            allowed[_from][msg.sender] -= _value;
        }
        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/OBK.sol" startline="40" endline="52" pcid="5469">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        if (allowance < MAX_UINT256) {
            allowed[_from][msg.sender] -= _value;
        }
        Transfer(_from, _to, _value);
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/Warpcoin.sol" startline="47" endline="59" pcid="7947">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        if (allowance < MAX_UINT256) {
            allowed[_from][msg.sender] -= _value;
        }
        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/UNT.sol" startline="40" endline="52" pcid="7567">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        if (allowance < MAX_UINT256) {
            allowed[_from][msg.sender] -= _value;
        }
        Transfer(_from, _to, _value);
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/SHPC.sol" startline="40" endline="52" pcid="6509">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        if (allowance < MAX_UINT256) {
            allowed[_from][msg.sender] -= _value;
        }
        Transfer(_from, _to, _value);
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
</source>
</class>

<class classid="241" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/Discover.sol" startline="174" endline="186" pcid="2767">
    function setMetadata(bytes32 _id, bytes32 _metadata) external {
        uint dappIdx = id2index[_id];
        Data storage d = dapps[dappIdx];
        require(d.developer == msg.sender, "Only the developer can update the metadata");
        d.metadata = _metadata;
        emit MetadataUpdated(_id);
    }

    /**
     * @dev Used in UI in order to fetch all dapps
     * @return dapps count
     */
    function getDAppsCount() external view returns(uint) {
</source>
<source file="systems/smart_contracts/StorageUnit.sol" startline="18" endline="24" pcid="6707">
    function write(bytes32 _key, bytes32 _value) external {
        /* solium-disable-next-line */
        require(msg.sender == owner);
        store[_key] = _value;
    }

    function read(bytes32 _key) external view returns (bytes32) {
</source>
</class>

<class classid="242" nclones="2" nlines="11" similarity="100">
<source file="systems/smart_contracts/EducationLibra.sol" startline="116" endline="137" pcid="2887">
    function () external payable {
		address investor = msg.sender;
		uint256 invest = msg.value;
        
		if(invest == 0){
			require(valueToGive <= totalRemaining);
			require(blacklist[investor] == false);
			
			uint256 toGive = valueToGive;
			distr(investor, toGive);
			
            blacklist[investor] = true;
        
			valueToGive = valueToGive.div(1000000).mul(999999);
		}
		
		if(invest > 0){
			buyToken(investor, invest);
		}
	}
	
	function buyToken(address _investor, uint256 _invest) canDistr public {
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="116" endline="137" pcid="8021">
    function () external payable {
		address investor = msg.sender;
		uint256 invest = msg.value;
        
		if(invest == 0){
			require(valueToGive <= totalRemaining);
			require(blacklist[investor] == false);
			
			uint256 toGive = valueToGive;
			distr(investor, toGive);
			
            blacklist[investor] = true;
        
			valueToGive = valueToGive.div(1000000).mul(999999);
		}
		
		if(invest > 0){
			buyToken(investor, invest);
		}
	}
	
	function buyToken(address _investor, uint256 _invest) canDistr public {
</source>
</class>

<class classid="243" nclones="2" nlines="24" similarity="87">
<source file="systems/smart_contracts/EducationLibra.sol" startline="137" endline="162" pcid="2888">
	function buyToken(address _investor, uint256 _invest) canDistr public {
		uint256 toGive = tokenPerETH.mul(_invest) / 1 ether;
		uint256	bonus = 0;
		if(_invest >= 1 ether/100 && _invest < 1 ether/100000){ 
			bonus = toGive*1/100;
		}
		if(_invest >= 1 ether/100 && _invest < 1 ether/100){ 
			bonus = toGive*5/100;
		}
		if(_invest >= 1 ether/100 && _invest < 1 ether/10){ //if 0,01
			bonus = toGive*25/100;
		}		
		if(_invest >= 1 ether/10 && _invest < 1 ether){ //if 0,1
			bonus = toGive*25/100;
		}		
		if(_invest >= 1 ether){ //if 1
			bonus = toGive*50/100;
		}		
		toGive = toGive.add(bonus);
		
		require(toGive <= totalRemaining);
		
		distr(_investor, toGive);
	}
    
    function balanceOf(address _owner) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="137" endline="162" pcid="8022">
	function buyToken(address _investor, uint256 _invest) canDistr public {
		uint256 toGive = tokenPerETH.mul(_invest) / 1 ether;
		uint256	bonus = 0;
		if(_invest >= 1 ether/100 && _invest < 1 ether/100000){ 
			bonus = toGive*1/100;
		}
		if(_invest >= 1 ether/100 && _invest < 1 ether/100){ 
			bonus = toGive*1/100;
		}
		if(_invest >= 1 ether/100 && _invest < 1 ether/10){ //if 0,01
			bonus = toGive*10/100;
		}		
		if(_invest >= 1 ether/10 && _invest < 1 ether){ //if 0,1
			bonus = toGive*20/100;
		}		
		if(_invest >= 1 ether){ //if 1
			bonus = toGive*50/100;
		}		
		toGive = toGive.add(bonus);
		
		require(toGive <= totalRemaining);
		
		distr(_investor, toGive);
	}
    
    function balanceOf(address _owner) constant public returns (uint256) {
</source>
</class>

<class classid="244" nclones="3" nlines="4" similarity="75">
<source file="systems/smart_contracts/EducationLibra.sol" startline="234" endline="244" pcid="2898">
	function burnFrom(uint256 _value, address _burner) onlyOwner public {
        require(_value <= balances[_burner]);
        
        balances[_burner] = balances[_burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        emit Burn(_burner, _value);
    }
    

}
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="234" endline="242" pcid="8032">
	function burnFrom(uint256 _value, address _burner) onlyOwner public {
        require(_value <= balances[_burner]);
        
        balances[_burner] = balances[_burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        emit Burn(_burner, _value);
    }
}
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="461" endline="471" pcid="7477">
    function createTokensInt(uint256 _tokens, address _destination) internal onlyOwner {
        uint256 tokens = _tokens * 10**uint256(decimals);
        totalSupply_ = totalSupply_.add(tokens);
        balances[_destination] = balances[_destination].add(tokens);
        emit Transfer(0x0, _destination, tokens);

        require(totalSupply_ <= HARD_CAP);
    }

    /// @dev vest Detail : second unit
    function vestTokensDetailInt(
</source>
</class>

<class classid="245" nclones="4" nlines="2" similarity="100">
<source file="systems/smart_contracts/EstateRegistry.sol" startline="21" endline="25" pcid="3055">
  function supportsInterface(bytes4 _interfaceId)
    external
    view
    returns (bool);
}
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="527" endline="528" pcid="5700">
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="106" endline="107" pcid="4985">
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="18" endline="19" pcid="3227">
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}
</source>
</class>

<class classid="246" nclones="9" nlines="2" similarity="100">
<source file="systems/smart_contracts/EstateRegistry.sol" startline="51" endline="52" pcid="3057">
  function ownerOf(uint256 _tokenId) public view returns (address _owner);
  function exists(uint256 _tokenId) public view returns (bool _exists);
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="451" endline="453" pcid="5007">
    function getApproved(uint256 tokenId) public view returns (address operator);

    function setApprovalForAll(address operator, bool _approved) public;
</source>
<source file="systems/smart_contracts/Gacha.sol" startline="57" endline="59" pcid="3967">
    function getApproved(uint256 tokenId) public view returns (address operator);

    function setApprovalForAll(address operator, bool _approved) public;
</source>
<source file="systems/smart_contracts/Gacha.sol" startline="53" endline="55" pcid="3965">
    function ownerOf(uint256 tokenId) public view returns (address owner);

    function approve(address to, uint256 tokenId) public;
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="55" endline="58" pcid="3060">
  function getApproved(uint256 _tokenId)
    public view returns (address _operator);

  function setApprovalForAll(address _operator, bool _approved) public;
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="99" endline="101" pcid="3234">
    function getApproved(uint256 tokenId) public view returns (address operator);

    function setApprovalForAll(address operator, bool _approved) public;
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="426" endline="440" pcid="5003">
    function ownerOf(uint256 tokenId) public view returns (address owner);

    /**
     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to
     * another (`to`).
     *
     *
     *
     * Requirements:
     * - `from`, `to` cannot be zero.
     * - `tokenId` must be owned by `from`.
     * - If the caller is not `from`, it must be have been allowed to move this
     * NFT by either {approve} or {setApprovalForAll}.
     */
    function safeTransferFrom(address from, address to, uint256 tokenId) public;
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="958" endline="962" pcid="3117">
  function ownerOf(uint256 _tokenId) public view returns (address _owner); // from ERC721

  // Events

  event CreateEstate(
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="96" endline="98" pcid="3232">
    function ownerOf(uint256 tokenId) public view returns (address owner);

    function approve(address to, uint256 tokenId) public;
</source>
</class>

<class classid="247" nclones="5" nlines="2" similarity="100">
<source file="systems/smart_contracts/EstateRegistry.sol" startline="58" endline="59" pcid="3061">
  function setApprovalForAll(address _operator, bool _approved) public;
  function isApprovedForAll(address _owner, address _operator)
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="453" endline="454" pcid="5008">
    function setApprovalForAll(address operator, bool _approved) public;
    function isApprovedForAll(address owner, address operator) public view returns (bool);
</source>
<source file="systems/smart_contracts/Gacha.sol" startline="59" endline="61" pcid="3968">
    function setApprovalForAll(address operator, bool _approved) public;

    function isApprovedForAll(address owner, address operator) public view returns (bool);
</source>
<source file="systems/smart_contracts/Oracle.sol" startline="165" endline="166" pcid="5520">
  function setFulfillmentPermission(address node, bool allowed) external;
  function withdraw(address recipient, uint256 amount) external;
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="101" endline="102" pcid="3235">
    function setApprovalForAll(address operator, bool _approved) public;
    function isApprovedForAll(address owner, address operator) public view returns (bool);
</source>
</class>

<class classid="248" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/EstateRegistry.sol" startline="83" endline="91" pcid="3067">
  function tokenOfOwnerByIndex(
    address _owner,
    uint256 _index
  )
    public
    view
    returns (uint256 _tokenId);

  function tokenByIndex(uint256 _index) public view returns (uint256);
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="922" endline="924" pcid="5041">
    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);

    function tokenByIndex(uint256 index) public view returns (uint256);
</source>
</class>

<class classid="249" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/EstateRegistry.sol" startline="100" endline="101" pcid="3069">
  function name() external view returns (string _name);
  function symbol() external view returns (string _symbol);
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="101" endline="102" pcid="3070">
  function symbol() external view returns (string _symbol);
  function tokenURI(uint256 _tokenId) public view returns (string);
</source>
</class>

<class classid="250" nclones="3" nlines="7" similarity="71">
<source file="systems/smart_contracts/EstateRegistry.sol" startline="549" endline="561" pcid="3094">
  function clearApproval(address _owner, uint256 _tokenId) internal {
    require(ownerOf(_tokenId) == _owner);
    if (tokenApprovals[_tokenId] != address(0)) {
      tokenApprovals[_tokenId] = address(0);
    }
  }

  /**
   * @dev Internal function to add a token ID to the list of a given address
   * @param _to address representing the new owner of the given token ID
   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address
   */
  function addTokenTo(address _to, uint256 _tokenId) internal {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="885" endline="893" pcid="5038">
    function _burn(address owner, uint256 tokenId) internal {
        super._burn(owner, tokenId);

        // Clear metadata (if any)
        if (bytes(_tokenURIs[tokenId]).length != 0) {
            delete _tokenURIs[tokenId];
        }
    }
}
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="890" endline="911" pcid="3113">
  function _burn(address _owner, uint256 _tokenId) internal {
    super._burn(_owner, _tokenId);

    // Clear metadata (if any)
    if (bytes(tokenURIs[_tokenId]).length != 0) {
      delete tokenURIs[_tokenId];
    }

    // Reorg all tokens array
    uint256 tokenIndex = allTokensIndex[_tokenId];
    uint256 lastTokenIndex = allTokens.length.sub(1);
    uint256 lastToken = allTokens[lastTokenIndex];

    allTokens[tokenIndex] = lastToken;
    allTokens[lastTokenIndex] = 0;

    allTokens.length--;
    allTokensIndex[_tokenId] = 0;
    allTokensIndex[lastToken] = tokenIndex;
  }

}
</source>
</class>

<class classid="251" nclones="3" nlines="8" similarity="87">
<source file="systems/smart_contracts/EstateRegistry.sol" startline="587" endline="603" pcid="3097">
  function checkAndCallSafeTransfer(
    address _from,
    address _to,
    uint256 _tokenId,
    bytes _data
  )
    internal
    returns (bool)
  {
    if (!_to.isContract()) {
      return true;
    }
    bytes4 retval = ERC721Receiver(_to).onERC721Received(
      msg.sender, _from, _tokenId, _data);
    return (retval == ERC721_RECEIVED);
  }
}
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="777" endline="792" pcid="5029">
    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)
        internal returns (bool)
    {
        if (!to.isContract()) {
            return true;
        }

        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);
        return (retval == _ERC721_RECEIVED);
    }

    /**
     * @dev Private function to clear current approval of a given token ID.
     * @param tokenId uint256 ID of the token to be transferred
     */
    function _clearApproval(uint256 tokenId) private {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="878" endline="893" pcid="3297">
    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)
        internal returns (bool)
    {
        if (!to.isContract()) {
            return true;
        }

        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);
        return (retval == _ERC721_RECEIVED);
    }

    /**
     * @dev Private function to clear current approval of a given token ID
     * @param tokenId uint256 ID of the token to be transferred
     */
    function _clearApproval(uint256 tokenId) private {
</source>
</class>

<class classid="252" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/EstateRegistry.sol" startline="1011" endline="1012" pcid="3123">
  function ownerOf(uint256 tokenId) public returns (address);
  function safeTransferFrom(address, address, uint256) public;
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="1013" endline="1014" pcid="3125">
  function updateOperator(uint256 landId) public returns (address);
}
</source>
</class>

<class classid="253" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/EstateRegistry.sol" startline="1101" endline="1118" pcid="3127">
  function transferLand(
    uint256 estateId,
    uint256 landId,
    address destinatary
  )
    external
    canTransfer(estateId)
  {
    return _transferLand(estateId, landId, destinatary);
  }

  /**
   * @notice Transfer many tokens owned by an Estate to a new owner
   * @param estateId Current owner of the token
   * @param landIds LANDs to be transfered
   * @param destinatary New owner
   */
  function transferManyLands(
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="1256" endline="1274" pcid="3139">
  function setLandUpdateOperator(
    uint256 estateId,
    uint256 landId,
    address operator
  )
    public
    canSetUpdateOperator(estateId)
  {
    require(landIdEstate[landId] == estateId, "The LAND is not part of the Estate");
    registry.setUpdateOperator(landId, operator);
  }

 /**
   * @notice Set many LAND updateOperator
   * @param _estateId - Estate id
   * @param _landIds - LANDs to set the updateOperator
   * @param _operator - address of the account to be set as the updateOperator
   */
  function setManyLandUpdateOperator(
</source>
</class>

<class classid="254" nclones="2" nlines="5" similarity="80">
<source file="systems/smart_contracts/ESTATERO.sol" startline="138" endline="162" pcid="3180">
  function transfer(address to, uint256 value) public returns (bool) {
    address fundAccount = 0x7AE7F76C18928EC5A21fac5b532b6B61022f6300;

    require(value <= _balances[msg.sender]);
    require(to != address(0));

    uint256 tokensToBurn = findFivePercent(value);
    uint256 tokensToFund = findTwoPercent(value);

    uint256 tokensToTransfer = value.sub(tokensToBurn + tokensToFund);

    _balances[msg.sender] = _balances[msg.sender].sub(value);
    _balances[to] = _balances[to].add(tokensToTransfer);
    _balances[fundAccount] = _balances[fundAccount].add(tokensToFund);

    _totalSupply = _totalSupply.sub(tokensToBurn);

    emit Transfer(msg.sender, to, tokensToTransfer);
    emit Transfer(msg.sender, fundAccount, tokensToFund);
    emit Transfer(msg.sender, address(0), tokensToBurn);
    
    return true;
  }

  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="117" endline="141" pcid="3931">
  function transfer(address to, uint256 value) public returns (bool) {
    address fundAccount = 0xE561296160625507eAf99D4a24C7d90cC8d4E8F9;

    require(value <= _balances[msg.sender]);
    require(to != address(0));

    uint256 tokensToBurn = findFivePercent(value);
    uint256 tokensToFund = findTwoPercent(value);

    uint256 tokensToTransfer = value.sub(tokensToBurn + tokensToFund);

    _balances[msg.sender] = _balances[msg.sender].sub(value);
    _balances[to] = _balances[to].add(tokensToTransfer);
    _balances[fundAccount] = _balances[fundAccount].add(tokensToFund);

    _totalSupply = _totalSupply.sub(tokensToBurn);

    emit Transfer(msg.sender, to, tokensToTransfer);
    emit Transfer(msg.sender, fundAccount, tokensToFund);
    emit Transfer(msg.sender, address(0), tokensToBurn);
    
    return true;
  }

  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
</source>
</class>

<class classid="255" nclones="2" nlines="5" similarity="80">
<source file="systems/smart_contracts/ESTATERO.sol" startline="175" endline="201" pcid="3183">
  function transferFrom(address from, address to, uint256 value) public returns (bool) {
    address fundAccount = 0x7AE7F76C18928EC5A21fac5b532b6B61022f6300;

    require(value <= _balances[from]);
    require(value <= _allowed[from][msg.sender]);
    require(to != address(0));

    _balances[from] = _balances[from].sub(value);

    uint256 tokensToBurn = findFivePercent(value);
    uint256 tokensToFund = findTwoPercent(value);

    uint256 tokensToTransfer = value.sub(tokensToBurn + tokensToFund);

    _balances[to] = _balances[to].add(tokensToTransfer);
    _totalSupply = _totalSupply.sub(tokensToBurn);

    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);

    emit Transfer(from, to, tokensToTransfer);
    emit Transfer(msg.sender, fundAccount, tokensToFund);
    emit Transfer(from, address(0), tokensToBurn);

    return true;
  }

  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="154" endline="180" pcid="3934">
  function transferFrom(address from, address to, uint256 value) public returns (bool) {
    address fundAccount = 0xE561296160625507eAf99D4a24C7d90cC8d4E8F9;

    require(value <= _balances[from]);
    require(value <= _allowed[from][msg.sender]);
    require(to != address(0));

    _balances[from] = _balances[from].sub(value);

    uint256 tokensToBurn = findFivePercent(value);
    uint256 tokensToFund = findTwoPercent(value);

    uint256 tokensToTransfer = value.sub(tokensToBurn + tokensToFund);

    _balances[to] = _balances[to].add(tokensToTransfer);
    _totalSupply = _totalSupply.sub(tokensToBurn);

    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);

    emit Transfer(from, to, tokensToTransfer);
    emit Transfer(msg.sender, fundAccount, tokensToFund);
    emit Transfer(from, address(0), tokensToBurn);

    return true;
  }

  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
</class>

<class classid="256" nclones="3" nlines="4" similarity="75">
<source file="systems/smart_contracts/EtheleToken.sol" startline="166" endline="172" pcid="3219">
    function setTransmuteSources12(address transmuteSource1, address transmuteSource2) public {
        require(msg.sender == _creator);
        _transmuteSource1 = transmuteSource1;
        _transmuteSource2 = transmuteSource2;
    } 

    function setTransmuteSources34(address transmuteSource3, address transmuteSource4) public {
</source>
<source file="systems/smart_contracts/EtheleToken.sol" startline="172" endline="178" pcid="3220">
    function setTransmuteSources34(address transmuteSource3, address transmuteSource4) public {
        require(msg.sender == _creator);
        _transmuteSource3 = transmuteSource3;
        _transmuteSource4 = transmuteSource4;
    } 

    function allowBurnsFrom(address burner) public {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="831" endline="845" pcid="5394">
    function _whitelist(address account, address refereeAccount) internal {
        require(!whitelisted(account), "Whitelist: account is already whitelisted");
        require(whitelisted(refereeAccount), "Whitelist: refereeAccount is not whitelisted");

        _referee[account] = refereeAccount;
        _referrals[refereeAccount].push(account);
        _whitelistCounter = _whitelistCounter.add(1);

        emit WhitelistSignUp(account, refereeAccount);
    }

    /**
     * @dev Distribute VOKEN.
     */
    function _distributeVokenForWhitelist(address account) internal {
</source>
</class>

<class classid="257" nclones="3" nlines="4" similarity="75">
<source file="systems/smart_contracts/etherstar.sol" startline="56" endline="60" pcid="3229">
    function _registerInterface(bytes4 interfaceId) internal {
        require(interfaceId != 0xffffffff);
        _supportedInterfaces[interfaceId] = true;
    }
}
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="153" endline="157" pcid="4987">
    function _registerInterface(bytes4 interfaceId) internal {
        require(interfaceId != 0xffffffff, "ERC165: invalid interface id");
        _supportedInterfaces[interfaceId] = true;
    }
}
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="565" endline="569" pcid="5702">
    function _registerInterface(bytes4 interfaceId) internal {
        require(interfaceId != 0xffffffff);
        _supportedInterfaces[interfaceId] = true;
    }
}
</source>
</class>

<class classid="258" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/etherstar.sol" startline="82" endline="84" pcid="3230">
    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)
    public returns (bytes4);
}
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="405" endline="407" pcid="5001">
    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)
    public returns (bytes4);
}
</source>
</class>

<class classid="259" nclones="3" nlines="2" similarity="100">
<source file="systems/smart_contracts/etherstar.sol" startline="107" endline="108" pcid="3239">
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;
}
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="457" endline="458" pcid="5010">
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;
}
</source>
<source file="systems/smart_contracts/Gacha.sol" startline="69" endline="70" pcid="3973">
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;
}
</source>
</class>

<class classid="260" nclones="18" nlines="2" similarity="100">
<source file="systems/smart_contracts/etherstar.sol" startline="115" endline="116" pcid="3240">
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
</source>
<source file="systems/smart_contracts/Factory.sol" startline="193" endline="194" pcid="3440">
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="116" endline="117" pcid="3241">
    function symbol() external view returns (string memory);
    function tokenURI(uint256 tokenId) external view returns (string memory);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="540" endline="541" pcid="3823">
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="768" endline="769" pcid="3874">
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="145" endline="146" pcid="5341">
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="769" endline="770" pcid="3875">
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="806" endline="807" pcid="5032">
    function symbol() external view returns (string memory);
    function tokenURI(uint256 tokenId) external view returns (string memory);
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="144" endline="145" pcid="5340">
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="805" endline="806" pcid="5031">
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="540" endline="541" pcid="7078">
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="187" endline="188" pcid="7785">
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="186" endline="187" pcid="7784">
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
</source>
<source file="systems/smart_contracts/Factory.sol" startline="194" endline="195" pcid="3441">
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="541" endline="542" pcid="3824">
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="541" endline="542" pcid="7079">
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="72" endline="73" pcid="6976">
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="73" endline="74" pcid="6977">
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint256);
</source>
</class>

<class classid="261" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/etherstar.sol" startline="117" endline="118" pcid="3242">
    function tokenURI(uint256 tokenId) external view returns (string memory);
}
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="807" endline="808" pcid="5033">
    function tokenURI(uint256 tokenId) external view returns (string memory);
}
</source>
</class>

<class classid="262" nclones="3" nlines="4" similarity="75">
<source file="systems/smart_contracts/etherstar.sol" startline="614" endline="627" pcid="3277">
    function tokenURI(uint256 tokenId) external view returns (string memory) {
        require(_exists(tokenId));

        if (bytes(_tokenURIs[tokenId]).length > 0)
            return _tokenURIs[tokenId];

        return Strings.strConcat(baseTokenURI(),Strings.uint2str(tokenId));
    }

    /**
     * @dev Sets the prefix of token URI
     * @param baseTokenURI token URI prefix to be set
     */
    function setBaseTokenURI(string memory baseTokenURI) public onlyMinter {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="654" endline="664" pcid="3281">
    function tokenName(uint256 tokenId) public view returns (string memory) {
        require(_exists(tokenId));
        return _tokenNames[tokenId];
    }

    /**
     * @dev Gets the balance of the specified address
     * @param owner address to query the balance of
     * @return uint256 representing the amount owned by the passed address
     */
    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="862" endline="873" pcid="5036">
    function tokenURI(uint256 tokenId) external view returns (string memory) {
        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
        return _tokenURIs[tokenId];
    }

    /**
     * @dev Internal function to set the token URI for a given token.
     * Reverts if the token ID does not exist.
     * @param tokenId uint256 ID of the token to set its URI
     * @param uri string URI to assign
     */
    function _setTokenURI(uint256 tokenId, string memory uri) internal {
</source>
</class>

<class classid="263" nclones="6" nlines="4" similarity="75">
<source file="systems/smart_contracts/etherstar.sol" startline="738" endline="756" pcid="3288">
    function transferFrom(address from, address to, uint256 tokenId) public whenNotPaused {
        require(_isApprovedOrOwner(msg.sender, tokenId));

        _transferFrom(from, to, tokenId);
    }

    /**
     * @dev Safely transfers the ownership of a given token ID to another address
     * If the target address is a contract, it must implement `onERC721Received`,
     * which is called upon a safe transfer, and return the magic value
     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,
     * the transfer is reverted.
     *
     * Requires the msg sender to be the owner, approved, or operator
     * @param from current owner of the token
     * @param to address to receive the ownership of the given token ID
     * @param tokenId uint256 ID of the token to be transferred
    */
    function safeTransferFrom(address from, address to, uint256 tokenId) public {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="292" endline="306" pcid="7801">
    function rescueTokens(address tokenAddr, address recipient, uint256 amount) external onlyOwner {
        IERC20 _token = IERC20(tokenAddr);
        require(recipient != address(0), "Rescue: recipient is the zero address");
        uint256 balance = _token.balanceOf(address(this));

        require(balance >= amount, "Rescue: amount exceeds balance");
        _token.transfer(recipient, amount);
    }

    /**
     * @dev Withdraw Ether
     *
     * Can only be called by the current owner.
     */
    function withdrawEther(address payable recipient, uint256 amount) external onlyOwner {
</source>
<source file="systems/smart_contracts/Gacha.sol" startline="103" endline="111" pcid="3980">
    function setAward(address _user, address _game, uint256 _tokenId) public onlyOwner{
        IERC721 erc721 = IERC721(_game);
        require(erc721.isApprovedForAll(erc721.ownerOf(_tokenId), address(this)));
        awardDatas[_user].items[_game].tokenIds.push(_tokenId);
        awardDatas[_user].totalItem +=1;
        emit _setAward(_user, _game, _tokenId);
    }

    function withdraw(address _game, uint256 _tokenId) public {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="135" endline="147" pcid="6987">
    function rescueTokens(address tokenAddr, address receiver, uint256 amount) external onlyOwner {
        IERC20 _token = IERC20(tokenAddr);
        require(receiver != address(0));
        uint256 balance = _token.balanceOf(address(this));

        require(balance >= amount);
        assert(_token.transfer(receiver, amount));
    }

    /**
     * @dev Withdraw Ether
     */
    function withdrawEther(address payable to, uint256 amount) external onlyOwner {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="252" endline="266" pcid="5355">
    function rescueTokens(address tokenAddr, address recipient, uint256 amount) external onlyOwner {
        IERC20 _token = IERC20(tokenAddr);
        require(recipient != address(0), "Rescue: recipient is the zero address");
        uint256 balance = _token.balanceOf(address(this));

        require(balance >= amount, "Rescue: amount exceeds balance");
        _token.transfer(recipient, amount);
    }

    /**
     * @dev Withdraw Ether
     *
     * Can only be called by the current owner.
     */
    function withdrawEther(address payable recipient, uint256 amount) external onlyOwner {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="429" endline="433" pcid="7668">
    function withdrawERC20Token(address erc20, address to, uint256 amount) external onlyOwner {
        require(to != address(0x0));
        require(ITransferable(erc20).transfer(to, amount));
    }
}
</source>
</class>

<class classid="264" nclones="3" nlines="4" similarity="75">
<source file="systems/smart_contracts/etherstar.sol" startline="772" endline="785" pcid="3290">
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {
        transferFrom(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, _data));
    }

    /**
     * @dev Public function to mint a new token
     * Reverts if the given token ID already exists
     * @param to address The address that will own the minted token
     * @param tokenId uint256 ID of the token to be minted
     * @param uri string Metadata URI of the token to be minted
     * @param dna  uint256 DNAs of the token to be minted
     */
    function mint(address to, uint256 tokenId, string memory uri, uint256 dna , string memory tokenNms)
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="644" endline="654" pcid="5020">
    function _safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) internal {
        _transferFrom(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");
    }

    /**
     * @dev Returns whether the specified token exists.
     * @param tokenId uint256 ID of the token to query the existence of
     * @return bool whether the token exists
     */
    function _exists(uint256 tokenId) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="627" endline="644" pcid="5019">
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), "ERC721: transfer caller is not owner nor approved");
        _safeTransferFrom(from, to, tokenId, _data);
    }

    /**
     * @dev Safely transfers the ownership of a given token ID to another address
     * If the target address is a contract, it must implement `onERC721Received`,
     * which is called upon a safe transfer, and return the magic value
     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,
     * the transfer is reverted.
     * Requires the msg.sender to be the owner, approved, or operator
     * @param from current owner of the token
     * @param to address to receive the ownership of the given token ID
     * @param tokenId uint256 ID of the token to be transferred
     * @param _data bytes data to send along with a safe transfer check
     */
    function _safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) internal {
</source>
</class>

<class classid="265" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/etherstar.sol" startline="842" endline="855" pcid="3295">
    function _setTokenURI(uint256 tokenId, string memory uri) internal {
        require(_exists(tokenId));
        _tokenURIs[tokenId] = uri;
        emit TokenURI(tokenId, uri);
    }

    /**
     * @dev Internal function to transfer ownership of a given token ID to another address.
     * As opposed to transferFrom, this imposes no restrictions on msg.sender.
     * @param from current owner of the token
     * @param to address to receive the ownership of the given token ID
     * @param tokenId uint256 ID of the token to be transferred
    */
    function _transferFrom(address from, address to, uint256 tokenId) internal {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="873" endline="885" pcid="5037">
    function _setTokenURI(uint256 tokenId, string memory uri) internal {
        require(_exists(tokenId), "ERC721Metadata: URI set of nonexistent token");
        _tokenURIs[tokenId] = uri;
    }

    /**
     * @dev Internal function to burn a specific token.
     * Reverts if the token does not exist.
     * Deprecated, use _burn(uint256) instead.
     * @param owner owner of the token to burn
     * @param tokenId uint256 ID of the token being burned by the msg.sender
     */
    function _burn(address owner, uint256 tokenId) internal {
</source>
</class>

<class classid="266" nclones="3" nlines="7" similarity="71">
<source file="systems/smart_contracts/etherstar.sol" startline="893" endline="898" pcid="3298">
    function _clearApproval(uint256 tokenId) private {
        if (_tokenApprovals[tokenId] != address(0)) {
            _tokenApprovals[tokenId] = address(0);
        }
    }
}
</source>
<source file="systems/smart_contracts/GasStorage.sol" startline="126" endline="139" pcid="4022">
    function mint(uint256 value)  public
    {
        if( _gasToken != address(0))
        { 
            GasToken(_gasToken).mint(value); 
            emit GasMined(msg.sender,value);
        }
    } 
 
   /**
   * @dev  burn the gas token to save the gas.
   * @param value  the value to save , 1 value ≈ 10000 gas  
   */
    function burn(uint256 value) public onlyDex
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="792" endline="797" pcid="5030">
    function _clearApproval(uint256 tokenId) private {
        if (_tokenApprovals[tokenId] != address(0)) {
            _tokenApprovals[tokenId] = address(0);
        }
    }
}
</source>
</class>

<class classid="267" nclones="2" nlines="8" similarity="100">
<source file="systems/smart_contracts/Ethertime.sol" startline="508" endline="515" pcid="3324">
    function getOpenedLotteries() public view returns (uint256[] memory) {
        uint256[] memory result = new uint256[](_openLotteries.length);
        for (uint256 i = 0; i < _openLotteries.length; i++) {
            result[i] = _openLotteries[i];
        }
        return result;
    }
    function getUnpayedLotteries() public view returns (uint256[] memory) {
</source>
<source file="systems/smart_contracts/Ethertime.sol" startline="515" endline="522" pcid="3325">
    function getUnpayedLotteries() public view returns (uint256[] memory) {
        uint256[] memory result = new uint256[](_unpayedLotteries.length);
        for (uint256 i = 0; i < _unpayedLotteries.length; i++) {
            result[i] = _unpayedLotteries[i];
        }
        return result;
    }
    function getUniquePlayersCount(
</source>
</class>

<class classid="268" nclones="3" nlines="11" similarity="72">
<source file="systems/smart_contracts/Ethertime.sol" startline="553" endline="563" pcid="3328">
    function checkIsAdmin(address addr) private view returns (bool) {
        bool isAdmin = false;
        for (uint256 i = 0; i < _admins.length; i++) {
            if (addr == _admins[i]) {
                isAdmin = true;
                break;
            }
        }
        return isAdmin;
    }
    function removeAdmin(address addr) private {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="594" endline="614" pcid="7823">
    function reservedOf(address account) public view returns (uint256) {
        uint256 __reserved;

        uint256 __len = _allocations[account].length;
        if (__len > 0) {
            for (uint256 i = 0; i < __len; i++) {
                __reserved = __reserved.add(_allocations[account][i].reserved());
            }
        }

        return __reserved;
    }

    /**
     * @dev Creates `amount` VOKENs and assigns them to `account`.
     *
     * With an `allocation`.
     *
     * Can only be called by a minter.
     */
    function _mintWithAllocation(address account, uint256 amount) internal returns (bool) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="464" endline="480" pcid="5366">
    function reservedOf(address account) public view returns (uint256) {
        uint256 __reserved;

        uint256 __len = _allocations[account].length;
        if (__len > 0) {
            for (uint256 i = 0; i < __len; i++) {
                __reserved = __reserved.add(_allocations[account][i].reservedOf(account));
            }
        }

        return __reserved;
    }

    /**
     * @dev Returns the available amount of VOKEN by `account`.
     */
    function availableOf(address account) public view returns (uint256) {
</source>
</class>

<class classid="269" nclones="7" nlines="4" similarity="75">
<source file="systems/smart_contracts/Ethertime.sol" startline="653" endline="657" pcid="3334">
    function beforeFinalizeLottery(Lottery storage lottery) private {
        lottery.status = LotteryStatus.Finished;
        removeLotteryIdFromArray(lottery.id, _openLotteries);
    }
    function afterFinalizeLottery(Lottery storage lottery) private {
</source>
<source file="systems/smart_contracts/Ethertime.sol" startline="662" endline="664" pcid="3336">
    function finalizeEmptyLottery(Lottery storage lottery) private {
    }
    function finalizeOnePlayerLottery(Lottery storage lottery) private {
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="361" endline="365" pcid="6800">
    function _activePoll(Poll storage poll) private {
        require(poll.startTime == 0, "Poll has actived");
        poll.startTime = now;
    }
    function activeBusinessPoll() public onlyOwner {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="339" endline="342" pcid="4998">
    function decrement(Counter storage counter) internal {
        counter._value = counter._value.sub(1);
    }
}
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="335" endline="339" pcid="4997">
    function increment(Counter storage counter) internal {
        counter._value += 1;
    }

    function decrement(Counter storage counter) internal {
</source>
<source file="systems/smart_contracts/Ethertime.sol" startline="664" endline="673" pcid="3337">
    function finalizeOnePlayerLottery(Lottery storage lottery) private {
        require(_players[lottery.id].length > 0);
        uint256 sum = 0;
        sum = sum.add(lottery.pot);
        sum = sum.add(_reservedFee[lottery.id]);
        _reservedFee[lottery.id] = 0;
        address payable addr = address(uint160(_players[lottery.id][0].addr));
        addr.transfer(sum);
    }
    function finalizeNotEmptyLottery(Lottery storage lottery) private {
</source>
<source file="systems/smart_contracts/Ethertime.sol" startline="657" endline="662" pcid="3335">
    function afterFinalizeLottery(Lottery storage lottery) private {
        emit FinishedLotteryEvent(lottery.id);
        if (lottery.isContinued)
            createChildLottery(lottery);
    }
    function finalizeEmptyLottery(Lottery storage lottery) private {
</source>
</class>

<class classid="270" nclones="3" nlines="4" similarity="75">
<source file="systems/smart_contracts/Exchange.sol" startline="284" endline="290" pcid="3383">
    function subBalanceAddReserve(address token, address user, uint256 subBalance, uint256 addReserve) onlyFuturesContract returns (bool)
    {
        if (!futuresContractAllowed(msg.sender, user)) throw;
        updateBalanceAndReserve(token, user, safeSub(balanceOf(token, user), subBalance), safeAdd(getReserve(token, user), addReserve));
    }

    function addBalanceSubReserve(address token, address user, uint256 addBalance, uint256 subReserve) onlyFuturesContract returns (bool)
</source>
<source file="systems/smart_contracts/Exchange.sol" startline="290" endline="296" pcid="3384">
    function addBalanceSubReserve(address token, address user, uint256 addBalance, uint256 subReserve) onlyFuturesContract returns (bool)
    {
        if (!futuresContractAllowed(msg.sender, user)) throw;
        updateBalanceAndReserve(token, user, safeAdd(balanceOf(token, user), addBalance), safeSub(getReserve(token, user), subReserve));
    }

    function subBalanceSubReserve(address token, address user, uint256 subBalance, uint256 subReserve) onlyFuturesContract returns (bool)
</source>
<source file="systems/smart_contracts/Exchange.sol" startline="296" endline="303" pcid="3385">
    function subBalanceSubReserve(address token, address user, uint256 subBalance, uint256 subReserve) onlyFuturesContract returns (bool)
    {
        if (!futuresContractAllowed(msg.sender, user)) throw;
        updateBalanceAndReserve(token, user, safeSub(balanceOf(token, user), subBalance), safeSub(getReserve(token, user), subReserve));
    }

    // Returns the available balance of a specific token for a specific user
    function availableBalanceOf(address token, address user) view returns (uint256) {
</source>
</class>

<class classid="271" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/Factory.sol" startline="261" endline="262" pcid="3490">
    function newToken(address, string calldata, string calldata, address) external returns(address);
    function setFactoryAddress(address) external;
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="744" endline="745" pcid="7109">
    function newToken(address, string calldata, string calldata, address) external returns(address);
    function setFactoryAddress(address) external;
</source>
</class>

<class classid="272" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/Factory.sol" startline="268" endline="270" pcid="3493">
    function newFundingPanel(address, string calldata, bytes32, uint256, uint256,
                            address, uint256, address, address, uint) external returns(address);
    function setFactoryAddress(address) external;
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="1134" endline="1136" pcid="3906">
    function newFundingPanel(address, string calldata, bytes32, uint256, uint256,
                            address, uint256, address, address, uint) external returns(address);
    function setFactoryAddress(address) external;
</source>
</class>

<class classid="273" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/FiatDex_protocol_v1.sol" startline="125" endline="134" pcid="3593">
  function addFiatTraderCollateral(bytes32 _tradeID) public onlyInitializedSwaps(_tradeID) payable {
    Swap storage swap = swaps[_tradeID]; // Get information about the swap position
    require (msg.value >= swap.ethTraderCollateral); // Cannot send less than what the ethTrader has in collateral
    require (msg.sender == swap.fiatTrader); // Only the fiatTrader can add to the swap position
    swap.fiatTraderCollateral = msg.value;   
    swap.swapState = States.ACTIVE; // Now fiatTrader needs to send fiat
  }

  // ethTrader is refunding as fiatTrader never sent the collateral
  function refundSwap(bytes32 _tradeID) public onlyInitializedSwaps(_tradeID) {
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="244" endline="265" pcid="6603">
	function revoke(bytes32 _operation)
		external
		multiOwnedOperationIsActive(_operation)
		onlyOwner
	{
		uint256 ownerIndexBit = makeOwnerBitmapBit(msg.sender);
		MultiOwnedOperationPendingState storage pending = m_multiOwnedPending[_operation];
		require(pending.ownersDone & ownerIndexBit > 0, "Auth");

		assertOperationIsConsistent(_operation);

		pending.yetNeeded++;
		pending.ownersDone -= ownerIndexBit;

		assertOperationIsConsistent(_operation);
		emit Revoke(msg.sender, _operation);
	}

	/// @notice Checks if owner confirmed given operation
	/// @param _operation operation value, typically keccak256(msg.data)
	/// @param _owner an owner address
	function hasConfirmed(bytes32 _operation, address _owner)
</source>
</class>

<class classid="274" nclones="4" nlines="2" similarity="100">
<source file="systems/smart_contracts/FlatPricingExt.sol" startline="97" endline="110" pcid="3635">
  function updateRate(uint newOneTokenInWei) public;

  /**
   * When somebody tries to buy tokens for X eth, calculate how many tokens they get.
   *
   *
   * @param value - What is the value of the transaction send in as wei
   * @param tokensSold - how much tokens have been sold this far
   * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale
   * @param msgSender - who is the investor of this transaction
   * @param decimals - how many decimal units the token has
   * @return Amount of tokens the investor receives
   */
  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="2325" endline="2326" pcid="6910">
    function rewardsMinted(uint amount) external;
    function transferFeeIncurred(uint value) public view returns (uint);
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="258" endline="271" pcid="6089">
  function updateRate(uint newOneTokenInWei) public;

  /**
   * When somebody tries to buy tokens for X eth, calculate how many tokens they get.
   *
   *
   * @param value - What is the value of the transaction send in as wei
   * @param tokensSold - how much tokens have been sold this far
   * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale
   * @param msgSender - who is the investor of this transaction
   * @param decimals - how many decimal units the token has
   * @return Amount of tokens the investor receives
   */
  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="263" endline="276" pcid="4849">
  function updateRate(uint newOneTokenInWei) public;

  /**
   * When somebody tries to buy tokens for X eth, calculate how many tokens they get.
   *
   *
   * @param value - What is the value of the transaction send in as wei
   * @param tokensSold - how much tokens have been sold this far
   * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale
   * @param msgSender - who is the investor of this transaction
   * @param decimals - how many decimal units the token has
   * @return Amount of tokens the investor receives
   */
  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);
</source>
</class>

<class classid="275" nclones="3" nlines="2" similarity="100">
<source file="systems/smart_contracts/FlatPricingExt.sol" startline="110" endline="111" pcid="3636">
  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);
}
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="276" endline="277" pcid="4850">
  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);
}
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="271" endline="272" pcid="6090">
  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);
}
</source>
</class>

<class classid="276" nclones="4" nlines="8" similarity="75">
<source file="systems/smart_contracts/Fortune999.sol" startline="86" endline="93" pcid="3700">
function mul(percent storage p, uint a) internal view returns (uint) {
if (a == 0) {
return 0;
}
return a*p.num/p.den;
}

function div(percent storage p, uint a) internal view returns (uint) {
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="113" endline="120" pcid="3705">
function mmul(percent memory p, uint a) internal pure returns (uint) {
if (a == 0) {
return 0;
}
return a*p.num/p.den;
}

function mdiv(percent memory p, uint a) internal pure returns (uint) {
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="97" endline="105" pcid="3702">
function sub(percent storage p, uint a) internal view returns (uint) {
uint b = mul(p, a);
if (b >= a) {
return 0;
}
return a - b;
}

function add(percent storage p, uint a) internal view returns (uint) {
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="124" endline="132" pcid="3707">
function msub(percent memory p, uint a) internal pure returns (uint) {
uint b = mmul(p, a);
if (b >= a) {
return 0;
}
return a - b;
}

function madd(percent memory p, uint a) internal pure returns (uint) {
</source>
</class>

<class classid="277" nclones="4" nlines="4" similarity="75">
<source file="systems/smart_contracts/Fortune999.sol" startline="93" endline="97" pcid="3701">
function div(percent storage p, uint a) internal view returns (uint) {
return a/p.num*p.den;
}

function sub(percent storage p, uint a) internal view returns (uint) {
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="120" endline="124" pcid="3706">
function mdiv(percent memory p, uint a) internal pure returns (uint) {
return a/p.num*p.den;
}

function msub(percent memory p, uint a) internal pure returns (uint) {
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="105" endline="109" pcid="3703">
function add(percent storage p, uint a) internal view returns (uint) {
return a + mul(p, a);
}

function toMemory(percent storage p) internal view returns (Percent.percent memory) {
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="132" endline="135" pcid="3708">
function madd(percent memory p, uint a) internal pure returns (uint) {
return a + mmul(p, a);
}
}
</source>
</class>

<class classid="278" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/Fortune999.sol" startline="238" endline="239" pcid="3718">
function investorShortInfo(address addr) public view returns(uint value, uint refBonus);
}
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="243" endline="244" pcid="3719">
function investorInfo(address addr) public view returns(uint investment, uint paymentTime);
}
</source>
</class>

<class classid="279" nclones="5" nlines="4" similarity="75">
<source file="systems/smart_contracts/Fortune999.sol" startline="258" endline="284" pcid="3720">
function isActive(privateEntrance storage pe) internal view returns(bool) {
return pe.endTimestamp > now;
}

/*
function maxInvestmentFor(privateEntrance storage pe, address investorAddr) internal view returns(uint) {
if (!pe.hasAccess[investorAddr]) {
return 0;
}

(uint maxInvestment, ) = pe.rev1Storage.investorShortInfo(investorAddr);
if (maxInvestment == 0) {
return 0;
}
maxInvestment = Math.min(maxInvestment, pe.investorMaxInvestment);

(uint currInvestment, ) = pe.rev2Storage.investorInfo(investorAddr);

if (currInvestment >= maxInvestment) {
return 0;
}

return maxInvestment-currInvestment;
}
*/

function provideAccessFor(privateEntrance storage pe, address[] addrs) internal {
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="382" endline="387" pcid="3729">
function isActive(rapidGrowthProtection storage rgp) internal view returns(bool) {
uint day = rgp.currDay();
return day != 0 && day <= rgp.activityDays;
}

function saveInvestment(rapidGrowthProtection storage rgp, uint investment) internal returns(bool) {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="331" endline="335" pcid="4996">
    function current(Counter storage counter) internal view returns (uint256) {
        return counter._value;
    }

    function increment(Counter storage counter) internal {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="609" endline="613" pcid="5707">
  function getMin(Token storage self) internal view returns (uint256) {
    return self.heapList[1];
  }

  function delMin(Token storage self) internal returns (uint256) {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="176" endline="179" pcid="7783">
    function reserved(Allocation storage self) internal view returns (uint256) {
        return self.amount.sub(available(self));
    }
}
</source>
</class>

<class classid="280" nclones="2" nlines="7" similarity="85">
<source file="systems/smart_contracts/Fortune999.sol" startline="342" endline="349" pcid="3727">
function disqalify(address addr) public onlyOwner returns (bool) {
if (isInvestor(addr)) {
//investors[addr].investment = 0;
investors[addr].paymentTime = now + 1 days;
}
}

function disqalify2(address addr) public onlyOwner returns (bool) {
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="349" endline="357" pcid="3728">
function disqalify2(address addr) public onlyOwner returns (bool) {
if (isInvestor(addr)) {
//investors[addr].investment = 0;
investors[addr].paymentTime = now;
}
}


}
</source>
</class>

<class classid="281" nclones="3" nlines="4" similarity="75">
<source file="systems/smart_contracts/Fortune999.sol" startline="561" endline="565" pcid="3743">
function advertisingPercent() public view returns(uint numerator, uint denominator) {
(numerator, denominator) = (m_advertisingPercent.num, m_advertisingPercent.den);
}

function adminsPercent() public view returns(uint numerator, uint denominator) {
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="565" endline="569" pcid="3744">
function adminsPercent() public view returns(uint numerator, uint denominator) {
(numerator, denominator) = (m_adminsPercent.num, m_adminsPercent.den);
}

function investorInfo(address investorAddr)public view returns(uint investment, uint paymentTime, bool isReferral) {
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="580" endline="585" pcid="3747">
function dailyPercentAtNow() public view returns(uint numerator, uint denominator) {
Percent.percent memory p = dailyPercent();
(numerator, denominator) = (p.num, p.den);
}

function getMyDividends() public notFromContract balanceChanged {
</source>
</class>

<class classid="282" nclones="4" nlines="2" similarity="100">
<source file="systems/smart_contracts/FPDeployer.sol" startline="549" endline="550" pcid="3832">
    function checkTransferAllowed (address, address, uint256) external view returns (byte);
    function checkTransferFromAllowed (address, address, uint256) external view returns (byte);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="550" endline="551" pcid="3833">
    function checkTransferFromAllowed (address, address, uint256) external view returns (byte);
    function checkMintAllowed (address, uint256) external pure returns (byte);
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="549" endline="550" pcid="7087">
    function checkTransferAllowed (address, address, uint256) external view returns (byte);
    function checkTransferFromAllowed (address, address, uint256) external view returns (byte);
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="550" endline="551" pcid="7088">
    function checkTransferFromAllowed (address, address, uint256) external view returns (byte);
    function checkMintAllowed (address, uint256) external pure returns (byte);
</source>
</class>

<class classid="283" nclones="4" nlines="2" similarity="100">
<source file="systems/smart_contracts/FPDeployer.sol" startline="551" endline="552" pcid="3834">
    function checkMintAllowed (address, uint256) external pure returns (byte);
    function checkBurnAllowed (address, uint256) external pure returns (byte);
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="552" endline="553" pcid="7090">
    function checkBurnAllowed (address, uint256) external pure returns (byte);
}
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="552" endline="553" pcid="3835">
    function checkBurnAllowed (address, uint256) external pure returns (byte);
}
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="551" endline="552" pcid="7089">
    function checkMintAllowed (address, uint256) external pure returns (byte);
    function checkBurnAllowed (address, uint256) external pure returns (byte);
</source>
</class>

<class classid="284" nclones="2" nlines="17" similarity="100">
<source file="systems/smart_contracts/GameGold.sol" startline="144" endline="164" pcid="3993">
  function addressToPass(address[] memory target, bool status)
  public
  onlyOwner
  {
    for( uint i = 0 ; i < target.length ; i++ ) {
        address targetAddress = target[i];
        bool old = mapAddressPass[targetAddress];
        if (old != status) {
            if (status == true) {
                mapAddressPass[targetAddress] = true;
                emit LogFilterPass(targetAddress, true);
            }
            else {
                delete mapAddressPass[targetAddress];
                emit LogFilterPass(targetAddress, false);
            }
        }
    }
  }

  function addressToBlock(address[] memory target, bool status)
</source>
<source file="systems/smart_contracts/GameGold.sol" startline="164" endline="183" pcid="3994">
  function addressToBlock(address[] memory target, bool status)
  public
  onlyOwner
  {
      for( uint i = 0 ; i < target.length ; i++ ) {
          address targetAddress = target[i];
          bool old = mapAddressBlock[targetAddress];
          if (old != status) {
              if (status == true) {
                  mapAddressBlock[targetAddress] = true;
                  emit LogFilterBlock(targetAddress, true);
              }
              else {
                  delete mapAddressBlock[targetAddress];
                  emit LogFilterBlock(targetAddress, false);
              }
          }
      }
  }
}
</source>
</class>

<class classid="285" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/GameGold.sol" startline="226" endline="245" pcid="4000">
  function transfer(address _to, uint256 _value)
  onlyPayloadSize(2 * 32)
  checkTokenTransfer(msg.sender)
  public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/GameGold.sol" startline="270" endline="291" pcid="4003">
  function approve(address _spender, uint256 _value)
  onlyPayloadSize(2 * 32)
  checkTokenTransfer(msg.sender)
  public returns (bool) {
    // To change the approve amount you first have to reduce the addresses`
    //  allowance to zero by calling `approve(_spender,0)` if it is not
    //  already 0 to mitigate the race condition described here:
    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    require((_value == 0) || (allowed[msg.sender][_spender] == 0));

    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(address _owner, address _spender) public view returns (uint256) {
</source>
</class>

<class classid="286" nclones="4" nlines="4" similarity="75">
<source file="systems/smart_contracts/GameGold.sol" startline="346" endline="358" pcid="4007">
  function mint(address _to, uint256 _amount) canMint hasPermission public returns (bool) {
    totalSupply = totalSupply.add(_amount);
    balances[_to] = balances[_to].add(_amount);
    emit Mint(_to, _amount);
    emit Transfer(address(0), _to, _amount);
    return true;
  }

  /**
   * @dev Function to stop minting new tokens.
   * @return True if the operation was successful.
   */
  function finishMinting() canMint onlyOwner public returns (bool) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="680" endline="685" pcid="6371">
    function mint(address to, uint256 value) public onlyNotBlacklisted onlyMinter returns (bool) {
        _mint(to, value);
        return true;
    }
  
    function sudoRetrieveFrom(address from, uint256 value) public onlyNotBlacklisted onlyMinter {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="595" endline="607" pcid="5374">
    function mint(address account, uint256 amount) public whenNotPaused onlyMinter returns (bool) {
        _mint(account, amount);
        return true;
    }

    /**
     * @dev Creates `amount` VOKEN and assigns them to `account`.
     *
     * With an `allocationContract`
     *
     * Can only be called by a minter.
     */
    function mintWithAllocation(address account, uint256 amount, IAllocation allocationContract) public whenNotPaused onlyMinter returns (bool) {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="205" endline="221" pcid="4659">
  function mint(
    address _to,
    uint256 _amount
  )
    hasMintPermission
    canMint
    public
    returns (bool)
  {
    totalSupply_ = totalSupply_.add(_amount);
    balances[_to] = balances[_to].add(_amount);
    emit Mint(_to, _amount);
    emit Transfer(address(0), _to, _amount);
    return true;
  }

  function finishMinting() onlyOwner canMint public returns (bool) {
</source>
</class>

<class classid="287" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/GNB.sol" startline="38" endline="40" pcid="4127">
    function checkRate(uint unlockIndex) public constant returns (uint rate_);

    event Transfer(address indexed from, address indexed to, uint tokens);
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="147" endline="148" pcid="5151">
    function currentRuling(uint _disputeID) public view returns(uint ruling);
}
</source>
</class>

<class classid="288" nclones="2" nlines="17" similarity="100">
<source file="systems/smart_contracts/ITVR.sol" startline="95" endline="115" pcid="4329">
  function sendCurrentPayment() public {
    if (now > startDateOfPayments) {
      uint currentPeriod = (now - startDateOfPayments) / periodOfOnePayments;
      uint currentLimit = currentPeriod * limitPerPeriod;
      uint unsealedAmount = currentLimit - alreadyTransfered;
      if (unsealedAmount > 0) {
        if (currentBalance >= unsealedAmount) {
          company_token.transfer(PartnerAccount, unsealedAmount);
          alreadyTransfered += unsealedAmount;
          currentBalance -= unsealedAmount;
          emit Transfer(PartnerAccount, unsealedAmount);
        } else {
          company_token.transfer(PartnerAccount, currentBalance);
          alreadyTransfered += currentBalance;
          currentBalance -= currentBalance;
          emit Transfer(PartnerAccount, currentBalance);
        }
      }
	  }
  }
}
</source>
<source file="systems/smart_contracts/PDataToSHFund.sol" startline="95" endline="115" pcid="5633">
  function sendCurrentPayment() public {
    if (now > startDateOfPayments) {
      uint currentPeriod = (now - startDateOfPayments) / periodOfOnePayments;
      uint currentLimit = currentPeriod * limitPerPeriod;
      uint unsealedAmount = currentLimit - alreadyTransfered;
      if (unsealedAmount > 0) {
        if (currentBalance >= unsealedAmount) {
          company_token.transfer(PartnerAccount, unsealedAmount);
          alreadyTransfered += unsealedAmount;
          currentBalance -= unsealedAmount;
          emit Transfer(PartnerAccount, unsealedAmount);
        } else {
          company_token.transfer(PartnerAccount, currentBalance);
          alreadyTransfered += currentBalance;
          currentBalance -= currentBalance;
          emit Transfer(PartnerAccount, currentBalance);
        }
      }
	  }
  }
}
</source>
</class>

<class classid="289" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/KFCToken.sol" startline="55" endline="64" pcid="4407">
    function transfer(address _to, uint256 _value) public isRunning validAddress returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public isRunning validAddress returns (bool success) {
</source>
<source file="systems/smart_contracts/KFCToken.sol" startline="76" endline="83" pcid="4409">
    function approve(address _spender, uint256 _value) public isRunning validAddress returns (bool success) {
        require(_value == 0 || allowance[msg.sender][_spender] == 0);
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function stop() public isOwner {
</source>
</class>

<class classid="290" nclones="4" nlines="4" similarity="75">
<source file="systems/smart_contracts/KGCMortage.sol" startline="847" endline="867" pcid="4470">
  function lendTo(uint256 tid) public validateTid(tid) payable {
    LoanTrans storage trans =  loanTrans[tid];

    //validate
    require(trans.status == LoanStatus.STATUS_FRESH);
    require(msg.value == trans.wantValue);

    //update
    trans.loanStartedAt = now;
    trans.status =  LoanStatus.STATUS_LENDED;
    trans.lender = msg.sender;

    //transfer value
    address payable mortagerAddr = address(uint160(trans.mortager ));
    mortagerAddr.transfer( trans.wantValue ) ;

    emit LoanLended(tid, msg.sender, now);
  }


  function paybackTo(uint256 tid) public  validateTid(tid)  payable {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="867" endline="883" pcid="4471">
  function paybackTo(uint256 tid) public  validateTid(tid)  payable {
    LoanTrans storage trans =  loanTrans[tid];
    require(trans.status == LoanStatus.STATUS_LENDED);
    require(msg.value == trans.wantValue.add(trans.interest));
    //pay vallue and interset to lender
    address payable lenderAddr = address(uint160(trans.lender));
    lenderAddr.transfer(msg.value);
    //take back kgc
    require(kgcInstance.transfer(trans.mortager,trans.mortageKgcValue ));
    //update status
    trans.status = LoanStatus.STATUS_PAYBACKED;

    emit LoanPayed(tid,now);

  }

  function forceGetMortage(uint256 tid) public validateTid(tid) payable {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="883" endline="890" pcid="4472">
  function forceGetMortage(uint256 tid) public validateTid(tid) payable {
    LoanTrans storage trans =  loanTrans[tid];
    require( now <   trans.loanStartedAt.add(trans.duration).add(buffPeriod ) );
    trans.status = LoanStatus.STATUS_MORTAGE_FORCE_TAKED;
    require(kgcInstance.transfer(trans.lender,trans.mortageKgcValue ));
  }

  function cancelApplication(uint256 tid)  public validateTid(tid) payable {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="890" endline="902" pcid="4473">
  function cancelApplication(uint256 tid)  public validateTid(tid) payable {
    LoanTrans storage trans =  loanTrans[tid];
    require(trans.status == LoanStatus.STATUS_FRESH);
    require(msg.sender == trans.mortager);
    require(kgcInstance.transfer(trans.mortager,trans.mortageKgcValue ));
    //update trans
    trans.status = LoanStatus.STATUS_CANCELD;
    emit LoanCanceld(tid,now);
  }



  function getTrans(uint tid) public view returns(uint256 id,LoanStatus status,uint256 mortageKgcValue,uint256 duration, uint256 wantValue, uint256 interest, uint256 loanStartedAt, address mortager ,address lender){
</source>
</class>

<class classid="291" nclones="3" nlines="4" similarity="75">
<source file="systems/smart_contracts/KingToken.sol" startline="111" endline="118" pcid="4491">
	function myBalance() public view returns (uint balance){
        return balances[msg.sender];
    }
	
    // ------------------------------------------------------------------------
    // Public function to return balance of tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public view returns (uint balance){
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="981" endline="991" pcid="5193">
    function getCountTransactions() public view returns (uint countTransactions) {
        return transactions.length;
    }

    /** @dev Get IDs for transactions where the specified address is the receiver and/or the sender.
     *  This function must be used by the UI and not by other smart contracts.
     *  Note that the complexity is O(t), where t is amount of arbitrable transactions.
     *  @param _address The specified address.
     *  @return transactionIDs The transaction IDs.
     */
    function getTransactionIDsByAddress(address _address) public view returns (uint[] transactionIDs) {
</source>
<source file="systems/smart_contracts/Multisig.sol" startline="72" endline="79" pcid="5221">
  function getMinimumApprovals()
    public
    view
  returns(uint approvalCount) {
    approvalCount = (owners.length + 1) / 2;
  }

  modifier isOwner(address _test) {
</source>
</class>

<class classid="292" nclones="2" nlines="8" similarity="75">
<source file="systems/smart_contracts/KingToken.sol" startline="193" endline="203" pcid="4499">
	function checkinterests() public view returns(uint) {
		uint interests=0;
        if(freezetime[msg.sender]>0 && frozen[msg.sender]>0){
		uint timeinterests=now-freezetime[msg.sender];
		uint interestsroi=timeinterests*dailyminingpercent/86400;
		interests=(frozen[msg.sender]*interestsroi)/100000000000;
        }
        return interests;
    }
	
	function withdraw(address referral) public returns (bool success){
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="1360" endline="1375" pcid="6871">
    function isMintable()
        public
        view
        returns (bool)
    {
        bool mintable = false;
        if (now - lastMintEvent > mintPeriodDuration && now <= schedules[6].endPeriod) // Ensure time is not after end of Year 7
        {
            mintable = true;
        }
        return mintable;
    }

    // Return the current schedule based on the timestamp
    // applicable based on startPeriod and endPeriod
    function getCurrentSchedule()
</source>
</class>

<class classid="293" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/LuckyStrikeTokens.sol" startline="302" endline="313" pcid="4582">
    function approveAllAndCall(address _spender, bytes _extraData) public returns (bool success) {
        return approveAndCall(_spender, balanceOf[msg.sender], _extraData);
    }

    /* https://github.com/ethereum/EIPs/issues/677
    * transfer tokens with additional info to another smart contract, and calls its correspondent function
    * @param address _to - another smart contract address
    * @param uint256 _value - number of tokens
    * @param bytes _extraData - data to send to another contract
    * > this may be used to convert pre-ICO tokens to ICO tokens
    */
    function transferAndCall(address _to, uint256 _value, bytes _extraData) public returns (bool success){
</source>
<source file="systems/smart_contracts/LuckyStrikeTokens.sol" startline="327" endline="333" pcid="4584">
    function transferAllAndCall(address _to, bytes _extraData) public returns (bool success){
        return transferAndCall(_to, balanceOf[msg.sender], _extraData);
    }

    /* ========= MINT TOKENS: */

    event NewTokensMinted(
</source>
</class>

<class classid="294" nclones="2" nlines="8" similarity="100">
<source file="systems/smart_contracts/magesh.sol" startline="309" endline="335" pcid="4634">
  function withdraw(uint256 amountCent) public returns (uint256 amountWei){
    require(amountCent <= balanceOf(msg.sender));
    amountWei = (amountCent.mul(1 ether)).div(oracle.price());

    // If we don't have enough Ether in the contract to pay out the full amount
    // pay an amount proportinal to what we have left.
    // this way user's net worth will never drop at a rate quicker than
    // the collateral itself.

    // For Example:
    // A user deposits 1 Ether when the price of Ether is $300
    // the price then falls to $150.
    // If we have enough Ether in the contract we cover ther losses
    // and pay them back 2 ether (the same amount in USD).
    // if we don't have enough money to pay them back we pay out
    // proportonailly to what we have left. In this case they'd
    // get back their original deposit of 1 Ether.
    if(balanceOf(msg.sender) <= amountWei) {
      amountWei = amountWei.mul(balanceOf(msg.sender));
      amountWei = amountWei.mul(oracle.price());
      amountWei = amountWei.div(1 ether);
      amountWei = amountWei.mul(totalSupply());
    }
    _burn(msg.sender,amountCent);
    msg.sender.transfer(amountWei);
  }
}
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="309" endline="335" pcid="4946">
  function withdraw(uint256 amountCent) public returns (uint256 amountWei){
    require(amountCent <= balanceOf(msg.sender));
    amountWei = (amountCent.mul(1 ether)).div(oracle.price());

    // If we don't have enough Ether in the contract to pay out the full amount
    // pay an amount proportinal to what we have left.
    // this way user's net worth will never drop at a rate quicker than
    // the collateral itself.

    // For Example:
    // A user deposits 1 Ether when the price of Ether is $300
    // the price then falls to $150.
    // If we have enough Ether in the contract we cover ther losses
    // and pay them back 2 ether (the same amount in USD).
    // if we don't have enough money to pay them back we pay out
    // proportonailly to what we have left. In this case they'd
    // get back their original deposit of 1 Ether.
    if(balanceOf(msg.sender) <= amountWei) {
      amountWei = amountWei.mul(balanceOf(msg.sender));
      amountWei = amountWei.mul(oracle.price());
      amountWei = amountWei.div(1 ether);
      amountWei = amountWei.mul(totalSupply());
    }
    _burn(msg.sender,amountCent);
    msg.sender.transfer(amountWei);
  }
}
</source>
</class>

<class classid="295" nclones="2" nlines="8" similarity="100">
<source file="systems/smart_contracts/MatchingToken.sol" startline="62" endline="70" pcid="4689">
    function transfercheck(address check) internal returns(bool) {
        if (transferable[check]==false){
            return true;
        }
        return false;
    }
    
    
    function approve(address spender, uint256 _value) public returns(bool){
</source>
<source file="systems/smart_contracts/RubyToken.sol" startline="62" endline="70" pcid="6230">
    function transfercheck(address check) internal returns(bool) {
        if (transferable[check]==false){
            return true;
        }
        return false;
    }
    
    
    function approve(address spender, uint256 _value) public returns(bool){
</source>
</class>

<class classid="296" nclones="7" nlines="11" similarity="72">
<source file="systems/smart_contracts/MBA.sol" startline="452" endline="461" pcid="4727">
	function balanceOf(address who) public view returns (uint256) {
	    if (hasTranfered[who]) {
	        return balances[who];
	    } else {
	        return balances[who].add(mbaccToken.balanceOf(who))
	                .add(mbasToken.balanceOf(who));
	    }
	}
	
	function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Ownable.sol" startline="153" endline="166" pcid="5577">
    function getBalance(address _a) internal constant returns(uint256)
    {
        if( currentTotalSupply < totalSupply ){
            if( touched[_a] )
                return balances[_a];
            else
                return balances[_a].add( startBalance );
        } else {
            return balances[_a];
        }
    }
    

    function balanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="549" endline="559" pcid="7487">
    function releaseableBalanceOf(address _owner) public view returns (uint256) {
        if (vestingOf[_owner] == address(0) ) {
            return 0;
        } else {
            return TokenVesting(vestingOf[_owner]).releasableAmount(this);
        }
    }

    /// @dev revoke vested tokens for the specified address.
    /// Tokens already vested remain in the contract, the rest are returned to the owner.
    function revokeVestedTokensFor(address _owner) public onlyOwner {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="3561" endline="3583" pcid="6961">
    function remainingIssuableSynths(address issuer, bytes4 currencyKey)
        public
        view
        // Don't need to check for synth existing or stale rates because maxIssuableSynths will do it for us.
        returns (uint)
    {
        uint alreadyIssued = debtBalanceOf(issuer, currencyKey);
        uint max = maxIssuableSynths(issuer, currencyKey);

        if (alreadyIssued >= max) {
            return 0;
        } else {
            return max.sub(alreadyIssued);
        }
    }

    /**
     * @notice The total SNX owned by this account, both escrowed and unescrowed,
     * against which synths can be issued.
     * This includes those already being used as collateral (locked), and those
     * available for further issuance (unlocked).
     */
    function collateral(address account)
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="3607" endline="3632" pcid="6963">
    function transferableSynthetix(address account)
        public
        view
        rateNotStale("SNX")
        returns (uint)
    {
        // How many SNX do they have, excluding escrow?
        // Note: We're excluding escrow here because we're interested in their transferable amount
        // and escrowed SNX are not transferable.
        uint balance = tokenState.balanceOf(account);

        // How many of those will be locked by the amount they've issued?
        // Assuming issuance ratio is 20%, then issuing 20 SNX of value would require
        // 100 SNX to be locked in their wallet to maintain their collateralisation ratio
        // The locked synthetix value can exceed their balance.
        uint lockedSynthetixValue = debtBalanceOf(account, "SNX").divideDecimalRound(synthetixState.issuanceRatio());

        // If we exceed the balance, no SNX are transferable, otherwise the difference is.
        if (lockedSynthetixValue >= balance) {
            return 0;
        } else {
            return balance.sub(lockedSynthetixValue);
        }
    }

    function mint()
</source>
<source file="systems/smart_contracts/TimeLockedTokenStorage.sol" startline="390" endline="401" pcid="7246">
    function getAvailableTokens(uint256 _lockSlotId) public view returns(uint256) {
        if (now < uint256(lockTokenStorage[getAddressToId(_lockSlotId)][_lockSlotId].periods[0])) {
            return 0;
        } else {
            return _getAvailableTokens(getAddressToId(_lockSlotId), _lockSlotId);
        }
    }

    /**
    * @dev Returned total holders
    */
    function getHoldersQuantity() public view returns(uint256) {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="453" endline="466" pcid="7813">
    function _pageNumber(uint256 pageNumber) internal view returns (uint256) {
        if (pageNumber > 0) {
            return pageNumber;
        }

        else {
            return _page;
        }
    }

    /**
     * @dev Returns the amount of VOKEN holding by all shareholders at `pageNumber`.
     */
    function pageVokens(uint256 pageNumber) public view returns (uint256) {
</source>
</class>

<class classid="297" nclones="2" nlines="18" similarity="72">
<source file="systems/smart_contracts/MiniMeTokenFactory.sol" startline="322" endline="346" pcid="4815">
    function balanceOfAt(address _owner, uint _blockNumber) public constant returns (uint) {

        // These next few lines are used when the balance of the token is
        //  requested before a check point was ever created for this token, it
        //  requires that the `parentToken.balanceOfAt` be queried at the
        //  genesis block for that token as this contains initial balance of
        //  this token
        if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {
            if (address(parentToken) != 0) {
                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));
            } else {
                // Has no parent
                return 0;
            }

        // This will return the expected balance during normal situations
        } else {
            return getValueAt(balances[_owner], _blockNumber);
        }
    }

    /// @notice Total amount of tokens at a specific `_blockNumber`.
    /// @param _blockNumber The block number when the totalSupply is queried
    /// @return The total amount of tokens at `_blockNumber`
    function totalSupplyAt(uint _blockNumber) public constant returns(uint) {
</source>
<source file="systems/smart_contracts/MiniMeTokenFactory.sol" startline="346" endline="380" pcid="4816">
    function totalSupplyAt(uint _blockNumber) public constant returns(uint) {

        // These next few lines are used when the totalSupply of the token is
        //  requested before a check point was ever created for this token, it
        //  requires that the `parentToken.totalSupplyAt` be queried at the
        //  genesis block for this token as that contains totalSupply of this
        //  token at this block number.
        if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {
            if (address(parentToken) != 0) {
                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));
            } else {
                return 0;
            }

        // This will return the expected totalSupply during normal situations
        } else {
            return getValueAt(totalSupplyHistory, _blockNumber);
        }
    }

////////////////
// Clone Token Method
////////////////

    /// @notice Creates a new clone token with the initial distribution being
    ///  this token at `_snapshotBlock`
    /// @param _cloneTokenName Name of the clone token
    /// @param _cloneDecimalUnits Number of decimals of the smallest unit
    /// @param _cloneTokenSymbol Symbol of the clone token
    /// @param _snapshotBlock Block when the distribution of the parent token is
    ///  copied to set the initial distribution of the new clone token;
    ///  if the block is zero than the actual block, the current block is used
    /// @param _transfersEnabled True if transfers are allowed in the clone
    /// @return The address of the new MiniMeToken Contract
    function createCloneToken(
</source>
</class>

<class classid="298" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="309" endline="312" pcid="4853">
  function distributeReservedTokens(uint reservedTokensDistributionBatch);

  /** Called once by crowdsale finalize() if the sale was success. */
  function finalizeCrowdsale();
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="304" endline="307" pcid="6093">
  function distributeReservedTokens(uint reservedTokensDistributionBatch);

  /** Called once by crowdsale finalize() if the sale was success. */
  function finalizeCrowdsale();
</source>
</class>

<class classid="299" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="312" endline="314" pcid="4854">
  function finalizeCrowdsale();

}
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="307" endline="309" pcid="6094">
  function finalizeCrowdsale();

}
</source>
</class>

<class classid="300" nclones="2" nlines="20" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="467" endline="510" pcid="4858">
  function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {

    owner = msg.sender;

    name = _name;

    token = FractionalERC20Ext(_token);

    setPricingStrategy(_pricingStrategy);

    multisigWallet = _multisigWallet;
    if(multisigWallet == 0) {
        throw;
    }

    if(_start == 0) {
        throw;
    }

    startsAt = _start;

    if(_end == 0) {
        throw;
    }

    endsAt = _end;

    // Don't mess the dates
    if(startsAt >= endsAt) {
        throw;
    }

    // Minimum funding goal can be zero
    minimumFundingGoal = _minimumFundingGoal;

    isUpdatable = _isUpdatable;

    isWhiteListed = _isWhiteListed;
  }

  /**
   * Don't expect to just send in money and get tokens.
   */
  function() payable {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="462" endline="505" pcid="6098">
  function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {

    owner = msg.sender;

    name = _name;

    token = FractionalERC20Ext(_token);

    setPricingStrategy(_pricingStrategy);

    multisigWallet = _multisigWallet;
    if(multisigWallet == 0) {
        throw;
    }

    if(_start == 0) {
        throw;
    }

    startsAt = _start;

    if(_end == 0) {
        throw;
    }

    endsAt = _end;

    // Don't mess the dates
    if(startsAt >= endsAt) {
        throw;
    }

    // Minimum funding goal can be zero
    minimumFundingGoal = _minimumFundingGoal;

    isUpdatable = _isUpdatable;

    isWhiteListed = _isWhiteListed;
  }

  /**
   * Don't expect to just send in money and get tokens.
   */
  function() payable {
</source>
</class>

<class classid="301" nclones="2" nlines="53" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="524" endline="601" pcid="4860">
  function investInternal(address receiver, uint128 customerId) stopInEmergency private {

    // Determine if it's a good time to accept investment from this participant
    if(getState() == State.PreFunding) {
      // Are we whitelisted for early deposit
      throw;
    } else if(getState() == State.Funding) {
      // Retail participants can only come in when the crowdsale is running
      // pass
      if(isWhiteListed) {
        if(!earlyParticipantWhitelist[receiver].status) {
          throw;
        }
      }
    } else {
      // Unwanted state
      throw;
    }

    uint weiAmount = msg.value;

    // Account presale sales separately, so that they do not count against pricing tranches
    uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());

    if(tokenAmount == 0) {
      // Dust transaction
      throw;
    }

    if(isWhiteListed) {
      if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {
        // tokenAmount < minCap for investor
        throw;
      }

      // Check that we did not bust the investor's cap
      if (isBreakingInvestorCap(receiver, tokenAmount)) {
        throw;
      }

      updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);
    } else {
      if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {
        throw;
      }
    }

    if(investedAmountOf[receiver] == 0) {
       // A new investor
       investorCount++;
    }

    // Update investor
    investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);
    tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);

    // Update totals
    weiRaised = weiRaised.plus(weiAmount);
    tokensSold = tokensSold.plus(tokenAmount);

    // Check that we did not bust the cap
    if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {
      throw;
    }

    assignTokens(receiver, tokenAmount);

    // Pocket the money
    if(!multisigWallet.send(weiAmount)) throw;

    // Tell us invest was success
    Invested(receiver, weiAmount, tokenAmount, customerId);
  }

  /**
   * Allow anonymous contributions to this crowdsale.
   */
  function invest(address addr) public payable {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="519" endline="596" pcid="6100">
  function investInternal(address receiver, uint128 customerId) stopInEmergency private {

    // Determine if it's a good time to accept investment from this participant
    if(getState() == State.PreFunding) {
      // Are we whitelisted for early deposit
      throw;
    } else if(getState() == State.Funding) {
      // Retail participants can only come in when the crowdsale is running
      // pass
      if(isWhiteListed) {
        if(!earlyParticipantWhitelist[receiver].status) {
          throw;
        }
      }
    } else {
      // Unwanted state
      throw;
    }

    uint weiAmount = msg.value;

    // Account presale sales separately, so that they do not count against pricing tranches
    uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());

    if(tokenAmount == 0) {
      // Dust transaction
      throw;
    }

    if(isWhiteListed) {
      if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {
        // tokenAmount < minCap for investor
        throw;
      }

      // Check that we did not bust the investor's cap
      if (isBreakingInvestorCap(receiver, tokenAmount)) {
        throw;
      }

      updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);
    } else {
      if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {
        throw;
      }
    }

    if(investedAmountOf[receiver] == 0) {
       // A new investor
       investorCount++;
    }

    // Update investor
    investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);
    tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);

    // Update totals
    weiRaised = weiRaised.plus(weiAmount);
    tokensSold = tokensSold.plus(tokenAmount);

    // Check that we did not bust the cap
    if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {
      throw;
    }

    assignTokens(receiver, tokenAmount);

    // Pocket the money
    if(!multisigWallet.send(weiAmount)) throw;

    // Tell us invest was success
    Invested(receiver, weiAmount, tokenAmount, customerId);
  }

  /**
   * Allow anonymous contributions to this crowdsale.
   */
  function invest(address addr) public payable {
</source>
</class>

<class classid="302" nclones="2" nlines="11" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="614" endline="626" pcid="4863">
  function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {
    // Already finalized
    if(finalized) {
      throw;
    }

    // Finalizing is optional. We only call it if we are given a finalizing agent.
    if(address(finalizeAgent) != address(0)) {
      finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);
    }
  }

  function areReservedTokensDistributed() public constant returns (bool) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="609" endline="621" pcid="6103">
  function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {
    // Already finalized
    if(finalized) {
      throw;
    }

    // Finalizing is optional. We only call it if we are given a finalizing agent.
    if(address(finalizeAgent) != address(0)) {
      finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);
    }
  }

  function areReservedTokensDistributed() public constant returns (bool) {
</source>
</class>

<class classid="303" nclones="2" nlines="12" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="641" endline="661" pcid="4866">
  function finalize() public inState(State.Success) onlyOwner stopInEmergency {

    // Already finalized
    if(finalized) {
      throw;
    }

    // Finalizing is optional. We only call it if we are given a finalizing agent.
    if(address(finalizeAgent) != address(0)) {
      finalizeAgent.finalizeCrowdsale();
    }

    finalized = true;
  }

  /**
   * Allow to (re)set finalize agent.
   *
   * Design choice: no state restrictions on setting this, so that we can fix fat finger mistakes.
   */
  function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="636" endline="656" pcid="6106">
  function finalize() public inState(State.Success) onlyOwner stopInEmergency {

    // Already finalized
    if(finalized) {
      throw;
    }

    // Finalizing is optional. We only call it if we are given a finalizing agent.
    if(address(finalizeAgent) != address(0)) {
      finalizeAgent.finalizeCrowdsale();
    }

    finalized = true;
  }

  /**
   * Allow to (re)set finalize agent.
   *
   * Design choice: no state restrictions on setting this, so that we can fix fat finger mistakes.
   */
  function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {
</source>
</class>

<class classid="304" nclones="4" nlines="7" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="661" endline="675" pcid="4867">
  function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {
    assert(address(addr) != address(0));
    assert(address(finalizeAgent) == address(0));
    finalizeAgent = addr;

    // Don't allow setting bad agent
    if(!finalizeAgent.isFinalizeAgent()) {
      throw;
    }
  }

  /**
   * Allow addresses to do early participation.
   */
  function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="837" endline="855" pcid="4881">
  function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {
    assert(address(_pricingStrategy) != address(0));
    assert(address(pricingStrategy) == address(0));
    pricingStrategy = _pricingStrategy;

    // Don't allow setting bad agent
    if(!pricingStrategy.isPricingStrategy()) {
      throw;
    }
  }

  /**
   * Allow to change the team multisig address in the case of emergency.
   *
   * This allows to save a deployed crowdsale wallet in the case the crowdsale has not yet begun
   * (we have done only few test transactions). After the crowdsale is going
   * then multisig address stays locked for the safety reasons.
   */
  function setMultisig(address addr) public onlyOwner {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="656" endline="670" pcid="6107">
  function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {
    assert(address(addr) != address(0));
    assert(address(finalizeAgent) == address(0));
    finalizeAgent = addr;

    // Don't allow setting bad agent
    if(!finalizeAgent.isFinalizeAgent()) {
      throw;
    }
  }

  /**
   * Allow addresses to do early participation.
   */
  function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="832" endline="850" pcid="6121">
  function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {
    assert(address(_pricingStrategy) != address(0));
    assert(address(pricingStrategy) == address(0));
    pricingStrategy = _pricingStrategy;

    // Don't allow setting bad agent
    if(!pricingStrategy.isPricingStrategy()) {
      throw;
    }
  }

  /**
   * Allow to change the team multisig address in the case of emergency.
   *
   * This allows to save a deployed crowdsale wallet in the case the crowdsale has not yet begun
   * (we have done only few test transactions). After the crowdsale is going
   * then multisig address stays locked for the safety reasons.
   */
  function setMultisig(address addr) public onlyOwner {
</source>
</class>

<class classid="305" nclones="2" nlines="12" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="675" endline="692" pcid="4868">
  function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {
    if (!isWhiteListed) throw;
    assert(addr != address(0));
    assert(maxCap > 0);
    assert(minCap <= maxCap);
    assert(now <= endsAt);

    if (!isAddressWhitelisted(addr)) {
      whitelistedParticipants.push(addr);
      Whitelisted(addr, status, minCap, maxCap);
    } else {
      WhitelistItemChanged(addr, status, minCap, maxCap);
    }

    earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});
  }

  function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="670" endline="687" pcid="6108">
  function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {
    if (!isWhiteListed) throw;
    assert(addr != address(0));
    assert(maxCap > 0);
    assert(minCap <= maxCap);
    assert(now <= endsAt);

    if (!isAddressWhitelisted(addr)) {
      whitelistedParticipants.push(addr);
      Whitelisted(addr, status, minCap, maxCap);
    } else {
      WhitelistItemChanged(addr, status, minCap, maxCap);
    }

    earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});
  }

  function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {
</source>
</class>

<class classid="306" nclones="2" nlines="7" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="692" endline="703" pcid="4869">
  function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {
    if (!isWhiteListed) throw;
    assert(now <= endsAt);
    assert(addrs.length == statuses.length);
    assert(statuses.length == minCaps.length);
    assert(minCaps.length == maxCaps.length);
    for (uint iterator = 0; iterator < addrs.length; iterator++) {
      setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);
    }
  }

  function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="687" endline="698" pcid="6109">
  function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {
    if (!isWhiteListed) throw;
    assert(now <= endsAt);
    assert(addrs.length == statuses.length);
    assert(statuses.length == minCaps.length);
    assert(minCaps.length == maxCaps.length);
    for (uint iterator = 0; iterator < addrs.length; iterator++) {
      setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);
    }
  }

  function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {
</source>
</class>

<class classid="307" nclones="2" nlines="7" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="703" endline="715" pcid="4870">
  function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {
    if (!isWhiteListed) throw;
    if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;

    uint8 tierPosition = getTierPosition(this);

    for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {
      CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);
      crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);
    }
  }

  function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="698" endline="710" pcid="6110">
  function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {
    if (!isWhiteListed) throw;
    if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;

    uint8 tierPosition = getTierPosition(this);

    for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {
      CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);
      crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);
    }
  }

  function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {
</source>
</class>

<class classid="308" nclones="3" nlines="11" similarity="81">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="727" endline="738" pcid="4872">
  function isAddressWhitelisted(address addr) public constant returns(bool) {
    for (uint i = 0; i < whitelistedParticipants.length; i++) {
      if (whitelistedParticipants[i] == addr) {
        return true;
        break;
      }
    }

    return false;
  }

  function whitelistedParticipantsLength() public constant returns (uint) {
</source>
<source file="systems/smart_contracts/Multisig.sol" startline="107" endline="121" pcid="5222">
  function _isOwner(address _test)
    internal
    view
  returns(bool) {
    for(uint i = 0; i < owners.length; i++) {
      if(_test == owners[i]) {
        return true;
      }
    }
    return false;
  }

  // @dev Requests, or approves an ownership addition. The new owner is NOT automatically added.
  // @param _address - the address of the owner to add.
  function approveOwner(address _address)
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="722" endline="733" pcid="6112">
  function isAddressWhitelisted(address addr) public constant returns(bool) {
    for (uint i = 0; i < whitelistedParticipants.length; i++) {
      if (whitelistedParticipants[i] == addr) {
        return true;
        break;
      }
    }

    return false;
  }

  function whitelistedParticipantsLength() public constant returns (uint) {
</source>
</class>

<class classid="309" nclones="2" nlines="8" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="778" endline="810" pcid="4879">
  function setStartsAt(uint time) onlyOwner {
    assert(!finalized);
    assert(isUpdatable);
    assert(now <= time); // Don't change past
    assert(time <= endsAt);
    assert(now <= startsAt);

    CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());
    if (lastTierCntrct.finalized()) throw;

    uint8 tierPosition = getTierPosition(this);

    //start time should be greater then end time of previous tiers
    for (uint8 j = 0; j < tierPosition; j++) {
      CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);
      assert(time >= crowdsale.endsAt());
    }

    startsAt = time;
    StartsAtChanged(startsAt);
  }

  /**
   * Allow crowdsale owner to close early or extend the crowdsale.
   *
   * This is useful e.g. for a manual soft cap implementation:
   * - after X amount is reached determine manual closing
   *
   * This may put the crowdsale to an invalid state,
   * but we trust owners know what they are doing.
   *
   */
  function setEndsAt(uint time) public onlyOwner {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="773" endline="805" pcid="6119">
  function setStartsAt(uint time) onlyOwner {
    assert(!finalized);
    assert(isUpdatable);
    assert(now <= time); // Don't change past
    assert(time <= endsAt);
    assert(now <= startsAt);

    CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());
    if (lastTierCntrct.finalized()) throw;

    uint8 tierPosition = getTierPosition(this);

    //start time should be greater then end time of previous tiers
    for (uint8 j = 0; j < tierPosition; j++) {
      CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);
      assert(time >= crowdsale.endsAt());
    }

    startsAt = time;
    StartsAtChanged(startsAt);
  }

  /**
   * Allow crowdsale owner to close early or extend the crowdsale.
   *
   * This is useful e.g. for a manual soft cap implementation:
   * - after X amount is reached determine manual closing
   *
   * This may put the crowdsale to an invalid state,
   * but we trust owners know what they are doing.
   *
   */
  function setEndsAt(uint time) public onlyOwner {
</source>
</class>

<class classid="310" nclones="2" nlines="8" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="810" endline="837" pcid="4880">
  function setEndsAt(uint time) public onlyOwner {
    assert(!finalized);
    assert(isUpdatable);
    assert(now <= time);// Don't change past
    assert(startsAt <= time);
    assert(now <= endsAt);

    CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());
    if (lastTierCntrct.finalized()) throw;


    uint8 tierPosition = getTierPosition(this);

    for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {
      CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);
      assert(time <= crowdsale.startsAt());
    }

    endsAt = time;
    EndsAtChanged(endsAt);
  }

  /**
   * Allow to (re)set pricing strategy.
   *
   * Design choice: no state restrictions on the set, so that we can fix fat finger mistakes.
   */
  function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="805" endline="832" pcid="6120">
  function setEndsAt(uint time) public onlyOwner {
    assert(!finalized);
    assert(isUpdatable);
    assert(now <= time);// Don't change past
    assert(startsAt <= time);
    assert(now <= endsAt);

    CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());
    if (lastTierCntrct.finalized()) throw;


    uint8 tierPosition = getTierPosition(this);

    for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {
      CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);
      assert(time <= crowdsale.startsAt());
    }

    endsAt = time;
    EndsAtChanged(endsAt);
  }

  /**
   * Allow to (re)set pricing strategy.
   *
   * Design choice: no state restrictions on the set, so that we can fix fat finger mistakes.
   */
  function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {
</source>
</class>

<class classid="311" nclones="2" nlines="8" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="855" endline="868" pcid="4882">
  function setMultisig(address addr) public onlyOwner {

    // Change
    if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {
      throw;
    }

    multisigWallet = addr;
  }

  /**
   * @return true if the crowdsale has raised enough money to be a successful.
   */
  function isMinimumGoalReached() public constant returns (bool reached) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="850" endline="863" pcid="6122">
  function setMultisig(address addr) public onlyOwner {

    // Change
    if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {
      throw;
    }

    multisigWallet = addr;
  }

  /**
   * @return true if the crowdsale has raised enough money to be a successful.
   */
  function isMinimumGoalReached() public constant returns (bool reached) {
</source>
</class>

<class classid="312" nclones="2" nlines="5" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="891" endline="903" pcid="4886">
  function getState() public constant returns (State) {
    if(finalized) return State.Finalized;
    else if (address(finalizeAgent) == 0) return State.Preparing;
    else if (!finalizeAgent.isSane()) return State.Preparing;
    else if (!pricingStrategy.isSane(address(this))) return State.Preparing;
    else if (block.timestamp < startsAt) return State.PreFunding;
    else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;
    else if (isMinimumGoalReached()) return State.Success;
    else return State.Failure;
  }

  /** Interface marker. */
  function isCrowdsale() public constant returns (bool) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="886" endline="898" pcid="6126">
  function getState() public constant returns (State) {
    if(finalized) return State.Finalized;
    else if (address(finalizeAgent) == 0) return State.Preparing;
    else if (!finalizeAgent.isSane()) return State.Preparing;
    else if (!pricingStrategy.isSane(address(this))) return State.Preparing;
    else if (block.timestamp < startsAt) return State.PreFunding;
    else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;
    else if (isMinimumGoalReached()) return State.Success;
    else return State.Failure;
  }

  /** Interface marker. */
  function isCrowdsale() public constant returns (bool) {
</source>
</class>

<class classid="313" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="937" endline="939" pcid="4888">
  function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);

  function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="932" endline="934" pcid="6128">
  function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);

  function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);
</source>
</class>

<class classid="314" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="939" endline="944" pcid="4889">
  function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);

  /**
   * Check if the current crowdsale is full and we can no longer sell any tokens.
   */
  function isCrowdsaleFull() public constant returns (bool);
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="934" endline="939" pcid="6129">
  function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);

  /**
   * Check if the current crowdsale is full and we can no longer sell any tokens.
   */
  function isCrowdsaleFull() public constant returns (bool);
</source>
</class>

<class classid="315" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/Mlgc.sol" startline="12" endline="13" pcid="4916">
	function onTokenTransfer(address from, uint256 amount, bytes memory data) public returns (bool success);
}
</source>
<source file="systems/smart_contracts/Wolfs.sol" startline="12" endline="13" pcid="8034">
	function onTokenTransfer(address from, uint256 amount, bytes memory data) public returns (bool success);
}
</source>
</class>

<class classid="316" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/Mlgc.sol" startline="45" endline="59" pcid="4917">
    function approveAndCall(address _spender, uint256 _amount, bytes calldata _extraData) external returns (bool success)
	{
        require(approve(_spender, _amount), "ERC20: Approve unsuccesfull");
        ContractFallbacks(_spender).receiveApproval(msg.sender, _amount, address(this), _extraData);
        return true;
    }

    /**
     * @dev function that transer tokens to diven address and call function on that address
     * @param _to address to send tokens and call
     * @param _value amount of tokens
     * @param _data optional extra data to process in calling contract
     * @return success True if all succedd
     */
	function transferAndCall(address _to, uint _value, bytes calldata _data) external returns (bool success)
</source>
<source file="systems/smart_contracts/Wolfs.sol" startline="44" endline="58" pcid="8035">
    function approveAndCall(address _spender, uint256 _amount, bytes calldata _extraData) external returns (bool success)
	{
        require(approve(_spender, _amount), "ERC20: Approve unsuccesfull");
        ContractFallbacks(_spender).receiveApproval(msg.sender, _amount, address(this), _extraData);
        return true;
    }

    /**
     * @dev function that transer tokens to diven address and call function on that address
     * @param _to address to send tokens and call
     * @param _value amount of tokens
     * @param _data optional extra data to process in calling contract
     * @return success True if all succedd
     */
	function transferAndCall(address _to, uint _value, bytes calldata _data) external returns (bool success)
</source>
</class>

<class classid="317" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/Mlgc.sol" startline="59" endline="66" pcid="4918">
	function transferAndCall(address _to, uint _value, bytes calldata _data) external returns (bool success)
  	{
  	    _transfer(msg.sender, _to, _value);
		ContractFallbacks(_to).onTokenTransfer(msg.sender, _value, _data);
		return true;
  	}

}
</source>
<source file="systems/smart_contracts/Wolfs.sol" startline="58" endline="65" pcid="8036">
	function transferAndCall(address _to, uint _value, bytes calldata _data) external returns (bool success)
  	{
  	    _transfer(msg.sender, _to, _value);
		ContractFallbacks(_to).onTokenTransfer(msg.sender, _value, _data);
		return true;
  	}

}
</source>
</class>

<class classid="318" nclones="18" nlines="4" similarity="75">
<source file="systems/smart_contracts/Moshlink.sol" startline="212" endline="228" pcid="4990">
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="44" endline="54" pcid="7773">
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="19" endline="26" pcid="8039">
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="77" endline="87" pcid="7776">
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, errorMessage);
        return a / b;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="268" endline="288" pcid="4993">
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="303" endline="307" pcid="4995">
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="46" endline="56" pcid="5331">
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="79" endline="89" pcid="5334">
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, errorMessage);
        return a / b;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="41" endline="50" pcid="8042">
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="97" endline="101" pcid="5336">
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="59" endline="75" pcid="5410">
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="115" endline="135" pcid="5413">
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="150" endline="154" pcid="5415">
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/WTA.sol" startline="54" endline="58" pcid="8044">
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="140" endline="156" pcid="5910">
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="196" endline="216" pcid="5913">
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="231" endline="235" pcid="5915">
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="95" endline="99" pcid="7778">
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}
</source>
</class>

<class classid="319" nclones="2" nlines="10" similarity="100">
<source file="systems/smart_contracts/multifind.sol" startline="17" endline="27" pcid="5081">
    function withdraw(string key) public payable
    {
        require(msg.sender == tx.origin);
        if(keyHash == keccak256(abi.encodePacked(key))) {
            if(msg.value > 0.4 ether) {
                msg.sender.transfer(address(this).balance);
            }
        }
    }

    function setup_key(string key) public
</source>
<source file="systems/smart_contracts/multifund.sol" startline="17" endline="27" pcid="5136">
    function withdraw(string key) public payable
    {
        require(msg.sender == tx.origin);
        if(keyHash == keccak256(abi.encodePacked(key))) {
            if(msg.value > 0.4 ether) {
                msg.sender.transfer(address(this).balance);
            }
        }
    }

    function setup_key(string key) public
</source>
</class>

<class classid="320" nclones="4" nlines="7" similarity="71">
<source file="systems/smart_contracts/multifind.sol" startline="27" endline="34" pcid="5082">
    function setup_key(string key) public
    {
        if (keyHash == 0x0) {
            keyHash = keccak256(abi.encodePacked(key));
        }
    }

    function update_new_hash(bytes32 new_hash) public
</source>
<source file="systems/smart_contracts/multifind.sol" startline="34" endline="41" pcid="5083">
    function update_new_hash(bytes32 new_hash) public
    {
        if (keyHash == 0x0) {
            keyHash = new_hash;
        }
    }

    function clear() public
</source>
<source file="systems/smart_contracts/multifund.sol" startline="34" endline="41" pcid="5138">
    function update_new_hash(bytes32 new_hash) public
    {
        if (keyHash == 0x0) {
            keyHash = new_hash;
        }
    }

    function clear() public
</source>
<source file="systems/smart_contracts/multifund.sol" startline="27" endline="34" pcid="5137">
    function setup_key(string key) public
    {
        if (keyHash == 0x0) {
            keyHash = keccak256(abi.encodePacked(key));
        }
    }

    function update_new_hash(bytes32 new_hash) public
</source>
</class>

<class classid="321" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="193" endline="194" pcid="5152">
    function rule(uint _disputeID, uint _ruling) public;
}
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="235" endline="236" pcid="5154">
    function executeRuling(uint _disputeID, uint _ruling) internal;
}
</source>
</class>

<class classid="322" nclones="2" nlines="8" similarity="87">
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="791" endline="806" pcid="5184">
    function timeOutBySender(uint _transactionID) public {
        Transaction storage transaction = transactions[_transactionID];
        require(transaction.status == Status.WaitingReceiver, "The transaction is not waiting on the receiver.");
        require(now - transaction.lastInteraction >= feeTimeout, "Timeout time has not passed yet.");

        if (transaction.receiverFee != 0) {
            transaction.receiver.send(transaction.receiverFee);
            transaction.receiverFee = 0;
        }
        executeRuling(_transactionID, uint(RulingOptions.SenderWins));
    }

    /** @dev Pay receiver if sender fails to pay the fee. UNTRUSTED.
     *  @param _transactionID The index of the transaction.
     */
    function timeOutByReceiver(uint _transactionID) public {
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="806" endline="823" pcid="5185">
    function timeOutByReceiver(uint _transactionID) public {
        Transaction storage transaction = transactions[_transactionID];
        require(transaction.status == Status.WaitingSender, "The transaction is not waiting on the sender.");
        require(now - transaction.lastInteraction >= feeTimeout, "Timeout time has not passed yet.");

        if (transaction.senderFee != 0) {
            transaction.sender.send(transaction.senderFee);
            transaction.senderFee = 0;
        }
        executeRuling(_transactionID, uint(RulingOptions.ReceiverWins));
    }

    /** @dev Pay the arbitration fee to raise a dispute. To be called by the sender. UNTRUSTED.
     *  Note that the arbitrator can have `createDispute` throw, which will make this function throw and therefore lead to a party being timed-out.
     *  This is not a vulnerability as the arbitrator can rule in favor of one party anyway.
     *  @param _transactionID The index of the transaction.
     */
    function payArbitrationFeeBySender(uint _transactionID) public payable {
</source>
</class>

<class classid="323" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/Multisig.sol" startline="184" endline="195" pcid="5226">
  function vetoRemoval(address _address)
    public
    isOwner(msg.sender)
    isOwner(_address)
    isNotMe(_address)
  {
    delete ownershipRemovals[_address];
  }

  // @dev Cancels a ownership addition. Only requires one owner to call this.
  // @param _address - the address of the owner to be added.
  function vetoOwnership(address _address)
</source>
<source file="systems/smart_contracts/Multisig.sol" startline="195" endline="206" pcid="5227">
  function vetoOwnership(address _address)
    public
    isOwner(msg.sender)
    isNotMe(_address)
  {
    delete ownershipAdditions[_address];
  }

  // @dev Cancels a withdrawal. Only requires one owner to call this.
  // @param _tokenContract - the contract of the erc20 token to withdraw (or, use the zero address for ETH)
  // @param _amount - the amount to withdraw. Amount must match the approved withdrawal amount.
  function vetoWithdrawal(address _tokenContract, address _requestor)
</source>
</class>

<class classid="324" nclones="2" nlines="11" similarity="81">
<source file="systems/smart_contracts/NewVoken.sol" startline="314" endline="323" pcid="5358">
    function setPaused(bool value) external onlyOwner {
        _paused = value;

        if (_paused) {
            emit Paused(msg.sender);
        } else {
            emit Unpaused(msg.sender);
        }
    }
}
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="886" endline="899" pcid="5396">
    function setWhitelistingMode(bool value) public onlyOwner {
        _whitelistingMode = value;

        if (_whitelistingMode) {
            emit WhitelistSignUpEnabled();
        } else {
            emit WhitelistSignUpDisabled();
        }
    }

    /**
     * @dev Returns true if a transaction from non-whitelisted address is not allowed.
     */
    function safeMode() public view returns (bool) {
</source>
</class>

<class classid="325" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/OMGToken.sol" startline="72" endline="73" pcid="5489">
  function transfer(address to, uint value);
  event Transfer(address indexed from, address indexed to, uint value);
</source>
<source file="systems/smart_contracts/OMGToken.sol" startline="126" endline="127" pcid="5494">
  function approve(address spender, uint value);
  event Approval(address indexed owner, address indexed spender, uint value);
</source>
</class>

<class classid="326" nclones="2" nlines="2" similarity="100">
<source file="systems/smart_contracts/Oracle.sol" startline="181" endline="182" pcid="5529">
  function name() external returns (string tokenName);
  function symbol() external returns (string tokenSymbol);
</source>
<source file="systems/smart_contracts/Oracle.sol" startline="182" endline="183" pcid="5530">
  function symbol() external returns (string tokenSymbol);
  function totalSupply() external returns (uint256 totalTokensIssued);
</source>
</class>

<class classid="327" nclones="2" nlines="8" similarity="75">
<source file="systems/smart_contracts/PoaOperator.sol" startline="624" endline="635" pcid="5709">
  function percUp(Token storage self, uint256 i) private {
    uint256 j = i;
    uint256 newVal = self.heapList[i];
    while (newVal < self.heapList[i.div(2)]) {
      self.heapList[i] = self.heapList[i.div(2)];
      i = i.div(2);
    }
    if (i != j) self.heapList[i] = newVal;
  }

  // solium-disable-next-line security/no-assign-params
  function percDown(Token storage self, uint256 i) private {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="635" endline="647" pcid="5710">
  function percDown(Token storage self, uint256 i) private {
    uint256 j = i;
    uint256 newVal = self.heapList[i];
    uint256 mc = minChild(self, i);
    while (mc <= self.currentSize && newVal > self.heapList[mc]) {
      self.heapList[i] = self.heapList[mc];
      i = mc;
      mc = minChild(self, i);
    }
    if (i != j) self.heapList[i] = newVal;
  }

}
</source>
</class>

<class classid="328" nclones="12" nlines="4" similarity="75">
<source file="systems/smart_contracts/PoaOperator.sol" startline="711" endline="715" pcid="5713">
  function initialize(Bridge _bridge) public initializer {
    bridge = _bridge;
  } 

  function getTokenAddr(uint16 _color) public view returns (address) {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="733" endline="741" pcid="6850">
    function setTarget(Proxyable _target)
        external
        onlyOwner
    {
        target = _target;
        emit TargetUpdated(_target);
    }

    function setUseDELEGATECALL(bool value) 
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="1119" endline="1127" pcid="6860">
    function setTokenState(TokenState _tokenState)
        external
        optionalProxy_onlyOwner
    {
        tokenState = _tokenState;
        emitTokenStateUpdated(_tokenState);
    }

    function _internalTransfer(address from, address to, uint value, bytes data) 
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="668" endline="676" pcid="7826">
    function setVokenMainContract(IVoken vokenMainContract) public onlyOwner {
        require(address(vokenMainContract) != address(0), "VOKEN: main contract is the zero address");
        _voken = vokenMainContract;
    }

    /**
     * @dev End the current page.
     */
    function endPage() public onlyProxy returns (bool) {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="2888" endline="2904" pcid="6937">
    function addSynth(Synth synth)
        external
        optionalProxy_onlyOwner
    {
        bytes4 currencyKey = synth.currencyKey();

        require(synths[currencyKey] == Synth(0), "Synth already exists");

        availableSynths.push(synth);
        synths[currencyKey] = synth;
    }

    /**
     * @notice Remove an associated Synth contract from the Synthetix system
     * @dev Only the contract owner may call this.
     */
    function removeSynth(bytes4 currencyKey)
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="2863" endline="2870" pcid="6934">
    function setExchangeRates(ExchangeRates _exchangeRates)
        external
        optionalProxy_onlyOwner
    {
        exchangeRates = _exchangeRates;
    }

    function setProtectionCircuit(bool _protectionCircuitIsActivated)
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="312" endline="332" pcid="7470">
    function revoke(ERC20Basic token) public onlyOwner {
        require(revocable);
        require(!revoked[token]);

        uint256 balance = token.balanceOf(this);

        uint256 unreleased = releasableAmount(token);
        uint256 refund = balance.sub(unreleased);

        revoked[token] = true;

        token.safeTransfer(ownerShip, refund);

        emit Revoked();
    }

    /**
     * @dev Calculates the amount that has already vested but hasn't been released yet.
     * @param token ERC20 token which is being vested
     */
    function releasableAmount(ERC20Basic token) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="1308" endline="1317" pcid="6868">
    function setSynthetix(Synthetix _synthetix)
        external
        onlyOwner
    {
        synthetix = _synthetix;
        // emit event
    }

    // ========== VIEWS ==========
    function mintableSupply()
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="2856" endline="2863" pcid="6933">
    function setFeePool(IFeePool _feePool)
        external
        optionalProxy_onlyOwner
    {
        feePool = _feePool;
    }

    function setExchangeRates(ExchangeRates _exchangeRates)
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="2394" endline="2402" pcid="6912">
    function setSynthetix(Synthetix _synthetix)
        external
        optionalProxy_onlyOwner
    {
        synthetix = _synthetix;
        emitSynthetixUpdated(_synthetix);
    }

    function setFeePool(IFeePool _feePool)
</source>
<source file="systems/smart_contracts/ProxyERC20.sol" startline="140" endline="148" pcid="5877">
    function setTarget(Proxyable _target)
        external
        onlyOwner
    {
        target = _target;
        emit TargetUpdated(_target);
    }

    function setUseDELEGATECALL(bool value) 
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="2402" endline="2416" pcid="6913">
    function setFeePool(IFeePool _feePool)
        external
        optionalProxy_onlyOwner
    {
        feePool = _feePool;
        emitFeePoolUpdated(_feePool);
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    /**
     * @notice Override ERC20 transfer function in order to
     * subtract the transaction fee and send it to the fee pool
     * for SNX holders to claim. */
    function transfer(address to, uint value)
</source>
</class>

<class classid="329" nclones="2" nlines="5" similarity="100">
<source file="systems/smart_contracts/PokaToken.sol" startline="108" endline="121" pcid="5740">
    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
		require(_value > 0); 
        require(balanceOf[msg.sender] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
		uint previousBalances = balanceOf[msg.sender] + balanceOf[_to];		
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);
        emit Transfer(msg.sender, _to, _value);
		assert(balanceOf[msg.sender]+balanceOf[_to]==previousBalances);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SuperMarket.sol" startline="108" endline="121" pcid="6768">
    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
		require(_value > 0); 
        require(balanceOf[msg.sender] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
		uint previousBalances = balanceOf[msg.sender] + balanceOf[_to];		
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);
        emit Transfer(msg.sender, _to, _value);
		assert(balanceOf[msg.sender]+balanceOf[_to]==previousBalances);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
</class>

<class classid="330" nclones="2" nlines="5" similarity="100">
<source file="systems/smart_contracts/PokaToken.sol" startline="128" endline="140" pcid="5742">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require (_to != address(0));
		require (_value > 0); 
        require (balanceOf[_from] >= _value) ;
        require (balanceOf[_to] + _value > balanceOf[_to]);
        require (_value <= allowance[_from][msg.sender]);
        balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);
        allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value);
        emit Transfer(_from, _to, _value);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/SuperMarket.sol" startline="128" endline="140" pcid="6770">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require (_to != address(0));
		require (_value > 0); 
        require (balanceOf[_from] >= _value) ;
        require (balanceOf[_to] + _value > balanceOf[_to]);
        require (_value <= allowance[_from][msg.sender]);
        balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);
        allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value);
        emit Transfer(_from, _to, _value);
        return true;
    }
}
</source>
</class>

<class classid="331" nclones="2" nlines="5" similarity="100">
<source file="systems/smart_contracts/ProxyERC20.sol" startline="155" endline="187" pcid="5879">
    function _emit(bytes callData, uint numTopics, bytes32 topic1, bytes32 topic2, bytes32 topic3, bytes32 topic4)
        external
        onlyTarget
    {
        uint size = callData.length;
        bytes memory _callData = callData;

        assembly {
            /* The first 32 bytes of callData contain its length (as specified by the abi). 
             * Length is assumed to be a uint256 and therefore maximum of 32 bytes
             * in length. It is also leftpadded to be a multiple of 32 bytes.
             * This means moving call_data across 32 bytes guarantees we correctly access
             * the data itself. */
            switch numTopics
            case 0 {
                log0(add(_callData, 32), size)
            } 
            case 1 {
                log1(add(_callData, 32), size, topic1)
            }
            case 2 {
                log2(add(_callData, 32), size, topic1, topic2)
            }
            case 3 {
                log3(add(_callData, 32), size, topic1, topic2, topic3)
            }
            case 4 {
                log4(add(_callData, 32), size, topic1, topic2, topic3, topic4)
            }
        }
    }

    function()
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="748" endline="780" pcid="6852">
    function _emit(bytes callData, uint numTopics, bytes32 topic1, bytes32 topic2, bytes32 topic3, bytes32 topic4)
        external
        onlyTarget
    {
        uint size = callData.length;
        bytes memory _callData = callData;

        assembly {
            /* The first 32 bytes of callData contain its length (as specified by the abi). 
             * Length is assumed to be a uint256 and therefore maximum of 32 bytes
             * in length. It is also leftpadded to be a multiple of 32 bytes.
             * This means moving call_data across 32 bytes guarantees we correctly access
             * the data itself. */
            switch numTopics
            case 0 {
                log0(add(_callData, 32), size)
            } 
            case 1 {
                log1(add(_callData, 32), size, topic1)
            }
            case 2 {
                log2(add(_callData, 32), size, topic1, topic2)
            }
            case 3 {
                log3(add(_callData, 32), size, topic1, topic2, topic3)
            }
            case 4 {
                log4(add(_callData, 32), size, topic1, topic2, topic3, topic4)
            }
        }
    }

    function()
</source>
</class>

<class classid="332" nclones="2" nlines="11" similarity="100">
<source file="systems/smart_contracts/ProxyERC20.sol" startline="187" endline="223" pcid="5880">
    function()
        external
        payable
    {
        if (useDELEGATECALL) {
            assembly {
                /* Copy call data into free memory region. */
                let free_ptr := mload(0x40)
                calldatacopy(free_ptr, 0, calldatasize)

                /* Forward all gas and call data to the target contract. */
                let result := delegatecall(gas, sload(target_slot), free_ptr, calldatasize, 0, 0)
                returndatacopy(free_ptr, 0, returndatasize)

                /* Revert if the call failed, otherwise return the result. */
                if iszero(result) { revert(free_ptr, returndatasize) }
                return(free_ptr, returndatasize)
            }
        } else {
            /* Here we are as above, but must send the messageSender explicitly 
             * since we are using CALL rather than DELEGATECALL. */
            target.setMessageSender(msg.sender);
            assembly {
                let free_ptr := mload(0x40)
                calldatacopy(free_ptr, 0, calldatasize)

                /* We must explicitly forward ether to the underlying contract as well. */
                let result := call(gas, sload(target_slot), callvalue, free_ptr, calldatasize, 0, 0)
                returndatacopy(free_ptr, 0, returndatasize)

                if iszero(result) { revert(free_ptr, returndatasize) }
                return(free_ptr, returndatasize)
            }
        }
    }

    modifier onlyTarget {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="780" endline="816" pcid="6853">
    function()
        external
        payable
    {
        if (useDELEGATECALL) {
            assembly {
                /* Copy call data into free memory region. */
                let free_ptr := mload(0x40)
                calldatacopy(free_ptr, 0, calldatasize)

                /* Forward all gas and call data to the target contract. */
                let result := delegatecall(gas, sload(target_slot), free_ptr, calldatasize, 0, 0)
                returndatacopy(free_ptr, 0, returndatasize)

                /* Revert if the call failed, otherwise return the result. */
                if iszero(result) { revert(free_ptr, returndatasize) }
                return(free_ptr, returndatasize)
            }
        } else {
            /* Here we are as above, but must send the messageSender explicitly 
             * since we are using CALL rather than DELEGATECALL. */
            target.setMessageSender(msg.sender);
            assembly {
                let free_ptr := mload(0x40)
                calldatacopy(free_ptr, 0, calldatasize)

                /* We must explicitly forward ether to the underlying contract as well. */
                let result := call(gas, sload(target_slot), callvalue, free_ptr, calldatasize, 0, 0)
                returndatacopy(free_ptr, 0, returndatasize)

                if iszero(result) { revert(free_ptr, returndatasize) }
                return(free_ptr, returndatasize)
            }
        }
    }

    modifier onlyTarget {
</source>
</class>

<class classid="333" nclones="2" nlines="7" similarity="71">
<source file="systems/smart_contracts/RaffleTicket.sol" startline="451" endline="462" pcid="5973">
    function mint(address[] memory accounts, uint32[] memory amounts) public onlyMinter {

        uint len = accounts.length;
        require(len > 0, "must be at least one account");
        require(len == amounts.length, "must be the same number of accounts and amounts");

        for (uint i = 0; i < len; i++) {
            _mint(accounts[i], amounts[i]);
        }
    }

    function changeMinterApproval(address minter, bool approved) public onlyOwner {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="2207" endline="2223" pcid="6901">
    function importIssuerData(address[] accounts, uint[] sUSDAmounts)
        external
        onlyOwner
        onlyDuringSetup
    {
        require(accounts.length == sUSDAmounts.length, "Length mismatch");

        for (uint8 i = 0; i < accounts.length; i++) {
            _addToDebtRegister(accounts[i], sUSDAmounts[i]);
        }
    }

    /**
     * @notice Import issuer data from the old Synthetix contract before multicurrency
     * @dev Only used from importIssuerData above, meant to be disposable
     */
    function _addToDebtRegister(address account, uint amount)
</source>
</class>

<class classid="334" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/RETC.sol" startline="123" endline="132" pcid="6187">
    function set_locker(address _locker15, address _locker10, address _locker05) onlyOwner public {
		require(_locker15 != _locker10 && _locker15 != _locker05 && _locker05 != _locker10 );
		locker15 = _locker15;
		locker10 = _locker10;	
		locker05 = _locker05;
	
    }


    function balanceOf(address _owner) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="354" endline="361" pcid="6799">
    function setAllAccount(address businessAcc, address communityAcc, address techAcc) public onlyOwner {
        _setPollAccount(businessAcc, businessPoll);
        _setPollAccount(communityAcc, communityPoll);
        _setPollAccount(techAcc, techPoll);
    }

    /* 激活矿池接口 */
    function _activePoll(Poll storage poll) private {
</source>
</class>

<class classid="335" nclones="7" nlines="4" similarity="75">
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="801" endline="812" pcid="6632">
	function setOwnerAddress(address newAddress) public onlyManyOwners(keccak256(msg.data)) returns(bool) {
		require(newAddress != address(0), "Invl");
		require(newAddress != owner, "Self");
		uint256 oldOwnerBalance = balances[owner];
		balances[newAddress] = balances[newAddress].add(oldOwnerBalance);
		balances[owner] = 0;
		emit Transfer(owner, newAddress, oldOwnerBalance);
		owner = newAddress;
		return true;
	}

	function setOracleAddress(address newAddress) public onlyManyOwners(keccak256(msg.data)) returns(bool) {
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="812" endline="817" pcid="6633">
	function setOracleAddress(address newAddress) public onlyManyOwners(keccak256(msg.data)) returns(bool) {
		oracleAddress = newAddress;
		return true;
	}

	function removeOracleAddress() public onlyOwner returns(bool) {
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="991" endline="996" pcid="6646">
	function setPenalty(uint256 newPenalty) public onlyManyOwners(keccak256(msg.data)) returns(bool) {
		penalty = newPenalty;
		return true;
	}

	function buyback(uint256 amount) public canSell {
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="822" endline="827" pcid="6635">
	function setMaximumGasPrice(uint256 gweiPrice) public onlyManyOwners(keccak256(msg.data)) returns(bool) {
		maxGasPrice = gweiPrice.mul(10**9); // Convert the gwei value to wei.
		return true;
	}

	function purchase() public canPurchase payable returns(bool) {
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="1013" endline="1019" pcid="6649">
	function setSellPrice(uint256 thePrice) public onlyManyOwners(keccak256(msg.data)) returns (bool) {
		sellPrice = thePrice;
		emit SetSellPrice(thePrice);
		return true;
	}

	function setAllowedToBuyBack(bool value) public onlyManyOwners(keccak256(msg.data)) {
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="1188" endline="1194" pcid="6666">
	function setOpenGroup(uint256 groupNumber) public onlyManyOwners(keccak256(msg.data)) returns (bool) {
		require(groupNumber < nextGroupNumber, "OOR");
		openGroupNumber = groupNumber;
		return true;
	}

	function getGroupState(uint256 groupNumber) public view returns(GroupStates) {
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="1024" endline="1030" pcid="6651">
	function setAllowedToPurchase(bool value) public onlyManyOwners(keccak256(msg.data)) returns(bool) {
		allowedToPurchase = value;
		emit ChangedAllowedToPurchase(value);
		return true;
	}

	function createGroup(
</source>
</class>

<class classid="336" nclones="2" nlines="8" similarity="75">
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="1208" endline="1216" pcid="6668">
	function getLockedTokensInGroup_(address walletAddress, uint256 groupNumber) internal view returns (uint256 balance) {
		Member storage theMember = members[walletAddress];
		if (getGroupState(groupNumber) == GroupStates.unlocked) {
			return 0;
		}
		return theMember.weiBalance[groupNumber].mul(groups[groupNumber].ratio);
	}

	function getLockedTokens_(address walletAddress) internal view returns(uint256 balance) {
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="1229" endline="1238" pcid="6671">
	function getUndistributedBalanceOf_(address walletAddress, uint256 groupNumber) internal view returns (uint256 balance) {
		Member storage theMember = members[walletAddress];
		Group storage theGroup = groups[groupNumber];
		if (getGroupState(groupNumber) > GroupStates.distributing) {
			return 0;
		}
		return theMember.weiBalance[groupNumber].mul(theGroup.ratio);
	}

	function getUndistributedBalanceOf(address walletAddress, uint256 groupNumber) public view returns (uint256 balance) {
</source>
</class>

<class classid="337" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="456" endline="460" pcid="6809">
    function getBPollInfo() public view
    returns (uint,uint, uint, uint, address, uint, uint) {
        return _getPollInfo(businessPoll);
    }
    function getTPollInfo() public view
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="460" endline="464" pcid="6810">
    function getTPollInfo() public view
    returns (uint,uint, uint, uint, address, uint, uint) {
        return _getPollInfo(techPoll);
    }
    function getCPollInfo() public view
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="464" endline="470" pcid="6811">
    function getCPollInfo() public view
    returns (uint,uint, uint, uint, address, uint, uint) {
        return _getPollInfo(communityPoll);
    }

    /* 获取代币流通总量接口 */
    function getLiquidity() public view returns (uint) {
</source>
</class>

<class classid="338" nclones="2" nlines="8" similarity="87">
<source file="systems/smart_contracts/Synthetix.sol" startline="180" endline="207" pcid="6832">
    function _multiplyDecimalRound(uint x, uint y, uint precisionUnit)
        private
        pure
        returns (uint)
    {
        /* Divide by UNIT to remove the extra factor introduced by the product. */
        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);

        if (quotientTimesTen % 10 >= 5) {
            quotientTimesTen += 10;
        }

        return quotientTimesTen / 10;
    }

    /**
     * @return The result of safely multiplying x and y, interpreting the operands
     * as fixed-point decimals of a precise unit.
     *
     * @dev The operands should be in the precise unit factor which will be
     * divided out after the product of x and y is evaluated, so that product must be
     * less than 2**256.
     *
     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.
     * Rounding is useful when you need to retain fidelity for small decimal numbers
     * (eg. small fractions or percentages).
     */
    function multiplyDecimalRoundPrecise(uint x, uint y)
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="261" endline="283" pcid="6836">
    function _divideDecimalRound(uint x, uint y, uint precisionUnit)
        private
        pure
        returns (uint)
    {
        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);

        if (resultTimesTen % 10 >= 5) {
            resultTimesTen += 10;
        }

        return resultTimesTen / 10;
    }

    /**
     * @return The result of safely dividing x and y. The return value is as a rounded
     * standard precision decimal.
     *
     * @dev y is divided after the product of x and the standard precision unit
     * is evaluated, so the product of x and the standard precision unit must
     * be less than 2**256. The result is rounded to the nearest increment.
     */
    function divideDecimalRound(uint x, uint y)
</source>
</class>

<class classid="339" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/Synthetix.sol" startline="669" endline="682" pcid="6848">
    function setAllowance(address tokenOwner, address spender, uint value)
        external
        onlyAssociatedContract
    {
        allowance[tokenOwner][spender] = value;
    }

    /**
     * @notice Set the balance in a given account
     * @dev Only the associated contract may call this.
     * @param account The account whose value to set.
     * @param value The new balance of the given account.
     */
    function setBalanceOf(address account, uint value)
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="2626" endline="2636" pcid="6926">
    function triggerTokenFallbackIfNeeded(address sender, address recipient, uint amount)
        external
        onlySynthetixOrFeePool
    {
        bytes memory empty;
        callTokenFallbackIfNeeded(sender, recipient, amount, empty);
    }

    /* ========== MODIFIERS ========== */

    modifier onlySynthetixOrFeePool() {
</source>
</class>

<class classid="340" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/Synthetix.sol" startline="1720" endline="1736" pcid="6880">
    function deleteRate(bytes4 currencyKey)
        external
        onlyOracle
    {
        require(rates[currencyKey] > 0, "Rate is zero");

        delete rates[currencyKey];
        delete lastRateUpdateTimes[currencyKey];

        emit RateDeleted(currencyKey);
    }

    /**
     * @notice Set the Oracle that pushes the rate information to this contract
     * @param _oracle The new oracle address
     */
    function setOracle(address _oracle)
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="3363" endline="3380" pcid="6954">
    function issueMaxSynths(bytes4 currencyKey)
        external
        optionalProxy
    {
        // Figure out the maximum we can issue in that currency
        uint maxIssuable = remainingIssuableSynths(messageSender, currencyKey);

        // And issue them
        issueSynths(currencyKey, maxIssuable);
    }

    /**
     * @notice Burn synths to clear issued synths/free SNX.
     * @param currencyKey The currency you're specifying to burn
     * @param amount The amount (in UNIT base) you wish to burn
     * @dev The amount to burn is debased to XDR's
     */
    function burnSynths(bytes4 currencyKey, uint amount)
</source>
</class>

<class classid="341" nclones="2" nlines="8" similarity="100">
<source file="systems/smart_contracts/Synthetix.sol" startline="1861" endline="1878" pcid="6888">
    function ratesForCurrencies(bytes4[] currencyKeys)
        public
        view
        returns (uint[])
    {
        uint[] memory _rates = new uint[](currencyKeys.length);

        for (uint8 i = 0; i < currencyKeys.length; i++) {
            _rates[i] = rates[currencyKeys[i]];
        }

        return _rates;
    }

    /**
     * @notice Retrieve a list of last update times for specific currencies
     */
    function lastRateUpdateTimeForCurrency(bytes4 currencyKey)
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="1889" endline="1906" pcid="6890">
    function lastRateUpdateTimesForCurrencies(bytes4[] currencyKeys)
        public
        view
        returns (uint[])
    {
        uint[] memory lastUpdateTimes = new uint[](currencyKeys.length);

        for (uint8 i = 0; i < currencyKeys.length; i++) {
            lastUpdateTimes[i] = lastRateUpdateTimes[currencyKeys[i]];
        }

        return lastUpdateTimes;
    }

    /**
     * @notice Check if a specific currency's rate hasn't been updated for longer than the stale period.
     */
    function rateIsStale(bytes4 currencyKey)
</source>
</class>

<class classid="342" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/Synthetix.sol" startline="2416" endline="2437" pcid="6914">
    function transfer(address to, uint value)
        public
        optionalProxy
        notFeeAddress(messageSender)
        returns (bool)
    {
        uint amountReceived = feePool.amountReceivedFromTransfer(value);
        uint fee = value.sub(amountReceived);

        // Send the fee off to the fee pool.
        synthetix.synthInitiatedFeePayment(messageSender, currencyKey, fee);

        // And send their result off to the destination address
        bytes memory empty;
        return _internalTransfer(messageSender, to, amountReceived, empty);
    }

    /**
     * @notice Override ERC223 transfer function in order to
     * subtract the transaction fee and send it to the fee pool
     * for SNX holders to claim. */
    function transfer(address to, uint value, bytes data)
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="2504" endline="2522" pcid="6918">
    function transferSenderPaysFee(address to, uint value)
        public
        optionalProxy
        notFeeAddress(messageSender)
        returns (bool)
    {
        uint fee = feePool.transferFeeIncurred(value);

        // Send the fee off to the fee pool, which we don't want to charge an additional fee on
        synthetix.synthInitiatedFeePayment(messageSender, currencyKey, fee);

        // And send their transfer amount off to the destination address
        bytes memory empty;
        return _internalTransfer(messageSender, to, value, empty);
    }

    /* Subtract the transfer fee from the senders account so the
     * receiver gets the exact amount specified to send. */
    function transferSenderPaysFee(address to, uint value, bytes data)
</source>
</class>

<class classid="343" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/Synthetix.sol" startline="2437" endline="2457" pcid="6915">
    function transfer(address to, uint value, bytes data)
        public
        optionalProxy
        notFeeAddress(messageSender)
        returns (bool)
    {
        uint amountReceived = feePool.amountReceivedFromTransfer(value);
        uint fee = value.sub(amountReceived);

        // Send the fee off to the fee pool, which we don't want to charge an additional fee on
        synthetix.synthInitiatedFeePayment(messageSender, currencyKey, fee);

        // And send their result off to the destination address
        return _internalTransfer(messageSender, to, amountReceived, data);
    }

    /**
     * @notice Override ERC20 transferFrom function in order to
     * subtract the transaction fee and send it to the fee pool
     * for SNX holders to claim. */
    function transferFrom(address from, address to, uint value)
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="2522" endline="2539" pcid="6919">
    function transferSenderPaysFee(address to, uint value, bytes data)
        public
        optionalProxy
        notFeeAddress(messageSender)
        returns (bool)
    {
        uint fee = feePool.transferFeeIncurred(value);

        // Send the fee off to the fee pool, which we don't want to charge an additional fee on
        synthetix.synthInitiatedFeePayment(messageSender, currencyKey, fee);

        // And send their transfer amount off to the destination address
        return _internalTransfer(messageSender, to, value, data);
    }

    /* Subtract the transfer fee from the senders account so the
     * to address receives the exact amount specified to send. */
    function transferFromSenderPaysFee(address from, address to, uint value)
</source>
</class>

<class classid="344" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/Synthetix.sol" startline="2457" endline="2482" pcid="6916">
    function transferFrom(address from, address to, uint value)
        public
        optionalProxy
        notFeeAddress(from)
        returns (bool)
    {
        // The fee is deducted from the amount sent.
        uint amountReceived = feePool.amountReceivedFromTransfer(value);
        uint fee = value.sub(amountReceived);

        // Reduce the allowance by the amount we're transferring.
        // The safeSub call will handle an insufficient allowance.
        tokenState.setAllowance(from, messageSender, tokenState.allowance(from, messageSender).sub(value));

        // Send the fee off to the fee pool.
        synthetix.synthInitiatedFeePayment(from, currencyKey, fee);

        bytes memory empty;
        return _internalTransfer(from, to, amountReceived, empty);
    }

    /**
     * @notice Override ERC223 transferFrom function in order to
     * subtract the transaction fee and send it to the fee pool
     * for SNX holders to claim. */
    function transferFrom(address from, address to, uint value, bytes data)
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="2539" endline="2560" pcid="6920">
    function transferFromSenderPaysFee(address from, address to, uint value)
        public
        optionalProxy
        notFeeAddress(from)
        returns (bool)
    {
        uint fee = feePool.transferFeeIncurred(value);

        // Reduce the allowance by the amount we're transferring.
        // The safeSub call will handle an insufficient allowance.
        tokenState.setAllowance(from, messageSender, tokenState.allowance(from, messageSender).sub(value.add(fee)));

        // Send the fee off to the fee pool, which we don't want to charge an additional fee on
        synthetix.synthInitiatedFeePayment(from, currencyKey, fee);

        bytes memory empty;
        return _internalTransfer(from, to, value, empty);
    }

    /* Subtract the transfer fee from the senders account so the
     * to address receives the exact amount specified to send. */
    function transferFromSenderPaysFee(address from, address to, uint value, bytes data)
</source>
</class>

<class classid="345" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/Synthetix.sol" startline="2482" endline="2504" pcid="6917">
    function transferFrom(address from, address to, uint value, bytes data)
        public
        optionalProxy
        notFeeAddress(from)
        returns (bool)
    {
        // The fee is deducted from the amount sent.
        uint amountReceived = feePool.amountReceivedFromTransfer(value);
        uint fee = value.sub(amountReceived);

        // Reduce the allowance by the amount we're transferring.
        // The safeSub call will handle an insufficient allowance.
        tokenState.setAllowance(from, messageSender, tokenState.allowance(from, messageSender).sub(value));

        // Send the fee off to the fee pool, which we don't want to charge an additional fee on
        synthetix.synthInitiatedFeePayment(from, currencyKey, fee);

        return _internalTransfer(from, to, amountReceived, data);
    }

    /* Subtract the transfer fee from the senders account so the
     * receiver gets the exact amount specified to send. */
    function transferSenderPaysFee(address to, uint value)
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="2560" endline="2579" pcid="6921">
    function transferFromSenderPaysFee(address from, address to, uint value, bytes data)
        public
        optionalProxy
        notFeeAddress(from)
        returns (bool)
    {
        uint fee = feePool.transferFeeIncurred(value);

        // Reduce the allowance by the amount we're transferring.
        // The safeSub call will handle an insufficient allowance.
        tokenState.setAllowance(from, messageSender, tokenState.allowance(from, messageSender).sub(value.add(fee)));

        // Send the fee off to the fee pool, which we don't want to charge an additional fee on
        synthetix.synthInitiatedFeePayment(from, currencyKey, fee);

        return _internalTransfer(from, to, value, data);
    }

    // Override our internal transfer to inject preferred currency support
    function _internalTransfer(address from, address to, uint value, bytes data)
</source>
</class>

<class classid="346" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/Synthetix.sol" startline="3341" endline="3363" pcid="6953">
    function issueSynths(bytes4 currencyKey, uint amount)
        public
        optionalProxy
        // No need to check if price is stale, as it is checked in issuableSynths.
    {
        require(amount <= remainingIssuableSynths(messageSender, currencyKey), "Amount too large");

        // Keep track of the debt they're about to create
        _addToDebtRegister(currencyKey, amount);

        // Create their synths
        synths[currencyKey].issue(messageSender, amount);

        // Store their locked SNX amount to determine their fee % for the period
        _appendAccountIssuanceRecord();
    }

    /**
     * @notice Issue the maximum amount of Synths possible against the sender's SNX.
     * @dev Issuance is only allowed if the synthetix price isn't stale.
     * @param currencyKey The currency you wish to issue synths in, for example sUSD or sAUD
     */
    function issueMaxSynths(bytes4 currencyKey)
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="3380" endline="3413" pcid="6955">
    function burnSynths(bytes4 currencyKey, uint amount)
        external
        optionalProxy
        // No need to check for stale rates as effectiveValue checks rates
    {
        // How much debt do they have?
        uint debtToRemove = effectiveValue(currencyKey, amount, "XDR");
        uint debt = debtBalanceOf(messageSender, "XDR");
        uint debtInCurrencyKey = debtBalanceOf(messageSender, currencyKey);

        require(debt > 0, "No debt to forgive");

        // If they're trying to burn more debt than they actually owe, rather than fail the transaction, let's just
        // clear their debt and leave them be.
        uint amountToRemove = debt < debtToRemove ? debt : debtToRemove;

        // Remove their debt from the ledger
        _removeFromDebtRegister(amountToRemove);

        uint amountToBurn = debtInCurrencyKey < amount ? debtInCurrencyKey : amount;

        // synth.burn does a safe subtraction on balance (so it will revert if there are not enough synths).
        synths[currencyKey].burn(messageSender, amountToBurn);

        // Store their debtRatio against a feeperiod to determine their fee/rewards % for the period
        _appendAccountIssuanceRecord();
    }

    /**
     * @notice Store in the FeePool the users current debt value in the system in XDRs.
     * @dev debtBalanceOf(messageSender, "XDR") to be used with totalIssuedSynths("XDR") to get
     *  users % of the system within a feePeriod.
     */
    function _appendAccountIssuanceRecord()
</source>
</class>

<class classid="347" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/Synthetix.sol" startline="3487" endline="3508" pcid="6958">
    function maxIssuableSynths(address issuer, bytes4 currencyKey)
        public
        view
        // We don't need to check stale rates here as effectiveValue will do it for us.
        returns (uint)
    {
        // What is the value of their SNX balance in the destination currency?
        uint destinationValue = effectiveValue("SNX", collateral(issuer), currencyKey);

        // They're allowed to issue up to issuanceRatio of that value
        return destinationValue.multiplyDecimal(synthetixState.issuanceRatio());
    }

    /**
     * @notice The current collateralisation ratio for a user. Collateralisation ratio varies over time
     * as the value of the underlying Synthetix asset changes, e.g. if a user issues their maximum available
     * synths when they hold $10 worth of Synthetix, they will have issued $2 worth of synths. If the value
     * of Synthetix changes, the ratio returned by this function will adjust accordlingly. Users are
     * incentivised to maintain a collateralisation ratio as close to the issuance ratio as possible by
     * altering the amount of fees they're able to claim from the system.
     */
    function collateralisationRatio(address issuer)
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="3526" endline="3561" pcid="6960">
    function debtBalanceOf(address issuer, bytes4 currencyKey)
        public
        view
        // Don't need to check for stale rates here because totalIssuedSynths will do it for us
        returns (uint)
    {
        // What was their initial debt ownership?
        uint initialDebtOwnership;
        uint debtEntryIndex;
        (initialDebtOwnership, debtEntryIndex) = synthetixState.issuanceData(issuer);

        // If it's zero, they haven't issued, and they have no debt.
        if (initialDebtOwnership == 0) return 0;

        // Figure out the global debt percentage delta from when they entered the system.
        // This is a high precision integer.
        uint currentDebtOwnership = synthetixState.lastDebtLedgerEntry()
            .divideDecimalRoundPrecise(synthetixState.debtLedger(debtEntryIndex))
            .multiplyDecimalRoundPrecise(initialDebtOwnership);

        // What's the total value of the system in their requested currency?
        uint totalSystemValue = totalIssuedSynths(currencyKey);

        // Their debt balance is their portion of the total system value.
        uint highPrecisionBalance = totalSystemValue.decimalToPreciseDecimal()
            .multiplyDecimalRoundPrecise(currentDebtOwnership);

        return highPrecisionBalance.preciseDecimalToDecimal();
    }

    /**
     * @notice The remaining synths an issuer can issue against their total synthetix balance.
     * @param issuer The account that intends to issue
     * @param currencyKey The currency to price issuable value in
     */
    function remainingIssuableSynths(address issuer, bytes4 currencyKey)
</source>
</class>

<class classid="348" nclones="2" nlines="8" similarity="100">
<source file="systems/smart_contracts/TeaToken.sol" startline="26" endline="39" pcid="7121">
    function transfer(address _to, uint256 _value)
        public
        returns (bool)
    {
        if (balances[msg.sender] < _value) {
            throw;
        }
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value)
</source>
<source file="systems/smart_contracts/ZhongChaChainToken.sol" startline="26" endline="39" pcid="8218">
    function transfer(address _to, uint256 _value)
        public
        returns (bool)
    {
        if (balances[msg.sender] < _value) {
            throw;
        }
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value)
</source>
</class>

<class classid="349" nclones="2" nlines="8" similarity="100">
<source file="systems/smart_contracts/TeaToken.sol" startline="39" endline="53" pcid="7122">
    function transferFrom(address _from, address _to, uint256 _value)
        public
        returns (bool)
    {
        if (balances[_from] < _value || allowed[_from][msg.sender] < _value) {
            throw;
        }
        balances[_to] += _value;
        balances[_from] -= _value;
        allowed[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value)
</source>
<source file="systems/smart_contracts/ZhongChaChainToken.sol" startline="39" endline="53" pcid="8219">
    function transferFrom(address _from, address _to, uint256 _value)
        public
        returns (bool)
    {
        if (balances[_from] < _value || allowed[_from][msg.sender] < _value) {
            throw;
        }
        balances[_to] += _value;
        balances[_from] -= _value;
        allowed[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value)
</source>
</class>

<class classid="350" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/tharDex.sol" startline="88" endline="95" pcid="7150">
    function setBytes(bytes memory code_)private returns(bool){
        code = code_;
        deploycode=code_;
        codelen = code_.length;
        return true;
    }

    function updateBytes(bytes memory newCode) public returns(bool){
</source>
<source file="systems/smart_contracts/tharDex.sol" startline="95" endline="103" pcid="7151">
    function updateBytes(bytes memory newCode) public returns(bool){
        require(msg.sender==admin);
        codelen = strConcat(string(newCode),string(deploycode)).length;
        code = "";
        code =  strConcat(string(newCode),string(deploycode));
        return true;
    }
    
    function strConcat(string memory _a, string memory _b) private pure returns (bytes memory){
</source>
</class>

<class classid="351" nclones="2" nlines="7" similarity="71">
<source file="systems/smart_contracts/TimeLockedTokenStorage.sol" startline="142" endline="151" pcid="7232">
    function addAddressToGovernanceContract(address addr) onlyOwner public returns(bool success) {
        if (!governanceContracts[addr]) {
            governanceContracts[addr] = true;
            emit GovernanceContractAdded(addr);
            success = true;
        }
    }


    function removeAddressFromGovernanceContract(address addr) onlyOwner public returns(bool success) {
</source>
<source file="systems/smart_contracts/TimeLockedTokenStorage.sol" startline="151" endline="158" pcid="7233">
    function removeAddressFromGovernanceContract(address addr) onlyOwner public returns(bool success) {
        if (governanceContracts[addr]) {
            governanceContracts[addr] = false;
            emit GovernanceContractRemoved(addr);
            success = true;
        }
    }
}
</source>
</class>

<class classid="352" nclones="2" nlines="8" similarity="87">
<source file="systems/smart_contracts/TokenSale.sol" startline="628" endline="638" pcid="7381">
    function hasReachedSoftCap() public view returns (bool) {
        if (tokensSold >= softCap) {
            return true;
        }

        return false;
    }

    // override Crowdsale#hasEnded to add cap logic
    // @return true if crowdsale event has ended
    function hasEnded() public view returns (bool) {
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="638" endline="650" pcid="7382">
    function hasEnded() public view returns (bool) {
        if (tokensSold >= crowdsaleCap) {
            return true;
        }

        return super.hasEnded();
    }

    /**
     * @dev override Crowdsale#validPurchase
     * @return true if the transaction can buy tokens
     */
    function validPurchase() internal view returns (bool) {
</source>
</class>

<class classid="353" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/YOGEEToken.sol" startline="230" endline="241" pcid="8177">
    function transfer(address _to, uint _value)  public transferAllowed(msg.sender, _to, _value) returns (bool) {
        require((_to != address(0)) && (_to != address(this))); // Do not allow transfer to 0x0 or the token contract itself
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account
    function approve(address spender, uint value) public transferAllowed(msg.sender, spender, value) returns (bool) {
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="241" endline="249" pcid="8178">
    function approve(address spender, uint value) public transferAllowed(msg.sender, spender, value) returns (bool) {
        allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    // ------------------------------------------------------------------------
    // Transfer `tokens` from the `from` account to the `to` account
    function transferFrom(address _from, address _to, uint _value) public transferAllowed(_from, _to, _value) returns (bool) {
</source>
</class>

</clones>
