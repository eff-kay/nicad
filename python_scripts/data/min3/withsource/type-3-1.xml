<clones>
<systeminfo processor="nicad5" system="smart_contracts" granularity="functions" threshold="30%" minlines="3" maxlines="2500"/>
<cloneinfo npcs="8259" npairs="87287"/>
<runinfo ncompares="15681479" cputime="847958"/>
<classinfo nclasses="514"/>

<class classid="1" nclones="2" nlines="3" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="35" endline="37" pcid="10">
    function owner() public pure returns (address) {}

    event OwnerUpdate(address _prevOwner, address _newOwner);
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="33" endline="35" pcid="2816">
    function owner() public pure returns (address) {}

    event OwnerUpdate(address _prevOwner, address _newOwner);
</source>
</class>

<class classid="2" nclones="2" nlines="3" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="45" endline="47" pcid="13">
    function callers(address) public pure returns (bool) { }

    function appendCaller(address _caller) public;  // ownerOnly
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="43" endline="45" pcid="2819">
    function callers(address) public pure returns (bool) { }

    function appendCaller(address _caller) public;  // ownerOnly
</source>
</class>

<class classid="3" nclones="2" nlines="3" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="78" endline="80" pcid="26">
    function operator() public pure returns(ITokenOperator) {}
    //ITokenOperator public operator;
}
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="74" endline="76" pcid="2832">
    function operator() public pure returns(ITokenOperator) {}
    //ITokenOperator public operator;
}
</source>
</class>

<class classid="4" nclones="2" nlines="3" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="91" endline="93" pcid="30">
    function dummy() public pure returns (IDummyToken) {}
    
	function emitEventTransfer(address _from, address _to, uint256 _amount) public;
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="85" endline="87" pcid="2836">
    function dummy() public pure returns (IDummyToken) {}
    
	function emitEventTransfer(address _from, address _to, uint256 _amount) public;
</source>
</class>

<class classid="5" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="118" endline="126" pcid="47">
    function isContract(address _addr) internal view returns (bool is_contract) {
        uint length;
        assembly {
              //retrieve the size of the code on target address, this needs assembly
              length := extcodesize(_addr)
        }
        return (length>0);
    }
}
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="112" endline="120" pcid="2853">
    function isContract(address _addr) internal view returns (bool is_contract) {
        uint length;
        assembly {
              //retrieve the size of the code on target address, this needs assembly
              length := extcodesize(_addr)
        }
        return (length>0);
    }
}
</source>
</class>

<class classid="6" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="152" endline="160" pcid="48">
    function transferOwnership(address _newOwner) public ownerOnly {
        require(_newOwner != owner);
        newOwner = _newOwner;
    }

    /**
        @dev used by a new owner to accept an ownership transfer
    */
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="145" endline="153" pcid="2854">
    function transferOwnership(address _newOwner) public ownerOnly {
        require(_newOwner != owner);
        newOwner = _newOwner;
    }

    /**
        @dev used by a new owner to accept an ownership transfer
    */
    function acceptOwnership() public {
</source>
</class>

<class classid="7" nclones="44" nlines="4" similarity="75">
<source file="systems/smart_contracts/$martFund.sol" startline="160" endline="166" pcid="49">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnerUpdate(owner, newOwner);
        owner = newOwner;
        newOwner = address(0x0);
    }
}
</source>
<source file="systems/smart_contracts/BIBCOINID.sol" startline="93" endline="99" pcid="1207">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="77" endline="83" pcid="1230">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="153" endline="159" pcid="2855">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnerUpdate(owner, newOwner);
        owner = newOwner;
        newOwner = address(0x0);
    }
}
</source>
<source file="systems/smart_contracts/DGC.sol" startline="92" endline="98" pcid="2523">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/AnxToken.sol" startline="92" endline="98" pcid="714">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/AICRYPTO.sol" startline="90" endline="96" pcid="430">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="183" endline="195" pcid="266">
    function acceptOwnership() public {

        require(msg.sender == newOwner);

        OwnershipTransferred(owner, newOwner);

        owner = newOwner;

        newOwner = address(0);

    }

}
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="77" endline="83" pcid="1254">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="108" endline="115" pcid="233">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }

}
</source>
<source file="systems/smart_contracts/CGT.sol" startline="92" endline="98" pcid="1693">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/SapientiaCharlesToken.sol" startline="92" endline="98" pcid="6279">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/SolaToken.sol" startline="78" endline="84" pcid="6585">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="76" endline="82" pcid="5813">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/Perlin.sol" startline="93" endline="99" pcid="5647">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/PAYCASH.sol" startline="92" endline="98" pcid="5617">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="69" endline="75" pcid="2430">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/OSManagerToken.sol" startline="61" endline="67" pcid="5555">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/Melodic.sol" startline="93" endline="99" pcid="4790">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="73" endline="79" pcid="7437">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="77" endline="83" pcid="1308">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/LanceToken.sol" startline="93" endline="99" pcid="4522">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/JUNDCOIN.sol" startline="89" endline="95" pcid="4364">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/ContractCoffeeToken.sol" startline="88" endline="94" pcid="1983">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/JDC.sol" startline="67" endline="73" pcid="4342">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="77" endline="83" pcid="7554">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/ContractCargoberToken.sol" startline="88" endline="94" pcid="1961">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/GRAM.sol" startline="90" endline="96" pcid="4206">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="87" endline="93" pcid="407">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/VACCToken.sol" startline="96" endline="102" pcid="7625">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/GoaToken.sol" startline="100" endline="108" pcid="4154">
    function acceptOwnership() public {
        require(msg.sender == newOwner, "must be new owner");
        
        owner = newOwner;
        newOwner = address(0);

        emit OwnershipTransferred(owner, newOwner);
    }
}
</source>
<source file="systems/smart_contracts/GNB.sol" startline="82" endline="88" pcid="4130">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/GFNX.sol" startline="109" endline="113" pcid="4104">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/VENT.sol" startline="24" endline="30" pcid="7675">
        function acceptOwnership() public {
            require(msg.sender == newOwner);
            emit OwnershipTransferred(owner, newOwner);
            owner = newOwner;
            newOwner = address(0);
        }
    }
</source>
<source file="systems/smart_contracts/FUNNYTOKEN.sol" startline="69" endline="75" pcid="3953">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/VOTENOmodumtokenswapdotcom.sol" startline="93" endline="99" pcid="7841">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/WanCoinSupplyToken.sol" startline="78" endline="84" pcid="7863">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/WanCoinToken.sol" startline="78" endline="84" pcid="7885">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/FixedSupplyToken.sol" startline="92" endline="98" pcid="3608">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="77" endline="83" pcid="3419">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/XTRLPAY.sol" startline="93" endline="99" pcid="8139">
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="72" endline="78" pcid="8162">
    function acceptOwnership() external {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="402" endline="411" pcid="6842">
    function acceptOwnership()
        external
    {
        require(msg.sender == nominatedOwner, "You must be nominated before you can accept ownership");
        emit OwnerChanged(owner, nominatedOwner);
        owner = nominatedOwner;
        nominatedOwner = address(0);
    }

    modifier onlyOwner
</source>
<source file="systems/smart_contracts/ProxyERC20.sol" startline="78" endline="87" pcid="5876">
    function acceptOwnership()
        external
    {
        require(msg.sender == nominatedOwner, "You must be nominated before you can accept ownership");
        emit OwnerChanged(owner, nominatedOwner);
        owner = nominatedOwner;
        nominatedOwner = address(0);
    }

    modifier onlyOwner
</source>
</class>

<class classid="8" nclones="2" nlines="7" similarity="71">
<source file="systems/smart_contracts/$martFund.sol" startline="477" endline="483" pcid="99">
    function calledUpdate(address _oldCalled, address _newCalled) public ownerOnly {
        if(data == _oldCalled) {
            data = IData(_newCalled);
            emit CalledUpdate(_oldCalled, _newCalled);
        }
    }
}
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="163" endline="170" pcid="2856">
    function calledUpdate(address _oldCalled, address _newCalled) public ownerOnly {
        if(operator == _oldCalled) {
            operator = ITokenOperator(_newCalled);
        	emit CalledUpdate(_oldCalled, _newCalled);
		}
    }
    
    function name() public view returns (string){
</source>
</class>

<class classid="9" nclones="2" nlines="3" similarity="100">
<source file="systems/smart_contracts/$martFund.sol" startline="551" endline="553" pcid="132">
    function reserve() public pure returns(IReserve) { }

    function totalSupply() public view returns (uint256);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="584" endline="585" pcid="146">
	function reserve() public pure returns(IReserve){}
	function formula() public pure returns(IFormula){}
</source>
</class>

<class classid="10" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/$martFund.sol" startline="741" endline="744" pcid="185">
    function destruct() public ownerOnly {
        selfdestruct(owner);
    }
}
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="226" endline="230" pcid="3716">
function ToDo() public onlyOwner {
    selfdestruct(owner);
    }

function disown() internal {
</source>
</class>

<class classid="11" nclones="94" nlines="4" similarity="75">
<source file="systems/smart_contracts/$martFund.sol" startline="1058" endline="1061" pcid="214">
    function() public payable{
        purchase(false, false, 0x0, 0x0);
    }
}
</source>
<source file="systems/smart_contracts/Alfa_quiz.sol" startline="52" endline="53" pcid="641">
    function() public payable{}
}
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="288" endline="292" pcid="1905">
    function() public payable {
         //not payable fallback function
          
    }
    function close() public onlyOwner { //onlyOwner is custom modifier
</source>
<source file="systems/smart_contracts/BTGS.sol" startline="188" endline="192" pcid="1551">
    function () public payable{
        revert();
    }

}
</source>
<source file="systems/smart_contracts/multifind.sol" startline="51" endline="53" pcid="5086">
    function () public payable {
    }
}
</source>
<source file="systems/smart_contracts/ContractCargoberToken.sol" startline="213" endline="221" pcid="1969">
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/ContractCoffeeToken.sol" startline="213" endline="221" pcid="1991">
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="153" endline="158" pcid="1239">
    function () public payable {
        revert();
    }


    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/KingToken.sol" startline="139" endline="143" pcid="4494">
    function () public payable {
       
    }
	
	function settings(uint _burning, uint _dailyminingpercent, uint _mint, uint _burn, uint _refrate) public {
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="385" endline="389" pcid="8096">
  function() public payable {
  }

 
}
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="220" endline="224" pcid="2868">
    function() public payable {
        operator.fallback.value(msg.value)(msg.sender, msg.data);
	}
	
    function tokenFallback(address _from, uint _value, bytes _data) public returns(bool){
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="211" endline="219" pcid="416">
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/En_GAME.sol" startline="52" endline="53" pcid="2944">
    function() public payable{}
}
</source>
<source file="systems/smart_contracts/AnxToken.sol" startline="215" endline="223" pcid="722">
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/Digital_QUIZ.sol" startline="52" endline="53" pcid="2732">
    function() public payable{}
}
</source>
<source file="systems/smart_contracts/XTRLPAY.sol" startline="216" endline="224" pcid="8147">
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="153" endline="158" pcid="1263">
    function () public payable {
        revert();
    }


    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/multifund.sol" startline="51" endline="53" pcid="5141">
    function () public payable {
    }
}
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="153" endline="158" pcid="3428">
    function () public payable {
        revert();
    }


    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/play_IQuiz.sol" startline="52" endline="53" pcid="5667">
    function() public payable{}
}
</source>
<source file="systems/smart_contracts/BatchTransfer.sol" startline="59" endline="61" pcid="1090">
    function () public payable {
    }
}
</source>
<source file="systems/smart_contracts/WanCoinToken.sol" startline="203" endline="211" pcid="7893">
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/WanCoinSupplyToken.sol" startline="203" endline="211" pcid="7871">
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/VOTENOmodumtokenswapdotcom.sol" startline="216" endline="224" pcid="7849">
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/FUNNYTOKEN.sol" startline="135" endline="139" pcid="3961">
    function () public payable {
        revert();
    }
    
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/quiz_BLZ.sol" startline="52" endline="53" pcid="5938">
    function() public payable{}
}
</source>
<source file="systems/smart_contracts/SellableToken.sol" startline="170" endline="173" pcid="6472">
    function () public payable {
        revert();
    }
}
</source>
<source file="systems/smart_contracts/VACCToken.sol" startline="224" endline="232" pcid="7633">
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint256 tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/GNB.sol" startline="301" endline="308" pcid="4140">
    function () public payable {
        revert();
    }

    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/BIBCOINID.sol" startline="216" endline="224" pcid="1215">
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/GRAM.sol" startline="214" endline="222" pcid="4214">
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/UTC.sol" startline="238" endline="243" pcid="7589">
  function() public payable{
    revert();
  }


}
</source>
<source file="systems/smart_contracts/ITVR.sol" startline="67" endline="76" pcid="4326">
  function()
    public
    payable
  {
    revert();
  }


  /// @dev Get current balance of the contract
  function getBalance()
</source>
<source file="systems/smart_contracts/JDC.sol" startline="151" endline="157" pcid="4350">
    function () public payable {
        revert();
    }


    
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/JUNDCOIN.sol" startline="212" endline="220" pcid="4372">
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="654" endline="668" pcid="284">
    function () public payable {

        revert();

    }



    // ------------------------------------------------------------------------

    // Owner can transfer out any accidentally sent ERC20 tokens

    // ------------------------------------------------------------------------

    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="196" endline="204" pcid="7446">
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/LanceToken.sol" startline="216" endline="224" pcid="4530">
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/Melodic.sol" startline="216" endline="224" pcid="4798">
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/c_Bank.sol" startline="34" endline="41" pcid="1604">
    function() 
    public 
    payable
    {
        Put(0);
    }

    struct Holder   
</source>
<source file="systems/smart_contracts/OSManagerToken.sol" startline="127" endline="131" pcid="5563">
    function () public payable {
        revert();
    }

    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/PAYCASH.sol" startline="215" endline="223" pcid="5626">
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/PDataToSHFund.sol" startline="67" endline="76" pcid="5630">
  function()
    public
    payable
  {
    revert();
  }


  /// @dev Get current balance of the contract
  function getBalance()
</source>
<source file="systems/smart_contracts/Piggy_Bank.sol" startline="34" endline="41" pcid="5660">
    function() 
    public 
    payable
    {
        Put(0);
    }

    struct Holder   
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="200" endline="208" pcid="5822">
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/SolaToken.sol" startline="203" endline="211" pcid="6593">
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="153" endline="158" pcid="1317">
    function () public payable {
        revert();
    }


    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="287" endline="291" pcid="2065">
    function() external payable {
        // The contract don`t receive ether
        revert();
    } 
}
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="296" endline="300" pcid="2066">
    function() external payable {
        // The contract don`t receive ether
        revert();
    } 
}
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="250" endline="254" pcid="2062">
    function() external payable {
        // The token contract don`t receive ether
        revert();
    }  
}
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="305" endline="309" pcid="2067">
    function() external payable {
        // The contract don`t receive ether
        revert();
    } 
}
</source>
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="398" endline="406" pcid="250">
    function () external payable {
        revert();
    }

    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------

    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns(bool success) {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="313" endline="317" pcid="2068">
    function() external payable {
        // The contract don`t receive ether
        revert();
    } 
}
</source>
<source file="systems/smart_contracts/FMT.sol" startline="272" endline="276" pcid="3666">
  function() external payable {
    revert();
  }

  function setERC721Address(address _ERC721Address) external onlyOwner {
</source>
<source file="systems/smart_contracts/UTRAToken.sol" startline="128" endline="134" pcid="7604">
    function () payable public {
        revert();
    }
    

    /* Internal transfer, only can be called by this contract */
    function _transfer(address _from, address _to, uint _value) internal {
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="184" endline="192" pcid="2438">
    function () external payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/FixedSupplyToken.sol" startline="217" endline="225" pcid="3616">
    function () external payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/DGC.sol" startline="217" endline="225" pcid="2531">
    function () external payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="270" endline="277" pcid="8181">
    function () payable external {
        revert();
    }

    /* ------------------------------------------------------------------------
     * This function prevents accidentally sent tokens to the contract
     */
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="161" endline="169" pcid="7562">
    function () external payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/NBToken.sol" startline="257" endline="261" pcid="5315">
    function () payable external {
        revert();
    }

}
</source>
<source file="systems/smart_contracts/SAMPLE.sol" startline="250" endline="258" pcid="6264">
	function () external payable {
		revert();
	}


	// ------------------------------------------------------------------------
	// Owner can transfer out any accidentally sent ERC20 tokens
	// ------------------------------------------------------------------------
	function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/AICRYPTO.sol" startline="215" endline="223" pcid="438">
    function () external payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/CGT.sol" startline="217" endline="225" pcid="1701">
    function () external payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/SapientiaCharlesToken.sol" startline="217" endline="225" pcid="6287">
    function () external payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/multiSend.sol" startline="17" endline="21" pcid="5196">
    function() external payable { 
        revert();
    }
    
    function sendOutToken(uint256 limitInFinney, address[] memory addrs) public {
</source>
<source file="systems/smart_contracts/MultiSign.sol" startline="106" endline="109" pcid="5240">
    function() payable external {
        revert();
    }
}
</source>
<source file="systems/smart_contracts/BlockPoolToken.sol" startline="268" endline="272" pcid="1427">
    function () payable external {
        revert();
    }

}
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="173" endline="177" pcid="1284">
    function () external payable {
        getTokens();
     }
    
    function getTokens() payable canDistr  public {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="242" endline="250" pcid="6992">
    function () external payable {
        emit Donate(msg.sender, msg.value);
    }


    /**
     * @return the name of the token.
     */
    function name() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/GameGold.sol" startline="336" endline="346" pcid="4006">
  function () external payable {
    require(false);
  }

  /**
   * @dev Function to mint tokens
   * @param _to The address that will receive the minted tokens.
   * @param _amount The amount of tokens to mint.
   * @return A boolean that indicates if the operation was successful.
   */
  function mint(address _to, uint256 _amount) canMint hasPermission public returns (bool) {
</source>
<source file="systems/smart_contracts/MiniMeTokenFactory.sol" startline="522" endline="536" pcid="4825">
    function () external payable {
        require(isContract(controller));
        // Adding the ` == true` makes the linter shut up so...
        require(ITokenController(controller).proxyPayment.value(msg.value)(msg.sender) == true);
    }

//////////
// Safety Methods
//////////

    /// @notice This method can be used by the controller to extract mistakenly
    ///  sent tokens to this contract.
    /// @param _token The address of the token contract that you want to recover
    ///  set to 0 in case you want to extract ether.
    function claimTokens(address _token) onlyController public {
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="182" endline="186" pcid="6560">
    function () external payable {
        getTokens();
     }

    function getTokens() payable canDistr  public {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="706" endline="713" pcid="7931">
    function () external payable {
        buyTokens(msg.sender);
    }

    /**
     * @return the token being sold.
     */
    function token() public view returns (IERC20) {
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="178" endline="182" pcid="3530">
    function () external payable {
        getTokens();
     }

    function getTokens() payable canDistr  public {
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="496" endline="504" pcid="7374">
    function () external payable {
        revert("No fallback function defined!");
    }

    /**
     * @dev change crowdsale ETH rate
     * @param newRate Figure that corresponds to the new ETH rate per token
     */
    function setRate(uint256 newRate) external onlyOwner {
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="766" endline="770" pcid="6630">
	function() external payable {
		purchase();
	}

	constructor()
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="202" endline="206" pcid="6695">
    function () external payable {
        getTokens();
     }
    
    function getTokens() payable canDistr  public {
</source>
<source file="systems/smart_contracts/XGP.sol" startline="185" endline="189" pcid="8116">
    function () external payable {
        getTokens();
     }
    
    function getTokens() payable canDistr  public {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="766" endline="773" pcid="1785">
    function () external payable {
        buyTokens(msg.sender);
    }

    /**
     * @return the token being sold.
     */
    function token() public view returns (IERC20) {
</source>
<source file="systems/smart_contracts/ICOImplementation.sol" startline="162" endline="164" pcid="4275">
    function () external payable {}

uint256 public basePrice = 5000000000000000000000;
</source>
<source file="systems/smart_contracts/Aigopay.sol" startline="185" endline="189" pcid="459">
    function () external payable {
        getTokens();
     }
    
    function getTokens() payable canDistr  public {
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="186" endline="190" pcid="6494">
    function () external payable {
        getTokens();
     }

    function getTokens() payable canDistr  public {
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="182" endline="186" pcid="2963">
    function () external payable {
        getTokens();
     }

    function getTokens() payable canDistr  public {
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="193" endline="197" pcid="4311">
    function () external payable {
        getTokens();
     }

    function getTokens() payable canDistr  public {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="168" endline="172" pcid="2567">
    function () external payable {
        buyTokens(msg.sender);
    }

    function token() public view returns (IERC20) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="164" endline="168" pcid="2658">
    function () external payable {
        buyTokens(msg.sender);
    }

    function token() public view returns (IERC20) {
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="167" endline="171" pcid="4968">
    function () external payable {
        getTokens();
     }
    
    function getTokens() payable canDistr  public {
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="189" endline="193" pcid="1446">
    function () external payable {
        getTokens();
     }

    function getTokens() payable canDistr  public {
</source>
<source file="systems/smart_contracts/CoinDDC.sol" startline="175" endline="184" pcid="1872">
    function () external payable
    {
                
        
        
           
    }


    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) 
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="622" endline="626" pcid="2090">
    function() external payable {
        saleTokens();
    }    
 
}
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="188" endline="192" pcid="1726">
    function() payable public {
        buyTokens(msg.sender);
    }

    function buyTokens(address _investor) public payable returns (uint256){
</source>
<source file="systems/smart_contracts/CommunityChest.sol" startline="27" endline="31" pcid="1941">
    function () payable external {
        emit Deposit(msg.value);
    }

    function getBalance() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/AdminUpgradeabilityProxy.sol" startline="21" endline="28" pcid="348">
    function () payable external {
        _fallback();
    }

    /**
     * @return The Address of the implementation.
     */
    function _implementation() internal view returns (address);
</source>
</class>

<class classid="12" nclones="40" nlines="4" similarity="75">
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="23" endline="28" pcid="220">
    function add(uint a, uint b) internal pure returns(uint c) {
        c = a + b;
        require(c >= a);
    }

    function sub(uint a, uint b) internal pure returns(uint c) {
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="22" endline="26" pcid="1217">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="22" endline="26" pcid="1295">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="47" endline="55" pcid="252">
    function add(uint a, uint b) internal pure returns (uint c) {

        c = a + b;

        require(c >= a);

    }

    function sub(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/AnxToken.sol" startline="26" endline="30" pcid="702">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/BIBCOINID.sol" startline="26" endline="30" pcid="1195">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="22" endline="26" pcid="1241">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/CGT.sol" startline="25" endline="29" pcid="1681">
    function add(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function sub(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="9" endline="13" pcid="2418">
    function add(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function sub(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/DGC.sol" startline="25" endline="29" pcid="2511">
    function add(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function sub(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="20" endline="24" pcid="394">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/AICRYPTO.sol" startline="23" endline="27" pcid="418">
    function add(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function sub(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="19" endline="21" pcid="8149">
    function add(uint a, uint b) internal pure returns (uint c) {
        c = a + b; require(c >= a,"Can not add Negative Values"); }
    function sub(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="22" endline="26" pcid="3406">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/XTRLPAY.sol" startline="26" endline="30" pcid="8127">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/SapientiaCharlesToken.sol" startline="25" endline="29" pcid="6267">
    function add(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function sub(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/FixedSupplyToken.sol" startline="25" endline="29" pcid="3596">
    function add(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function sub(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/WanCoinToken.sol" startline="11" endline="15" pcid="7873">
    function add(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function sub(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/WanCoinSupplyToken.sol" startline="11" endline="15" pcid="7851">
    function add(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function sub(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/VOTENOmodumtokenswapdotcom.sol" startline="26" endline="30" pcid="7829">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/FUNNYTOKEN.sol" startline="17" endline="21" pcid="3941">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/VENT.sol" startline="35" endline="39" pcid="7676">
        function add(uint a, uint b) internal pure returns (uint c) {
            c = a + b;
            require(c >= a);
        }
        function sub(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/GNB.sol" startline="9" endline="13" pcid="4117">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/GoaToken.sol" startline="32" endline="37" pcid="4145">
    function add(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }

    function sub(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/VACCToken.sol" startline="26" endline="30" pcid="7613">
    function safeAdd(uint256 a, uint256 b) public pure returns (uint256 c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint256 a, uint256 b) public pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/GRAM.sol" startline="23" endline="27" pcid="4194">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="19" endline="23" pcid="7542">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/SAMPLE.sol" startline="29" endline="33" pcid="6243">
	function add(uint a, uint b) internal pure returns (uint c) {
		c = a + b;
		require(c >= a);
	}
	function sub(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/ContractCoffeeToken.sol" startline="21" endline="25" pcid="1971">
    function add(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function sub(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/ContractCargoberToken.sol" startline="21" endline="25" pcid="1949">
    function add(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function sub(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/SolaToken.sol" startline="11" endline="15" pcid="6573">
    function add(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function sub(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="9" endline="13" pcid="5800">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/Perlin.sol" startline="26" endline="30" pcid="5634">
    function safeAdd(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/PAYCASH.sol" startline="25" endline="29" pcid="5605">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/JDC.sol" startline="9" endline="13" pcid="4330">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/JUNDCOIN.sol" startline="22" endline="26" pcid="4352">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/LanceToken.sol" startline="26" endline="30" pcid="4510">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="6" endline="10" pcid="7424">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/OSManagerToken.sol" startline="9" endline="13" pcid="5543">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/Melodic.sol" startline="26" endline="30" pcid="4778">
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
</source>
</class>

<class classid="13" nclones="40" nlines="4" similarity="75">
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="28" endline="33" pcid="221">
    function sub(uint a, uint b) internal pure returns(uint c) {
        require(b <= a);
        c = a - b;
    }

    function mul(uint a, uint b) internal pure returns(uint c) {
</source>
<source file="systems/smart_contracts/XTRLPAY.sol" startline="30" endline="34" pcid="8128">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="26" endline="30" pcid="3407">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/FixedSupplyToken.sol" startline="29" endline="33" pcid="3597">
    function sub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function mul(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="21" endline="23" pcid="8150">
    function sub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a, "Result can not be negative"); c = a - b;  }
    function mul(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/WanCoinToken.sol" startline="15" endline="19" pcid="7874">
    function sub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function mul(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/WanCoinSupplyToken.sol" startline="15" endline="19" pcid="7852">
    function sub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function mul(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/VOTENOmodumtokenswapdotcom.sol" startline="30" endline="34" pcid="7830">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/FUNNYTOKEN.sol" startline="21" endline="25" pcid="3942">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/VENT.sol" startline="39" endline="43" pcid="7677">
        function sub(uint a, uint b) internal pure returns (uint c) {
            require(b <= a);
            c = a - b;
        }
        function mul(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/GNB.sol" startline="13" endline="17" pcid="4118">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/GoaToken.sol" startline="37" endline="42" pcid="4146">
    function sub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }

    function mul(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/VACCToken.sol" startline="30" endline="34" pcid="7614">
    function safeSub(uint256 a, uint256 b) public pure returns (uint256 c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint256 a, uint256 b) public pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/GRAM.sol" startline="27" endline="31" pcid="4195">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="23" endline="27" pcid="7543">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/JDC.sol" startline="13" endline="17" pcid="4331">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/JUNDCOIN.sol" startline="26" endline="30" pcid="4353">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/LanceToken.sol" startline="30" endline="34" pcid="4511">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="10" endline="14" pcid="7425">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/Melodic.sol" startline="30" endline="34" pcid="4779">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/OSManagerToken.sol" startline="13" endline="17" pcid="5544">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/PAYCASH.sol" startline="29" endline="33" pcid="5606">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/Perlin.sol" startline="30" endline="34" pcid="5635">
    function safeSub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="13" endline="17" pcid="5801">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/SolaToken.sol" startline="15" endline="19" pcid="6574">
    function sub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function mul(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/SAMPLE.sol" startline="33" endline="37" pcid="6244">
	function sub(uint a, uint b) internal pure returns (uint c) {
		require(b <= a);
		c = a - b;
	}
	function mul(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/AICRYPTO.sol" startline="27" endline="31" pcid="419">
    function sub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function mul(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="24" endline="28" pcid="395">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/SapientiaCharlesToken.sol" startline="29" endline="33" pcid="6268">
    function sub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function mul(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/DGC.sol" startline="29" endline="33" pcid="2512">
    function sub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function mul(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="13" endline="17" pcid="2419">
    function sub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function mul(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/ContractCoffeeToken.sol" startline="25" endline="29" pcid="1972">
    function sub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function mul(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/ContractCargoberToken.sol" startline="25" endline="29" pcid="1950">
    function sub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function mul(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="55" endline="63" pcid="253">
    function sub(uint a, uint b) internal pure returns (uint c) {

        require(b <= a);

        c = a - b;

    }

    function mul(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/CGT.sol" startline="29" endline="33" pcid="1682">
    function sub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function mul(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="26" endline="30" pcid="1242">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/BIBCOINID.sol" startline="30" endline="34" pcid="1196">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/AnxToken.sol" startline="30" endline="34" pcid="703">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="26" endline="30" pcid="1296">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="26" endline="30" pcid="1218">
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
</source>
</class>

<class classid="14" nclones="39" nlines="4" similarity="75">
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="33" endline="38" pcid="222">
    function mul(uint a, uint b) internal pure returns(uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }

    function div(uint a, uint b) internal pure returns(uint c) {
</source>
<source file="systems/smart_contracts/AnxToken.sol" startline="34" endline="38" pcid="704">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="30" endline="34" pcid="1297">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="30" endline="34" pcid="1219">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/BIBCOINID.sol" startline="34" endline="38" pcid="1197">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="63" endline="71" pcid="254">
    function mul(uint a, uint b) internal pure returns (uint c) {

        c = a * b;

        require(a == 0 || c / a == b);

    }

    function div(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="30" endline="34" pcid="1243">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/ContractCargoberToken.sol" startline="29" endline="33" pcid="1951">
    function mul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function div(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/CGT.sol" startline="33" endline="37" pcid="1683">
    function mul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function div(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/ContractCoffeeToken.sol" startline="29" endline="33" pcid="1973">
    function mul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function div(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="17" endline="21" pcid="2420">
    function mul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function div(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/DGC.sol" startline="33" endline="37" pcid="2513">
    function mul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function div(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="28" endline="32" pcid="396">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/AICRYPTO.sol" startline="31" endline="35" pcid="420">
    function mul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function div(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="23" endline="25" pcid="8151">
    function mul(uint a, uint b) internal pure returns (uint c) {
        c = a * b; require(a == 0 || c / a == b,"Dived by Zero protection"); }
    function div(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="30" endline="34" pcid="3408">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/XTRLPAY.sol" startline="34" endline="38" pcid="8129">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/FixedSupplyToken.sol" startline="33" endline="37" pcid="3598">
    function mul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function div(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/WanCoinToken.sol" startline="19" endline="23" pcid="7875">
    function mul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function div(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/WanCoinSupplyToken.sol" startline="19" endline="23" pcid="7853">
    function mul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function div(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/VOTENOmodumtokenswapdotcom.sol" startline="34" endline="38" pcid="7831">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/FUNNYTOKEN.sol" startline="25" endline="29" pcid="3943">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/VENT.sol" startline="43" endline="47" pcid="7678">
        function mul(uint a, uint b) internal pure returns (uint c) {
            c = a * b;
            require(a == 0 || c / a == b);
        }
        function div(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/SapientiaCharlesToken.sol" startline="33" endline="37" pcid="6269">
    function mul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function div(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/SAMPLE.sol" startline="37" endline="41" pcid="6245">
	function mul(uint a, uint b) internal pure returns (uint c) {
		c = a * b;
		require(a == 0 || c / a == b);
	}
	function div(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/SolaToken.sol" startline="19" endline="23" pcid="6575">
    function mul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function div(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="17" endline="21" pcid="5802">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/Perlin.sol" startline="34" endline="38" pcid="5636">
    function safeMul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/PAYCASH.sol" startline="33" endline="37" pcid="5607">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/OSManagerToken.sol" startline="17" endline="21" pcid="5545">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/GNB.sol" startline="17" endline="21" pcid="4119">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/GoaToken.sol" startline="42" endline="47" pcid="4147">
    function mul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }

    function div(uint a, uint b) internal pure returns (uint c) {
</source>
<source file="systems/smart_contracts/GRAM.sol" startline="31" endline="35" pcid="4196">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="27" endline="31" pcid="7544">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/Melodic.sol" startline="34" endline="38" pcid="4780">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/JDC.sol" startline="17" endline="21" pcid="4332">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="14" endline="18" pcid="7426">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/LanceToken.sol" startline="34" endline="38" pcid="4512">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
<source file="systems/smart_contracts/JUNDCOIN.sol" startline="30" endline="34" pcid="4354">
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
</source>
</class>

<class classid="15" nclones="40" nlines="4" similarity="75">
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="38" endline="43" pcid="223">
    function div(uint a, uint b) internal pure returns(uint c) {
        require(b > 0);
        c = a / b;
    }

}
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="71" endline="79" pcid="255">
    function div(uint a, uint b) internal pure returns (uint c) {

        require(b > 0);

        c = a / b;

    }

}
</source>
<source file="systems/smart_contracts/SapientiaCharlesToken.sol" startline="37" endline="41" pcid="6270">
    function div(uint a, uint b) internal pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="34" endline="38" pcid="1220">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/AnxToken.sol" startline="38" endline="42" pcid="705">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/PAYCASH.sol" startline="37" endline="41" pcid="5608">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="34" endline="38" pcid="1298">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/SAMPLE.sol" startline="41" endline="45" pcid="6246">
	function div(uint a, uint b) internal pure returns (uint c) {
		require(b > 0);
		c = a / b;
	}
}
</source>
<source file="systems/smart_contracts/ContractCargoberToken.sol" startline="33" endline="37" pcid="1952">
    function div(uint a, uint b) internal pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/ContractCoffeeToken.sol" startline="33" endline="37" pcid="1974">
    function div(uint a, uint b) internal pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="21" endline="25" pcid="2421">
    function div(uint a, uint b) internal pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/DGC.sol" startline="37" endline="41" pcid="2514">
    function div(uint a, uint b) internal pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="32" endline="36" pcid="397">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/AICRYPTO.sol" startline="35" endline="39" pcid="421">
    function div(uint a, uint b) internal pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="25" endline="27" pcid="8152">
    function div(uint a, uint b) internal pure returns (uint c) {
        require(b > 0,"Devide by Zero protection"); c = a / b; }
}
</source>
<source file="systems/smart_contracts/SolaToken.sol" startline="23" endline="27" pcid="6576">
    function div(uint a, uint b) internal pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="34" endline="38" pcid="3409">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/CGT.sol" startline="37" endline="41" pcid="1684">
    function div(uint a, uint b) internal pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/XTRLPAY.sol" startline="38" endline="42" pcid="8130">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="21" endline="25" pcid="5803">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/FixedSupplyToken.sol" startline="37" endline="41" pcid="3599">
    function div(uint a, uint b) internal pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/BIBCOINID.sol" startline="38" endline="42" pcid="1198">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="34" endline="38" pcid="1244">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/WanCoinToken.sol" startline="23" endline="27" pcid="7876">
    function div(uint a, uint b) internal pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/WanCoinSupplyToken.sol" startline="23" endline="27" pcid="7854">
    function div(uint a, uint b) internal pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/VOTENOmodumtokenswapdotcom.sol" startline="38" endline="42" pcid="7832">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/FUNNYTOKEN.sol" startline="29" endline="33" pcid="3944">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/VENT.sol" startline="47" endline="51" pcid="7679">
        function div(uint a, uint b) internal pure returns (uint c) {
            require(b > 0);
            c = a / b;
        }
    }
</source>
<source file="systems/smart_contracts/GNB.sol" startline="21" endline="25" pcid="4120">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/GoaToken.sol" startline="47" endline="51" pcid="4148">
    function div(uint a, uint b) internal pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/VACCToken.sol" startline="41" endline="45" pcid="7616">
    function safeDiv(uint256 a, uint256 b) public pure returns (uint256 c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/GRAM.sol" startline="35" endline="39" pcid="4197">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="31" endline="35" pcid="7545">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/JDC.sol" startline="21" endline="25" pcid="4333">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/JUNDCOIN.sol" startline="34" endline="38" pcid="4355">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/LanceToken.sol" startline="38" endline="42" pcid="4513">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="18" endline="22" pcid="7427">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/Melodic.sol" startline="38" endline="42" pcid="4781">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/Perlin.sol" startline="38" endline="42" pcid="5637">
    function safeDiv(uint a, uint b) internal pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
<source file="systems/smart_contracts/OSManagerToken.sol" startline="21" endline="25" pcid="5546">
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
</source>
</class>

<class classid="16" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="48" endline="52" pcid="224">
    function limitLessThan(uint a, uint b) internal pure returns(uint c) {
        if (a > b) return b;
        return a;
    }
}
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="87" endline="94" pcid="256">
    function limitLessThan(uint a, uint b) internal pure returns (uint c) {

        if(a > b) return b;

        return a;

    }
}
</source>
</class>

<class classid="17" nclones="54" nlines="4" similarity="75">
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="104" endline="108" pcid="232">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }

    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="177" endline="183" pcid="265">
    function transferOwnership(address _newOwner) public onlyOwner {

        newOwner = _newOwner;

    }

    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="60" endline="65" pcid="1624">
    function transferOwnership(address _newOwner) public onlyOwner {
        require(_newOwner != address(0));
        newOwner = _newOwner;
    }

    function acceptOwnership() public onlyNewOwner returns(bool) {
</source>
<source file="systems/smart_contracts/CDS.sol" startline="83" endline="91" pcid="1657">
  function transferOwnership(address _newOwner) public onlyOwner {
    _transferOwnership(_newOwner);
  }

  /**
   * @dev Transfers control of the contract to a newOwner.
   * @param _newOwner The address to transfer ownership to.
   */
  function _transferOwnership(address _newOwner) internal {
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="74" endline="77" pcid="1229">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/CGT.sol" startline="89" endline="92" pcid="1692">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/OSManagerToken.sol" startline="58" endline="61" pcid="5554">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/PAYCASH.sol" startline="89" endline="92" pcid="5616">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/FixedSupplyToken.sol" startline="89" endline="92" pcid="3607">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/GoaToken.sol" startline="96" endline="100" pcid="4153">
    function transferOwnership(address payable _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }

    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/Perlin.sol" startline="90" endline="93" pcid="5646">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/GNB.sol" startline="79" endline="82" pcid="4129">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/BIBCOINID.sol" startline="90" endline="93" pcid="1206">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/GFNX.sol" startline="106" endline="109" pcid="4103">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/VENT.sol" startline="21" endline="24" pcid="7674">
        function transferOwnership(address _newOwner) public onlyOwner {
            newOwner = _newOwner;
        }
        function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="113" endline="117" pcid="7705">
  function transferOwnership(address _newOwner) public onlyOwner {
    _transferOwnership(_newOwner);
  }
  
  function _transferOwnership(address _newOwner) internal {
</source>
<source file="systems/smart_contracts/FUNNYTOKEN.sol" startline="66" endline="69" pcid="3952">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/AnxToken.sol" startline="89" endline="92" pcid="713">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/VOTENOmodumtokenswapdotcom.sol" startline="90" endline="93" pcid="7840">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/ContractCargoberToken.sol" startline="85" endline="88" pcid="1960">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/ContractCoffeeToken.sol" startline="85" endline="88" pcid="1982">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="113" endline="117" pcid="2232">
  function transferOwnership(address _newOwner) public onlyOwner {
    _transferOwnership(_newOwner);
  }
  
  function _transferOwnership(address _newOwner) internal {
</source>
<source file="systems/smart_contracts/VACCToken.sol" startline="93" endline="96" pcid="7624">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="66" endline="69" pcid="2429">
    function transferOwnership(address payable _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/DGC.sol" startline="89" endline="92" pcid="2522">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/GRAM.sol" startline="87" endline="90" pcid="4205">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/ICOImplementation.sol" startline="295" endline="308" pcid="4282">
    function transferOwnership(address _newOwner) public onlyOwner {
        require(_newOwner != address(0), "cannot transfer ownership to address zero");
        emit OwnershipTransferred(owner, _newOwner);
        owner = _newOwner;
    }


    // PAUSABILITY FUNCTIONALITY


    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     */
    modifier whenNotPaused() {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="113" endline="117" pcid="6718">
  function transferOwnership(address _newOwner) public onlyOwner {
    _transferOwnership(_newOwner);
  }
  
  function _transferOwnership(address _newOwner) internal {
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="74" endline="77" pcid="7553">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="74" endline="77" pcid="1307">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/JDC.sol" startline="64" endline="67" pcid="4341">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/JUNDCOIN.sol" startline="86" endline="89" pcid="4363">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="61" endline="66" pcid="4378">
    function transferOwnership(address _newOwner) public onlyOwner {
        require(_newOwner != address(0));
        newOwner = _newOwner;
    }

    function acceptOwnership() public onlyNewOwner returns(bool) {
</source>
<source file="systems/smart_contracts/LanceToken.sol" startline="90" endline="93" pcid="4521">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="74" endline="77" pcid="3418">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/XTRLPAY.sol" startline="90" endline="93" pcid="8138">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="70" endline="73" pcid="7436">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="74" endline="77" pcid="1253">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="68" endline="72" pcid="8161">
    function transferOwnership(address _newOwner) external onlyOwner {
        newOwner = _newOwner;
    }

    function acceptOwnership() external {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="178" endline="182" pcid="4657">
  function transferOwnership(address _newOwner) public onlyOwner {
    _transferOwnership(_newOwner);
  }

  function _transferOwnership(address _newOwner) internal {
</source>
<source file="systems/smart_contracts/MBA.sol" startline="159" endline="167" pcid="4712">
  function transferOwnership(address _newOwner) public onlyOwner {
    _transferOwnership(_newOwner);
  }

  /**
   * @dev Transfers control of the contract to a newOwner.
   * @param _newOwner The address to transfer ownership to.
   */
  function _transferOwnership(address _newOwner) internal {
</source>
<source file="systems/smart_contracts/Melodic.sol" startline="90" endline="93" pcid="4789">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/PositionTokenV2.sol" startline="155" endline="163" pcid="5756">
  function transferOwnership(address _newOwner) public onlyOwner {
    _transferOwnership(_newOwner);
  }

  /**
   * @dev Transfers control of the contract to a newOwner.
   * @param _newOwner The address to transfer ownership to.
   */
  function _transferOwnership(address _newOwner) internal {
</source>
<source file="systems/smart_contracts/Oracle.sol" startline="57" endline="65" pcid="5510">
  function transferOwnership(address _newOwner) public onlyOwner {
    _transferOwnership(_newOwner);
  }

  /**
   * @dev Transfers control of the contract to a newOwner.
   * @param _newOwner The address to transfer ownership to.
   */
  function _transferOwnership(address _newOwner) internal {
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="73" endline="76" pcid="5812">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/SolaToken.sol" startline="75" endline="78" pcid="6584">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/SapientiaCharlesToken.sol" startline="89" endline="92" pcid="6278">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="84" endline="87" pcid="406">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/TimeLockedTokenStorage.sol" startline="114" endline="122" pcid="7230">
    function transferOwnership(address _newOwner) public onlyOwner {
        _transferOwnership(_newOwner);
    }

    /**
     * @dev Transfers control of the contract to a newOwner.
     * @param _newOwner The address to transfer ownership to.
     */
    function _transferOwnership(address _newOwner) internal {
</source>
<source file="systems/smart_contracts/AICRYPTO.sol" startline="87" endline="90" pcid="429">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/NBToken.sol" startline="86" endline="94" pcid="5302">
    function transferOwnership(address _newOwner) public onlyOwner {
        _transferOwnership(_newOwner);
    }

    /**
     * @dev Transfers control of the contract to a newOwner.
     * @param _newOwner The address to transfer ownership to.
     */
    function _transferOwnership(address _newOwner) internal {
</source>
<source file="systems/smart_contracts/WanCoinToken.sol" startline="75" endline="78" pcid="7884">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/WanCoinSupplyToken.sol" startline="75" endline="78" pcid="7862">
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="165" endline="173" pcid="7175">
    function transferOwnership(address _newOwner) public onlyOwner {
        _transferOwnership(_newOwner);
    }

    /**
     * Transfers control of the contract to a newOwner.
     * @param _newOwner The address to transfer ownership to.
     */
    function _transferOwnership(address _newOwner) internal {
</source>
</class>

<class classid="18" nclones="2" nlines="12" similarity="91">
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="209" endline="231" pcid="235">
    function _startNewMiningEpoch() internal {
        //if max supply for the era will be exceeded next reward round then enter the new era before that happens
        //40 is the final reward era, almost all tokens minted
        //once the final era is reached, more tokens will not be given out because the assert function
        if (tokensMinted.add(getMiningReward()) > maxSupplyForEra && rewardEra < 39) {
            rewardEra = rewardEra + 1;
        }
        //set the next minted supply at which the era will change
        // total supply is 2100000000000  because of 8 decimal places
        maxSupplyForEra = _totalSupply - _totalSupply.div(2 ** (rewardEra + 1));
        epochCount = epochCount.add(1);
        //every so often, readjust difficulty. Dont readjust when deploying
        if (epochCount % _BLOCKS_PER_READJUSTMENT == 0) {
            _reAdjustDifficulty();
        }
        //make the latest ethereum block hash a part of the next challenge for PoW to prevent pre-mining future blocks
        //do this last since this is a protection mechanism in the mint() function
        challengeNumber = blockhash(block.number - 1);
    }
    //https://en.bitcoin.it/wiki/Difficulty#What_is_the_formula_for_difficulty.3F
    //as of 2017 the bitcoin difficulty was up to 17 zeroes, it was only 8 in the early days
    //readjust the target by 5 percent
    function _reAdjustDifficulty() internal {
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="357" endline="399" pcid="269">
    function _startNewMiningEpoch() internal {

      //if max supply for the era will be exceeded next reward round then enter the new era before that happens

      //40 is the final reward era, almost all tokens minted
      //once the final era is reached, more tokens will not be given out because the assert function
      if( tokensMinted.add(getMiningReward()) > maxSupplyForEra && rewardEra < 39)
      {
        rewardEra = rewardEra + 1;
      }

      //set the next minted supply at which the era will change
      // total supply is 10000000000000000  because of 8 decimal places
      maxSupplyForEra = _totalSupply - _totalSupply.div( 2**(rewardEra + 1));

      epochCount = epochCount.add(1);

      //every so often, readjust difficulty. Dont readjust when deploying
      if(epochCount % _BLOCKS_PER_READJUSTMENT == 0)
      {
        _reAdjustDifficulty();
      }


      //make the latest ethereum block hash a part of the next challenge for PoW to prevent pre-mining future blocks
      //do this last since this is a protection mechanism in the mint() function
      challengeNumber = block.blockhash(block.number - 1);






    }




    //https://en.Litecoin.it/wiki/Difficulty#What_is_the_formula_for_difficulty.3F
    //as of 2017 the Litecoin difficulty was up to 17 zeroes, it was only 8 in the early days

    //readjust the target by 5 percent
    function _reAdjustDifficulty() internal {
</source>
</class>

<class classid="19" nclones="2" nlines="22" similarity="100">
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="231" endline="262" pcid="236">
    function _reAdjustDifficulty() internal {
        uint ethBlocksSinceLastDifficultyPeriod = block.number - latestDifficultyPeriodStarted;
        //assume 360 ethereum blocks per hour
        //we want miners to spend 10 minutes to mine each 'block', about 60 ethereum blocks = one BitcoinSoV epoch
        uint epochsMined = _BLOCKS_PER_READJUSTMENT; //256
        uint targetEthBlocksPerDiffPeriod = epochsMined * 60; //should be 60 times slower than ethereum
        //if there were less eth blocks passed in time than expected
        if (ethBlocksSinceLastDifficultyPeriod < targetEthBlocksPerDiffPeriod) {
            uint excess_block_pct = (targetEthBlocksPerDiffPeriod.mul(100)).div(ethBlocksSinceLastDifficultyPeriod);
            uint excess_block_pct_extra = excess_block_pct.sub(100).limitLessThan(1000);
            // If there were 5% more blocks mined than expected then this is 5.  If there were 100% more blocks mined than expected then this is 100.
            //make it harder
            miningTarget = miningTarget.sub(miningTarget.div(2000).mul(excess_block_pct_extra)); //by up to 50 %
        } else {
            uint shortage_block_pct = (ethBlocksSinceLastDifficultyPeriod.mul(100)).div(targetEthBlocksPerDiffPeriod);
            uint shortage_block_pct_extra = shortage_block_pct.sub(100).limitLessThan(1000); //always between 0 and 1000
            //make it easier
            miningTarget = miningTarget.add(miningTarget.div(2000).mul(shortage_block_pct_extra)); //by up to 50 %
        }
        latestDifficultyPeriodStarted = block.number;
        if (miningTarget < _MINIMUM_TARGET) //very difficult
        {
            miningTarget = _MINIMUM_TARGET;
        }
        if (miningTarget > _MAXIMUM_TARGET) //very easy
        {
            miningTarget = _MAXIMUM_TARGET;
        }
    }

    //this is a recent ethereum block hash, used to prevent pre-mining future blocks
    function getChallengeNumber() public view returns(bytes32) {
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="399" endline="446" pcid="270">
    function _reAdjustDifficulty() internal {


        uint ethBlocksSinceLastDifficultyPeriod = block.number - latestDifficultyPeriodStarted;
        //assume 360 ethereum blocks per hour

        //we want miners to spend 10 minutes to mine each 'block', about 60 ethereum blocks = one 0xLitecoin epoch
        uint epochsMined = _BLOCKS_PER_READJUSTMENT; //256

        uint targetEthBlocksPerDiffPeriod = epochsMined * 60; //should be 60 times slower than ethereum

        //if there were less eth blocks passed in time than expected
        if( ethBlocksSinceLastDifficultyPeriod < targetEthBlocksPerDiffPeriod )
        {
          uint excess_block_pct = (targetEthBlocksPerDiffPeriod.mul(100)).div( ethBlocksSinceLastDifficultyPeriod );

          uint excess_block_pct_extra = excess_block_pct.sub(100).limitLessThan(1000);
          // If there were 5% more blocks mined than expected then this is 5.  If there were 100% more blocks mined than expected then this is 100.

          //make it harder
          miningTarget = miningTarget.sub(miningTarget.div(2000).mul(excess_block_pct_extra));   //by up to 50 %
        }else{
          uint shortage_block_pct = (ethBlocksSinceLastDifficultyPeriod.mul(100)).div( targetEthBlocksPerDiffPeriod );

          uint shortage_block_pct_extra = shortage_block_pct.sub(100).limitLessThan(1000); //always between 0 and 1000

          //make it easier
          miningTarget = miningTarget.add(miningTarget.div(2000).mul(shortage_block_pct_extra));   //by up to 50 %
        }



        latestDifficultyPeriodStarted = block.number;

        if(miningTarget < _MINIMUM_TARGET) //very difficult
        {
          miningTarget = _MINIMUM_TARGET;
        }

        if(miningTarget > _MAXIMUM_TARGET) //very easy
        {
          miningTarget = _MAXIMUM_TARGET;
        }
    }


    //this is a recent ethereum block hash, used to prevent pre-mining future blocks
    function getChallengeNumber() public constant returns (bytes32) {
</source>
</class>

<class classid="20" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="262" endline="267" pcid="237">
    function getChallengeNumber() public view returns(bytes32) {
        return challengeNumber;
    }

    //the number of zeroes the digest of the PoW solution requires.  Auto adjusts
    function getMiningDifficulty() public view returns(uint) {
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="446" endline="451" pcid="271">
    function getChallengeNumber() public constant returns (bytes32) {
        return challengeNumber;
    }

    //the number of zeroes the digest of the PoW solution requires.  Auto adjusts
     function getMiningDifficulty() public constant returns (uint) {
</source>
</class>

<class classid="21" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="267" endline="271" pcid="238">
    function getMiningDifficulty() public view returns(uint) {
        return _MAXIMUM_TARGET.div(miningTarget);
    }

    function getMiningTarget() public view returns(uint) {
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="451" endline="455" pcid="272">
     function getMiningDifficulty() public constant returns (uint) {
        return _MAXIMUM_TARGET.div(miningTarget);
    }

    function getMiningTarget() public constant returns (uint) {
</source>
</class>

<class classid="22" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="271" endline="277" pcid="239">
    function getMiningTarget() public view returns(uint) {
        return miningTarget;
    }

    //0.021m coins total
    //reward begins at 2 and is cut in half every reward era (as tokens are mined)
    function getMiningReward() public view returns(uint) {
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="455" endline="463" pcid="273">
    function getMiningTarget() public constant returns (uint) {
       return miningTarget;
   }



    //84m coins total
    //reward begins at 50 and is cut in half every reward era (as tokens are mined)
    function getMiningReward() public constant returns (uint) {
</source>
</class>

<class classid="23" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="284" endline="290" pcid="241">
    function getMintDigest(uint256 nonce, bytes32 challenge_digest, bytes32 challenge_number) public view returns(bytes32 digesttest) {
        bytes32 digest = keccak256(abi.encodePacked(challenge_number, msg.sender, nonce));
        return digest;
    }

    //help debug mining software
    function checkMintSolution(uint256 nonce, bytes32 challenge_digest, bytes32 challenge_number, uint testTarget) public view returns(bool success) {
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="473" endline="482" pcid="275">
    function getMintDigest(uint256 nonce, bytes32 challenge_digest, bytes32 challenge_number) public view returns (bytes32 digesttest) {

        bytes32 digest = keccak256(challenge_number,msg.sender,nonce);

        return digest;

      }

        //help debug mining software
      function checkMintSolution(uint256 nonce, bytes32 challenge_digest, bytes32 challenge_number, uint testTarget) public view returns (bool success) {
</source>
</class>

<class classid="24" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="290" endline="300" pcid="242">
    function checkMintSolution(uint256 nonce, bytes32 challenge_digest, bytes32 challenge_number, uint testTarget) public view returns(bool success) {
        bytes32 digest = keccak256(abi.encodePacked(challenge_number, msg.sender, nonce));
        if (uint256(digest) > testTarget) revert();
        return (digest == challenge_digest);
    }

    // ------------------------------------------------------------------------
    // Total supply
    // ------------------------------------------------------------------------

    function totalSupply() public view returns(uint) {
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="482" endline="500" pcid="276">
      function checkMintSolution(uint256 nonce, bytes32 challenge_digest, bytes32 challenge_number, uint testTarget) public view returns (bool success) {

          bytes32 digest = keccak256(challenge_number,msg.sender,nonce);

          if(uint256(digest) > testTarget) revert();

          return (digest == challenge_digest);

        }



    // ------------------------------------------------------------------------

    // Total supply

    // ------------------------------------------------------------------------

    function totalSupply() public constant returns (uint) {
</source>
</class>

<class classid="25" nclones="41" nlines="4" similarity="75">
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="300" endline="308" pcid="243">
    function totalSupply() public view returns(uint) {
        return _totalSupply - balances[address(0)];
    }

    // ------------------------------------------------------------------------
    // Get the token balance for account `tokenOwner`
    // ------------------------------------------------------------------------

    function balanceOf(address tokenOwner) public view returns(uint balance) {
</source>
<source file="systems/smart_contracts/Melodic.sol" startline="132" endline="140" pcid="4791">
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/OSManagerToken.sol" startline="87" endline="91" pcid="5556">
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }

    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/VOTENOmodumtokenswapdotcom.sol" startline="132" endline="140" pcid="7842">
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/PAYCASH.sol" startline="131" endline="139" pcid="5619">
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/Perlin.sol" startline="135" endline="143" pcid="5649">
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account `tokenOwner`
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/FUNNYTOKEN.sol" startline="95" endline="99" pcid="3954">
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }

    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/LanceToken.sol" startline="132" endline="140" pcid="4523">
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="116" endline="124" pcid="5815">
    function totalSupply() public view returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public view returns (uint balance) {
</source>
<source file="systems/smart_contracts/SolaToken.sol" startline="119" endline="127" pcid="6586">
    function totalSupply() public view returns (uint) {
        return _totalSupply.sub(balances[address(0)]);
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account `tokenOwner`
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public view returns (uint balance) {
</source>
<source file="systems/smart_contracts/SAMPLE.sol" startline="131" endline="139" pcid="6255">
	function totalSupply() public view returns (uint) {
		return _totalSupply.sub(balances[address(0)]);
	}


	// ------------------------------------------------------------------------
	// Stop Trade
	// ------------------------------------------------------------------------
	function stopTrade() public onlyOwner {
</source>
<source file="systems/smart_contracts/WanCoinSupplyToken.sol" startline="119" endline="127" pcid="7864">
    function totalSupply() public view returns (uint) {
        return _totalSupply.sub(balances[address(0)]);
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account `tokenOwner`
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public view returns (uint balance) {
</source>
<source file="systems/smart_contracts/SapientiaCharlesToken.sol" startline="133" endline="141" pcid="6280">
    function totalSupply() public view returns (uint) {
        return _totalSupply.sub(balances[address(0)]);
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account `tokenOwner`
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public view returns (uint balance) {
</source>
<source file="systems/smart_contracts/KingToken.sol" startline="84" endline="88" pcid="4484">
    function totalSupply() public view returns (uint){
        return supply;
    }
	
	function frozenSupply() public view returns (uint){
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="106" endline="111" pcid="1232">
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/JUNDCOIN.sol" startline="128" endline="136" pcid="4365">
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/JDC.sol" startline="98" endline="104" pcid="4343">
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }



    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="113" endline="117" pcid="7555">
    function totalSupply() public view returns (uint) {
        return _totalSupply  - balances[address(0)];
    }

    function balanceOf(address tokenOwner) public view returns (uint balance) {
</source>
<source file="systems/smart_contracts/WanCoinToken.sol" startline="119" endline="127" pcid="7886">
    function totalSupply() public view returns (uint) {
        return _totalSupply.sub(balances[address(0)]);
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account `tokenOwner`
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public view returns (uint balance) {
</source>
<source file="systems/smart_contracts/FixedSupplyToken.sol" startline="133" endline="141" pcid="3609">
    function totalSupply() public view returns (uint) {
        return _totalSupply.sub(balances[address(0)]);
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account `tokenOwner`
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public view returns (uint balance) {
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="106" endline="111" pcid="3421">
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/XTRLPAY.sol" startline="132" endline="140" pcid="8140">
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="127" endline="135" pcid="409">
    function totalSupply() public view returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public view returns (uint balance) {
</source>
<source file="systems/smart_contracts/AICRYPTO.sol" startline="131" endline="139" pcid="431">
    function totalSupply() public view returns (uint) {
        return _totalSupply.sub(balances[address(0)]);
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account `tokenOwner`
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public view returns (uint balance) {
</source>
<source file="systems/smart_contracts/DGC.sol" startline="133" endline="141" pcid="2524">
    function totalSupply() public view returns (uint) {
        return _totalSupply.sub(balances[address(0)]);
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account `tokenOwner`
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public view returns (uint balance) {
</source>
<source file="systems/smart_contracts/BIBCOINID.sol" startline="132" endline="140" pcid="1208">
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="110" endline="118" pcid="2431">
    function totalSupply() public view returns (uint) {
        return _totalSupply.sub(balances[address(0)]);
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account `tokenOwner`
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public view returns (uint balance) {
</source>
<source file="systems/smart_contracts/VENT.sol" startline="98" endline="104" pcid="7686">
        function totalSupply() public view returns (uint){
        return _totalSupply * 10**uint(decimals);
        }
        // ------------------------------------------------------------------------
        // Get the token balance for account `tokenOwner`
        // ------------------------------------------------------------------------
        function balanceOf(address tokenOwner) public view returns (uint balance) {
</source>
<source file="systems/smart_contracts/GRAM.sol" startline="130" endline="138" pcid="4207">
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/GNB.sol" startline="171" endline="179" pcid="4132">
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/ContractCoffeeToken.sol" startline="129" endline="137" pcid="1984">
    function totalSupply() public view returns (uint) {
        return _totalSupply.sub(balances[address(0)]);
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account `tokenOwner`
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public view returns (uint balance) {
</source>
<source file="systems/smart_contracts/ContractCargoberToken.sol" startline="129" endline="137" pcid="1962">
    function totalSupply() public view returns (uint) {
        return _totalSupply.sub(balances[address(0)]);
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account `tokenOwner`
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public view returns (uint balance) {
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="500" endline="514" pcid="277">
    function totalSupply() public constant returns (uint) {

        return _totalSupply  - balances[address(0)];

    }



    // ------------------------------------------------------------------------

    // Get the token balance for account `tokenOwner`

    // ------------------------------------------------------------------------

    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/CGT.sol" startline="133" endline="141" pcid="1694">
    function totalSupply() public view returns (uint) {
        return _totalSupply.sub(balances[address(0)]);
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account `tokenOwner`
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public view returns (uint balance) {
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="106" endline="111" pcid="1256">
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/GFNX.sol" startline="141" endline="146" pcid="4105">
    function totalSupply() public view returns (uint) {
        return supply;
    }
 
    // Get the token balance for account `tokenOwner`
    function balanceOf(address tokenOwner) public view returns (uint balance) {
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="106" endline="111" pcid="1310">
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/AnxToken.sol" startline="131" endline="139" pcid="715">
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/MiniMeTokenFactory.sol" startline="309" endline="322" pcid="4814">
    function totalSupply() public constant returns (uint) {
        return totalSupplyAt(block.number);
    }


////////////////
// Query balance and totalSupply in History
////////////////

    /// @dev Queries the balance of `_owner` at a specific `_blockNumber`
    /// @param _owner The address from which the balance will be retrieved
    /// @param _blockNumber The block number when the balance is queried
    /// @return The balance at `_blockNumber`
    function balanceOfAt(address _owner, uint _blockNumber) public constant returns (uint) {
</source>
<source file="systems/smart_contracts/BEX.sol" startline="24" endline="28" pcid="1165">
	function totalSupply()public constant returns (uint) {
		return totalBEXSupply;
	}
	
	function balanceOf(address tokenOwner)public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="215" endline="221" pcid="8175">
    function totalSupply() external view returns (uint) {
        return _totalSupply.sub(balances[address(0)]);
    }

    // ------------------------------------------------------------------------
    // Get the token balance for account `tokenOwner`
    function balanceOf(address owner) public view returns (uint256) {
</source>
</class>

<class classid="26" nclones="42" nlines="4" similarity="75">
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="308" endline="318" pcid="244">
    function balanceOf(address tokenOwner) public view returns(uint balance) {
        return balances[tokenOwner];
    }

    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to `to` account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------

    function transfer(address to, uint tokens) public returns(bool success) {
</source>
<source file="systems/smart_contracts/ProofOfContributionChainToken.sol" startline="29" endline="33" pcid="5824">
    function balanceOf(address tokenOwner) public view returns (uint) {
        return balances[tokenOwner];
    }

    function transfer(address receiver, uint numTokens) public returns (bool) {
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="124" endline="134" pcid="5816">
    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to to account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Perlin.sol" startline="143" endline="153" pcid="5650">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to `to` account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/PAYCASH.sol" startline="139" endline="149" pcid="5620">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to to account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/OSManagerToken.sol" startline="91" endline="95" pcid="5557">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }

    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Melodic.sol" startline="140" endline="150" pcid="4792">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to to account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BIBCOINID.sol" startline="140" endline="150" pcid="1209">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to to account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="120" endline="130" pcid="7440">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to to account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/LanceToken.sol" startline="140" endline="150" pcid="4524">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to to account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/KingToken.sol" startline="118" endline="124" pcid="4492">
    function balanceOf(address tokenOwner) public view returns (uint balance){
        return balances[tokenOwner];
    }
    // ------------------------------------------------------------------------
    // Public Function to transfer tokens
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success){
</source>
<source file="systems/smart_contracts/JUNDCOIN.sol" startline="136" endline="146" pcid="4366">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to to account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/JDC.sol" startline="104" endline="110" pcid="4344">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }



    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="117" endline="121" pcid="7556">
    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return balances[tokenOwner];
    }

    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/GRAM.sol" startline="138" endline="148" pcid="4208">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to to account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/VACCToken.sol" startline="143" endline="153" pcid="7627">
    function balanceOf(address tokenOwner) public constant returns (uint256 balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to to account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint256 tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/GNB.sol" startline="179" endline="183" pcid="4133">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }

    function checkRate(uint unlockIndex) public constant returns (uint rate_ ){
</source>
<source file="systems/smart_contracts/GFNX.sol" startline="146" endline="151" pcid="4106">
    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return _balances[tokenOwner];
    }
 
    // Get the allowance of funds beteen a token holder and a spender
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="514" endline="532" pcid="278">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {

        return balances[tokenOwner];

    }



    // ------------------------------------------------------------------------

    // Transfer the balance from token owner's account to `to` account

    // - Owner's account must have sufficient balance to transfer

    // - 0 value transfers are allowed

    // ------------------------------------------------------------------------

    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/VENT.sol" startline="104" endline="112" pcid="7687">
        function balanceOf(address tokenOwner) public view returns (uint balance) {
            return balances[tokenOwner];
        }
        // ------------------------------------------------------------------------
        // Transfer the balance from token owner's account `to` account
        // - Owner's account must have sufficient balance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/FUNNYTOKEN.sol" startline="99" endline="103" pcid="3955">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }

    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/VOTENOmodumtokenswapdotcom.sol" startline="140" endline="150" pcid="7843">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to to account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/WanCoinSupplyToken.sol" startline="127" endline="137" pcid="7865">
    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to `to` account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/WanCoinToken.sol" startline="127" endline="137" pcid="7887">
    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to `to` account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/FixedSupplyToken.sol" startline="141" endline="151" pcid="3610">
    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to `to` account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="111" endline="116" pcid="3422">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/XTRLPAY.sol" startline="140" endline="150" pcid="8141">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to to account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BEX.sol" startline="28" endline="32" pcid="1166">
	function balanceOf(address tokenOwner)public constant returns (uint balance) {
		return balances[tokenOwner];
	}

	function transfer(address to, uint tokens)public returns (bool success) {
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="135" endline="145" pcid="410">
    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to to account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/AICRYPTO.sol" startline="139" endline="149" pcid="432">
    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to `to` account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="111" endline="116" pcid="1311">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/DGC.sol" startline="141" endline="151" pcid="2525">
    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to `to` account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="118" endline="128" pcid="2432">
    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to `to` account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ContractCoffeeToken.sol" startline="137" endline="147" pcid="1985">
    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to `to` account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ContractCargoberToken.sol" startline="137" endline="147" pcid="1963">
    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to `to` account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SapientiaCharlesToken.sol" startline="141" endline="151" pcid="6281">
    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to `to` account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/CGT.sol" startline="141" endline="151" pcid="1695">
    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to `to` account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SAMPLE.sol" startline="157" endline="167" pcid="6258">
	function balanceOf(address tokenOwner) public view returns (uint balance) {
		return balances[tokenOwner];
	}


	// ------------------------------------------------------------------------
	// Transfer the balance from token owner's account to `to` account
	// - Owner's account must have sufficient balance to transfer
	// - 0 value transfers are allowed
	// ------------------------------------------------------------------------
	function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SolaToken.sol" startline="127" endline="137" pcid="6587">
    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to `to` account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="111" endline="116" pcid="1257">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/AnxToken.sol" startline="139" endline="149" pcid="716">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to to account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="111" endline="116" pcid="1233">
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    function transfer(address to, uint tokens) public returns (bool success) {
</source>
</class>

<class classid="27" nclones="40" nlines="4" similarity="75">
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="344" endline="360" pcid="246">
    function approve(address spender, uint tokens) public returns(bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

    // ------------------------------------------------------------------------
    // Transfer `tokens` from the `from` account to the `to` account
    //
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the `from` account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------

    function transferFrom(address from, address to, uint tokens) public returns(bool success) {
</source>
<source file="systems/smart_contracts/VACCToken.sol" startline="171" endline="187" pcid="7629">
    function approve(address spender, uint256 tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint256 tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/GNB.sol" startline="253" endline="268" pcid="4136">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/VENT.sol" startline="132" endline="145" pcid="7689">
        function approve(address spender, uint tokens) public returns (bool success){
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender,spender,tokens);
            return true;
        }
        // ------------------------------------------------------------------------
        // Transfer `tokens` from the `from` account to the `to` account
        // The calling account must already have sufficient tokens approve(...)
        // for spending from the `from` account and
        // - From account must have sufficient balance to transfer
        // - Spender must have sufficient allowance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transferFrom(address from, address to, uint tokens) public returns (bool success){
</source>
<source file="systems/smart_contracts/FUNNYTOKEN.sol" startline="110" endline="116" pcid="3957">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/VOTENOmodumtokenswapdotcom.sol" startline="166" endline="182" pcid="7845">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    //
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/WanCoinSupplyToken.sol" startline="153" endline="169" pcid="7867">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer `tokens` from the `from` account to the `to` account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the `from` account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/WanCoinToken.sol" startline="153" endline="169" pcid="7889">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer `tokens` from the `from` account to the `to` account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the `from` account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/GoaToken.sol" startline="161" endline="175" pcid="4156">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowance[msg.sender][spender] = tokens;

        emit Approval(msg.sender, spender, tokens);

        return true;
    }

    //-- transferFrom
    // Transfer "tokens" tokens from the "from" account to the "to" account
    // From account must have sufficient balance to transfer
    // Spender must have sufficient allowance to transfer
    // 0 value transfers are allowed

    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/FixedSupplyToken.sol" startline="167" endline="183" pcid="3612">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer `tokens` from the `from` account to the `to` account
    //
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the `from` account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="124" endline="131" pcid="3424">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }


    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/GRAM.sol" startline="164" endline="180" pcid="4210">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/XTRLPAY.sol" startline="166" endline="182" pcid="8143">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="161" endline="177" pcid="412">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/AICRYPTO.sol" startline="165" endline="181" pcid="434">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer `tokens` from the `from` account to the `to` account
    //
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the `from` account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="129" endline="136" pcid="7558">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/DGC.sol" startline="167" endline="183" pcid="2527">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer `tokens` from the `from` account to the `to` account
    //
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the `from` account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="141" endline="154" pcid="2434">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer `tokens` from the `from` account to the `to` account
    //
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the `from` account and
    
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ContractCoffeeToken.sol" startline="163" endline="179" pcid="1987">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer `tokens` from the `from` account to the `to` account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the `from` account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Perlin.sol" startline="169" endline="185" pcid="5652">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer `tokens` from the `from` account to the `to` account
    //
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the `from` account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ContractCargoberToken.sol" startline="163" endline="179" pcid="1965">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer `tokens` from the `from` account to the `to` account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the `from` account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/CGT.sol" startline="167" endline="183" pcid="1697">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer `tokens` from the `from` account to the `to` account
    //
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the `from` account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="150" endline="166" pcid="5818">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SolaToken.sol" startline="153" endline="169" pcid="6589">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer `tokens` from the `from` account to the `to` account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the `from` account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SAMPLE.sol" startline="186" endline="205" pcid="6260">
	function approve(address spender, uint tokens) public returns (bool success) {
		require(_stopTrade != true);
		require(msg.sender != spender);

		allowed[msg.sender][spender] = tokens;
		emit Approval(msg.sender, spender, tokens);
		return true;
	}


	// ------------------------------------------------------------------------
	// Transfer `tokens` from the `from` account to the `to` account
	//
	// The calling account must already have sufficient tokens approve(...)-d
	// for spending from the `from` account and
	// - From account must have sufficient balance to transfer
	// - Spender must have sufficient allowance to transfer
	// - 0 value transfers are allowed
	// ------------------------------------------------------------------------
	function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SapientiaCharlesToken.sol" startline="167" endline="183" pcid="6283">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer `tokens` from the `from` account to the `to` account
    //
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the `from` account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="146" endline="162" pcid="7442">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="124" endline="131" pcid="1235">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }


    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Melodic.sol" startline="166" endline="182" pcid="4794">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="124" endline="131" pcid="1313">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }


    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/PAYCASH.sol" startline="165" endline="181" pcid="5622">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/OSManagerToken.sol" startline="102" endline="108" pcid="5559">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BIBCOINID.sol" startline="166" endline="182" pcid="1211">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BEX.sol" startline="60" endline="66" pcid="1169">
	function approve(address spender, uint tokens)public returns (bool success) {
		allowed[msg.sender][spender] = tokens;
		emit Approval(msg.sender, spender, tokens);
		return true;
	}
	
	function allowance(address tokenOwner, address spender)public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="124" endline="131" pcid="1259">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }


    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/JDC.sol" startline="119" endline="126" pcid="4346">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="562" endline="592" pcid="280">
    function approve(address spender, uint tokens) public returns (bool success) {

        allowed[msg.sender][spender] = tokens;

        Approval(msg.sender, spender, tokens);

        return true;

    }



    // ------------------------------------------------------------------------

    // Transfer `tokens` from the `from` account to the `to` account

    //

    // The calling account must already have sufficient tokens approve(...)-d

    // for spending from the `from` account and

    // - From account must have sufficient balance to transfer

    // - Spender must have sufficient allowance to transfer

    // - 0 value transfers are allowed

    // ------------------------------------------------------------------------

    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/AnxToken.sol" startline="165" endline="181" pcid="718">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/LanceToken.sol" startline="166" endline="182" pcid="4526">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/JUNDCOIN.sol" startline="162" endline="178" pcid="4368">
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
</source>
</class>

<class classid="28" nclones="41" nlines="4" similarity="75">
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="377" endline="387" pcid="248">
    function allowance(address tokenOwner, address spender) public view returns(uint remaining) {
        return allowed[tokenOwner][spender];
    }

    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account. The `spender` contract function
    // `receiveApproval(...)` is then executed
    // ------------------------------------------------------------------------

    function approveAndCall(address spender, uint tokens, bytes memory data) public returns(bool success) {
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="140" endline="145" pcid="1261">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="140" endline="145" pcid="1315">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ContractCoffeeToken.sol" startline="192" endline="202" pcid="1989">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account. The `spender` contract function
    // `receiveApproval(...)` is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/AnxToken.sol" startline="194" endline="204" pcid="720">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/FixedSupplyToken.sol" startline="196" endline="206" pcid="3614">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account. The `spender` contract function
    // `receiveApproval(...)` is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BEX.sol" startline="66" endline="70" pcid="1170">
	function allowance(address tokenOwner, address spender)public constant returns (uint remaining) {
		return allowed[tokenOwner][spender];
	}
	
	event Transfer(address indexed from, address indexed to, uint tokens);//transfer方法调用时的通知事件
</source>
<source file="systems/smart_contracts/GNB.sol" startline="280" endline="290" pcid="4138">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="140" endline="145" pcid="3426">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="616" endline="634" pcid="282">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {

        return allowed[tokenOwner][spender];

    }



    // ------------------------------------------------------------------------

    // Token owner can approve for `spender` to transferFrom(...) `tokens`

    // from the token owner's account. The `spender` contract function

    // `receiveApproval(...)` is then executed

    // ------------------------------------------------------------------------

    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/VACCToken.sol" startline="203" endline="213" pcid="7631">
    function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint256 tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BIBCOINID.sol" startline="195" endline="205" pcid="1213">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/WanCoinToken.sol" startline="182" endline="192" pcid="7891">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account. The `spender` contract function
    // `receiveApproval(...)` is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/WanCoinSupplyToken.sol" startline="182" endline="192" pcid="7869">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account. The `spender` contract function
    // `receiveApproval(...)` is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/GRAM.sol" startline="193" endline="203" pcid="4212">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/XTRLPAY.sol" startline="195" endline="205" pcid="8145">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/VOTENOmodumtokenswapdotcom.sol" startline="195" endline="205" pcid="7847">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="145" endline="150" pcid="7560">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="190" endline="200" pcid="414">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="140" endline="145" pcid="1237">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/JDC.sol" startline="136" endline="142" pcid="4348">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/AICRYPTO.sol" startline="194" endline="204" pcid="436">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account. The `spender` contract function
    // `receiveApproval(...)` is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/JUNDCOIN.sol" startline="191" endline="201" pcid="4370">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/KingToken.sol" startline="50" endline="57" pcid="4481">
    function allowance(address tokenOwner, address spender) public view returns(uint){
        return allowed[tokenOwner][spender];
    }
    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns(bool){
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="175" endline="185" pcid="7444">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/DGC.sol" startline="196" endline="206" pcid="2529">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account. The `spender` contract function
    // `receiveApproval(...)` is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ContractCargoberToken.sol" startline="192" endline="202" pcid="1967">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account. The `spender` contract function
    // `receiveApproval(...)` is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/LanceToken.sol" startline="195" endline="205" pcid="4528">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/GFNX.sol" startline="151" endline="156" pcid="4107">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return _allowed[tokenOwner][spender];
    }
 
    // Transfer the balance from owner's account to another account
    function transfer(address to, uint value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/CGT.sol" startline="196" endline="206" pcid="1699">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account. The `spender` contract function
    // `receiveApproval(...)` is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/FUNNYTOKEN.sol" startline="124" endline="128" pcid="3959">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }

    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/VENT.sol" startline="164" endline="174" pcid="7691">
        function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
            return allowed[tokenOwner][spender];
        }
        // ------------------------------------------------------------------------
        // Transfer the balance from token owner's account to `to` account
        // - Owner's account must have sufficient balance to transfer
        // - 0 value transfers are allowed
        // - takes in locking Period to lock the tokens to be used
        // - if want to transfer without locking enter 0 in lockingPeriod argument 
        // ------------------------------------------------------------------------
        function distributeTokens(address to, uint tokens, uint256 lockingPeriod) onlyOwner public returns (bool success) {
</source>
<source file="systems/smart_contracts/Perlin.sol" startline="198" endline="208" pcid="5654">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account. The `spender` contract function
    // `receiveApproval(...)` is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SapientiaCharlesToken.sol" startline="196" endline="206" pcid="6285">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account. The `spender` contract function
    // `receiveApproval(...)` is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="167" endline="173" pcid="2436">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


   
    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/PAYCASH.sol" startline="194" endline="204" pcid="5624">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/OSManagerToken.sol" startline="116" endline="120" pcid="5561">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }

    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SAMPLE.sol" startline="224" endline="236" pcid="6262">
	function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
		require(_stopTrade != true);

		return allowed[tokenOwner][spender];
	}


	// ------------------------------------------------------------------------
	// Token owner can approve for `spender` to transferFrom(...) `tokens`
	// from the token owner's account. The `spender` contract function
	// `receiveApproval(...)` is then executed
	// ------------------------------------------------------------------------
	function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SolaToken.sol" startline="182" endline="192" pcid="6591">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account. The `spender` contract function
    // `receiveApproval(...)` is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Melodic.sol" startline="195" endline="205" pcid="4796">
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="179" endline="189" pcid="5820">
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
</source>
</class>

<class classid="29" nclones="9" nlines="4" similarity="75">
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="387" endline="398" pcid="249">
    function approveAndCall(address spender, uint tokens, bytes memory data) public returns(bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);
        return true;
    }

    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------

    function () external payable {
</source>
<source file="systems/smart_contracts/SapientiaCharlesToken.sol" startline="206" endline="217" pcid="6286">
    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () external payable {
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="150" endline="161" pcid="7561">
    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () external payable {
</source>
<source file="systems/smart_contracts/GoaToken.sol" startline="190" endline="205" pcid="4158">
    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
        allowance[msg.sender][spender] = tokens;

        emit Approval(msg.sender, spender, tokens);

        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);

        return true;
    }

    //-- mint
    // Transfer ETH to receive a given amount of tokens in exchange
    // Token amount must be integers, no decimals
    // Current token cost is determined through computeCost, frontend sets the proper ETH amount to send

    function mint(uint fullToken) public payable {
</source>
<source file="systems/smart_contracts/DGC.sol" startline="206" endline="217" pcid="2530">
    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () external payable {
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="173" endline="184" pcid="2437">
    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () external payable {
</source>
<source file="systems/smart_contracts/CGT.sol" startline="206" endline="217" pcid="1700">
    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () external payable {
</source>
<source file="systems/smart_contracts/AICRYPTO.sol" startline="204" endline="215" pcid="437">
    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () external payable {
</source>
<source file="systems/smart_contracts/FixedSupplyToken.sol" startline="206" endline="217" pcid="3615">
    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () external payable {
</source>
</class>

<class classid="30" nclones="39" nlines="4" similarity="75">
<source file="systems/smart_contracts/_0xSatoshi.sol" startline="406" endline="410" pcid="251">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns(bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }

}
</source>
<source file="systems/smart_contracts/WanCoinSupplyToken.sol" startline="211" endline="214" pcid="7872">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/WanCoinToken.sol" startline="211" endline="214" pcid="7894">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="208" endline="211" pcid="5823">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/FixedSupplyToken.sol" startline="225" endline="228" pcid="3617">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="158" endline="161" pcid="3429">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/XTRLPAY.sol" startline="224" endline="227" pcid="8148">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="158" endline="161" pcid="1240">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="219" endline="222" pcid="417">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/AnxToken.sol" startline="223" endline="226" pcid="723">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/VOTENOmodumtokenswapdotcom.sol" startline="224" endline="227" pcid="7850">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/FUNNYTOKEN.sol" startline="139" endline="142" pcid="3962">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/VACCToken.sol" startline="232" endline="235" pcid="7634">
    function transferAnyERC20Token(address tokenAddress, uint256 tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/GNB.sol" startline="308" endline="315" pcid="4141">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
    
    // ------------------------------------------------------------------------
    // Owner can add an increase total supply.
    // ------------------------------------------------------------------------
	function totalSupplyIncrease(uint256 _supply) public onlyOwner{
</source>
<source file="systems/smart_contracts/GoaToken.sol" startline="289" endline="292" pcid="4165">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/GRAM.sol" startline="222" endline="225" pcid="4215">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="169" endline="173" pcid="7563">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
    
    function destruct() onlyOwner public{
</source>
<source file="systems/smart_contracts/CGT.sol" startline="225" endline="228" pcid="1702">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/JDC.sol" startline="157" endline="160" pcid="4351">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/JUNDCOIN.sol" startline="220" endline="223" pcid="4373">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="668" endline="674" pcid="285">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {

        return ERC20Interface(tokenAddress).transfer(owner, tokens);

    }

}
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="158" endline="161" pcid="1318">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="204" endline="207" pcid="7447">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/Perlin.sol" startline="237" endline="240" pcid="5657">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/ContractCargoberToken.sol" startline="221" endline="224" pcid="1970">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/LanceToken.sol" startline="224" endline="227" pcid="4531">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/ContractCoffeeToken.sol" startline="221" endline="224" pcid="1992">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="158" endline="161" pcid="1264">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="192" endline="198" pcid="2439">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
    
    
    
     mapping(address => uint) ShareStatus;
</source>
<source file="systems/smart_contracts/DGC.sol" startline="225" endline="228" pcid="2532">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/SapientiaCharlesToken.sol" startline="225" endline="228" pcid="6288">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/SAMPLE.sol" startline="258" endline="266" pcid="6265">
	function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
		return ERC20Interface(tokenAddress).transfer(owner, tokens);
	}


	// ------------------------------------------------------------------------
	// Burns a specific amount of tokens.
	// ------------------------------------------------------------------------
	function burn(uint256 tokens) public {
</source>
<source file="systems/smart_contracts/SolaToken.sol" startline="211" endline="214" pcid="6594">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/Melodic.sol" startline="224" endline="227" pcid="4799">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/OSManagerToken.sol" startline="131" endline="134" pcid="5564">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/BIBCOINID.sol" startline="224" endline="227" pcid="1216">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="277" endline="285" pcid="8182">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }

    /* ------------------------------------------------------------------------
     * The following functions are for 1404 interface compliance, to detect
     * a transaction is allowed before sending, to save gas and obtain a clear Message
    */
    function detectTransferRestriction (address _from, address _to, uint256 _value) public view returns (uint8 restrictionCode)
</source>
<source file="systems/smart_contracts/PAYCASH.sol" startline="223" endline="226" pcid="5627">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
<source file="systems/smart_contracts/AICRYPTO.sol" startline="223" endline="226" pcid="439">
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}
</source>
</class>

<class classid="31" nclones="27" nlines="4" similarity="75">
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="161" endline="168" pcid="264">
    function Owned() public {

        owner = msg.sender;

    }


    modifier onlyOwner {
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="64" endline="68" pcid="5811">
    function Owned2() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="65" endline="69" pcid="1228">
    function Owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
</source>
<source file="systems/smart_contracts/BEX.sol" startline="105" endline="112" pcid="1172">
    function BEX() public {
	
		owner = msg.sender;
    }
	

	
	function sendByOwner(address _to, uint256 _value) public {
</source>
<source file="systems/smart_contracts/BDAM.sol" startline="64" endline="72" pcid="1112">
  function Ownable() {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/BatchTransfer.sol" startline="14" endline="18" pcid="1085">
    function BatchTransfer() public{
        owner=msg.sender;
    }
    
    function changeOwner(address _newOwner) onlyOwner{
</source>
<source file="systems/smart_contracts/Perlin.sol" startline="81" endline="85" pcid="5645">
    function Owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
</source>
<source file="systems/smart_contracts/Ownable.sol" startline="45" endline="49" pcid="5569">
  function Ownable() public {
    owner = msg.sender;
  }

  modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/OMGToken.sol" startline="204" endline="212" pcid="5498">
  function Ownable() {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/MyAdvancedToken.sol" startline="10" endline="14" pcid="5259">
    function owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
</source>
<source file="systems/smart_contracts/MpctLockupTeam.sol" startline="39" endline="43" pcid="5058">
    function Ownable() public {
        owner = msg.sender;
    }

    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="134" endline="142" pcid="4842">
  function Ownable() {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="61" endline="65" pcid="7435">
    function Owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
</source>
<source file="systems/smart_contracts/TrueProfileLogic.sol" startline="18" endline="22" pcid="7490">
    function Accessible() public {
        owner = msg.sender;
    }

    modifier ownership() {
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="198" endline="206" pcid="7756">
  function Ownable() public {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="134" endline="142" pcid="6082">
  function Ownable() {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="65" endline="69" pcid="1306">
    function Owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="39" endline="47" pcid="2093">
  function Ownable() {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="65" endline="69" pcid="1252">
    function Owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
</source>
<source file="systems/smart_contracts/CRYPTOMZ.sol" startline="54" endline="62" pcid="2176">
  function Constructor() public {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/Airdropper.sol" startline="10" endline="14" pcid="470">
  function Ownable() public {
    owner = msg.sender;
  }

  modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="75" endline="79" pcid="405">
    function Owned2() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
</source>
<source file="systems/smart_contracts/AronCoin.sol" startline="198" endline="206" pcid="772">
  function Ownable() public {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="65" endline="69" pcid="3417">
    function Owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
</source>
<source file="systems/smart_contracts/FlatPricingExt.sol" startline="25" endline="33" pcid="3630">
  function Ownable() {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/FMT.sol" startline="163" endline="170" pcid="3659">
  function Ownable() public {
    owner = msg.sender;
  }

  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/CRYPTOMZ.sol" startline="253" endline="258" pcid="2191">
    function Constructor () public {
        totalSupply = initialSupply;
        balances[msg.sender] = initialSupply; // Send all tokens to owner
    }

}
</source>
</class>

<class classid="32" nclones="35" nlines="4" similarity="75">
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="532" endline="562" pcid="279">
    function transfer(address to, uint tokens) public returns (bool success) {

        balances[msg.sender] = balances[msg.sender].sub(tokens);

        balances[to] = balances[to].add(tokens);

        Transfer(msg.sender, to, tokens);

        return true;

    }



    // ------------------------------------------------------------------------

    // Token owner can approve for `spender` to transferFrom(...) `tokens`

    // from the token owner's account

    //

    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md

    // recommends that there are no checks for the approval double-spend attack

    // as this should be implemented in user interfaces

    // ------------------------------------------------------------------------

    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/FUNNYTOKEN.sol" startline="103" endline="110" pcid="3956">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }

    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="116" endline="124" pcid="1258">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }


    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/FixedSupplyToken.sol" startline="151" endline="167" pcid="3611">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="121" endline="129" pcid="7557">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="116" endline="124" pcid="3423">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }


    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/GoaToken.sol" startline="145" endline="161" pcid="4155">
    function transfer(address to, uint tokens) public returns (bool success) {
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(tokens);
        balanceOf[to] = balanceOf[to].add(tokens);

        emit Transfer(msg.sender, to, tokens);

        return true;
    }

    //-- approve
    // Token owner can approve for "spender" to transferFrom(...) or burn(...) "tokens"
    // from the token owner's account
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces

    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/VOTENOmodumtokenswapdotcom.sol" startline="150" endline="166" pcid="7844">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/GRAM.sol" startline="148" endline="164" pcid="4209">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/JDC.sol" startline="110" endline="119" pcid="4345">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/WanCoinSupplyToken.sol" startline="137" endline="153" pcid="7866">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/CGT.sol" startline="151" endline="167" pcid="1696">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/WanCoinToken.sol" startline="137" endline="153" pcid="7888">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/XTRLPAY.sol" startline="150" endline="166" pcid="8142">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ContractCargoberToken.sol" startline="147" endline="163" pcid="1964">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ContractCoffeeToken.sol" startline="147" endline="163" pcid="1986">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="128" endline="141" pcid="2433">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account
    //
    
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="145" endline="161" pcid="411">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/DGC.sol" startline="151" endline="167" pcid="2526">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/AICRYPTO.sol" startline="149" endline="165" pcid="433">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="116" endline="124" pcid="1312">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }


    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BIBCOINID.sol" startline="150" endline="166" pcid="1210">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SolaToken.sol" startline="137" endline="153" pcid="6588">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SapientiaCharlesToken.sol" startline="151" endline="167" pcid="6282">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="134" endline="150" pcid="5817">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="116" endline="124" pcid="1234">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }


    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Perlin.sol" startline="153" endline="169" pcid="5651">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for `spender` to transferFrom(...) `tokens`
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/PAYCASH.sol" startline="149" endline="165" pcid="5621">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/JUNDCOIN.sol" startline="146" endline="162" pcid="4367">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/OSManagerToken.sol" startline="95" endline="102" pcid="5558">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }

    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Melodic.sol" startline="150" endline="166" pcid="4793">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="130" endline="146" pcid="7441">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/LanceToken.sol" startline="150" endline="166" pcid="4525">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SAMPLE.sol" startline="167" endline="186" pcid="6259">
	function transfer(address to, uint tokens) public returns (bool success) {
		require(_stopTrade != true || isOwner());
		require(to > address(0));

		balances[msg.sender] = balances[msg.sender].sub(tokens);
		balances[to] = balances[to].add(tokens);
		emit Transfer(msg.sender, to, tokens);
		return true;
	}


	// ------------------------------------------------------------------------
	// Token owner can approve for `spender` to transferFrom(...) `tokens`
	// from the token owner's account
	//
	// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
	// recommends that there are no checks for the approval double-spend attack
	// as this should be implemented in user interfaces
	// ------------------------------------------------------------------------
	function approve(address spender, uint tokens) public returns (bool success) {
</source>
<source file="systems/smart_contracts/AnxToken.sol" startline="149" endline="165" pcid="717">
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
</source>
</class>

<class classid="33" nclones="35" nlines="4" similarity="75">
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="592" endline="616" pcid="281">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {

        balances[from] = balances[from].sub(tokens);

        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);

        balances[to] = balances[to].add(tokens);

        Transfer(from, to, tokens);

        return true;

    }



    // ------------------------------------------------------------------------

    // Returns the amount of tokens approved by the owner that can be

    // transferred to the spender's account

    // ------------------------------------------------------------------------

    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/AnxToken.sol" startline="181" endline="194" pcid="719">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="131" endline="140" pcid="1260">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }


    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="131" endline="140" pcid="1314">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }


    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="177" endline="190" pcid="413">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
</source>
<source file="systems/smart_contracts/ContractCargoberToken.sol" startline="179" endline="192" pcid="1966">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = balances[from].sub(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
</source>
<source file="systems/smart_contracts/LanceToken.sol" startline="182" endline="195" pcid="4527">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="162" endline="175" pcid="7443">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/Melodic.sol" startline="182" endline="195" pcid="4795">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/OSManagerToken.sol" startline="108" endline="116" pcid="5560">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }

    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/AICRYPTO.sol" startline="181" endline="194" pcid="435">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = balances[from].sub(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
</source>
<source file="systems/smart_contracts/PAYCASH.sol" startline="181" endline="194" pcid="5623">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/Perlin.sol" startline="185" endline="198" pcid="5653">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/DGC.sol" startline="183" endline="196" pcid="2528">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = balances[from].sub(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
</source>
<source file="systems/smart_contracts/XTRLPAY.sol" startline="182" endline="195" pcid="8144">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="131" endline="140" pcid="3425">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }


    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/DemoBigPoint4.sol" startline="154" endline="167" pcid="2435">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = balances[from].sub(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
</source>
<source file="systems/smart_contracts/FUNNYTOKEN.sol" startline="116" endline="124" pcid="3958">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }

    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="166" endline="179" pcid="5819">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
</source>
<source file="systems/smart_contracts/FixedSupplyToken.sol" startline="183" endline="196" pcid="3613">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = balances[from].sub(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
</source>
<source file="systems/smart_contracts/WanCoinToken.sol" startline="169" endline="182" pcid="7890">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = balances[from].sub(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
</source>
<source file="systems/smart_contracts/WanCoinSupplyToken.sol" startline="169" endline="182" pcid="7868">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = balances[from].sub(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
</source>
<source file="systems/smart_contracts/BIBCOINID.sol" startline="182" endline="195" pcid="1212">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/SolaToken.sol" startline="169" endline="182" pcid="6590">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = balances[from].sub(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
</source>
<source file="systems/smart_contracts/VOTENOmodumtokenswapdotcom.sol" startline="182" endline="195" pcid="7846">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/SapientiaCharlesToken.sol" startline="183" endline="196" pcid="6284">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = balances[from].sub(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
</source>
<source file="systems/smart_contracts/ContractCoffeeToken.sol" startline="179" endline="192" pcid="1988">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = balances[from].sub(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
</source>
<source file="systems/smart_contracts/JUNDCOIN.sol" startline="178" endline="191" pcid="4369">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/JDC.sol" startline="126" endline="136" pcid="4347">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="136" endline="145" pcid="7559">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
</source>
<source file="systems/smart_contracts/GRAM.sol" startline="180" endline="193" pcid="4211">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/GoaToken.sol" startline="175" endline="190" pcid="4157">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balanceOf[from] = balanceOf[from].sub(tokens);
        allowance[from][msg.sender] = allowance[from][msg.sender].sub(tokens);
        balanceOf[to] = balanceOf[to].add(tokens);

        emit Transfer(from, to, tokens);

        return true;
    }

    //-- approveAndCall
    // Token owner can approve for "spender" to transferFrom(...) "tokens" tokens
    // from the token owner's account. The "spender" contract function
    // "receiveApproval(...)"" is then executed

    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
</source>
<source file="systems/smart_contracts/GNB.sol" startline="268" endline="280" pcid="4137">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }

    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/CGT.sol" startline="183" endline="196" pcid="1698">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = balances[from].sub(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="131" endline="140" pcid="1236">
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }


    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
</source>
</class>

<class classid="34" nclones="28" nlines="4" similarity="75">
<source file="systems/smart_contracts/_DrSebiToken.sol" startline="634" endline="654" pcid="283">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {

        allowed[msg.sender][spender] = tokens;

        Approval(msg.sender, spender, tokens);

        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);

        return true;

    }



    // ------------------------------------------------------------------------

    // Don't accept ETH

    // ------------------------------------------------------------------------

    function () public payable {
</source>
<source file="systems/smart_contracts/BIBCOINID.sol" startline="205" endline="216" pcid="1214">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/VOTENOmodumtokenswapdotcom.sol" startline="205" endline="216" pcid="7848">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/FUNNYTOKEN.sol" startline="128" endline="135" pcid="3960">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }

    function () public payable {
</source>
<source file="systems/smart_contracts/GNB.sol" startline="290" endline="301" pcid="4139">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/Bitrix.sol" startline="145" endline="153" pcid="1316">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    function () public payable {
</source>
<source file="systems/smart_contracts/GRAM.sol" startline="203" endline="214" pcid="4213">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/ContractCargoberToken.sol" startline="202" endline="213" pcid="1968">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/ContractCoffeeToken.sol" startline="202" endline="213" pcid="1990">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/JDC.sol" startline="142" endline="151" pcid="4349">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    
    function () public payable {
</source>
<source file="systems/smart_contracts/WanCoinSupplyToken.sol" startline="192" endline="203" pcid="7870">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/JUNDCOIN.sol" startline="201" endline="212" pcid="4371">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="185" endline="196" pcid="7445">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH ???????
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/AnxToken.sol" startline="204" endline="215" pcid="721">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/WanCoinToken.sol" startline="192" endline="203" pcid="7892">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/AHLE.sol" startline="200" endline="211" pcid="415">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/XTRLPAY.sol" startline="205" endline="216" pcid="8146">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/LanceToken.sol" startline="205" endline="216" pcid="4529">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/BitDigit.sol" startline="145" endline="153" pcid="1262">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    function () public payable {
</source>
<source file="systems/smart_contracts/Melodic.sol" startline="205" endline="216" pcid="4797">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/OSManagerToken.sol" startline="120" endline="127" pcid="5562">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }

    function () public payable {
</source>
<source file="systems/smart_contracts/SolaToken.sol" startline="192" endline="203" pcid="6592">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/PRIT.sol" startline="189" endline="200" pcid="5821">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/Perlin.sol" startline="208" endline="218" pcid="5655">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }

    // ------------------------------------------------------------------------
    // 3,250 Perlin per 1 ETH
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/PAYCASH.sol" startline="204" endline="215" pcid="5625">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
</source>
<source file="systems/smart_contracts/Exzie.sol" startline="145" endline="153" pcid="3427">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    function () public payable {
</source>
<source file="systems/smart_contracts/BitcoinDigital.sol" startline="145" endline="153" pcid="1238">
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    function () public payable {
</source>
<source file="systems/smart_contracts/VACCToken.sol" startline="213" endline="224" pcid="7632">
    function approveAndCall(address spender, uint256 tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
</source>
</class>

<class classid="35" nclones="21" nlines="4" similarity="75">
<source file="systems/smart_contracts/AACD.sol" startline="8" endline="14" pcid="286">
  function safeMul(uint256 a, uint256 b) public pure  returns (uint256)  {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SAS.sol" startline="8" endline="14" pcid="6289">
  function safeMul(uint256 a, uint256 b) public pure  returns (uint256)  {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SCMCoin.sol" startline="8" endline="14" pcid="6381">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/RETC.sol" startline="8" endline="14" pcid="6174">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PokaToken.sol" startline="63" endline="69" pcid="5736">
  function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SuperMarket.sol" startline="63" endline="69" pcid="6764">
  function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NMAI.sol" startline="8" endline="14" pcid="5438">
  function safeMul(uint256 a, uint256 b) public pure  returns (uint256)  {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NEM.sol" startline="8" endline="14" pcid="5316">
  function safeMul(uint256 a, uint256 b) public pure  returns (uint256)  {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MT.sol" startline="8" endline="14" pcid="5068">
  function safeMul(uint256 a, uint256 b) public pure  returns (uint256)  {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MpctLockupTeam.sol" startline="12" endline="18" pcid="5054">
    function mul(uint256 a, uint256 b) internal constant returns (uint256) {
        uint256 c = a * b;
        assert(a == 0 || c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal constant returns (uint256) {
</source>
<source file="systems/smart_contracts/UGCoin.sol" startline="8" endline="14" pcid="7523">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Hda.sol" startline="8" endline="14" pcid="4216">
  function safeMul(uint256 a, uint256 b) internal returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint256 a, uint256 b) internal returns (uint256) {
</source>
<source file="systems/smart_contracts/GoldenRings.sol" startline="13" endline="19" pcid="4166">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a * b;
        assert(a == 0 || c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DHF.sol" startline="8" endline="14" pcid="2533">
  function safeMul(uint256 a, uint256 b) public pure  returns (uint256)  {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CRYPTOMZ.sol" startline="12" endline="18" pcid="2172">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/AT.sol" startline="11" endline="17" pcid="787">
  function safeMul(uint256 a, uint256 b) internal returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint256 a, uint256 b) internal returns (uint256) {
</source>
<source file="systems/smart_contracts/BKN.sol" startline="115" endline="121" pcid="1331">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BDAM.sol" startline="22" endline="28" pcid="1108">
  function mul(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal constant returns (uint256) {
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="8" endline="14" pcid="1703">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a * b;
        assert(a == 0 || c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CAC.sol" startline="8" endline="14" pcid="1607">
  function safeMul(uint256 a, uint256 b) public pure  returns (uint256)  {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MultiSign.sol" startline="9" endline="15" pcid="5233">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a * b;
    require(a == 0 || c / a == b);
    return c;
  }
 
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
</class>

<class classid="36" nclones="146" nlines="4" similarity="75">
<source file="systems/smart_contracts/AACD.sol" startline="14" endline="21" pcid="287">
  function safeDiv(uint256 a, uint256 b)public pure returns (uint256) {
    assert(b > 0);
    uint256 c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SAS.sol" startline="14" endline="21" pcid="6290">
  function safeDiv(uint256 a, uint256 b)public pure returns (uint256) {
    assert(b > 0);
    uint256 c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PokaToken.sol" startline="69" endline="76" pcid="5737">
  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b > 0);
    uint256 c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CAC.sol" startline="14" endline="21" pcid="1608">
  function safeDiv(uint256 a, uint256 b)public pure returns (uint256) {
    assert(b > 0);
    uint256 c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SuperMarket.sol" startline="69" endline="76" pcid="6765">
  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b > 0);
    uint256 c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/AT.sol" startline="17" endline="24" pcid="788">
  function safeDiv(uint256 a, uint256 b) internal returns (uint256) {
    assert(b > 0);
    uint256 c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint256 a, uint256 b) internal returns (uint256) {
</source>
<source file="systems/smart_contracts/DHF.sol" startline="14" endline="21" pcid="2534">
  function safeDiv(uint256 a, uint256 b)public pure returns (uint256) {
    assert(b > 0);
    uint256 c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Hda.sol" startline="14" endline="21" pcid="4217">
  function safeDiv(uint256 a, uint256 b) internal returns (uint256) {
    assert(b > 0);
    uint256 c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint256 a, uint256 b) internal returns (uint256) {
</source>
<source file="systems/smart_contracts/LuckyAdvcedWoken.sol" startline="37" endline="44" pcid="4555">
  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b > 0);
    uint256 c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MAdvcedWoken.sol" startline="37" endline="44" pcid="4594">
  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b > 0);
    uint256 c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MT.sol" startline="14" endline="21" pcid="5069">
  function safeDiv(uint256 a, uint256 b)public pure returns (uint256) {
    assert(b > 0);
    uint256 c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NEM.sol" startline="14" endline="21" pcid="5317">
  function safeDiv(uint256 a, uint256 b)public pure returns (uint256) {
    assert(b > 0);
    uint256 c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NMAI.sol" startline="14" endline="21" pcid="5439">
  function safeDiv(uint256 a, uint256 b)public pure returns (uint256) {
    assert(b > 0);
    uint256 c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BACD.sol" startline="31" endline="38" pcid="1011">
  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BFGToken.sol" startline="18" endline="25" pcid="1178">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Comet.sol" startline="29" endline="34" pcid="1919">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CRYPTOMZ.sol" startline="18" endline="25" pcid="2173">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="29" endline="34" pcid="2151">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BKN.sol" startline="121" endline="128" pcid="1332">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="29" endline="34" pcid="3919">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="19" endline="26" pcid="1621">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;       
    }       

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="45" endline="52" pcid="7746">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="33" endline="38" pcid="2393">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/GameGold.sol" startline="78" endline="88" pcid="3987">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  /**
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/GoldenRings.sol" startline="19" endline="26" pcid="4167">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BANG.sol" startline="33" endline="38" pcid="1042">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="29" endline="34" pcid="6202">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BDAM.sol" startline="28" endline="35" pcid="1109">
  function div(uint256 a, uint256 b) internal constant returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal constant returns (uint256) {
</source>
<source file="systems/smart_contracts/UTC.sol" startline="30" endline="40" pcid="7572">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  /**
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/UGCoin.sol" startline="14" endline="19" pcid="7524">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SCMCoin.sol" startline="14" endline="19" pcid="6382">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SEA.sol" startline="17" endline="22" pcid="6392">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a / b;
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="20" endline="27" pcid="4375">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;       
    }       

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="14" endline="21" pcid="1704">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        
        uint256 c = a / b;
        
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="33" endline="38" pcid="1466">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/RETC.sol" startline="14" endline="19" pcid="6175">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SellableToken.sol" startline="17" endline="22" pcid="6456">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="29" endline="39" pcid="7449">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }

    /**
    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="31" endline="36" pcid="5991">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="29" endline="34" pcid="7317">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MpctLockupTeam.sol" startline="18" endline="23" pcid="5055">
    function div(uint256 a, uint256 b) internal constant returns (uint256) {
        uint256 c = a / b;
        return c;
    }

    function sub(uint256 a, uint256 b) internal constant returns (uint256) {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="78" endline="83" pcid="5094">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="33" endline="38" pcid="2553">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Byte.sol" startline="31" endline="36" pcid="1572">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NaorisToken.sol" startline="29" endline="39" pcid="5278">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }

    /**
    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/FMT.sol" startline="197" endline="204" pcid="3662">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NBToken.sol" startline="38" endline="47" pcid="5299">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }
    /**
     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Ownable.sol" startline="22" endline="27" pcid="5566">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BlockPoolToken.sol" startline="38" endline="47" pcid="1409">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }
    /**
     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="29" endline="34" pcid="2644">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="50" endline="55" pcid="3168">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/AronCoin.sol" startline="45" endline="52" pcid="762">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CST_TOKEN.sol" startline="27" endline="32" pcid="2198">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="318" endline="330" pcid="3260">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="100" endline="115" pcid="5412">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="71" endline="79" pcid="5333">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="171" endline="191" pcid="8233">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="41" endline="52" pcid="6825">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b > 0); // Solidity only automatically asserts when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold

    return c;
  }

  /**
  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="109" endline="121" pcid="8079">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
      // Solidity only automatically asserts when dividing by 0
      require(b > 0);
      uint256 c = a / b;
      // assert(a == b * c + a % b); // There is no case in which this doesn't hold

      return c;
  }

  /**
  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="37" endline="41" pcid="8041">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="75" endline="86" pcid="731">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0); // Solidity only automatically asserts when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="174" endline="184" pcid="3074">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    // uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return a / b;
  }

  /**
  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="24" endline="34" pcid="3513">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        // uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return a / b;
    }

    /**
    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NSTTeamLock.sol" startline="140" endline="152" pcid="5463">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Aigopay.sol" startline="40" endline="50" pcid="441">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        // uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return a / b;
    }

    /**
    * Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="16" endline="19" pcid="8007">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="33" endline="44" pcid="2977">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b > 0); // Solidity only automatically asserts when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold

    return c;
  }

  /**
  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="101" endline="113" pcid="5670">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Ethertime.sol" startline="15" endline="20" pcid="3300">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0);
        uint256 c = a / b;
        return c;
    }
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="28" endline="39" pcid="6710">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0); // Solidity only automatically asserts when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="32" endline="44" pcid="3544">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="32" endline="44" pcid="6304">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="49" endline="60" pcid="6974">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b > 0);
        uint256 c = a / b;
        assert(a == b * c + a % b);
        return a / b;
    }

    /**
     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
     * reverts when dividing by zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="33" endline="43" pcid="6675">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        // uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return a / b;
    }

    /*
    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="29" endline="40" pcid="7978">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b > 0); // Solidity only automatically asserts when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold

    return c;
  }

  /**
  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="28" endline="38" pcid="2946">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        // uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return a / b;
    }

    /**
    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="16" endline="19" pcid="2873">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MultiSendErc20.sol" startline="28" endline="40" pcid="5199">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="394" endline="414" pcid="5165">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="167" endline="187" pcid="484">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DNP.sol" startline="43" endline="50" pcid="2785">
    function div(uint256 a, uint256 b) internal pure returns (uint256) 
    {
        return a  / b;
    }
    /**
    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) 
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="168" endline="188" pcid="7020">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="72" endline="83" pcid="2740">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b > 0); // Solidity only automatically asserts when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold

    return c;
  }

  /**
  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="87" endline="107" pcid="8188">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="246" endline="266" pcid="954">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="210" endline="230" pcid="5783">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="33" endline="44" pcid="5833">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0); // Solidity only automatically asserts when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="253" endline="268" pcid="4992">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="92" endline="112" pcid="804">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="167" endline="187" pcid="524">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="78" endline="98" pcid="7170">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="27" endline="37" pcid="4951">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        // uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return a / b;
    }

    /**
    * Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="32" endline="44" pcid="4920">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="246" endline="266" pcid="2467">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/XGP.sol" startline="40" endline="50" pcid="8098">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        // uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return a / b;
    }

    /**
    * Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="181" endline="196" pcid="5912">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Token.sol" startline="32" endline="44" pcid="7252">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Subtracts two unsigned integers, reverts on underflow (i.e. if subtrahend is greater than minuend).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="88" endline="108" pcid="5951">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="38" endline="44" pcid="2303">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0);
        uint256 c = a / b;
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="28" endline="38" pcid="6543">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        // uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return a / b;
    }

    /**
    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Six.sol" startline="75" endline="95" pcid="6533">
     function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="33" endline="45" pcid="7265">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="246" endline="266" pcid="6026">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="31" endline="41" pcid="6477">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        // uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return a / b;
    }

    /**
    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="302" endline="322" pcid="4749">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="87" endline="99" pcid="570">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "Safe div error");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MBA.sol" startline="30" endline="40" pcid="4699">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    // uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return a / b;
  }

  /**
  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="26" endline="30" pcid="4642">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    return a / b;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DABANKING_SWAP.sol" startline="74" endline="86" pcid="2274">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // Solidity only automatically asserts when dividing by 0
    require(b > 0);
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold

    return c;
  }

  /**
   * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
   */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="62" endline="74" pcid="6413">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="159" endline="169" pcid="7347">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    // uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return a / b;
  }

  /**
  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/magesh.sol" startline="32" endline="44" pcid="4608">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="28" endline="39" pcid="2224">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0); // Solidity only automatically asserts when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TokenSwap.sol" startline="32" endline="44" pcid="7386">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TorexToken.sol" startline="34" endline="44" pcid="7404">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    // uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return a / b;
  }

  /**
  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/customIcoToken.sol" startline="19" endline="23" pcid="2209">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    return a / b;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/LuckyStrikeTokens.sol" startline="35" endline="45" pcid="4569">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        // uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return a / b;
    }

    /**
    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/LBBT.sol" startline="19" endline="23" pcid="4533">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    return a / b;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="76" endline="80" pcid="2047">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="89" endline="109" pcid="4418">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="37" endline="48" pcid="1878">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b > 0); // Solidity only automatically asserts when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold

    return c;
  }

  /**
  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CoinDDC.sol" startline="196" endline="201" pcid="1874">
    function div(uint256 a, uint256 b) internal pure returns (uint256) 
    {
        return a / b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) 
</source>
<source file="systems/smart_contracts/CNG.sol" startline="72" endline="83" pcid="1847">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b > 0); // Solidity only automatically asserts when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold

    return c;
  }

  /**
  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="168" endline="188" pcid="1753">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="165" endline="185" pcid="651">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CDS.sol" startline="27" endline="38" pcid="1654">
	function div(uint256 a, uint256 b) internal pure returns (uint256) {
		// Solidity only automatically asserts when dividing by 0
		require(b > 0);
		uint256 c = a / b;
		// assert(a == b * c + a % b); // There is no case in which this doesn't hold
		return c;
	}

	/**
		* @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
		*/
	function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="390" endline="410" pcid="321">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="39" endline="49" pcid="4294">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        // uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return a / b;
    }

    /**
    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ankara.sol" startline="48" endline="55" pcid="682">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0);
        uint256 c = a / b;

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BRZE.sol" startline="17" endline="22" pcid="1518">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b > 0);
    uint256 c = a / b;
    return c;
  }
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="41" endline="52" pcid="4230">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b > 0); // Solidity only automatically asserts when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold

    return c;
  }

  /**
  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Bridge.sol" startline="41" endline="53" pcid="1504">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BountyBoard.sol" startline="84" endline="103" pcid="1490">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }
    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="35" endline="45" pcid="1429">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        // uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return a / b;
    }

    /**
    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Governance.sol" startline="89" endline="109" pcid="4185">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="27" endline="37" pcid="1266">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        // uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return a / b;
    }

    /**
    * Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="60" endline="72" pcid="1366">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="70" endline="82" pcid="7642">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/GFNX.sol" startline="61" endline="72" pcid="4099">
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b > 0); // Solidity only automatically asserts when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold

    return c;
  }

  /**
  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="28" endline="39" pcid="7697">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0); // Solidity only automatically asserts when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="87" endline="107" pcid="4029">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="69" endline="77" pcid="7775">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="87" endline="107" pcid="7898">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Factory.sol" startline="165" endline="185" pcid="3438">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="92" endline="112" pcid="3759">
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Fk.sol" startline="75" endline="95" pcid="3621">
     function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
</class>

<class classid="37" nclones="162" nlines="4" similarity="75">
<source file="systems/smart_contracts/AACD.sol" startline="21" endline="26" pcid="288">
  function safeSub(uint256 a, uint256 b)public pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="45" endline="53" pcid="1430">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    /**
    * @dev Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="26" endline="31" pcid="1622">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="21" endline="26" pcid="1705">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BFGToken.sol" startline="25" endline="30" pcid="1179">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BKN.sol" startline="128" endline="133" pcid="1333">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BlockPoolToken.sol" startline="47" endline="54" pcid="1410">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }
    /**
     * @dev Adds two numbers, throws on overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BDAM.sol" startline="35" endline="40" pcid="1110">
  function sub(uint256 a, uint256 b) internal constant returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal constant returns (uint256) {
</source>
<source file="systems/smart_contracts/SafeMathLibExt.sol" startline="39" endline="44" pcid="6241">
  function minus(uint a, uint b) returns (uint) {
    assert(b <= a);
    return a - b;
  }

  function plus(uint a, uint b) returns (uint) {
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="34" endline="39" pcid="6203">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SCMCoin.sol" startline="19" endline="24" pcid="6383">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SEA.sol" startline="22" endline="27" pcid="6393">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/RETC.sol" startline="19" endline="24" pcid="6176">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SellableToken.sol" startline="22" endline="27" pcid="6457">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="41" endline="49" pcid="6478">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    /**
    * @dev Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="87" endline="92" pcid="6076">
  function safeSub(uint a, uint b) internal returns (uint) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint a, uint b) internal returns (uint) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="53" endline="58" pcid="6072">
  function minus(uint a, uint b) returns (uint) {
    assert(b <= a);
    return a - b;
  }

  function plus(uint a, uint b) returns (uint) {
</source>
<source file="systems/smart_contracts/SistContract.sol" startline="15" endline="23" pcid="6513">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="36" endline="41" pcid="5992">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="38" endline="46" pcid="6544">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    /**
    * @dev Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/SAS.sol" startline="21" endline="26" pcid="6291">
  function safeSub(uint256 a, uint256 b)public pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="464" endline="472" pcid="6617">
	function sub(uint256 a, uint256 b) internal pure returns (uint256) {
		assert(b <= a);
		return a - b;
	}

	/**
	* @dev Adds two numbers, throws on overflow.
	*/
	function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/ProofOfContributionChainToken.sol" startline="72" endline="76" pcid="5830">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="43" endline="51" pcid="6676">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    /*
    * @dev Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/PokaToken.sol" startline="76" endline="81" pcid="5738">
  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SuperMarket.sol" startline="76" endline="81" pcid="6766">
  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/OMGToken.sol" startline="29" endline="34" pcid="5481">
  function sub(uint a, uint b) internal returns (uint) {
    assert(b <= a);
    return a - b;
  }

  function add(uint a, uint b) internal returns (uint) {
</source>
<source file="systems/smart_contracts/NMAI.sol" startline="21" endline="26" pcid="5440">
  function safeSub(uint256 a, uint256 b)public pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NEM.sol" startline="21" endline="26" pcid="5318">
  function safeSub(uint256 a, uint256 b)public pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NBToken.sol" startline="47" endline="54" pcid="5300">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }
    /**
     * @dev Adds two numbers, throws on overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NaorisToken.sol" startline="39" endline="47" pcid="5279">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    /**
    * @dev Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="28" endline="36" pcid="6972">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    /**
     * @dev Multiplies two unsigned integers, reverts on overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="83" endline="88" pcid="5095">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MT.sol" startline="21" endline="26" pcid="5070">
  function safeSub(uint256 a, uint256 b)public pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MpctLockupTeam.sol" startline="23" endline="28" pcid="5056">
    function sub(uint256 a, uint256 b) internal constant returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    function add(uint256 a, uint256 b) internal constant returns (uint256) {
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="37" endline="45" pcid="4952">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    /**
    * Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="103" endline="108" pcid="4840">
  function minus(uint a, uint b) returns (uint) {
    assert(b <= a);
    return a - b;
  }

  function plus(uint a, uint b) returns (uint) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="28" endline="33" pcid="4830">
  function safeSub(uint a, uint b) internal returns (uint) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint a, uint b) internal returns (uint) {
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="34" endline="39" pcid="7318">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MBA.sol" startline="40" endline="48" pcid="4700">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="30" endline="35" pcid="4643">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="169" endline="177" pcid="7348">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/MAdvcedWoken.sol" startline="44" endline="49" pcid="4595">
  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TorexToken.sol" startline="44" endline="52" pcid="7405">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/LuckyStrikeTokens.sol" startline="45" endline="53" pcid="4570">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    /**
    * @dev Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/LuckyAdvcedWoken.sol" startline="44" endline="49" pcid="4556">
  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/LBBT.sol" startline="23" endline="28" pcid="4534">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="39" endline="47" pcid="7450">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    /**
    * @dev Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="27" endline="32" pcid="4376">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/UGCoin.sol" startline="19" endline="24" pcid="7525">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="49" endline="57" pcid="4295">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    /**
    * @dev Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/UTC.sol" startline="40" endline="48" pcid="7573">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Hda.sol" startline="21" endline="26" pcid="4218">
  function safeSub(uint256 a, uint256 b) internal returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint256 a, uint256 b) internal returns (uint256) {
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="38" endline="43" pcid="1467">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/GoldenRings.sol" startline="26" endline="31" pcid="4168">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/GameGold.sol" startline="88" endline="96" pcid="3988">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="52" endline="57" pcid="7747">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Byte.sol" startline="36" endline="41" pcid="1573">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="34" endline="39" pcid="3920">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/FMT.sol" startline="204" endline="209" pcid="3663">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/FlatPricingExt.sol" startline="146" endline="151" pcid="3639">
  function minus(uint a, uint b) returns (uint) {
    assert(b <= a);
    return a - b;
  }

  function plus(uint a, uint b) returns (uint) {
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="19" endline="23" pcid="8008">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="34" endline="42" pcid="3514">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    /**
    * @dev Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/XGP.sol" startline="50" endline="58" pcid="8099">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    /**
    * Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/Exchange.sol" startline="37" endline="43" pcid="3364">
    function safeSub(uint a, uint b) returns (uint) {
        assert(b <= a);
        return a - b;
    }

    // Safe Addition Function - prevents integer overflow 
    function safeAdd(uint a, uint b) returns (uint) {
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="55" endline="60" pcid="3169">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="184" endline="192" pcid="3075">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/Aigopay.sol" startline="50" endline="58" pcid="442">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    /**
    * Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="38" endline="46" pcid="2947">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    /**
    * @dev Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="19" endline="23" pcid="2874">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/DNP.sol" startline="50" endline="58" pcid="2786">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) 
    {
        assert(b <= a);
        return a - b;
    }
    /**
    * @dev Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) 
</source>
<source file="systems/smart_contracts/AronCoin.sol" startline="52" endline="57" pcid="763">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="34" endline="39" pcid="2645">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="38" endline="43" pcid="2554">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DHF.sol" startline="21" endline="26" pcid="2535">
  function safeSub(uint256 a, uint256 b)public pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="38" endline="43" pcid="2394">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BACD.sol" startline="38" endline="43" pcid="1012">
  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/AT.sol" startline="24" endline="29" pcid="789">
  function safeSub(uint256 a, uint256 b) internal returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint256 a, uint256 b) internal returns (uint256) {
</source>
<source file="systems/smart_contracts/BANG.sol" startline="38" endline="43" pcid="1043">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DaiSwap.sol" startline="13" endline="17" pcid="2282">
  function safeSub(uint a, uint b) internal pure returns (uint) {
    assert(b <= a);
    return a - b;
  }
  function safeAdd(uint a, uint b) internal pure returns (uint) {
</source>
<source file="systems/smart_contracts/customIcoToken.sol" startline="23" endline="28" pcid="2210">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/CST_TOKEN.sol" startline="32" endline="37" pcid="2199">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="37" endline="45" pcid="1267">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    /**
    * Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/CRYPTOMZ.sol" startline="25" endline="30" pcid="2174">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="34" endline="39" pcid="2152">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="514" endline="519" pcid="2127">
  function minus(uint a, uint b) returns (uint) {
    assert(b <= a);
    return a - b;
  }

  function plus(uint a, uint b) returns (uint) {
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="86" endline="91" pcid="2097">
  function safeSub(uint a, uint b) internal returns (uint) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint a, uint b) internal returns (uint) {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="80" endline="85" pcid="2048">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/CouncilVesting.sol" startline="23" endline="28" pcid="2019">
  function sub(uint a, uint b) internal returns (uint) {
    assert(b <= a);
    return a - b;
  }

  function add(uint a, uint b) internal returns (uint) {
</source>
<source file="systems/smart_contracts/Comet.sol" startline="34" endline="39" pcid="1920">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CoinDDC.sol" startline="201" endline="207" pcid="1875">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) 
    {
        assert(b <= a);
        return a - b;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256 c) 
</source>
<source file="systems/smart_contracts/CAC.sol" startline="21" endline="26" pcid="1609">
  function safeSub(uint256 a, uint256 b)public pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint256 a, uint256 b)public pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NSTTeamLock.sol" startline="152" endline="162" pcid="5464">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Adds two unsigned integers, reverts on overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="83" endline="93" pcid="2741">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b <= a);
    uint256 c = a - b;

    return c;
  }

  /**
  * @dev Adds two numbers, reverts on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="126" endline="142" pcid="522">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Ethertime.sol" startline="20" endline="25" pcid="3301">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;
        return c;
    }
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="330" endline="340" pcid="3261">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    /**
    * @dev Adds two unsigned integers, reverts on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DABANKING_SWAP.sol" startline="86" endline="96" pcid="2275">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b <= a);
    uint256 c = a - b;

    return c;
  }

  /**
   * @dev Adds two unsigned integers, reverts on overflow.
   */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="15" endline="19" pcid="8038">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="121" endline="131" pcid="8080">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
      require(b <= a);
      uint256 c = a - b;

      return c;
  }

  /**
  * @dev Adds two numbers, reverts on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="51" endline="67" pcid="3757">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Six.sol" startline="34" endline="50" pcid="6531">
     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
         require(b <= a, "SafeMath: subtraction overflow");
         uint256 c = a - b;

         return c;
     }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="130" endline="146" pcid="8231">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="205" endline="221" pcid="952">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="44" endline="50" pcid="2304">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;
        return c;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Ownable.sol" startline="27" endline="32" pcid="5567">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="47" endline="63" pcid="5949">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="99" endline="109" pcid="571">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "Safe sub error");
        uint256 c = a - b;

        return c;
    }

    /**
    * @dev Adds two unsigned integers, reverts on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="205" endline="221" pcid="2465">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="38" endline="46" pcid="5330">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="42" endline="52" pcid="3015">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Adds two unsigned integers, reverts on overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="38" endline="54" pcid="7168">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="46" endline="62" pcid="7896">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="36" endline="44" pcid="7772">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="127" endline="143" pcid="7018">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="46" endline="59" pcid="5409">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="205" endline="221" pcid="6024">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="169" endline="185" pcid="5781">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="74" endline="84" pcid="6414">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Adds two unsigned integers, reverts on overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="46" endline="62" pcid="4027">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="39" endline="49" pcid="7698">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Adds two numbers, reverts on overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/GFNX.sol" startline="72" endline="82" pcid="4100">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b <= a);
    uint256 c = a - b;

    return c;
  }

  /**
  * @dev Adds two numbers, reverts on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="82" endline="92" pcid="7643">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Adds two unsigned integers, reverts on overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="44" endline="54" pcid="5834">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    /**
    * @dev Adds two numbers, reverts on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="126" endline="142" pcid="482">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="44" endline="54" pcid="6305">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Adds two unsigned integers, reverts on overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Governance.sol" startline="48" endline="64" pcid="4183">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Factory.sol" startline="124" endline="140" pcid="3436">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="199" endline="212" pcid="4989">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="52" endline="62" pcid="4231">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b <= a);
    uint256 c = a - b;

    return c;
  }

  /**
  * @dev Adds two numbers, reverts on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CDS.sol" startline="38" endline="47" pcid="1655">
	function sub(uint256 a, uint256 b) internal pure returns (uint256) {
		require(b <= a);
		uint256 c = a - b;
		return c;
	}

	/**
		* @dev Adds two unsigned integers, reverts on overflow.
		*/
	function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="40" endline="50" pcid="7979">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b <= a);
    uint256 c = a - b;

    return c;
  }

  /**
  * @dev Adds two numbers, reverts on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="86" endline="96" pcid="732">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    /**
    * @dev Adds two numbers, reverts on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="48" endline="58" pcid="1879">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b <= a);
    uint256 c = a - b;

    return c;
  }

  /**
  * @dev Adds two numbers, reverts on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="44" endline="54" pcid="2978">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b <= a);
    uint256 c = a - b;

    return c;
  }

  /**
  * @dev Adds two numbers, reverts on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MultiSendErc20.sol" startline="40" endline="50" pcid="5200">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    /**
    * @dev Adds two unsigned integers, reverts on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="113" endline="123" pcid="5671">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    /**
    * @dev Adds two unsigned integers, reverts on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="51" endline="67" pcid="802">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="46" endline="62" pcid="8186">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="72" endline="82" pcid="1367">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    /**
    * @dev Adds two unsigned integers, reverts on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BountyBoard.sol" startline="45" endline="60" pcid="1488">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }
    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Bridge.sol" startline="53" endline="63" pcid="1505">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    /**
    * @dev Adds two unsigned integers, reverts on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Fk.sol" startline="34" endline="50" pcid="3619">
     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
     	require(b <= a, "SafeMath: subtraction overflow");
     	uint256 c = a - b;

     	return c;
     }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="39" endline="49" pcid="6711">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Adds two numbers, reverts on overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="44" endline="54" pcid="4921">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Adds two unsigned integers, reverts on overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BRZE.sol" startline="22" endline="27" pcid="1519">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b <= a);
    uint256 c = a - b;
    return c;
  }
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="48" endline="64" pcid="4416">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="52" endline="62" pcid="6826">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b <= a);
    uint256 c = a - b;

    return c;
  }

  /**
  * @dev Adds two numbers, reverts on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ankara.sol" startline="55" endline="62" pcid="683">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CNG.sol" startline="83" endline="93" pcid="1848">
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b <= a);
    uint256 c = a - b;

    return c;
  }

  /**
  * @dev Adds two numbers, reverts on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="44" endline="54" pcid="3545">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    /**
    * @dev Adds two numbers, reverts on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="127" endline="143" pcid="1751">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="353" endline="369" pcid="5163">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="39" endline="49" pcid="2225">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Adds two numbers, reverts on overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="261" endline="277" pcid="4747">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Token.sol" startline="44" endline="54" pcid="7253">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Adds two unsigned integers, reverts on overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="124" endline="140" pcid="649">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="349" endline="365" pcid="319">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="45" endline="55" pcid="7266">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Adds two unsigned integers, reverts on overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TokenSwap.sol" startline="44" endline="54" pcid="7387">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Adds two unsigned integers, reverts on overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="127" endline="140" pcid="5909">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/magesh.sol" startline="44" endline="54" pcid="4609">
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Adds two unsigned integers, reverts on overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
</class>

<class classid="38" nclones="125" nlines="4" similarity="75">
<source file="systems/smart_contracts/AACD.sol" startline="26" endline="32" pcid="289">
  function safeAdd(uint256 a, uint256 b)public pure returns (uint256) {
    uint256 c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

  function _assert(bool assertion)public pure {
</source>
<source file="systems/smart_contracts/PokaToken.sol" startline="81" endline="87" pcid="5739">
  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

}
</source>
<source file="systems/smart_contracts/SuperMarket.sol" startline="81" endline="87" pcid="6767">
  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

}
</source>
<source file="systems/smart_contracts/SAS.sol" startline="26" endline="32" pcid="6292">
  function safeAdd(uint256 a, uint256 b)public pure returns (uint256) {
    uint256 c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

  function _assert(bool assertion)public pure {
</source>
<source file="systems/smart_contracts/NMAI.sol" startline="26" endline="32" pcid="5441">
  function safeAdd(uint256 a, uint256 b)public pure returns (uint256) {
    uint256 c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

  function _assert(bool assertion)public pure {
</source>
<source file="systems/smart_contracts/NEM.sol" startline="26" endline="32" pcid="5319">
  function safeAdd(uint256 a, uint256 b)public pure returns (uint256) {
    uint256 c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

  function _assert(bool assertion)public pure {
</source>
<source file="systems/smart_contracts/MT.sol" startline="26" endline="32" pcid="5071">
  function safeAdd(uint256 a, uint256 b)public pure returns (uint256) {
    uint256 c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

  function _assert(bool assertion)public pure {
</source>
<source file="systems/smart_contracts/MAdvcedWoken.sol" startline="49" endline="55" pcid="4596">
  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

}
</source>
<source file="systems/smart_contracts/LuckyAdvcedWoken.sol" startline="49" endline="55" pcid="4557">
  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

}
</source>
<source file="systems/smart_contracts/Hda.sol" startline="26" endline="32" pcid="4219">
  function safeAdd(uint256 a, uint256 b) internal returns (uint256) {
    uint256 c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

  function assert(bool assertion) internal {
</source>
<source file="systems/smart_contracts/DHF.sol" startline="26" endline="32" pcid="2536">
  function safeAdd(uint256 a, uint256 b)public pure returns (uint256) {
    uint256 c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

  function _assert(bool assertion)public pure {
</source>
<source file="systems/smart_contracts/AT.sol" startline="29" endline="35" pcid="790">
  function safeAdd(uint256 a, uint256 b) internal returns (uint256) {
    uint256 c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

  function assert(bool assertion) internal {
</source>
<source file="systems/smart_contracts/CAC.sol" startline="26" endline="32" pcid="1610">
  function safeAdd(uint256 a, uint256 b)public pure returns (uint256) {
    uint256 c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

  function _assert(bool assertion)public pure {
</source>
<source file="systems/smart_contracts/BACD.sol" startline="43" endline="48" pcid="1013">
  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="39" endline="45" pcid="2646">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }

  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NBToken.sol" startline="54" endline="59" pcid="5301">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/AronCoin.sol" startline="57" endline="62" pcid="764">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="43" endline="49" pcid="2555">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }

  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="39" endline="45" pcid="2153">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }

  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="43" endline="49" pcid="2395">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }

  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NaorisToken.sol" startline="47" endline="52" pcid="5280">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="88" endline="94" pcid="5096">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }

  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BKN.sol" startline="133" endline="138" pcid="1334">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="60" endline="66" pcid="3170">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }

  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="31" endline="36" pcid="1623">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/CST_TOKEN.sol" startline="37" endline="42" pcid="2200">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/SCMCoin.sol" startline="24" endline="29" pcid="6384">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/Comet.sol" startline="39" endline="45" pcid="1921">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }

  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SEA.sol" startline="27" endline="32" pcid="6394">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/CRYPTOMZ.sol" startline="30" endline="35" pcid="2175">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/FMT.sol" startline="209" endline="214" pcid="3664">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/Byte.sol" startline="41" endline="47" pcid="1574">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }

  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ProofOfContributionChainToken.sol" startline="76" endline="81" pcid="5831">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/MpctLockupTeam.sol" startline="28" endline="33" pcid="5057">
    function add(uint256 a, uint256 b) internal constant returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="43" endline="49" pcid="1468">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }

  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/RETC.sol" startline="24" endline="29" pcid="6177">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="41" endline="47" pcid="5993">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }

  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SistContract.sol" startline="23" endline="28" pcid="6514">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/SellableToken.sol" startline="27" endline="32" pcid="6458">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="26" endline="32" pcid="1706">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }

    function max64(uint64 a, uint64 b) internal pure returns (uint64) {
</source>
<source file="systems/smart_contracts/GameGold.sol" startline="96" endline="101" pcid="3989">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="39" endline="45" pcid="7319">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }

  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BlockPoolToken.sol" startline="54" endline="59" pcid="1411">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/GoldenRings.sol" startline="31" endline="36" pcid="4169">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/BFGToken.sol" startline="30" endline="35" pcid="1180">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="57" endline="62" pcid="7748">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/UTC.sol" startline="48" endline="53" pcid="7574">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="39" endline="45" pcid="6204">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }

  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BANG.sol" startline="43" endline="49" pcid="1044">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }

  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/UGCoin.sol" startline="24" endline="29" pcid="7526">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/BDAM.sol" startline="40" endline="45" pcid="1111">
  function add(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="32" endline="37" pcid="4377">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="47" endline="52" pcid="7451">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="39" endline="45" pcid="3921">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }

  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="123" endline="134" pcid="5672">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    /**
    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
    * reverts when dividing by zero.
    */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="49" endline="60" pcid="6712">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    /**
     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),
     * reverts when dividing by zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="153" endline="169" pcid="5780">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="54" endline="65" pcid="5835">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    /**
    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),
    * reverts when dividing by zero.
    */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="111" endline="127" pcid="5908">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="31" endline="47" pcid="5948">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="111" endline="127" pcid="1750">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Six.sol" startline="18" endline="34" pcid="6530">
     function add(uint256 a, uint256 b) internal pure returns (uint256) {
         uint256 c = a + b;
         require(c >= a, "SafeMath: addition overflow");

         return c;
     }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="333" endline="349" pcid="318">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ankara.sol" startline="62" endline="69" pcid="684">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="189" endline="205" pcid="6023">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="189" endline="205" pcid="2464">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DABANKING_SWAP.sol" startline="96" endline="107" pcid="2276">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a);

    return c;
  }

  /**
   * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
   * reverts when dividing by zero.
   */
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Ownable.sol" startline="32" endline="37" pcid="5568">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/BountyBoard.sol" startline="30" endline="45" pcid="1487">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }
    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NSTTeamLock.sol" startline="162" endline="173" pcid="5465">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
     * reverts when dividing by zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="62" endline="73" pcid="6827">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a);

    return c;
  }

  /**
  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),
  * reverts when dividing by zero.
  */
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="30" endline="46" pcid="5408">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="27" endline="38" pcid="5329">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MultiSign.sol" startline="15" endline="20" pcid="5234">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/MultiSendErc20.sol" startline="50" endline="61" pcid="5201">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    /**
    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
    * reverts when dividing by zero.
    */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="337" endline="353" pcid="5162">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="111" endline="127" pcid="7017">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="54" endline="65" pcid="6306">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    /**
     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
     * reverts when dividing by zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="58" endline="69" pcid="1880">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a);

    return c;
  }

  /**
  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),
  * reverts when dividing by zero.
  */
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="22" endline="38" pcid="7167">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="183" endline="199" pcid="4988">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="54" endline="65" pcid="4922">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
     * reverts when dividing by zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Token.sol" startline="54" endline="60" pcid="7254">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }
}
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="55" endline="66" pcid="7267">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    /**
     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
     * reverts when dividing by zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="245" endline="261" pcid="4746">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="109" endline="120" pcid="572">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "Safe add error");

        return c;
    }

    /**
    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
    * reverts when dividing by zero.
    */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/magesh.sol" startline="54" endline="65" pcid="4610">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
     * reverts when dividing by zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TokenSwap.sol" startline="54" endline="65" pcid="7388">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    /**
     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
     * reverts when dividing by zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="32" endline="48" pcid="4415">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="62" endline="73" pcid="4232">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a);

    return c;
  }

  /**
  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),
  * reverts when dividing by zero.
  */
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Governance.sol" startline="32" endline="48" pcid="4182">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="84" endline="95" pcid="6415">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
     * reverts when dividing by zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BRZE.sol" startline="27" endline="32" pcid="1520">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a && c >= b);
    return c;
  }
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="92" endline="103" pcid="7644">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    /**
     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
     * reverts when dividing by zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/GFNX.sol" startline="82" endline="93" pcid="4101">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a);

    return c;
  }

  /**
  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),
  * reverts when dividing by zero.
  */
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="49" endline="60" pcid="7699">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    /**
     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),
     * reverts when dividing by zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="96" endline="107" pcid="733">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    /**
    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),
    * reverts when dividing by zero.
    */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="30" endline="46" pcid="4026">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="25" endline="36" pcid="7771">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="30" endline="46" pcid="7895">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="35" endline="51" pcid="3756">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Fk.sol" startline="18" endline="34" pcid="3618">
     function add(uint256 a, uint256 b) internal pure returns (uint256) {
     	uint256 c = a + b;
     	require(c >= a, "SafeMath: addition overflow");

     	return c;
     }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="82" endline="93" pcid="1368">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    /**
    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
    * reverts when dividing by zero.
    */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="50" endline="61" pcid="7980">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a);

    return c;
  }

  /**
  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),
  * reverts when dividing by zero.
  */
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="54" endline="65" pcid="3546">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    /**
    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),
    * reverts when dividing by zero.
    */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="8" endline="15" pcid="8037">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="131" endline="142" pcid="8081">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
      uint256 c = a + b;
      require(c >= a);

      return c;
  }

  /**
  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),
  * reverts when dividing by zero.
  */
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Factory.sol" startline="108" endline="124" pcid="3435">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="30" endline="46" pcid="8185">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Ethertime.sol" startline="25" endline="30" pcid="3302">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);
        return c;
    }
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="340" endline="351" pcid="3262">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    /**
    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
    * reverts when dividing by zero.
    */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="114" endline="130" pcid="8230">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="49" endline="60" pcid="2226">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    /**
     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),
     * reverts when dividing by zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="35" endline="51" pcid="801">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="52" endline="58" pcid="3016">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }
}
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="54" endline="65" pcid="2979">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a);

    return c;
  }

  /**
  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),
  * reverts when dividing by zero.
  */
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CDS.sol" startline="47" endline="52" pcid="1656">
	function add(uint256 a, uint256 b) internal pure returns (uint256) {
		uint256 c = a + b;
		require(c >= a);
		return c;
	}
}
</source>
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="110" endline="126" pcid="481">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="189" endline="205" pcid="951">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="93" endline="104" pcid="2742">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a);

    return c;
  }

  /**
  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),
  * reverts when dividing by zero.
  */
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="110" endline="126" pcid="521">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="50" endline="56" pcid="2305">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);
        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="108" endline="124" pcid="648">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CNG.sol" startline="93" endline="104" pcid="1849">
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a);

    return c;
  }

  /**
  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),
  * reverts when dividing by zero.
  */
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Bridge.sol" startline="63" endline="74" pcid="1506">
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    /**
    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
    * reverts when dividing by zero.
    */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
</class>

<class classid="39" nclones="7" nlines="4" similarity="100">
<source file="systems/smart_contracts/AACD.sol" startline="32" endline="35" pcid="290">
  function _assert(bool assertion)public pure {
    assert(!assertion);
  }
}
</source>
<source file="systems/smart_contracts/SAS.sol" startline="32" endline="35" pcid="6293">
  function _assert(bool assertion)public pure {
    assert(!assertion);
  }
}
</source>
<source file="systems/smart_contracts/NMAI.sol" startline="32" endline="35" pcid="5442">
  function _assert(bool assertion)public pure {
    assert(!assertion);
  }
}
</source>
<source file="systems/smart_contracts/NEM.sol" startline="32" endline="35" pcid="5320">
  function _assert(bool assertion)public pure {
    assert(!assertion);
  }
}
</source>
<source file="systems/smart_contracts/DHF.sol" startline="32" endline="35" pcid="2537">
  function _assert(bool assertion)public pure {
    assert(!assertion);
  }
}
</source>
<source file="systems/smart_contracts/MT.sol" startline="32" endline="35" pcid="5072">
  function _assert(bool assertion)public pure {
    assert(!assertion);
  }
}
</source>
<source file="systems/smart_contracts/CAC.sol" startline="32" endline="35" pcid="1611">
  function _assert(bool assertion)public pure {
    assert(!assertion);
  }
}
</source>
</class>

<class classid="40" nclones="7" nlines="5" similarity="100">
<source file="systems/smart_contracts/AACD.sol" startline="66" endline="79" pcid="295">
    function transfer(address _to, uint256 _value)public returns (bool success) {
        require(_to != address(0));
        require(balanceOf[msg.sender] >= _value);
        require(balanceOf[ _to] + _value >= balanceOf[ _to]); 
        
        balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender],_value) ;
        balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ;
        
        emit Transfer(msg.sender, _to, _value);
        
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success) {
</source>
<source file="systems/smart_contracts/MT.sol" startline="66" endline="79" pcid="5077">
    function transfer(address _to, uint256 _value)public returns (bool success) {
        require(_to != address(0));
        require(balanceOf[msg.sender] >= _value);
        require(balanceOf[ _to] + _value >= balanceOf[ _to]); 
        
        balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender],_value) ;
        balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ;
        
        emit Transfer(msg.sender, _to, _value);
        
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success) {
</source>
<source file="systems/smart_contracts/NMAI.sol" startline="66" endline="79" pcid="5447">
    function transfer(address _to, uint256 _value)public returns (bool success) {
        require(_to != address(0));
        require(balanceOf[msg.sender] >= _value);
        require(balanceOf[ _to] + _value >= balanceOf[ _to]); 
        
        balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender],_value) ;
        balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ;
        
        emit Transfer(msg.sender, _to, _value);
        
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success) {
</source>
<source file="systems/smart_contracts/DHF.sol" startline="66" endline="79" pcid="2542">
    function transfer(address _to, uint256 _value)public returns (bool success) {
        require(_to != address(0));
        require(balanceOf[msg.sender] >= _value);
        require(balanceOf[ _to] + _value >= balanceOf[ _to]); 
        
        balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender],_value) ;
        balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ;
        
        emit Transfer(msg.sender, _to, _value);
        
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success) {
</source>
<source file="systems/smart_contracts/SAS.sol" startline="84" endline="98" pcid="6299">
  function transfer(address _to, uint256 _value)public returns (bool success) {
      require(_to != address(0));
      require(balanceOf[msg.sender] >= _value);
      require(balanceOf[ _to] + _value >= balanceOf[ _to]); 

      balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender],_value) ;
      balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ;

      emit Transfer(msg.sender, _to, _value);

      return true;
  }


  function transferFrom(address _from, address _to, uint256 _value)public returns (bool success) {
</source>
<source file="systems/smart_contracts/CAC.sol" startline="66" endline="79" pcid="1616">
    function transfer(address _to, uint256 _value)public returns (bool success) {
        require(_to != address(0));
        require(balanceOf[msg.sender] >= _value);
        require(balanceOf[ _to] + _value >= balanceOf[ _to]); 
        
        balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender],_value) ;
        balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ;
        
        emit Transfer(msg.sender, _to, _value);
        
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success) {
</source>
<source file="systems/smart_contracts/NEM.sol" startline="66" endline="79" pcid="5325">
    function transfer(address _to, uint256 _value)public returns (bool success) {
        require(_to != address(0));
        require(balanceOf[msg.sender] >= _value);
        require(balanceOf[ _to] + _value >= balanceOf[ _to]); 
        
        balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender],_value) ;
        balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ;
        
        emit Transfer(msg.sender, _to, _value);
        
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success) {
</source>
</class>

<class classid="41" nclones="7" nlines="5" similarity="100">
<source file="systems/smart_contracts/AACD.sol" startline="79" endline="94" pcid="296">
    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success) {
        require(_to != address(0));
        require(allowed[_from][msg.sender] >= _value);
        require(balanceOf[_from] >= _value);
        require(balanceOf[ _to] + _value >= balanceOf[ _to]);
        
        balanceOf[_from] =SafeMath.safeSub(balanceOf[_from],_value) ;
        balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ;
        
        allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender],_value) ;
        
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value)public returns (bool success) {
</source>
<source file="systems/smart_contracts/CAC.sol" startline="79" endline="94" pcid="1617">
    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success) {
        require(_to != address(0));
        require(allowed[_from][msg.sender] >= _value);
        require(balanceOf[_from] >= _value);
        require(balanceOf[ _to] + _value >= balanceOf[ _to]);
        
        balanceOf[_from] =SafeMath.safeSub(balanceOf[_from],_value) ;
        balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ;
        
        allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender],_value) ;
        
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value)public returns (bool success) {
</source>
<source file="systems/smart_contracts/NEM.sol" startline="79" endline="94" pcid="5326">
    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success) {
        require(_to != address(0));
        require(allowed[_from][msg.sender] >= _value);
        require(balanceOf[_from] >= _value);
        require(balanceOf[ _to] + _value >= balanceOf[ _to]);
        
        balanceOf[_from] =SafeMath.safeSub(balanceOf[_from],_value) ;
        balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ;
        
        allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender],_value) ;
        
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value)public returns (bool success) {
</source>
<source file="systems/smart_contracts/SAS.sol" startline="98" endline="113" pcid="6300">
  function transferFrom(address _from, address _to, uint256 _value)public returns (bool success) {
      require(_to != address(0));
      require(allowed[_from][msg.sender] >= _value);
      require(balanceOf[_from] >= _value);
      require(balanceOf[ _to] + _value >= balanceOf[ _to]);

      balanceOf[_from] =SafeMath.safeSub(balanceOf[_from],_value) ;
      balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ;

      allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender],_value) ;

      emit Transfer(msg.sender, _to, _value);
      return true;
  }

  function approve(address _spender, uint256 _value)public returns (bool success) {
</source>
<source file="systems/smart_contracts/MT.sol" startline="79" endline="94" pcid="5078">
    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success) {
        require(_to != address(0));
        require(allowed[_from][msg.sender] >= _value);
        require(balanceOf[_from] >= _value);
        require(balanceOf[ _to] + _value >= balanceOf[ _to]);
        
        balanceOf[_from] =SafeMath.safeSub(balanceOf[_from],_value) ;
        balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ;
        
        allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender],_value) ;
        
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value)public returns (bool success) {
</source>
<source file="systems/smart_contracts/NMAI.sol" startline="79" endline="94" pcid="5448">
    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success) {
        require(_to != address(0));
        require(allowed[_from][msg.sender] >= _value);
        require(balanceOf[_from] >= _value);
        require(balanceOf[ _to] + _value >= balanceOf[ _to]);
        
        balanceOf[_from] =SafeMath.safeSub(balanceOf[_from],_value) ;
        balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ;
        
        allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender],_value) ;
        
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value)public returns (bool success) {
</source>
<source file="systems/smart_contracts/DHF.sol" startline="79" endline="94" pcid="2543">
    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success) {
        require(_to != address(0));
        require(allowed[_from][msg.sender] >= _value);
        require(balanceOf[_from] >= _value);
        require(balanceOf[ _to] + _value >= balanceOf[ _to]);
        
        balanceOf[_from] =SafeMath.safeSub(balanceOf[_from],_value) ;
        balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ;
        
        allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender],_value) ;
        
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value)public returns (bool success) {
</source>
</class>

<class classid="42" nclones="90" nlines="4" similarity="75">
<source file="systems/smart_contracts/AACD.sol" startline="94" endline="102" pcid="297">
    function approve(address _spender, uint256 _value)public returns (bool success) {
        require((_value==0)||(allowed[msg.sender][_spender]==0));
        allowed[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender)public view returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/DHF.sol" startline="94" endline="102" pcid="2544">
    function approve(address _spender, uint256 _value)public returns (bool success) {
        require((_value==0)||(allowed[msg.sender][_spender]==0));
        allowed[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender)public view returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="215" endline="220" pcid="2867">
    function approve(address _spender, uint256 _value) public returns (bool success){
        success = operator.token_approve(msg.sender, _spender, _value);
        emit Approval(msg.sender, _spender, _value);
    }
    
    function() public payable {
</source>
<source file="systems/smart_contracts/ESCHToken.sol" startline="57" endline="64" pcid="3044">
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }


    function burn(uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ETGTOKEN.sol" startline="106" endline="122" pcid="3194">
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    /**
     * Set allowance for other address and notify
     *
     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     * @param _extraData some extra information to send to the approved contract
     */
    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)
</source>
<source file="systems/smart_contracts/Warpcoin.sol" startline="63" endline="69" pcid="7949">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/GameGold.sol" startline="270" endline="291" pcid="4003">
  function approve(address _spender, uint256 _value)
  onlyPayloadSize(2 * 32)
  checkTokenTransfer(msg.sender)
  public returns (bool) {
    // To change the approve amount you first have to reduce the addresses`
    //  allowance to zero by calling `approve(_spender,0)` if it is not
    //  already 0 to mitigate the race condition described here:
    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    require((_value == 0) || (allowed[msg.sender][_spender] == 0));

    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(address _owner, address _spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/GBE.sol" startline="51" endline="58" pcid="4057">
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        require((_value == 0) || (allowance[msg.sender][_spender] == 0));
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)
</source>
<source file="systems/smart_contracts/GEF.sol" startline="51" endline="58" pcid="4063">
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        require((_value == 0) || (allowance[msg.sender][_spender] == 0));
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)
</source>
<source file="systems/smart_contracts/VCTAToken.sol" startline="56" endline="62" pcid="7672">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/ICBB.sol" startline="125" endline="141" pcid="4268">
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    /**
     * Set allowance for other address and notify
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     * @param _extraData some extra information to send to the approved contract
     */
    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)
</source>
<source file="systems/smart_contracts/UNT.sol" startline="56" endline="62" pcid="7569">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/UGCoin.sol" startline="112" endline="118" pcid="7537">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/LuckyAdvcedWoken.sol" startline="172" endline="186" pcid="4562">
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    /**
     * Destroy tokens
     *
     * Remove `_value` tokens from the system irreversibly
     *
     * @param _value the amount of money to burn
     */
    function burn(uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/MAdvcedWoken.sol" startline="172" endline="186" pcid="4601">
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    /**
     * Destroy tokens
     *
     * Remove `_value` tokens from the system irreversibly
     *
     * @param _value the amount of money to burn
     */
    function burn(uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/TokenERC20.sol" startline="105" endline="121" pcid="7306">
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    /**
     * Set allowance for other address and notify
     *
     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     * @param _extraData some extra information to send to the approved contract
     */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
</source>
<source file="systems/smart_contracts/ThpToken.sol" startline="125" endline="141" pcid="7161">
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    /**
     * Set allowance for other address and notify
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     * @param _extraData some extra information to send to the approved contract
     */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
</source>
<source file="systems/smart_contracts/MT.sol" startline="94" endline="102" pcid="5079">
    function approve(address _spender, uint256 _value)public returns (bool success) {
        require((_value==0)||(allowed[msg.sender][_spender]==0));
        allowed[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender)public view returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/SAS.sol" startline="113" endline="121" pcid="6301">
  function approve(address _spender, uint256 _value)public returns (bool success) {
      require((_value==0)||(allowed[msg.sender][_spender]==0));
      allowed[msg.sender][_spender] = _value;

      emit Approval(msg.sender, _spender, _value);
      return true;
  }

  function allowance(address _owner, address _spender)public view returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/MyAdvancedToken.sol" startline="121" endline="137" pcid="5266">
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    /**
     * Set allowance for other address and notify
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     * @param _extraData some extra information to send to the approved contract
     */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
</source>
<source file="systems/smart_contracts/NEM.sol" startline="94" endline="102" pcid="5327">
    function approve(address _spender, uint256 _value)public returns (bool success) {
        require((_value==0)||(allowed[msg.sender][_spender]==0));
        allowed[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender)public view returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/NMAI.sol" startline="94" endline="102" pcid="5449">
    function approve(address _spender, uint256 _value)public returns (bool success) {
        require((_value==0)||(allowed[msg.sender][_spender]==0));
        allowed[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender)public view returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/OBK.sol" startline="56" endline="62" pcid="5471">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/OeroToken.sol" startline="56" endline="62" pcid="5475">
        function approve(address _spender, uint256 _value) public returns (bool success) {
            allowance[msg.sender][_spender] = _value;
            emit Approval(msg.sender, _spender, _value);
            return true;
        }

        function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SuperMarket.sol" startline="121" endline="128" pcid="6769">
    function approve(address _spender, uint256 _value) public returns (bool success) {
		require((_value == 0) || (allowance[msg.sender][_spender] == 0));
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/DENARIO.sol" startline="63" endline="69" pcid="2451">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/BACD.sol" startline="278" endline="291" pcid="1028">
  function approve (address _spender, uint256 _value) public
    returns (bool success) {
	require(allowance (msg.sender, _spender) == 0 || _value == 0);
    return AbstractToken.approve (_spender, _value);
  }

  /**
   * Create _value new tokens and give new created tokens to msg.sender.
   * May only be called by smart contract owner.
   *
   * @param _value number of tokens to create
   * @return true if tokens were created successfully, false otherwise
   */
  function createTokens(uint256 _value) public
</source>
<source file="systems/smart_contracts/PokaToken.sol" startline="121" endline="128" pcid="5741">
    function approve(address _spender, uint256 _value) public returns (bool success) {
		require((_value == 0) || (allowance[msg.sender][_spender] == 0));
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Rabbit.sol" startline="41" endline="47" pcid="5944">
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }
    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
</source>
<source file="systems/smart_contracts/RanchChain.sol" startline="100" endline="115" pcid="5980">
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    /**
     * Set allowance for other address and notify
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     * @param _extraData some extra information to send to the approved contract
     */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
</source>
<source file="systems/smart_contracts/SHPC.sol" startline="56" endline="62" pcid="6511">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/SEA.sol" startline="82" endline="90" pcid="6396">
    function approve(address _spender, uint256 _value) public returns (bool success) {
		require(_spender != address(0));
		require((_value == 0) || (allowance[msg.sender][_spender] == 0));
        allowance[msg.sender][_spender] = _value;
		emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SCMCoin.sol" startline="98" endline="104" pcid="6389">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/BACD.sol" startline="146" endline="163" pcid="1023">
   function approve (address _spender, uint256 _value) public returns (bool success) {
    allowances [msg.sender][_spender] = _value;
    emit Approval (msg.sender, _spender, _value);
    return true;
  }

  /**
   * Tell how many tokens given spender is currently allowed to transfer from
   * given owner.
   *
   * @param _owner address to get number of tokens allowed to be transferred
   *        from the owner of
   * @param _spender address to get number of tokens allowed to be transferred
   *        by the owner of
   * @return number of tokens given spender is currently allowed to transfer
   *         from given owner
   */
  function allowance(address _owner, address _spender) public view
</source>
<source file="systems/smart_contracts/Contracts.sol" startline="100" endline="115" pcid="1998">
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    /**
     * Set allowance for other address and notify
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     * @param _extraData some extra information to send to the approved contract
     */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
</source>
<source file="systems/smart_contracts/CLCTokenERC20.sol" startline="100" endline="115" pcid="1740">
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    /**
     * Set allowance for other address and notify
     *
     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     * @param _extraData some extra information to send to the approved contract
     */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
</source>
<source file="systems/smart_contracts/AzurToken.sol" startline="85" endline="91" pcid="1008">
  function approve(address _spender, uint256 _value) public returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }

  function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/DDPC.sol" startline="98" endline="113" pcid="2380">
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    /**
     * Set allowance for other address and notify
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     * @param _extraData some extra information to send to the approved contract
     */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
</source>
<source file="systems/smart_contracts/CAC.sol" startline="94" endline="102" pcid="1618">
    function approve(address _spender, uint256 _value)public returns (bool success) {
        require((_value==0)||(allowed[msg.sender][_spender]==0));
        allowed[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender)public view returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/BRZE.sol" startline="113" endline="120" pcid="1529">
  function approve(address _spender, uint256 _value) public returns (bool success) {
    allowance[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }


  function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {
</source>
<source file="systems/smart_contracts/byzbit.sol" startline="110" endline="118" pcid="1597">
	function approve (address _spender, uint256 _value) onlyOwner public 
	returns(bool success) 
	 {
		allowance[msg.sender][_spender] = _value; 
		emit Approval(msg.sender, _spender, _value);
		return true;
	}

	function approveAndCall (address _spender, uint256 _value, bytes _extradata) public 
</source>
<source file="systems/smart_contracts/Fk.sol" startline="189" endline="202" pcid="3625">
function approve(address _spender, uint256 _value) public returns (bool) {
	
	allowance[msg.sender][_spender] = _value;
	emit Approval(msg.sender, _spender, _value);
	return true;
}

/**
* @dev Call this function to burn tokens instead of sending to address(0)

* @param _value amount to burn

*/
function burn(uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Six.sol" startline="189" endline="202" pcid="6537">
function approve(address _spender, uint256 _value) public returns (bool) {
    
    allowance[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
}

/**
* @dev Call this function to burn tokens instead of sending to address(0)

* @param _value amount to burn

*/
function burn(uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/GoldenRings.sol" startline="113" endline="126" pcid="4178">
    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    /**
    * @dev Function to check the amount of tokens that an owner allowed to a spender.
    * @param _owner address The address which owns the funds.
    * @param _spender address The address which will spend the funds.
    * @return A uint256 specifying the amount of tokens still available for the spender.
    */
    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="193" endline="199" pcid="4393">
    function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="160" endline="172" pcid="7462">
    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param _owner address The address which owns the funds.
     * @param _spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/LBBT.sol" startline="85" endline="92" pcid="4544">
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }

  
  function allowance(
</source>
<source file="systems/smart_contracts/TorexToken.sol" startline="219" endline="231" pcid="7419">
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="106" endline="112" pcid="4652">
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }

  function allowance(
</source>
<source file="systems/smart_contracts/MBA.sol" startline="273" endline="285" pcid="4721">
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(
</source>
<source file="systems/smart_contracts/NaorisToken.sol" startline="160" endline="172" pcid="5291">
    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param _owner address The address which owns the funds.
     * @param _spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/NBToken.sol" startline="192" endline="203" pcid="5311">
    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param _owner address The address which owns the funds.
     * @param _spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address _owner, address _spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="146" endline="153" pcid="2054">
    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }


    function allowance(
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="225" endline="237" pcid="6786">
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(address _owner, address _spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DNP.sol" startline="215" endline="227" pcid="2802">
    function approve(address _spender, uint256 _value) public running returns (bool) 
    {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    /**
    * @dev Function to check the amount of tokens that an owner allowed to a spender.
    * @param _owner address The address which owns the funds.
    * @param _spender address The address which will spend the funds.
    * @return A uint256 specifying the amount of tokens still available for the spender.
    */
    function allowance(address _owner, address _spender) public view returns (uint256) 
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="589" endline="601" pcid="6626">
	function approve(address _spender, uint256 _value) public returns (bool) {
		allowed[msg.sender][_spender] = _value;
		emit Approval(msg.sender, _spender, _value);
		return true;
	}

	/**
	* @dev Function to check the amount of tokens that an owner allowed to a spender.
	* @param _owner address The address which owns the funds.
	* @param _spender address The address which will spend the funds.
	* @return A uint256 specifying the amount of tokens still available for the spender.
	*/
	function allowance(
</source>
<source file="systems/smart_contracts/SistContract.sol" startline="141" endline="153" pcid="6525">
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(address _owner, address _spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/SellableToken.sol" startline="84" endline="90" pcid="6467">
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }

  function allowance(address _owner, address _spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="192" endline="198" pcid="1639">
    function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
</source>
<source file="systems/smart_contracts/CoinDDC.sol" startline="88" endline="100" pcid="1866">
    function approve(
        address _spender, 
        uint256 _value
    ) 
    public 
    returns (bool) 
    {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(
</source>
<source file="systems/smart_contracts/BlockPoolToken.sol" startline="194" endline="205" pcid="1422">
    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param _owner address The address which owns the funds.
     * @param _spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address _owner, address _spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/customIcoToken.sol" startline="94" endline="100" pcid="2216">
    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/CST_TOKEN.sol" startline="96" endline="102" pcid="2205">
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }

  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/CDS.sol" startline="221" endline="233" pcid="1665">
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Transfer tokens from one address to another
   * @param _from address The address which you want to send tokens from
   * @param _to address The address which you want to transfer to
   * @param _value uint256 the amount of tokens to be transferred
   */
  function transferFrom(
</source>
<source file="systems/smart_contracts/CRYPTOMZ.sol" startline="177" endline="189" pcid="2186">
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/Ownable.sol" startline="122" endline="129" pcid="5573">
    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }


    function allowance(address _owner, address _spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="141" endline="153" pcid="7752">
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(address _owner, address _spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/FMT.sol" startline="97" endline="109" pcid="3655">
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(address _owner, address _spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="82" endline="88" pcid="7963">
    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
 
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/TECToken.sol" startline="70" endline="76" pcid="7136">
    function approve(address _spender, uint _value) returns (bool) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint) {
</source>
<source file="systems/smart_contracts/TeaToken.sol" startline="53" endline="62" pcid="7123">
    function approve(address _spender, uint256 _value)
        public
        returns (bool)
    {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender)
</source>
<source file="systems/smart_contracts/P21.sol" startline="70" endline="76" pcid="5588">
    function approve(address _spender, uint _value) returns (bool) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint) {
</source>
<source file="systems/smart_contracts/AronCoin.sol" startline="141" endline="153" pcid="768">
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(address _owner, address _spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/BDAM.sol" startline="224" endline="236" pcid="1126">
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="76" endline="82" pcid="4077">
    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
 
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="131" endline="138" pcid="1721">
    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    
    function allowance(address _owner, address _spender) public onlyPayloadSize(2) constant returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/UTC.sol" startline="170" endline="182" pcid="7585">
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(address _owner, address _spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/ZhongChaChainToken.sol" startline="53" endline="62" pcid="8220">
    function approve(address _spender, uint256 _value)
        public
        returns (bool)
    {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender)
</source>
<source file="systems/smart_contracts/BTToken.sol" startline="74" endline="80" pcid="1561">
    function approve(address _spender, uint _value) returns (bool) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint) {
</source>
<source file="systems/smart_contracts/BermToken.sol" startline="86" endline="92" pcid="1144">
    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
</source>
<source file="systems/smart_contracts/LuckyStrikeTokens.sol" startline="264" endline="284" pcid="4580">
    function approve(address _spender, uint256 _value) public returns (bool){
        require(_value >= 0);
        allowance[msg.sender][_spender] = _value;
        // event
        Approval(msg.sender, _spender, _value);
        return true;
    }

    /*  ---------- Interaction with other contracts  */

    /* User can allow another smart contract to spend some shares in his behalf
    *  (this function should be called by user itself)
    *  @param _spender another contract's address
    *  @param _value number of tokens
    *  @param _extraData Data that can be sent from user to another contract to be processed
    *  bytes - dynamically-sized byte array,
    *  see http://solidity.readthedocs.io/en/v0.4.15/types.html#dynamically-sized-byte-array
    *  see possible attack information in comments to function 'approve'
    *  > this may be used to convert pre-ICO tokens to ICO tokens
    */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool) {
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="277" endline="291" pcid="8088">
  function approve(address _spender, uint256 _value) public returns (bool) {
    _allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }



  /**
   * @dev Function to check the amount of tokens that an owner _allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(address _owner, address _spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/ICOImplementation.sol" startline="246" endline="260" pcid="4280">
    function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
        require(!frozen[_spender] && !frozen[msg.sender], "address frozen");
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }


    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param _owner address The address which owns the funds.
     * @param _spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="276" endline="280" pcid="7761">
  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
    return super.approve(_spender, _value);
  }

  function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {
</source>
<source file="systems/smart_contracts/AronCoin.sol" startline="276" endline="280" pcid="777">
  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
    return super.approve(_spender, _value);
  }

  function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {
</source>
<source file="systems/smart_contracts/CDS.sol" startline="357" endline="368" pcid="1673">
  function approve(
    address _spender,
    uint256 _value
  )
    public
    whenNotPaused
    returns (bool)
  {
    return super.approve(_spender, _value);
  }

  function increaseApproval(
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="276" endline="280" pcid="6792">
  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
    return super.approve(_spender, _value);
  }

  function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {
</source>
<source file="systems/smart_contracts/CouncilVesting.sol" startline="71" endline="72" pcid="2030">
    function approve(address _spender, uint256 _value) returns (bool success) {}
}
</source>
<source file="systems/smart_contracts/Hda.sol" startline="82" endline="91" pcid="4223">
    function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
       

    /* A contract attempts to get the coins */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/AT.sol" startline="92" endline="101" pcid="794">
    function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
       

    /* A contract attempts to get the coins */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
</source>
</class>

<class classid="43" nclones="81" nlines="4" similarity="75">
<source file="systems/smart_contracts/AACD.sol" startline="102" endline="106" pcid="298">
    function allowance(address _owner, address _spender)public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

}
</source>
<source file="systems/smart_contracts/UTC.sol" startline="182" endline="196" pcid="7586">
  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }

  /**
   * @dev Increase the amount of tokens that an owner allowed to a spender.
   *
   * approve should be called when allowed[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _addedValue The amount of tokens to increase the allowance by.
   */
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="202" endline="206" pcid="8027">
    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
    
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
</source>
<source file="systems/smart_contracts/AzurToken.sol" startline="91" endline="95" pcid="1009">
  function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }

  mapping (address => uint256) balances;
</source>
<source file="systems/smart_contracts/RETC.sol" startline="194" endline="198" pcid="6193">
    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }

    function withdraw() onlyOwner public {
</source>
<source file="systems/smart_contracts/SCMCoin.sol" startline="104" endline="107" pcid="6390">
    function allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
    }
}
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1024" endline="1028" pcid="6137">
  function allowance(address _owner, address _spender) constant returns (uint remaining) {
    return allowed[_owner][_spender];
  }

}
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="238" endline="242" pcid="1290">
    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
    
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
</source>
<source file="systems/smart_contracts/BlockPoolToken.sol" startline="205" endline="218" pcid="1423">
    function allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
    }
    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     *
     * approve should be called when allowed[_spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * @param _spender The address which will spend the funds.
     * @param _addedValue The amount of tokens to increase the allowance by.
     */
    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/SellableToken.sol" startline="90" endline="94" pcid="6468">
  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }

  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="295" endline="299" pcid="1452">
    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
    
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="292" endline="296" pcid="6500">
    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
    
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
</source>
<source file="systems/smart_contracts/DENARIO.sol" startline="69" endline="72" pcid="2452">
    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}
</source>
<source file="systems/smart_contracts/GoldenRings.sol" startline="126" endline="136" pcid="4179">
    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    /**
    * approve should be called when allowed[_spender] == 0. To increment
    * allowed value is better to use this function to avoid 2 calls (and wait until
    * the first transaction is mined)
    * From MonolithDAO Token.sol
    */
    function increaseApproval(address _spender, uint256 _addedValue) public returns (bool success) {
</source>
<source file="systems/smart_contracts/UNT.sol" startline="62" endline="65" pcid="7570">
    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }   
}
</source>
<source file="systems/smart_contracts/SHPC.sol" startline="62" endline="65" pcid="6512">
    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }   
}
</source>
<source file="systems/smart_contracts/SistContract.sol" startline="153" endline="167" pcid="6526">
  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }

  /**
   * @dev Increase the amount of tokens that an owner allowed to a spender.
   *
   * approve should be called when allowed[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _addedValue The amount of tokens to increase the allowance by.
   */
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/ICOImplementation.sol" startline="260" endline="285" pcid="4281">
    function allowance(
        address _owner,
        address _spender
    )
    public
    view
    returns (uint256)
    {
        return allowed[_owner][_spender];
    }
    




  
    


    // OWNER FUNCTIONALITY


    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/Ownable.sol" startline="129" endline="134" pcid="5574">
    function allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
     }


    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="299" endline="303" pcid="4317">
    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
    
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
</source>
<source file="systems/smart_contracts/BTGS.sol" startline="181" endline="188" pcid="1550">
    function allowance(address _owner, address _spender)
        public
        constant
        returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    function () public payable{
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="82" endline="86" pcid="4078">
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
 
    mapping (address => uint256) balances;
</source>
<source file="systems/smart_contracts/UGCoin.sol" startline="118" endline="122" pcid="7538">
    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
    
    function withdraw() onlyOwner public {
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="288" endline="292" pcid="6566">
    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
    
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
</source>
<source file="systems/smart_contracts/BermToken.sol" startline="92" endline="96" pcid="1145">
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }

    mapping (address => uint256) balances;
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="233" endline="237" pcid="4974">
    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
    
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="284" endline="288" pcid="3536">
    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
    
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
</source>
<source file="systems/smart_contracts/BTToken.sol" startline="80" endline="84" pcid="1562">
    function allowance(address _owner, address _spender) constant returns (uint) {
        return allowed[_owner][_spender];
    }

    mapping (address => uint) balances;
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="88" endline="92" pcid="7964">
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
 
    mapping (address => uint256) balances;
</source>
<source file="systems/smart_contracts/XGP.sol" startline="250" endline="254" pcid="8122">
    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
    
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
</source>
<source file="systems/smart_contracts/TECToken.sol" startline="76" endline="80" pcid="7137">
    function allowance(address _owner, address _spender) constant returns (uint) {
        return allowed[_owner][_spender];
    }

    mapping (address => uint) balances;
</source>
<source file="systems/smart_contracts/TeaToken.sol" startline="62" endline="70" pcid="7124">
    function allowance(address _owner, address _spender)
        constant
        public
        returns (uint256)
    {
        return allowed[_owner][_spender];
    }

    function balanceOf(address _owner)
</source>
<source file="systems/smart_contracts/MT.sol" startline="102" endline="106" pcid="5080">
    function allowance(address _owner, address _spender)public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

}
</source>
<source file="systems/smart_contracts/SAS.sol" startline="121" endline="125" pcid="6302">
  function allowance(address _owner, address _spender)public view returns (uint256 remaining) {
      return allowed[_owner][_spender];
  }

}
</source>
<source file="systems/smart_contracts/NaorisToken.sol" startline="172" endline="182" pcid="5292">
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    /**
     * approve should be called when allowed[_spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     */
    function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {
</source>
<source file="systems/smart_contracts/CouncilVesting.sol" startline="113" endline="117" pcid="2035">
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    mapping (address => uint256) balances;
</source>
<source file="systems/smart_contracts/NBToken.sol" startline="203" endline="216" pcid="5312">
    function allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
    }
    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     *
     * approve should be called when allowed[_spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * @param _spender The address which will spend the funds.
     * @param _addedValue The amount of tokens to increase the allowance by.
     */
    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/ZhongChaChainToken.sol" startline="62" endline="70" pcid="8221">
    function allowance(address _owner, address _spender)
        constant
        public
        returns (uint256)
    {
        return allowed[_owner][_spender];
    }

    function balanceOf(address _owner)
</source>
<source file="systems/smart_contracts/NEM.sol" startline="102" endline="106" pcid="5328">
    function allowance(address _owner, address _spender)public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

}
</source>
<source file="systems/smart_contracts/NMAI.sol" startline="102" endline="106" pcid="5450">
    function allowance(address _owner, address _spender)public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

}
</source>
<source file="systems/smart_contracts/AronCoin.sol" startline="153" endline="163" pcid="769">
  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }

  /**
   * approve should be called when allowed[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   */
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="288" endline="292" pcid="2969">
    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
    
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="202" endline="206" pcid="2893">
    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
    
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
</source>
<source file="systems/smart_contracts/Aigopay.sol" startline="250" endline="254" pcid="465">
    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
    
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
</source>
<source file="systems/smart_contracts/DNP.sol" startline="227" endline="231" pcid="2803">
    function allowance(address _owner, address _spender) public view returns (uint256) 
    {
        return allowed[_owner][_spender];
    }
}
</source>
<source file="systems/smart_contracts/DHF.sol" startline="102" endline="106" pcid="2545">
    function allowance(address _owner, address _spender)public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

}
</source>
<source file="systems/smart_contracts/OBK.sol" startline="62" endline="65" pcid="5472">
    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }   
}
</source>
<source file="systems/smart_contracts/OMGToken.sol" startline="184" endline="188" pcid="5497">
  function allowance(address _owner, address _spender) constant returns (uint remaining) {
    return allowed[_owner][_spender];
  }

}
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="237" endline="247" pcid="6787">
  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }

  /**
   * approve should be called when allowed[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   */
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="153" endline="165" pcid="2055">
    function allowance(
        address _owner,
        address _spender
    )
    public
    view
    returns (uint256)
    {
        return allowed[_owner][_spender];
    }


    function increaseApproval(
</source>
<source file="systems/smart_contracts/BACD.sol" startline="163" endline="172" pcid="1024">
  function allowance(address _owner, address _spender) public view
  returns (uint256 remaining) {
    return allowances [_owner][_spender];
  }

  /**
   * Mapping from addresses of token holders to the numbers of tokens belonging
   * to these token holders.
   */
  mapping (address => uint256) accounts;
</source>
<source file="systems/smart_contracts/P21.sol" startline="76" endline="80" pcid="5589">
    function allowance(address _owner, address _spender) constant returns (uint) {
        return allowed[_owner][_spender];
    }

    mapping (address => uint) balances;
</source>
<source file="systems/smart_contracts/CoinDDC.sol" startline="100" endline="111" pcid="1867">
    function allowance(
        address _owner,
        address _spender
    )
    public
    view
    returns (uint256)
    {
        return allowed[_owner][_spender];
    }

    function increaseApproval(
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="207" endline="211" pcid="2111">
  function allowance(address _owner, address _spender) constant returns (uint remaining) {
    return allowed[_owner][_spender];
  }

}
</source>
<source file="systems/smart_contracts/customIcoToken.sol" startline="77" endline="82" pcid="2214">
    function allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
    }

    /* Methods */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/VCTAToken.sol" startline="62" endline="65" pcid="7673">
    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}
</source>
<source file="systems/smart_contracts/CST_TOKEN.sol" startline="68" endline="72" pcid="2202">
  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }

  function transfer(address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/GameGold.sol" startline="291" endline="294" pcid="4004">
  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
}
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="172" endline="182" pcid="7463">
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    /**
     * approve should be called when allowed[_spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     */
    function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {
</source>
<source file="systems/smart_contracts/LBBT.sol" startline="92" endline="103" pcid="4545">
  function allowance(
    address _owner,
    address _spender
   )
    public
    view
    returns (uint256)
  {
    return allowed[_owner][_spender];
  }

  function increaseApproval(
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="138" endline="143" pcid="1722">
    function allowance(address _owner, address _spender) public onlyPayloadSize(2) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    
    function increaseApproval(address _spender, uint _addedValue) public returns (bool success) {
</source>
<source file="systems/smart_contracts/TorexToken.sol" startline="231" endline="252" pcid="7420">
  function allowance(
    address _owner,
    address _spender
   )
    public
    view
    returns (uint256)
  {
    return allowed[_owner][_spender];
  }

  /**
   * @dev Increase the amount of tokens that an owner allowed to a spender.
   *
   * approve should be called when allowed[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _addedValue The amount of tokens to increase the allowance by.
   */
  function increaseApproval(
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="153" endline="163" pcid="7753">
  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }

  /**
   * approve should be called when allowed[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   */
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/CRYPTOMZ.sol" startline="189" endline="198" pcid="2187">
  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }

  /**
   * approve should be called when allowed[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   */
  function increaseApproval (address _spender, uint _addedValue) public
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="601" endline="621" pcid="6627">
	function allowance(
		address _owner,
		address _spender
	)
	public
	view
	returns (uint256)
	{
		return allowed[_owner][_spender];
	}

	/**
	* @dev Increase the amount of tokens that an owner allowed to a spender.
	* approve should be called when allowed[_spender] == 0. To increment
	* allowed value is better to use this function to avoid 2 calls (and wait until
	* the first transaction is mined)
	* From MonolithDAO Token.sol
	* @param _spender The address which will spend the funds.
	* @param _addedValue The amount of tokens to increase the allowance by.
	*/
	function increaseApproval(
</source>
<source file="systems/smart_contracts/Warpcoin.sol" startline="69" endline="72" pcid="7950">
    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}
</source>
<source file="systems/smart_contracts/FMT.sol" startline="109" endline="123" pcid="3656">
  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }

  /**
   * @dev Increase the amount of tokens that an owner allowed to a spender.
   *
   * approve should be called when allowed[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _addedValue The amount of tokens to increase the allowance by.
   */
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="112" endline="123" pcid="4653">
  function allowance(
    address _owner,
    address _spender
   )
    public
    view
    returns (uint256)
  {
    return allowed[_owner][_spender];
  }

  function increaseApproval(
</source>
<source file="systems/smart_contracts/MBA.sol" startline="285" endline="305" pcid="4722">
  function allowance(
    address _owner,
    address _spender
   )
    public
    view
    returns (uint256)
  {
    return allowed[_owner][_spender];
  }

  /**
   * @dev Increase the amount of tokens that an owner allowed to a spender.
   * approve should be called when allowed[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _addedValue The amount of tokens to increase the allowance by.
   */
  function increaseApproval(
</source>
<source file="systems/smart_contracts/MiniMeTokenFactory.sol" startline="283" endline="294" pcid="4812">
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    /// @notice `msg.sender` approves `_spender` to send `_amount` tokens on
    ///  its behalf, and then a function is triggered in the contract that is
    ///  being approved, `_spender`. This allows users to use their tokens to
    ///  interact with contracts in one function call instead of two
    /// @param _spender The address of the contract able to transfer the tokens
    /// @param _amount The amount of tokens to be approved for transfer
    /// @return True if the function call was successful
    function approveAndCall(ApproveAndCallFallBack _spender, uint256 _amount, bytes _extraData) public returns (bool success) {
</source>
<source file="systems/smart_contracts/CAC.sol" startline="102" endline="106" pcid="1619">
    function allowance(address _owner, address _spender)public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

}
</source>
<source file="systems/smart_contracts/CDS.sol" startline="186" endline="202" pcid="1663">
  function allowance(
    address _owner,
    address _spender
   )
    public
    view
    returns (uint256)
  {
    return allowed[_owner][_spender];
  }

  /**
  * @dev Transfer token for a specified address
  * @param _to The address to transfer to.
  * @param _value The amount to be transferred.
  */
  function transfer(address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="1029" endline="1033" pcid="4897">
  function allowance(address _owner, address _spender) constant returns (uint remaining) {
    return allowed[_owner][_spender];
  }

}
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="269" endline="273" pcid="6701">
    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
    
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
</source>
<source file="systems/smart_contracts/BDAM.sol" startline="236" endline="246" pcid="1127">
  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }

  /**
   * approve should be called when allowed[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   */
  function increaseApproval (address _spender, uint _addedValue)
</source>
<source file="systems/smart_contracts/PositionTokenV2.sol" startline="323" endline="333" pcid="5762">
    function allowance(
        address _owner,
        address _spender)
        public
        view
        returns (uint256)
    {
        return denormalize(allowed[_owner][_spender]);
    }

    function normalize(
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="291" endline="306" pcid="8089">
  function allowance(address _owner, address _spender) public view returns (uint256) {
    return _allowed[_owner][_spender];
  }



  /**
   * @dev Increase the amount of tokens that an owner _allowed to a spender.
   *
   * approve should be called when _allowed[_spender] == 0. To increment
   * _allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)   
   * @param _spender The address which will spend the funds.
   * @param _addedValue The amount of tokens to increase the allowance by.
   */
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/P21.sol" startline="38" endline="40" pcid="5584">
    function allowance(address _owner, address _spender) constant returns (uint remaining) {}

    event Transfer(address indexed _from, address indexed _to, uint _value);
</source>
<source file="systems/smart_contracts/BTToken.sol" startline="42" endline="44" pcid="1557">
    function allowance(address _owner, address _spender) constant returns (uint remaining) {}

    event Transfer(address indexed _from, address indexed _to, uint _value);
</source>
<source file="systems/smart_contracts/TECToken.sol" startline="38" endline="40" pcid="7132">
    function allowance(address _owner, address _spender) constant returns (uint remaining) {}

    event Transfer(address indexed _from, address indexed _to, uint _value);
</source>
<source file="systems/smart_contracts/CouncilVesting.sol" startline="65" endline="69" pcid="2027">
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}

    // NON-CONSTANT METHODS

    function transfer(address _to, uint256 _value) returns (bool success) {}
</source>
</class>

<class classid="44" nclones="94" nlines="4" similarity="75">
<source file="systems/smart_contracts/ABCToken.sol" startline="119" endline="126" pcid="305">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="313" endline="320" pcid="956">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See `IERC20.balanceOf`.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="135" endline="144" pcid="2744">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param owner The address to query the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="605" endline="609" pcid="2714">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="374" endline="378" pcid="2685">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="609" endline="613" pcid="2623">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DNP.sol" startline="144" endline="153" pcid="2798">
    function totalSupply() public view returns (uint256) 
    {
        return totalSupply_;
    }
    /**
    * @dev transfer token for a specified address
    * @param _to The address to transfer to.
    * @param _value The amount to be transferred.
    */
    function transfer(address _to, uint256 _value) public running returns (bool) 
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="378" endline="382" pcid="2594">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="313" endline="320" pcid="2469">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See `IERC20.balanceOf`.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="103" endline="107" pcid="2400">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="180" endline="183" pcid="2860">
    function totalSupply() public view returns (uint256){
        return operator.token_totalSupply();
    }
    function balanceOf(address addr)public view returns(uint256){
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="72" endline="76" pcid="2307">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/BANG.sol" startline="97" endline="101" pcid="1049">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="219" endline="228" pcid="2244">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev Gets the balance of the specified address.
     * @param owner The address to query the balance of.
     * @return An uint256 representing the amount owned by the passed address.
     */
    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/customIcoToken.sol" startline="69" endline="73" pcid="2212">
    function totalSupply() public view returns (uint256) {
        return totalSupply;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="95" endline="99" pcid="2158">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="393" endline="402" pcid="597">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
    * @dev Gets the balance of the specified address.
    * @param owner The address to query the balance of.
    * @return An uint256 representing the amount owned by the passed address.
    */
    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="114" endline="121" pcid="2983">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  /**
   * @dev See `IERC20.balanceOf`.
   */
  function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="101" endline="105" pcid="2050">
    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }

    function transfer(address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="84" endline="93" pcid="3017">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev Gets the balance of the specified address.
     * @param owner The address to query the balance of.
     * @return A uint256 representing the amount owned by the passed address.
     */
    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/BCCT.sol" startline="55" endline="62" pcid="1091">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Comet.sol" startline="93" endline="97" pcid="1926">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/CNG.sol" startline="130" endline="139" pcid="1851">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param owner The address to query the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="235" endline="242" pcid="1755">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See `IERC20.balanceOf`.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="810" endline="820" pcid="3107">
  function totalSupply() public view returns (uint256) {
    return allTokens.length;
  }

  /**
   * @dev Gets the token ID at a given index of all the tokens in this contract
   * Reverts if the index is greater or equal to the total number of tokens
   * @param _index uint256 representing the index to be accessed of the tokens list
   * @return uint256 token ID at the given index of the tokens list
   */
  function tokenByIndex(uint256 _index) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="227" endline="234" pcid="653">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See `IERC20.balanceOf`.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="114" endline="118" pcid="3175">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/CDS.sol" startline="167" endline="176" pcid="1661">
  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="153" endline="157" pcid="1635">
    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }

    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="239" endline="246" pcid="8235">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See `IERC20.balanceOf`.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Byte.sol" startline="103" endline="107" pcid="1579">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/BTGS.sol" startline="71" endline="85" pcid="1543">
    function totalSupply()
        public
        constant
        returns (uint256) {
        return _totalSupply;
    }





    /// @dev Gets account's balance
    /// @param _addr Address of the account
    /// @return Account balance
    function balanceOf(address _addr)
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="578" endline="587" pcid="3273">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev Returns whether the specified token exists
     * @param tokenId uint256 ID of the token to query the existence of
     * @return whether the token exists
     */
    function exists(uint256 tokenId) external view returns (bool) {
</source>
<source file="systems/smart_contracts/ankara.sol" startline="84" endline="88" pcid="686">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="223" endline="230" pcid="8196">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See `IERC20.balanceOf`.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="97" endline="101" pcid="1473">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="215" endline="224" pcid="8084">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  /**
   * @dev Gets the balance of the specified address.
   * @param _owner The address to query the the balance of.
   * @return An uint256 representing the amount owned by the passed address.
   */
  function balanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="137" endline="146" pcid="735">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
    * @dev Gets the balance of the specified address.
    * @param owner The address to query the balance of.
    * @return An uint256 representing the amount owned by the passed address.
    */
    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="91" endline="95" pcid="8051">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }
    
    function name() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="289" endline="298" pcid="3570">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
    * @dev Gets the balance of the specified address.
    * @param owner The address to query the balance of.
    * @return An uint256 representing the amount owned by the passed address.
    */
    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="110" endline="117" pcid="7984">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  /**
   * @dev See `IERC20.balanceOf`.
   */
  function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/FMT.sol" startline="33" endline="42" pcid="3651">
  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }

  /**
  * @dev transfer token for a specified address
  * @param _to The address to transfer to.
  * @param _value The amount to be transferred.
  */
  function transfer(address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/BlockPoolToken.sol" startline="73" endline="80" pcid="1412">
    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }

    /**
     * @dev total number of tokens already burned
     */
    function totalBurned() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="125" endline="134" pcid="1370">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
    * @dev Gets the balance of the specified address.
    * @param owner The address to query the balance of.
    * @return An uint256 representing the amount owned by the passed address.
    */
    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/FogCoin.sol" startline="46" endline="55" pcid="3679">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev Gets the balance of the specified address.
     * @param owner The address to query the balance of.
     * @return A uint256 representing the amount owned by the passed address.
     */
    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="230" endline="237" pcid="7906">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See `IERC20.balanceOf`.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="349" endline="356" pcid="3810">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See `IERC20.balanceOf`.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="93" endline="97" pcid="3926">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="312" endline="321" pcid="6335">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev Gets the balance of the specified address.
     * @param owner The address to query the balance of.
     * @return An uint256 representing the amount owned by the passed address.
     */
    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="219" endline="228" pcid="7717">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev Gets the balance of the specified address.
     * @param owner The address to query the balance of.
     * @return An uint256 representing the amount owned by the passed address.
     */
    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="256" endline="263" pcid="4040">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See `IERC20.balanceOf`.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="133" endline="142" pcid="7646">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev Gets the balance of the specified address.
     * @param owner The address to query the balance of.
     * @return A uint256 representing the amount owned by the passed address.
     */
    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/VACCToken.sol" startline="135" endline="143" pcid="7626">
    function totalSupply() public constant returns (uint256) {
        return _totalSupply;
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/UTC.sol" startline="85" endline="94" pcid="7578">
  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }

  /**
  * @dev transfer token for a specified address
  * @param _to The address to transfer to.
  * @param _value The amount to be transferred.
  */
  function transfer(address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="135" endline="144" pcid="4240">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param owner The address to query the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/ICOImplementation.sol" startline="172" endline="182" pcid="4276">
    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }


    /**
    * @dev Transfer token for a specified address
    * @param _to The address to transfer to.
    * @param _value The amount to be transferred.
    */
    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="154" endline="158" pcid="4389">
    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }

    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="291" endline="298" pcid="4429">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See `IERC20.balanceOf`.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="80" endline="89" pcid="7455">
    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }

    /**
    * @dev transfer token for a specified address
    * @param _to The address to transfer to.
    * @param _value The amount to be transferred.
    */
    function transfer(address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/TournamentGameToken.sol" startline="112" endline="120" pcid="7439">
    function totalSupply()  constant returns (uint ) {
        return _totalSupply;
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/BFGToken.sol" startline="76" endline="80" pcid="1187">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  function balanceOf(address addr) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/LBBT.sol" startline="67" endline="71" pcid="4541">
  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }

  function transfer(address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="95" endline="99" pcid="5998">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="450" endline="457" pcid="5364">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev Returns the amount of VOKEN owned by `account`.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/NBToken.sol" startline="112" endline="121" pcid="5304">
    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }

    /**
     * @dev transfer token for a specified address
     * @param _to The address to transfer to.
     * @param _value The amount to be transferred.
     */
    function transfer(address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/NaorisToken.sol" startline="80" endline="89" pcid="5284">
    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }

    /**
    * @dev transfer token for a specified address
    * @param _to The address to transfer to.
    * @param _value The amount to be transferred.
    */
    function transfer(address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="278" endline="287" pcid="6997">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev Gets the balance of the specified address.
     * @param owner The address to query the balance of.
     * @return A uint256 representing the amount owned by the passed address.
     */
    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="313" endline="320" pcid="6028">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See `IERC20.balanceOf`.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="432" endline="439" pcid="5167">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See `IERC20.balanceOf`.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="267" endline="274" pcid="5422">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="247" endline="254" pcid="5960">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See `IERC20.balanceOf`.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/SistContract.sol" startline="68" endline="77" pcid="6521">
  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }

  /**
  * @dev transfer token for a specified address
  * @param _to The address to transfer to.
  * @param _value The amount to be transferred.
  */
  function transfer(address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="230" endline="237" pcid="7022">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See `IERC20.balanceOf`.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/TorexToken.sol" startline="89" endline="98" pcid="7410">
  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }

  /**
  * @dev transfer token for a specified address
  * @param _to The address to transfer to.
  * @param _value The amount to be transferred.
  */
  function transfer(address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="93" endline="97" pcid="6209">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/RubyToken.sol" startline="37" endline="41" pcid="6226">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }
    
    function _transfer(address _from, address _to, uint256 _value) internal {
</source>
<source file="systems/smart_contracts/magesh.sol" startline="115" endline="124" pcid="4618">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev Gets the balance of the specified address.
     * @param owner The address to query the balance of.
     * @return A uint256 representing the amount owned by the passed address.
     */
    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="138" endline="142" pcid="5101">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function myTokens() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="219" endline="228" pcid="6730">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev Gets the balance of the specified address.
     * @param owner The address to query the balance of.
     * @return An uint256 representing the amount owned by the passed address.
     */
    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="279" endline="286" pcid="5916">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="49" endline="53" pcid="4645">
  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }

  function transfer(address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="349" endline="358" pcid="5688">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
    * @dev Gets the balance of the specified address.
    * @param owner The address to query the balance of.
    * @return An uint256 representing the amount owned by the passed address.
    */
    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/PositionTokenV2.sol" startline="306" endline="314" pcid="5760">
    function totalSupply()
        public
        view
        returns (uint256)
    {
        return denormalize(totalSupply_);
    }

    function balanceOf(
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="269" endline="276" pcid="5785">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="977" endline="987" pcid="5044">
    function totalSupply() public view returns (uint256) {
        return _allTokens.length;
    }

    /**
     * @dev Gets the token ID at a given index of all the tokens in this contract
     * Reverts if the index is greater or equal to the total number of tokens.
     * @param index uint256 representing the index to be accessed of the tokens list
     * @return uint256 token ID at the given index of the tokens list
     */
    function tokenByIndex(uint256 index) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/ProxyERC20.sol" startline="417" endline="427" pcid="5896">
    function totalSupply() public view returns (uint256) {
        // Immutable static call from target contract
        return IERC20(target).totalSupply();
    }

    /**
    * @dev Gets the balance of the specified address.
    * @param owner The address to query the balance of.
    * @return An uint256 representing the amount owned by the passed address.
    */
    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="271" endline="278" pcid="7183">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     *  See `IERC20.balanceOf`.
     */
    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/MatchingToken.sol" startline="37" endline="41" pcid="4685">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }
    
    function _transfer(address _from, address _to, uint256 _value) internal {
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="93" endline="97" pcid="7324">
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="494" endline="503" pcid="6619">
	function totalSupply() public view returns (uint256) {
		return totalSupply_;
	}

	/**
	* @dev Transfer token for a specified address
	* @param _to The address to transfer to.
	* @param _value The amount to be transferred.
	*/
	function transfer(address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/MBA.sol" startline="72" endline="81" pcid="4705">
  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }

  /**
  * @dev Transfer token for a specified address
  * @param _to The address to transfer to.
  * @param _value The amount to be transferred.
  */
  function transfer(address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="261" endline="270" pcid="5854">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
    * @dev Gets the balance of the specified address.
    * @param owner The address to query the balance of.
    * @return An uint256 representing the amount owned by the passed address.
    */
    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="115" endline="124" pcid="4930">
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev Gets the balance of the specified address.
     * @param owner The address to query the balance of.
     * @return A uint256 representing the amount owned by the passed address.
     */
    function balanceOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/BKN.sol" startline="55" endline="58" pcid="1324">
    function totalSupply() public constant returns (uint256) {
        return totalSupply;
    }
    function balanceOf(address src) public constant returns (uint256) {
</source>
</class>

<class classid="45" nclones="27" nlines="4" similarity="100">
<source file="systems/smart_contracts/ABCToken.sol" startline="126" endline="138" pcid="306">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="254" endline="266" pcid="5961">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See `IERC20.transfer`.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="286" endline="298" pcid="5917">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="320" endline="332" pcid="6029">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See `IERC20.transfer`.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/BCCT.sol" startline="62" endline="74" pcid="1092">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="320" endline="332" pcid="2470">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See `IERC20.transfer`.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="276" endline="283" pcid="5786">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }
    
    /**
     * @dev Returns the name of the token.
     */
    function name() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="274" endline="286" pcid="5423">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="457" endline="464" pcid="5365">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev Returns the reserved amount of VOKEN by `account`.
     */
    function reservedOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="439" endline="451" pcid="5168">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See `IERC20.transfer`.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="237" endline="249" pcid="7023">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See `IERC20.transfer`.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="278" endline="290" pcid="7184">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     *  See `IERC20.transfer`.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1470" endline="1481" pcid="1831">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev Overrides parent by storing due balances, and delivering tokens to the vault instead of the end user. This
     * ensures that the tokens will be available by the time they are withdrawn (which may not be the case if
     * `_deliverTokens` was called later).
     * @param beneficiary Token purchaser
     * @param tokenAmount Amount of tokens purchased
     */
    function _processPurchase(address beneficiary, uint256 tokenAmount) internal {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="242" endline="254" pcid="1756">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See `IERC20.transfer`.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="234" endline="246" pcid="654">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See `IERC20.transfer`.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="298" endline="310" pcid="4430">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See `IERC20.transfer`.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="263" endline="274" pcid="4041">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See `IERC20.transfer`.
     *
     * Requirements:
     *
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="356" endline="368" pcid="3811">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See `IERC20.transfer`.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="237" endline="249" pcid="7907">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See `IERC20.transfer`.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="117" endline="125" pcid="7985">
  function balanceOf(address account) public view returns (uint256) {
    return _balances[account];
  }


  /**
   * @dev See `IERC20.allowance`.
   */
  function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="115" endline="119" pcid="8057">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="230" endline="242" pcid="8197">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See `IERC20.transfer`.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="246" endline="258" pcid="8236">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See `IERC20.transfer`.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="121" endline="129" pcid="2984">
  function balanceOf(address account) public view returns (uint256) {
    return _balances[account];
  }


  /**
   * @dev See `IERC20.allowance`.
   */
  function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="320" endline="332" pcid="957">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See `IERC20.transfer`.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="378" endline="382" pcid="2686">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="382" endline="386" pcid="2595">
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
</class>

<class classid="46" nclones="25" nlines="4" similarity="75">
<source file="systems/smart_contracts/ABCToken.sol" startline="138" endline="146" pcid="307">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="332" endline="340" pcid="6030">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev See `IERC20.allowance`.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="266" endline="274" pcid="5962">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev See `IERC20.allowance`.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="249" endline="257" pcid="7024">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev See `IERC20.allowance`.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="298" endline="306" pcid="5918">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="254" endline="262" pcid="1757">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev See `IERC20.allowance`.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="246" endline="254" pcid="655">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev See `IERC20.allowance`.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="319" endline="327" pcid="5790">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="286" endline="294" pcid="5424">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="360" endline="378" pcid="8004">
  function transfer(address recipient, uint256 amount) public returns (bool) {
    require(!_locked[msg.sender]);
    _transfer(msg.sender, recipient, amount);
    return true;
  }

  /**
   * @dev See `IERC20.transferFrom`.
   *
   * Emits an `Approval` event indicating the updated allowance. This is not
   * required by the EIP. See the note at the beginning of `ERC20`;
   *
   * Requirements:
   * - `sender` and `recipient` cannot be the zero address.
   * - `sender` must have a balance of at least `value`.
   * - the caller must have allowance for `sender`'s tokens of at least
   * `amount`.
   */
  function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="249" endline="257" pcid="7908">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev See `IERC20.allowance`.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="451" endline="459" pcid="5169">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev See `IERC20.allowance`.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="386" endline="391" pcid="2596">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="290" endline="298" pcid="7185">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     *  See `IERC20.allowance`.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="310" endline="318" pcid="4431">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev See `IERC20.allowance`.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="382" endline="387" pcid="2687">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="274" endline="282" pcid="4042">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev See `IERC20.allowance`.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="332" endline="340" pcid="958">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev See `IERC20.allowance`.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="368" endline="376" pcid="3812">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev See `IERC20.allowance`.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="336" endline="354" pcid="3002">
  function transfer(address recipient, uint256 amount) public returns (bool) {
    require(!_locked[msg.sender]);
    _transfer(msg.sender, recipient, amount);
    return true;
  }

  /**
   * @dev See `IERC20.transferFrom`.
   *
   * Emits an `Approval` event indicating the updated allowance. This is not
   * required by the EIP. See the note at the beginning of `ERC20`;
   *
   * Requirements:
   * - `sender` and `recipient` cannot be the zero address.
   * - `sender` must have a balance of at least `value`.
   * - the caller must have allowance for `sender`'s tokens of at least
   * `amount`.
   */
  function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="258" endline="266" pcid="8237">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev See `IERC20.allowance`.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="242" endline="250" pcid="8198">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev See `IERC20.allowance`.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="332" endline="340" pcid="2471">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev See `IERC20.allowance`.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/BCCT.sol" startline="74" endline="82" pcid="1093">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="119" endline="124" pcid="8058">
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
</source>
</class>

<class classid="47" nclones="63" nlines="4" similarity="75">
<source file="systems/smart_contracts/ABCToken.sol" startline="146" endline="157" pcid="308">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Comet.sol" startline="101" endline="105" pcid="1928">
  function allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }

  function findOnePercent(uint256 value) public view returns (uint256)  {
</source>
<source file="systems/smart_contracts/BCCT.sol" startline="82" endline="93" pcid="1094">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="412" endline="421" pcid="599">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }

    /**
    * @dev Transfer token for a specified address
    * @param to The address to transfer to.
    * @param value The amount to be transferred.
    */
    function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="103" endline="107" pcid="2160">
  function allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }

  function getTokensToBurn(uint256 value) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="238" endline="255" pcid="2246">
    function allowance(
        address owner,
        address spender
    )
    public
    view
    returns (uint256)
    {
        require(!frozenAccount[msg.sender]);
        return _allowed[owner][spender];
    }

    /**
     * @dev Transfer token for a specified address
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/BANG.sol" startline="105" endline="109" pcid="1051">
  function allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }

  function findTwentyPercent(uint256 value) public view returns (uint256)  {
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="80" endline="84" pcid="2309">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }

    function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="111" endline="115" pcid="2402">
  function allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }

    function findPercent(uint256 value) public view returns (uint256)  {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="340" endline="351" pcid="2472">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See `IERC20.approve`.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="391" endline="395" pcid="2597">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="617" endline="621" pcid="2625">
  function allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }

  function cut(uint256 value) public view returns (uint256)  {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="387" endline="391" pcid="2688">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="613" endline="617" pcid="2716">
  function allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }

  function cut(uint256 value) public view returns (uint256)  {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="340" endline="351" pcid="959">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See `IERC20.approve`.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/CNG.sol" startline="149" endline="165" pcid="1853">
  function allowance(
    address owner,
    address spender
   )
    public
    view
    returns (uint256)
  {
    return _allowed[owner][spender];
  }

  /**
  * @dev Transfer token for a specified address
  * @param to The address to transfer to.
  * @param value The amount to be transferred.
  */
  function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="154" endline="170" pcid="2746">
  function allowance(
    address owner,
    address spender
   )
    public
    view
    returns (uint256)
  {
    return _allowed[owner][spender];
  }

  /**
  * @dev Transfer token for a specified address
  * @param to The address to transfer to.
  * @param value The amount to be transferred.
  */
  function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="129" endline="140" pcid="2985">
  function allowance(address owner, address spender) public view returns (uint256) {
    return _allowances[owner][spender];
  }

  /**
   * @dev See `IERC20.approve`.
   *
   * Requirements:
   *
   * - `spender` cannot be the zero address.
   */
  function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="103" endline="112" pcid="3019">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev Transfer token to a specified address.
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="122" endline="126" pcid="3177">
  function allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }

  function findFivePercent(uint256 value) public view returns (uint256)  {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="266" endline="277" pcid="8238">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See `IERC20.approve`.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="250" endline="261" pcid="8199">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See `IERC20.approve`.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="124" endline="128" pcid="8059">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="308" endline="317" pcid="3572">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }

    /**
    * @dev Transfer token for a specified address
    * @param to The address to transfer to.
    * @param value The amount to be transferred.
    */
    function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="125" endline="136" pcid="7986">
  function allowance(address owner, address spender) public view returns (uint256) {
    return _allowances[owner][spender];
  }

  /**
   * @dev See `IERC20.approve`.
   *
   * Requirements:
   *
   * - `spender` cannot be the zero address.
   */
  function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/FogCoin.sol" startline="65" endline="74" pcid="3681">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev Transfer token to a specified address.
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="331" endline="340" pcid="6337">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }

    /**
     * @dev Transfer token for a specified address
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="257" endline="268" pcid="7909">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See `IERC20.approve`.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="376" endline="387" pcid="3813">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See `IERC20.approve`.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="101" endline="105" pcid="3928">
  function allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }

  function findFivePercent(uint256 value) public view returns (uint256)  {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="238" endline="255" pcid="7719">
    function allowance(
        address owner,
        address spender
    )
    public
    view
    returns (uint256)
    {
        require(!frozenAccount[msg.sender]);
        return _allowed[owner][spender];
    }

    /**
     * @dev Transfer token for a specified address
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="282" endline="293" pcid="4043">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See `IERC20.approve`.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="152" endline="161" pcid="7648">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }

    /**
     * @dev Transfer token to a specified address
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="154" endline="170" pcid="4242">
  function allowance(
    address owner,
    address spender
  )
  public
  view
  returns (uint256)
  {
    return _allowed[owner][spender];
  }

  /**
  * @dev Transfer token for a specified address
  * @param to The address to transfer to.
  * @param value The amount to be transferred.
  */
  function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="318" endline="329" pcid="4432">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See `IERC20.approve`.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/magesh.sol" startline="134" endline="143" pcid="4620">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }

    /**
     * @dev Transfer token to a specified address.
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="101" endline="105" pcid="7326">
  function allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }

  function findOnePercent(uint256 value) public view returns (uint256)  {
</source>
<source file="systems/smart_contracts/Token.sol" startline="104" endline="113" pcid="7256">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }

    /**
     * @dev Transfer token to a specified address.
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="134" endline="143" pcid="4932">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }

    /**
     * @dev Transfer token to a specified address.
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="298" endline="309" pcid="7186">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     *  See `IERC20.approve`.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="150" endline="154" pcid="5104">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }

    modifier onlyOwner(){
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="257" endline="268" pcid="7025">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See `IERC20.approve`.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="459" endline="470" pcid="5170">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See `IERC20.approve`.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="297" endline="306" pcid="6999">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }

    /**
     * @dev Transfer token to a specified address.
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="629" endline="638" pcid="5377">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * Emits an {Approval} event indicating the updated allowance.
     */
    function increaseAllowance(address spender, uint256 addedValue) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="262" endline="273" pcid="1758">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See `IERC20.approve`.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="294" endline="305" pcid="5425">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="238" endline="255" pcid="6732">
    function allowance(
        address owner,
        address spender
    )
    public
    view
    returns (uint256)
    {
        require(!frozenAccount[msg.sender]);
        return _allowed[owner][spender];
    }

    /**
     * @dev Transfer token for a specified address
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="368" endline="377" pcid="5690">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }

    /**
    * @dev Transfer token for a specified address
    * @param to The address to transfer to.
    * @param value The amount to be transferred.
    */
    function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="327" endline="338" pcid="5791">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="280" endline="296" pcid="5856">
    function allowance(
        address owner,
        address spender
    )
    public
    view
    returns (uint256)
    {
        return _allowed[owner][spender];
    }

    /**
    * @dev Transfer token for a specified address
    * @param to The address to transfer to.
    * @param value The amount to be transferred.
    */
    function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="254" endline="265" pcid="656">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See `IERC20.approve`.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ProxyERC20.sol" startline="438" endline="455" pcid="5898">
    function allowance(
        address owner,
        address spender
    )
        public
        view
        returns (uint256)
    {
        // Immutable static call from target contract
        return IERC20(target).allowance(owner, spender);
    }

    /**
    * @dev Transfer token for a specified address
    * @param to The address to transfer to.
    * @param value The amount to be transferred.
    */
    function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="306" endline="317" pcid="5919">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="156" endline="165" pcid="737">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }

    /**
    * @dev Transfer token for a specified address
    * @param to The address to transfer to.
    * @param value The amount to be transferred.
    */
    function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Byte.sol" startline="111" endline="117" pcid="1581">
  function allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }



  function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="274" endline="285" pcid="5963">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See `IERC20.approve`.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="103" endline="107" pcid="6000">
  function allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }

  function findOneTenthPercent(uint256 value) public view returns (uint256)  {
</source>
<source file="systems/smart_contracts/ankara.sol" startline="92" endline="96" pcid="688">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }

    function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="340" endline="351" pcid="6031">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See `IERC20.approve`.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="105" endline="109" pcid="1475">
  function allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }

  function findOnePercent(uint256 value) public view returns (uint256)  {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="144" endline="153" pcid="1372">
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }

    /**
    * @dev Transfer token for a specified address
    * @param to The address to transfer to.
    * @param value The amount to be transferred.
    */
    function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="101" endline="105" pcid="6211">
  function allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }

  function findOnePercent(uint256 value) public view returns (uint256)  {
</source>
</class>

<class classid="48" nclones="72" nlines="4" similarity="75">
<source file="systems/smart_contracts/ABCToken.sol" startline="157" endline="174" pcid="309">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20};
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/ProxyERC20.sol" startline="475" endline="492" pcid="5900">
    function approve(address spender, uint256 value) public returns (bool) {
        // Mutable state call requires the proxy to tell the target who the msg.sender is.
        target.setMessageSender(msg.sender);

        // Forward the ERC20 call to the target contract
        IERC20(target).approve(spender, value);

        // Event emitting will occur via Synthetix.Proxy._emit()
        return true;
    }

    /**
    * @dev Transfer tokens from one address to another
    * @param from address The address which you want to send tokens from
    * @param to address The address which you want to transfer to
    * @param value uint256 the amount of tokens to be transferred
    */
    function transferFrom(
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="184" endline="198" pcid="4244">
  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));

    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }

  /**
   * @dev Transfer tokens from one address to another
   * @param from address The address which you want to send tokens from
   * @param to address The address which you want to transfer to
   * @param value uint256 the amount of tokens to be transferred
   */
  function transferFrom(
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="391" endline="396" pcid="2689">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="317" endline="334" pcid="5920">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20};
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="351" endline="368" pcid="960">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev See `IERC20.transferFrom`.
     *
     * Emits an `Approval` event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of `ERC20`;
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="646" endline="653" pcid="2720">
  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }

  function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="175" endline="188" pcid="7650">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev Transfer tokens from one address to another.
     * Note that while this function emits an Approval event, this is not required as per the specification,
     * and other compliant implementations may not emit the event.
     * @param from address The address which you want to send tokens from
     * @param to address The address which you want to transfer to
     * @param value uint256 the amount of tokens to be transferred
     */
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="285" endline="302" pcid="5964">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev See `IERC20.transferFrom`.
     *
     * Emits an `Approval` event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of `ERC20`;
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/BCCT.sol" startline="93" endline="110" pcid="1095">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20};
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="293" endline="310" pcid="4044">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev See `IERC20.transferFrom`.
     *
     * Emits an `Approval` event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of `ERC20`;
     *
     * Requirements:
     * - `sender` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/CNG.sol" startline="179" endline="193" pcid="1855">
  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));

    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }

  /**
   * @dev Transfer tokens from one address to another
   * @param from address The address which you want to send tokens from
   * @param to address The address which you want to transfer to
   * @param value uint256 the amount of tokens to be transferred
   */
  function transferFrom(
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="136" endline="143" pcid="6004">
  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }

  function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="310" endline="324" pcid="5858">
    function approve(address spender, uint256 value) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev Transfer tokens from one address to another
     * @param from address The address which you want to send tokens from
     * @param to address The address which you want to transfer to
     * @param value uint256 the amount of tokens to be transferred
     */
    function transferFrom(
</source>
<source file="systems/smart_contracts/Comet.sol" startline="135" endline="142" pcid="1932">
  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }

  function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="329" endline="346" pcid="4433">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev See `IERC20.transferFrom`.
     *
     * Emits an `Approval` event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of `ERC20`;
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/magesh.sol" startline="157" endline="170" pcid="4622">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev Transfer tokens from one address to another.
     * Note that while this function emits an Approval event, this is not required as per the specification,
     * and other compliant implementations may not emit the event.
     * @param from address The address which you want to send tokens from
     * @param to address The address which you want to transfer to
     * @param value uint256 the amount of tokens to be transferred
     */
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="351" endline="368" pcid="6032">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev See `IERC20.transferFrom`.
     *
     * Emits an `Approval` event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of `ERC20`;
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="179" endline="193" pcid="739">
    function approve(address spender, uint256 value) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    /**
    * @dev Transfer tokens from one address to another
    * @param from address The address which you want to send tokens from
    * @param to address The address which you want to transfer to
    * @param value uint256 the amount of tokens to be transferred
    */
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="650" endline="657" pcid="2629">
  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }

  function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="270" endline="285" pcid="7721">
    function approve(address spender, uint256 value) public returns (bool) {
        require(spender != address(0));
        require(!frozenAccount[msg.sender]);

        _allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev Transfer tokens from one address to another
     * @param from address The address which you want to send tokens from
     * @param to address The address which you want to transfer to
     * @param value uint256 the amount of tokens to be transferred
     */
    function transferFrom(
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="435" endline="451" pcid="601">
    function approve(address spender, uint256 value) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev Transfer tokens from one address to another.
     * Note that while this function emits an Approval event, this is not required as per the specification,
     * and other compliant implementations may not emit the event.
     * @param from address The address which you want to send tokens from
     * @param to address The address which you want to transfer to
     * @param value uint256 the amount of tokens to be transferred
     */
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="184" endline="198" pcid="2748">
  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));

    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }

  /**
   * @dev Transfer tokens from one address to another
   * @param from address The address which you want to send tokens from
   * @param to address The address which you want to transfer to
   * @param value uint256 the amount of tokens to be transferred
   */
  function transferFrom(
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="135" endline="142" pcid="6215">
  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }

  function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="147" endline="154" pcid="3933">
  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }

  function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="387" endline="404" pcid="3814">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev See `IERC20.transferFrom`.
     *
     * Emits an `Approval` event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of `ERC20`;
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="395" endline="400" pcid="2598">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="134" endline="141" pcid="7330">
  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }

  function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="351" endline="368" pcid="2473">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev See `IERC20.transferFrom`.
     *
     * Emits an `Approval` event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of `ERC20`;
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="174" endline="190" pcid="1374">
    function approve(address spender, uint256 value) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev Transfer tokens from one address to another.
     * Note that while this function emits an Approval event, this is not required as per the specification,
     * and other compliant implementations may not emit the event.
     * @param from address The address which you want to send tokens from
     * @param to address The address which you want to transfer to
     * @param value uint256 the amount of tokens to be transferred
     */
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="138" endline="145" pcid="1479">
  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }

  function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="149" endline="156" pcid="2164">
  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }

  function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="173" endline="180" pcid="2408">
  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }

  function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="338" endline="355" pcid="5792">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20};
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/ankara.sol" startline="101" endline="106" pcid="690">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Byte.sol" startline="156" endline="163" pcid="1584">
  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }

  function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="89" endline="97" pcid="2311">
    function approve(address spender, uint256 value) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="391" endline="407" pcid="5692">
    function approve(address spender, uint256 value) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev Transfer tokens from one address to another.
     * Note that while this function emits an Approval event, this is not required as per the specification,
     * and other compliant implementations may not emit the event.
     * @param from address The address which you want to send tokens from
     * @param to address The address which you want to transfer to
     * @param value uint256 the amount of tokens to be transferred
     */
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="265" endline="282" pcid="657">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev See `IERC20.transferFrom`.
     *
     * Emits an `Approval` event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of `ERC20`;
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="140" endline="157" pcid="2986">
  function approve(address spender, uint256 value) public returns (bool) {
    _approve(msg.sender, spender, value);
    return true;
  }

  /**
   * @dev Atomically increases the allowance granted to `spender` by the caller.
   *
   * This is an alternative to `approve` that can be used as a mitigation for
   * problems described in `IERC20.approve`.
   *
   * Emits an `Approval` event indicating the updated allowance.
   *
   * Requirements:
   *
   * - `spender` cannot be the zero address.
   */
  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="126" endline="139" pcid="3021">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev Transfer tokens from one address to another.
     * Note that while this function emits an Approval event, this is not required as per the specification,
     * and other compliant implementations may not emit the event.
     * @param from address The address which you want to send tokens from
     * @param to address The address which you want to transfer to
     * @param value uint256 the amount of tokens to be transferred
     */
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="168" endline="175" pcid="3182">
  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }

  function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="270" endline="285" pcid="6734">
    function approve(address spender, uint256 value) public returns (bool) {
        require(spender != address(0));
        require(!frozenAccount[msg.sender]);

        _allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev Transfer tokens from one address to another
     * @param from address The address which you want to send tokens from
     * @param to address The address which you want to transfer to
     * @param value uint256 the amount of tokens to be transferred
     */
    function transferFrom(
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="277" endline="294" pcid="8239">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev See `IERC20.transferFrom`.
     *
     * Emits an `Approval` event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of `ERC20`;
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="261" endline="278" pcid="8200">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev See `IERC20.transferFrom`.
     *
     * Emits an `Approval` event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of `ERC20`;
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="305" endline="322" pcid="5426">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20};
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="128" endline="133" pcid="8060">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="619" endline="629" pcid="5376">
    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev Returns the remaining number of VOKEN that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}.
     * This is zero by default.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="273" endline="290" pcid="1759">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev See `IERC20.transferFrom`.
     *
     * Emits an `Approval` event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of `ERC20`;
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="331" endline="347" pcid="3574">
    function approve(address spender, uint256 value) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev Transfer tokens from one address to another.
     * Note that while this function emits an Approval event, this is not required as per the specification,
     * and other compliant implementations may not emit the event.
     * @param from address The address which you want to send tokens from
     * @param to address The address which you want to transfer to
     * @param value uint256 the amount of tokens to be transferred
     */
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Token.sol" startline="127" endline="140" pcid="7258">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev Transfer tokens from one address to another.
     * Note that while this function emits an Approval event, this is not required as per the specification,
     * and other compliant implementations may not emit the event.
     * @param from address The address which you want to send tokens from
     * @param to address The address which you want to transfer to
     * @param value uint256 the amount of tokens to be transferred
     */
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="268" endline="285" pcid="7910">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev See `IERC20.transferFrom`.
     *
     * Emits an `Approval` event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of `ERC20`;
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/BANG.sol" startline="146" endline="153" pcid="1056">
  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }

  function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="317" endline="327" pcid="7001">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     * @param spender The address which will spend the funds.
     * @param addedValue The amount of tokens to increase the allowance by.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="470" endline="487" pcid="5171">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev See `IERC20.transferFrom`.
     *
     * Emits an `Approval` event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of `ERC20`;
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="270" endline="285" pcid="2248">
    function approve(address spender, uint256 value) public returns (bool) {
        require(spender != address(0));
        require(!frozenAccount[msg.sender]);

        _allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev Transfer tokens from one address to another
     * @param from address The address which you want to send tokens from
     * @param to address The address which you want to transfer to
     * @param value uint256 the amount of tokens to be transferred
     */
    function transferFrom(
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="136" endline="153" pcid="7987">
  function approve(address spender, uint256 value) public returns (bool) {
    _approve(msg.sender, spender, value);
    return true;
  }

  /**
   * @dev Atomically increases the allowance granted to `spender` by the caller.
   *
   * This is an alternative to `approve` that can be used as a mitigation for
   * problems described in `IERC20.approve`.
   *
   * Emits an `Approval` event indicating the updated allowance.
   *
   * Requirements:
   *
   * - `spender` cannot be the zero address.
   */
  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="157" endline="170" pcid="4934">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev Transfer tokens from one address to another.
     * Note that while this function emits an Approval event, this is not required as per the specification,
     * and other compliant implementations may not emit the event.
     * @param from address The address which you want to send tokens from
     * @param to address The address which you want to transfer to
     * @param value uint256 the amount of tokens to be transferred
     */
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="309" endline="326" pcid="7187">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * See `IERC20.transferFrom`.
     *
     * Emits an `Approval` event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of `ERC20`;
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="268" endline="285" pcid="7026">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev See `IERC20.transferFrom`.
     *
     * Emits an `Approval` event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of `ERC20`;
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `value`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="354" endline="367" pcid="6339">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev Transfer tokens from one address to another.
     * Note that while this function emits an Approval event, this is not required as per the specification,
     * and other compliant implementations may not emit the event.
     * @param from address The address which you want to send tokens from
     * @param to address The address which you want to transfer to
     * @param value uint256 the amount of tokens to be transferred
     */
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="548" endline="555" pcid="5122">
    function approve(address spender, uint256 value) public returns (bool) {
        require(spender != address(0));
        _allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
  }

    function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/FogCoin.sol" startline="86" endline="97" pcid="3683">
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev Transfer tokens from one address to another. Emits an Approval event.
     * @param from address The address which you want to send tokens from
     * @param to address The address which you want to transfer to
     * @param value uint256 the amount of tokens to be transferred
     */
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="520" endline="524" pcid="6353">
    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {
        return super.approve(spender, value);
    }

    function increaseAllowance(address spender, uint addedValue) public whenNotPaused returns (bool success) {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="449" endline="453" pcid="6747">
    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {
        return super.approve(spender, value);
    }

    function increaseAllowance(address spender, uint256 addedValue) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="449" endline="453" pcid="7734">
    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {
        return super.approve(spender, value);
    }

    function increaseAllowance(address spender, uint256 addedValue) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="449" endline="453" pcid="2261">
    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {
        return super.approve(spender, value);
    }

    function increaseAllowance(address spender, uint256 addedValue) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="536" endline="540" pcid="7202">
    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {
        return super.approve(spender, value);
    }

    function increaseApproval(address spender, uint addedValue) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="658" endline="662" pcid="4455">
    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {
        return super.approve(spender, value);
    }

    function increaseAllowance(address spender, uint addedValue) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="480" endline="484" pcid="1397">
    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {
        return super.approve(spender, value);
    }

    function increaseAllowance(address spender, uint addedValue) public whenNotPaused returns (bool success) {
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="635" endline="639" pcid="339">
    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {
        return super.approve(spender, value);
    }

    function increaseAllowance(address spender, uint256 addedValue) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="668" endline="672" pcid="6368">
    function approve(address spender, uint256 value) public onlyNotBlacklisted returns (bool) {
        return super.approve(spender, value);
    }

    function increaseAllowance(address spender, uint addedValue) public onlyNotBlacklisted returns (bool success) {
</source>
</class>

<class classid="49" nclones="24" nlines="4" similarity="75">
<source file="systems/smart_contracts/ABCToken.sol" startline="174" endline="192" pcid="310">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="396" endline="402" pcid="2690">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="368" endline="386" pcid="961">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="354" endline="360" pcid="3003">
  function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
    require(!_locked[msg.sender]);
    _transfer(sender, recipient, amount);
    _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
    return true;
  }
}
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="400" endline="406" pcid="2599">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="294" endline="312" pcid="8240">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="278" endline="296" pcid="8201">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="133" endline="139" pcid="8061">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="378" endline="385" pcid="8005">
  function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
    require(!_locked[msg.sender]);
    require(!_locked[sender]);
    _transfer(sender, recipient, amount);
    _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
    return true;
  }
}
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="285" endline="303" pcid="7911">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="404" endline="422" pcid="3815">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="368" endline="386" pcid="2474">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="346" endline="364" pcid="4434">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/BCCT.sol" startline="110" endline="128" pcid="1096">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="326" endline="344" pcid="7188">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    /**
     * Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseApproval(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="290" endline="308" pcid="1760">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="285" endline="303" pcid="7027">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="282" endline="300" pcid="658">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="487" endline="505" pcid="5172">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="322" endline="340" pcid="5427">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="355" endline="373" pcid="5793">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="334" endline="352" pcid="5921">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="302" endline="320" pcid="5965">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="368" endline="386" pcid="6033">
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
</class>

<class classid="50" nclones="70" nlines="4" similarity="75">
<source file="systems/smart_contracts/ABCToken.sol" startline="192" endline="211" pcid="311">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/ankara.sol" startline="112" endline="117" pcid="692">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="166" endline="173" pcid="1481">
  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="214" endline="232" pcid="1376">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     * approve should be called when allowed_[_spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Byte.sol" startline="204" endline="211" pcid="1586">
  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="163" endline="170" pcid="6217">
  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="300" endline="319" pcid="659">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="386" endline="405" pcid="6034">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="164" endline="171" pcid="6006">
  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="320" endline="339" pcid="5966">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="308" endline="327" pcid="1761">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/CNG.sol" startline="217" endline="241" pcid="1857">
  function increaseAllowance(
    address spender,
    uint256 addedValue
  )
    public
    returns (bool)
  {
    require(spender != address(0));

    _allowed[msg.sender][spender] = (
      _allowed[msg.sender][spender].add(addedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  /**
   * @dev Decrease the amount of tokens that an owner allowed to a spender.
   * approve should be called when allowed_[_spender] == 0. To decrement
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param spender The address which will spend the funds.
   * @param subtractedValue The amount of tokens to decrease the allowance by.
   */
  function decreaseAllowance(
</source>
<source file="systems/smart_contracts/BCCT.sol" startline="128" endline="147" pcid="1097">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Comet.sol" startline="163" endline="170" pcid="1934">
  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="210" endline="227" pcid="741">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    /**
    * @dev Decrease the amount of tokens that an owner allowed to a spender.
    * approve should be called when allowed_[_spender] == 0. To decrement
    * allowed value is better to use this function to avoid 2 calls (and wait until
    * the first transaction is mined)
    * From MonolithDAO Token.sol
    * @param spender The address which will spend the funds.
    * @param subtractedValue The amount of tokens to decrease the allowance by.
    */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="468" endline="486" pcid="603">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     * approve should be called when allowed_[_spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="177" endline="184" pcid="2166">
  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/BANG.sol" startline="174" endline="181" pcid="1058">
  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="308" endline="333" pcid="2250">
    function increaseAllowance(
        address spender,
        uint256 addedValue
    )
    public
    returns (bool)
    {
        require(spender != address(0));
        require(!frozenAccount[msg.sender]);

        _allowed[msg.sender][spender] = (
        _allowed[msg.sender][spender].add(addedValue));
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     * approve should be called when allowed_[_spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * @param spender The address which will spend the funds.
     * @param subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="105" endline="113" pcid="2313">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="231" endline="238" pcid="2412">
  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="386" endline="405" pcid="2475">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="406" endline="411" pcid="2600">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="386" endline="405" pcid="962">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="402" endline="407" pcid="2691">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="222" endline="246" pcid="2750">
  function increaseAllowance(
    address spender,
    uint256 addedValue
  )
    public
    returns (bool)
  {
    require(spender != address(0));

    _allowed[msg.sender][spender] = (
      _allowed[msg.sender][spender].add(addedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  /**
   * @dev Decrease the amount of tokens that an owner allowed to a spender.
   * approve should be called when allowed_[_spender] == 0. To decrement
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param spender The address which will spend the funds.
   * @param subtractedValue The amount of tokens to decrease the allowance by.
   */
  function decreaseAllowance(
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="157" endline="176" pcid="2987">
  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
    _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
    return true;
  }

  /**
   * @dev Atomically decreases the allowance granted to `spender` by the caller.
   *
   * This is an alternative to `approve` that can be used as a mitigation for
   * problems described in `IERC20.approve`.
   *
   * Emits an `Approval` event indicating the updated allowance.
   *
   * Requirements:
   *
   * - `spender` cannot be the zero address.
   * - `spender` must have allowance for the caller of at least
   * `subtractedValue`.
   */
  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="155" endline="170" pcid="3023">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     * approve should be called when _allowances[msg.sender][spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="201" endline="208" pcid="3184">
  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="352" endline="371" pcid="5922">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="312" endline="331" pcid="8241">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="296" endline="315" pcid="8202">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="383" endline="398" pcid="6341">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     * approve should be called when allowed_[_spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="139" endline="144" pcid="8062">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="364" endline="382" pcid="3576">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     * approve should be called when allowed_[_spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="153" endline="172" pcid="7988">
  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
    _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
    return true;
  }

  /**
   * @dev Atomically decreases the allowance granted to `spender` by the caller.
   *
   * This is an alternative to `approve` that can be used as a mitigation for
   * problems described in `IERC20.approve`.
   *
   * Emits an `Approval` event indicating the updated allowance.
   *
   * Requirements:
   *
   * - `spender` cannot be the zero address.
   * - `spender` must have allowance for the caller of at least
   * `subtractedValue`.
   */
  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/FogCoin.sol" startline="108" endline="118" pcid="3685">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender. Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="303" endline="322" pcid="7912">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="422" endline="441" pcid="3816">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="180" endline="187" pcid="3935">
  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="308" endline="333" pcid="7723">
    function increaseAllowance(
        address spender,
        uint256 addedValue
    )
    public
    returns (bool)
    {
        require(spender != address(0));
        require(!frozenAccount[msg.sender]);

        _allowed[msg.sender][spender] = (
        _allowed[msg.sender][spender].add(addedValue));
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     * approve should be called when allowed_[_spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * @param spender The address which will spend the funds.
     * @param subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="332" endline="351" pcid="4046">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="204" endline="219" pcid="7652">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="222" endline="246" pcid="4246">
  function increaseAllowance(
    address spender,
    uint256 addedValue
  )
  public
  returns (bool)
  {
    require(spender != address(0));

    _allowed[msg.sender][spender] = (
    _allowed[msg.sender][spender].add(addedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  /**
   * @dev Decrease the amount of tokens that an owner allowed to a spender.
   * approve should be called when allowed_[_spender] == 0. To decrement
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param spender The address which will spend the funds.
   * @param subtractedValue The amount of tokens to decrease the allowance by.
   */
  function decreaseAllowance(
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="364" endline="383" pcid="4435">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="348" endline="372" pcid="5860">
    function increaseAllowance(
        address spender,
        uint256 addedValue
    )
    public
    returns (bool)
    {
        require(spender != address(0));

        _allowed[msg.sender][spender] = (
        _allowed[msg.sender][spender].add(addedValue));
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     * approve should be called when allowed_[_spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * @param spender The address which will spend the funds.
     * @param subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="373" endline="392" pcid="5794">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="424" endline="442" pcid="5694">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     * approve should be called when allowed_[_spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/magesh.sol" startline="186" endline="201" pcid="4624">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="162" endline="169" pcid="7332">
  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Token.sol" startline="156" endline="171" pcid="7260">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="186" endline="201" pcid="4936">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="308" endline="333" pcid="6736">
    function increaseAllowance(
        address spender,
        uint256 addedValue
    )
    public
    returns (bool)
    {
        require(spender != address(0));
        require(!frozenAccount[msg.sender]);

        _allowed[msg.sender][spender] = (
        _allowed[msg.sender][spender].add(addedValue));
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     * approve should be called when allowed_[_spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * @param spender The address which will spend the funds.
     * @param subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="340" endline="359" pcid="5428">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="638" endline="648" pcid="5378">
    function increaseAllowance(address spender, uint256 addedValue) public whenNotPaused returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * Emits an {Approval} event indicating the updated allowance.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="327" endline="337" pcid="7002">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     * @param spender The address which will spend the funds.
     * @param subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="505" endline="524" pcid="5173">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="303" endline="322" pcid="7028">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="571" endline="578" pcid="5124">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        require(spender != address(0));
        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="344" endline="363" pcid="7189">
    function increaseApproval(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     *  Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in `IERC20.approve`.
     *
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseApproval(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="674" endline="681" pcid="2722">
  function upAllowance(address spender, uint256 addedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function downAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="678" endline="685" pcid="2631">
  function upAllowance(address spender, uint256 addedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function downAllowance(address spender, uint256 subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="639" endline="643" pcid="340">
    function increaseAllowance(address spender, uint256 addedValue) public whenNotPaused returns (bool) {
        return super.increaseAllowance(spender, addedValue);
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="453" endline="457" pcid="2262">
    function increaseAllowance(address spender, uint256 addedValue) public whenNotPaused returns (bool) {
        return super.increaseAllowance(spender, addedValue);
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="453" endline="457" pcid="7735">
    function increaseAllowance(address spender, uint256 addedValue) public whenNotPaused returns (bool) {
        return super.increaseAllowance(spender, addedValue);
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="453" endline="457" pcid="6748">
    function increaseAllowance(address spender, uint256 addedValue) public whenNotPaused returns (bool) {
        return super.increaseAllowance(spender, addedValue);
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="672" endline="676" pcid="6369">
    function increaseAllowance(address spender, uint addedValue) public onlyNotBlacklisted returns (bool success) {
        return super.increaseAllowance(spender, addedValue);
    }

    function decreaseAllowance(address spender, uint subtractedValue) public onlyNotBlacklisted returns (bool success) {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="484" endline="488" pcid="1398">
    function increaseAllowance(address spender, uint addedValue) public whenNotPaused returns (bool success) {
        return super.increaseAllowance(spender, addedValue);
    }

    function decreaseAllowance(address spender, uint subtractedValue) public whenNotPaused returns (bool success) {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="662" endline="666" pcid="4456">
    function increaseAllowance(address spender, uint addedValue) public whenNotPaused returns (bool) {
        return super.increaseAllowance(spender, addedValue);
    }

    function decreaseAllowance(address spender, uint subtractedValue) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="524" endline="528" pcid="6354">
    function increaseAllowance(address spender, uint addedValue) public whenNotPaused returns (bool success) {
        return super.increaseAllowance(spender, addedValue);
    }

    function decreaseAllowance(address spender, uint subtractedValue) public whenNotPaused returns (bool success) {
</source>
</class>

<class classid="51" nclones="58" nlines="4" similarity="75">
<source file="systems/smart_contracts/ABCToken.sol" startline="211" endline="230" pcid="312">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/ankara.sol" startline="117" endline="122" pcid="693">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    function _transfer(address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="232" endline="246" pcid="1377">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    /**
    * @dev Transfer token for a specified addresses
    * @param from The address to transfer from.
    * @param to The address to transfer to.
    * @param value The amount to be transferred.
    */
    function _transfer(address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="173" endline="180" pcid="1482">
  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="405" endline="424" pcid="2476">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to `transfer`, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a `Transfer` event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="411" endline="416" pcid="2601">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="405" endline="424" pcid="963">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to `transfer`, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a `Transfer` event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="407" endline="412" pcid="2692">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="246" endline="267" pcid="2751">
  function decreaseAllowance(
    address spender,
    uint256 subtractedValue
  )
    public
    returns (bool)
  {
    require(spender != address(0));

    _allowed[msg.sender][spender] = (
      _allowed[msg.sender][spender].sub(subtractedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  /**
  * @dev Transfer token for a specified addresses
  * @param from The address to transfer from.
  * @param to The address to transfer to.
  * @param value The amount to be transferred.
  */
  function _transfer(address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="176" endline="195" pcid="2988">
  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
    _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
    return true;
  }

  /**
   * @dev Moves tokens `amount` from `sender` to `recipient`.
   *
   * This is internal function is equivalent to `transfer`, and can be used to
   * e.g. implement automatic token fees, slashing mechanisms, etc.
   *
   * Emits a `Transfer` event.
   *
   * Requirements:
   *
   * - `sender` cannot be the zero address.
   * - `recipient` cannot be the zero address.
   * - `sender` must have a balance of at least `amount`.
   */
  function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="170" endline="181" pcid="3024">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Transfer token for a specified addresses.
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function _transfer(address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/Byte.sol" startline="211" endline="218" pcid="1587">
  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="208" endline="215" pcid="3185">
  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="331" endline="350" pcid="8242">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to `transfer`, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a `Transfer` event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="315" endline="334" pcid="8203">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to `transfer`, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a `Transfer` event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="398" endline="409" pcid="6342">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Transfer token for a specified addresses
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function _transfer(address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="144" endline="149" pcid="8063">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="319" endline="338" pcid="660">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to `transfer`, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a `Transfer` event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="327" endline="346" pcid="1762">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to `transfer`, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a `Transfer` event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="382" endline="396" pcid="3577">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    /**
    * @dev Transfer token for a specified addresses
    * @param from The address to transfer from.
    * @param to The address to transfer to.
    * @param value The amount to be transferred.
    */
    function _transfer(address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="172" endline="191" pcid="7989">
  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
    _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
    return true;
  }

  /**
   * @dev Moves tokens `amount` from `sender` to `recipient`.
   *
   * This is internal function is equivalent to `transfer`, and can be used to
   * e.g. implement automatic token fees, slashing mechanisms, etc.
   *
   * Emits a `Transfer` event.
   *
   * Requirements:
   *
   * - `sender` cannot be the zero address.
   * - `recipient` cannot be the zero address.
   * - `sender` must have a balance of at least `amount`.
   */
  function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/FogCoin.sol" startline="118" endline="129" pcid="3686">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Transfer token for a specified addresses.
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function _transfer(address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="322" endline="341" pcid="7913">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to `transfer`, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a `Transfer` event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="441" endline="460" pcid="3817">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to `transfer`, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a `Transfer` event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="187" endline="194" pcid="3936">
  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="351" endline="369" pcid="4047">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to `transfer`, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a `Transfer` event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="219" endline="230" pcid="7653">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Transfer token for a specified addresses
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function _transfer(address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="246" endline="267" pcid="4247">
  function decreaseAllowance(
    address spender,
    uint256 subtractedValue
  )
  public
  returns (bool)
  {
    require(spender != address(0));

    _allowed[msg.sender][spender] = (
    _allowed[msg.sender][spender].sub(subtractedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  /**
  * @dev Transfer token for a specified addresses
  * @param from The address to transfer from.
  * @param to The address to transfer to.
  * @param value The amount to be transferred.
  */
  function _transfer(address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="383" endline="402" pcid="4436">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to `transfer`, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a `Transfer` event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/magesh.sol" startline="201" endline="212" pcid="4625">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Transfer token for a specified addresses.
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function _transfer(address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="169" endline="176" pcid="7333">
  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/Token.sol" startline="171" endline="182" pcid="7261">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Transfer token for a specified address.
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function _transfer(address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="201" endline="212" pcid="4937">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Transfer token for a specified addresses.
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function _transfer(address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="363" endline="382" pcid="7190">
    function decreaseApproval(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     *  Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to `transfer`, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a `Transfer` event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/CNG.sol" startline="241" endline="262" pcid="1858">
  function decreaseAllowance(
    address spender,
    uint256 subtractedValue
  )
    public
    returns (bool)
  {
    require(spender != address(0));

    _allowed[msg.sender][spender] = (
      _allowed[msg.sender][spender].sub(subtractedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  /**
  * @dev Transfer token for a specified addresses
  * @param from The address to transfer from.
  * @param to The address to transfer to.
  * @param value The amount to be transferred.
  */
  function _transfer(address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/BCCT.sol" startline="147" endline="157" pcid="1098">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    /**
     * @dev Destroys `amount` tokens from the caller.
     *
     * See {ERC20-_burn}.
     */
    function burn(uint256 amount) public {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="578" endline="585" pcid="5125">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        require(spender != address(0));
        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    function burn(uint256 amount) public {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="322" endline="341" pcid="7029">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to `transfer`, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a `Transfer` event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="238" endline="245" pcid="2413">
  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/Comet.sol" startline="170" endline="177" pcid="1935">
  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="524" endline="543" pcid="5174">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to `transfer`, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a `Transfer` event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="337" endline="347" pcid="7003">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));
        return true;
    }
    /**
     * @dev Transfer tokens from one address to another.
     * @param from address The address which you want to send tokens from
     * @param to address The address which you want to transfer to
     * @param value uint256 the amount of tokens to be transferred
     */
    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="227" endline="241" pcid="742">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    /**
    * @dev Transfer token for a specified addresses
    * @param from The address to transfer from.
    * @param to The address to transfer to.
    * @param value The amount to be transferred.
    */
    function _transfer(address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="359" endline="378" pcid="5429">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="442" endline="456" pcid="5695">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    /**
    * @dev Transfer token for a specified addresses
    * @param from The address to transfer from.
    * @param to The address to transfer to.
    * @param value The amount to be transferred.
    */
    function _transfer(address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="392" endline="411" pcid="5795">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="486" endline="500" pcid="604">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    /**
    * @dev Transfer token for a specified addresses
    * @param from The address to transfer from.
    * @param to The address to transfer to.
    * @param value The amount to be transferred.
    */
    function _transfer(address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="184" endline="191" pcid="2167">
  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="372" endline="393" pcid="5861">
    function decreaseAllowance(
        address spender,
        uint256 subtractedValue
    )
    public
    returns (bool)
    {
        require(spender != address(0));

        _allowed[msg.sender][spender] = (
        _allowed[msg.sender][spender].sub(subtractedValue));
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    /**
    * @dev Transfer token for a specified addresses
    * @param from The address to transfer from.
    * @param to The address to transfer to.
    * @param value The amount to be transferred.
    */
    function _transfer(address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/BANG.sol" startline="181" endline="188" pcid="1059">
  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="371" endline="390" pcid="5923">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="170" endline="177" pcid="6218">
  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="405" endline="424" pcid="6035">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to `transfer`, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a `Transfer` event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="339" endline="358" pcid="5967">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to `transfer`, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a `Transfer` event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="171" endline="178" pcid="6007">
  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="113" endline="121" pcid="2314">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    function _transfer(address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="685" endline="692" pcid="2632">
  function downAllowance(address spender, uint256 subtractedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function _issue(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="681" endline="688" pcid="2723">
  function downAllowance(address spender, uint256 subtractedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function _issue(address account, uint256 amount) internal {
</source>
</class>

<class classid="52" nclones="20" nlines="5" similarity="100">
<source file="systems/smart_contracts/ABCToken.sol" startline="230" endline="248" pcid="313">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="341" endline="359" pcid="7914">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a `Transfer` event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="460" endline="478" pcid="3818">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a `Transfer` event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="412" endline="421" pcid="2693">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="424" endline="442" pcid="964">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a `Transfer` event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="416" endline="425" pcid="2602">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="424" endline="442" pcid="2477">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a `Transfer` event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="350" endline="368" pcid="8243">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a `Transfer` event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="424" endline="442" pcid="6036">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a `Transfer` event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="382" endline="394" pcid="7191">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     */
    function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="334" endline="352" pcid="8204">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a `Transfer` event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="402" endline="420" pcid="4437">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a `Transfer` event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="543" endline="561" pcid="5175">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a `Transfer` event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="341" endline="359" pcid="7030">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a `Transfer` event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="191" endline="209" pcid="7990">
  function _transfer(address sender, address recipient, uint256 amount) internal {
    require(sender != address(0), "ERC20: transfer from the zero address");
    require(recipient != address(0), "ERC20: transfer to the zero address");

    _balances[sender] = _balances[sender].sub(amount);
    _balances[recipient] = _balances[recipient].add(amount);
    emit Transfer(sender, recipient, amount);
  }

  /** @dev Creates `amount` tokens and assigns them to `account`, increasing
   * the total supply.
   *
   * Emits a `Transfer` event with `from` set to the zero address.
   *
   * Requirements
   *
   * - `to` cannot be the zero address.
   */
  function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="358" endline="376" pcid="5968">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a `Transfer` event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="346" endline="364" pcid="1763">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a `Transfer` event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="338" endline="356" pcid="661">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a `Transfer` event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="195" endline="213" pcid="2989">
  function _transfer(address sender, address recipient, uint256 amount) internal {
    require(sender != address(0), "ERC20: transfer from the zero address");
    require(recipient != address(0), "ERC20: transfer to the zero address");

    _balances[sender] = _balances[sender].sub(amount);
    _balances[recipient] = _balances[recipient].add(amount);
    emit Transfer(sender, recipient, amount);
  }

  /** @dev Creates `amount` tokens and assigns them to `account`, increasing
   * the total supply.
   *
   * Emits a `Transfer` event with `from` set to the zero address.
   *
   * Requirements
   *
   * - `to` cannot be the zero address.
   */
  function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="411" endline="431" pcid="5796">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

     /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function burn(address account, uint256 value) public {
</source>
</class>

<class classid="53" nclones="36" nlines="4" similarity="75">
<source file="systems/smart_contracts/ABCToken.sol" startline="248" endline="267" pcid="314">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="180" endline="186" pcid="1483">
  function _mint(address account, uint256 amount) internal {
    require(amount != 0);
    _balances[account] = _balances[account].add(amount);
    emit Transfer(address(0), account, amount);
  }

  function burn(uint256 amount) external {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="359" endline="378" pcid="7915">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     /**
     * @dev Destoys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a `Transfer` event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/Byte.sol" startline="218" endline="224" pcid="1588">
  function _mint(address account, uint256 amount) internal {
    require(amount != 0);
    _ByteBalances[account] = _ByteBalances[account].add(amount);
    emit Transfer(address(0), account, amount);
  }

  function burn(uint256 amount) external {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="209" endline="228" pcid="7991">
  function _mint(address account, uint256 amount) internal {
    require(account != address(0), "ERC20: mint to the zero address");

    _totalSupply = _totalSupply.add(amount);
    _balances[account] = _balances[account].add(amount);
    emit Transfer(address(0), account, amount);
  }

  /**
   * @dev Destoys `amount` tokens from `account`, reducing the
   * total supply.
   *
   * Emits a `Transfer` event with `to` set to the zero address.
   *
   * Requirements
   *
   * - `account` cannot be the zero address.
   * - `account` must have at least `amount` tokens.
   */
  function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="356" endline="375" pcid="662">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     /**
     * @dev Destoys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a `Transfer` event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="352" endline="371" pcid="8205">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     /**
     * @dev Destoys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a `Transfer` event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="364" endline="383" pcid="1764">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a `Transfer` event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/BCCT.sol" startline="194" endline="213" pcid="1101">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/Comet.sol" startline="177" endline="183" pcid="1936">
  function _mint(address account, uint256 amount) internal {
    require(amount != 0);
    _balances[account] = _balances[account].add(amount);
    emit Transfer(address(0), account, amount);
  }

  function burn(uint256 amount) external {
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="191" endline="197" pcid="2168">
  function _mint(address account, uint256 amount) internal {
    require(amount != 0);
    _balances[account] = _balances[account].add(amount);
    emit Transfer(address(0), account, amount);
  }

  function burn(uint256 amount) external {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="368" endline="387" pcid="8244">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     /**
     * @dev Destoys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a `Transfer` event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/BANG.sol" startline="188" endline="194" pcid="1060">
  function _mint(address account, uint256 amount) internal {
    require(amount != 0);
    _balances[account] = _balances[account].add(amount);
    emit Transfer(address(0), account, amount);
  }

  function burn(uint256 amount) external {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="478" endline="497" pcid="3819">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     /**
     * @dev Destoys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a `Transfer` event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="194" endline="200" pcid="3937">
  function _mint(address account, uint256 amount) internal {
    require(amount != 0);
    _balances[account] = _balances[account].add(amount);
    emit Transfer(address(0), account, amount);
  }

  function burn(uint256 amount) external {
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="215" endline="221" pcid="3186">
  function _mint(address account, uint256 amount) internal {
    require(amount != 0);
    _balances[account] = _balances[account].add(amount);
    emit Transfer(address(0), account, amount);
  }

  function burn(uint256 amount) external {
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="245" endline="251" pcid="2414">
  function _mint(address account, uint256 amount) internal {
    require(amount != 0);
    _balances[account] = _balances[account].add(amount);
    emit Transfer(address(0), account, amount);
  }

  function burn(uint256 amount) external {
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="389" endline="408" pcid="4049">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     /**
     * @dev Destoys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a `Transfer` event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="442" endline="461" pcid="2478">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     /**
     * @dev Destoys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a `Transfer` event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="420" endline="439" pcid="4438">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     /**
     * @dev Destoys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a `Transfer` event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="425" endline="433" pcid="2603">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="442" endline="461" pcid="965">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     /**
     * @dev Destoys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a `Transfer` event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="421" endline="429" pcid="2694">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="213" endline="232" pcid="2990">
  function _mint(address account, uint256 amount) internal {
    require(account != address(0), "ERC20: mint to the zero address");

    _totalSupply = _totalSupply.add(amount);
    _balances[account] = _balances[account].add(amount);
    emit Transfer(address(0), account, amount);
  }

  /**
   * @dev Destoys `amount` tokens from `account`, reducing the
   * total supply.
   *
   * Emits a `Transfer` event with `to` set to the zero address.
   *
   * Requirements
   *
   * - `account` cannot be the zero address.
   * - `account` must have at least `amount` tokens.
   */
  function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="177" endline="183" pcid="6219">
  function _mint(address account, uint256 amount) internal {
    require(amount != 0);
    _balances[account] = _balances[account].add(amount);
    emit Transfer(address(0), account, amount);
  }

  function burn(uint256 amount) external {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="442" endline="461" pcid="6037">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     /**
     * @dev Destoys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a `Transfer` event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="178" endline="184" pcid="6008">
  function _mint(address account, uint256 amount) internal {
    require(amount != 0);
    _balances[account] = _balances[account].add(amount);
    emit Transfer(address(0), account, amount);
  }

  function burn(uint256 amount) external {
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="376" endline="395" pcid="5969">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a `Transfer` event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="408" endline="427" pcid="5925">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="396" endline="415" pcid="5431">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="176" endline="182" pcid="7334">
  function _mint(address account, uint256 amount) internal {
    require(amount != 0);
    _balances[account] = _balances[account].add(amount);
    emit Transfer(address(0), account, amount);
  }

  function burn(uint256 amount) external {
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="561" endline="580" pcid="5176">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a `Transfer` event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="394" endline="405" pcid="7192">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    /**
     *  Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="359" endline="378" pcid="7031">
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     /**
     * @dev Destoys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a `Transfer` event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="692" endline="698" pcid="2633">
  function _issue(address account, uint256 amount) internal {
    require(amount != 0);
    _balances[account] = _balances[account].add(amount);
    emit Transfer(address(0), account, amount);
  }

  function destroy(uint256 amount) external {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="688" endline="694" pcid="2724">
  function _issue(address account, uint256 amount) internal {
    require(amount != 0);
    _balances[account] = _balances[account].add(amount);
    emit Transfer(address(0), account, amount);
  }

  function destroy(uint256 amount) external {
</source>
</class>

<class classid="54" nclones="37" nlines="4" similarity="75">
<source file="systems/smart_contracts/ABCToken.sol" startline="267" endline="288" pcid="315">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="383" endline="404" pcid="1765">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an `Approval` event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/CNG.sol" startline="291" endline="307" pcid="1861">
  function _burn(address account, uint256 value) internal {
    require(account != 0);
    require(value <= _balances[account]);

    _totalSupply = _totalSupply.sub(value);
    _balances[account] = _balances[account].sub(value);
    emit Transfer(account, address(0), value);
  }

  /**
   * @dev Internal function that burns an amount of the token of a given
   * account, deducting from the sender's allowance for said account. Uses the
   * internal burn function.
   * @param account The account whose tokens will be burnt.
   * @param value The amount that will be burnt.
   */
  function _burnFrom(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="529" endline="545" pcid="607">
    function _burn(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account, deducting from the sender's allowance for said account. Uses the
     * internal burn function.
     * Emits an Approval event (reflecting the reduced allowance).
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burnFrom(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="383" endline="398" pcid="2254">
    function _burn(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account, deducting from the sender's allowance for said account. Uses the
     * internal burn function.
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burnFrom(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="461" endline="482" pcid="2479">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an `Approval` event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="275" endline="283" pcid="1380">
    function _burn(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0x0DabcB5d80A71A71aB9184E3a108b82ba909e133), value);
        emit Burn(account, value);
    }
}
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="433" endline="441" pcid="2604">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="387" endline="408" pcid="8245">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an `Approval` event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/magesh.sol" startline="241" endline="255" pcid="4628">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Approve an address to spend another addresses' tokens.
     * @param owner The address that owns the tokens.
     * @param spender The address that will spend the tokens.
     * @param value The number of tokens that can be spent.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="241" endline="255" pcid="4940">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Approve an address to spend another addresses' tokens.
     * @param owner The address that owns the tokens.
     * @param spender The address that will spend the tokens.
     * @param value The number of tokens that can be spent.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="378" endline="399" pcid="7032">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an `Approval` event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="371" endline="392" pcid="8206">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an `Approval` event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="580" endline="601" pcid="5177">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an `Approval` event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="375" endline="396" pcid="663">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an `Approval` event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="232" endline="253" pcid="2991">
  function _burn(address account, uint256 value) internal {
    require(account != address(0), "ERC20: burn from the zero address");

    _totalSupply = _totalSupply.sub(value);
    _balances[account] = _balances[account].sub(value);
    emit Transfer(account, address(0), value);
  }

  /**
   * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
   *
   * This is internal function is equivalent to `approve`, and can be used to
   * e.g. set automatic allowances for certain subsystems, etc.
   *
   * Emits an `Approval` event.
   *
   * Requirements:
   *
   * - `owner` cannot be the zero address.
   * - `spender` cannot be the zero address.
   */
  function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="228" endline="249" pcid="7992">
  function _burn(address account, uint256 value) internal {
    require(account != address(0), "ERC20: burn from the zero address");

    _totalSupply = _totalSupply.sub(value);
    _balances[account] = _balances[account].sub(value);
    emit Transfer(account, address(0), value);
  }

  /**
   * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
   *
   * This is internal function is equivalent to `approve`, and can be used to
   * e.g. set automatic allowances for certain subsystems, etc.
   *
   * Emits an `Approval` event.
   *
   * Requirements:
   *
   * - `owner` cannot be the zero address.
   * - `spender` cannot be the zero address.
   */
  function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="210" endline="224" pcid="3027">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Approve an address to spend another addresses' tokens.
     * @param owner The address that owns the tokens.
     * @param spender The address that will spend the tokens.
     * @param value The number of tokens that can be spent.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="425" endline="441" pcid="3580">
    function _burn(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account, deducting from the sender's allowance for said account. Uses the
     * internal burn function.
     * Emits an Approval event (reflecting the reduced allowance).
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burnFrom(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ankara.sol" startline="138" endline="146" pcid="696">
    function _burn(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="383" endline="398" pcid="6740">
    function _burn(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account, deducting from the sender's allowance for said account. Uses the
     * internal burn function.
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burnFrom(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/FogCoin.sol" startline="168" endline="182" pcid="3690">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Approve an address to spend another addresses' tokens.
     * @param owner The address that owns the tokens.
     * @param spender The address that will spend the tokens.
     * @param value The number of tokens that can be spent.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="485" endline="501" pcid="5698">
    function _burn(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account, deducting from the sender's allowance for said account. Uses the
     * internal burn function.
     * Emits an Approval event (reflecting the reduced allowance).
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burnFrom(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="431" endline="452" pcid="5797">
    function burn(address account, uint256 value) public {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="395" endline="416" pcid="5970">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an `Approval` event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="461" endline="482" pcid="6038">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an `Approval` event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="378" endline="399" pcid="7916">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an `Approval` event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="461" endline="482" pcid="966">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an `Approval` event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="497" endline="518" pcid="3820">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an `Approval` event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="438" endline="452" pcid="6345">
    function _burn(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Approve an address to spend another addresses' tokens.
     * @param owner The address that owns the tokens.
     * @param spender The address that will spend the tokens.
     * @param value The number of tokens that can be spent.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="383" endline="398" pcid="7727">
    function _burn(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account, deducting from the sender's allowance for said account. Uses the
     * internal burn function.
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burnFrom(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="408" endline="429" pcid="4050">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an `Approval` event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="258" endline="272" pcid="7656">
    function _burn(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Approve an address to spend another addresses' tokens.
     * @param owner The address that owns the tokens.
     * @param spender The address that will spend the tokens.
     * @param value The number of tokens that can be spent.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="296" endline="312" pcid="4250">
  function _burn(address account, uint256 value) internal {
    require(account != 0);
    require(value <= _balances[account]);

    _totalSupply = _totalSupply.sub(value);
    _balances[account] = _balances[account].sub(value);
    emit Transfer(account, address(0), value);
  }

  /**
   * @dev Internal function that burns an amount of the token of a given
   * account, deducting from the sender's allowance for said account. Uses the
   * internal burn function.
   * @param account The account whose tokens will be burnt.
   * @param value The amount that will be burnt.
   */
  function _burnFrom(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="429" endline="437" pcid="2695">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="439" endline="460" pcid="4439">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an `Approval` event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="296" endline="312" pcid="2754">
  function _burn(address account, uint256 value) internal {
    require(account != 0);
    require(value <= _balances[account]);

    _totalSupply = _totalSupply.sub(value);
    _balances[account] = _balances[account].sub(value);
    emit Transfer(account, address(0), value);
  }

  /**
   * @dev Internal function that burns an amount of the token of a given
   * account, deducting from the sender's allowance for said account. Uses the
   * internal burn function.
   * @param account The account whose tokens will be burnt.
   * @param value The amount that will be burnt.
   */
  function _burnFrom(address account, uint256 value) internal {
</source>
</class>

<class classid="55" nclones="34" nlines="4" similarity="75">
<source file="systems/smart_contracts/ABCToken.sol" startline="288" endline="302" pcid="316">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See {_burn} and {_approve}.
     */
    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="404" endline="418" pcid="1766">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See `_burn` and `_approve`.
     */
    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="482" endline="496" pcid="6039">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See `_burn` and `_approve`.
     */
    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/BCCT.sol" startline="234" endline="248" pcid="1103">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See {_burn} and {_approve}.
     */
    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="482" endline="496" pcid="2480">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See `_burn` and `_approve`.
     */
    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="441" endline="449" pcid="2605">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="482" endline="496" pcid="967">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See `_burn` and `_approve`.
     */
    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="437" endline="445" pcid="2696">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="253" endline="267" pcid="2992">
  function _approve(address owner, address spender, uint256 value) internal {
    require(owner != address(0), "ERC20: approve from the zero address");
    require(spender != address(0), "ERC20: approve to the zero address");

    _allowances[owner][spender] = value;
    emit Approval(owner, spender, value);
  }

  /**
   * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
   * from the caller's allowance.
   *
   * See `_burn` and `_approve`.
   */
  function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="224" endline="240" pcid="3028">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account, deducting from the sender's allowance for said account. Uses the
     * internal burn function.
     * Emits an Approval event (reflecting the reduced allowance).
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burnFrom(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="416" endline="430" pcid="5971">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See `_burn` and `_approve`.
     */
    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="408" endline="422" pcid="8246">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See `_burn` and `_approve`.
     */
    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="392" endline="406" pcid="8207">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See `_burn` and `_approve`.
     */
    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="166" endline="174" pcid="8066">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="249" endline="263" pcid="7993">
  function _approve(address owner, address spender, uint256 value) internal {
    require(owner != address(0), "ERC20: approve from the zero address");
    require(spender != address(0), "ERC20: approve to the zero address");

    _allowances[owner][spender] = value;
    emit Approval(owner, spender, value);
  }

  /**
   * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
   * from the caller's allowance.
   *
   * See `_burn` and `_approve`.
   */
  function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/FogCoin.sol" startline="182" endline="198" pcid="3691">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account, deducting from the sender's allowance for said account. Uses the
     * internal burn function.
     * Emits an Approval event (reflecting the reduced allowance).
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burnFrom(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="399" endline="413" pcid="7917">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See `_burn` and `_approve`.
     */
    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="518" endline="532" pcid="3821">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See `_burn` and `_approve`.
     */
    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="452" endline="468" pcid="6346">
    function _approve(address owner, address spender, uint256 value) internal {
        require(spender != address(0));
        require(owner != address(0));

        _allowed[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account, deducting from the sender's allowance for said account. Uses the
     * internal burn function.
     * Emits an Approval event (reflecting the reduced allowance).
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burnFrom(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="429" endline="443" pcid="4051">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See `_burn` and `_approve`.
     */
    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="272" endline="288" pcid="7657">
    function _approve(address owner, address spender, uint256 value) internal {
        require(spender != address(0));
        require(owner != address(0));

        _allowed[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account, deducting from the sender's allowance for said account. Uses the
     * internal burn function.
     * Emits an Approval event (reflecting the reduced allowance).
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burnFrom(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="460" endline="474" pcid="4440">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See `_burn` and `_approve`.
     */
    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/magesh.sol" startline="255" endline="271" pcid="4629">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowed[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account, deducting from the sender's allowance for said account. Uses the
     * internal burn function.
     * Emits an Approval event (reflecting the reduced allowance).
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burnFrom(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/Token.sol" startline="196" endline="203" pcid="7263">
    function _approve(address owner, address spender, uint256 value) internal {
        require(spender != address(0), "Cannot approve to the zero address");
        require(owner != address(0), "Setter cannot be a zero address");

        _allowed[owner][spender] = value;
        emit Approval(owner, spender, value);
    }
}
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="405" endline="413" pcid="7193">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

}
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="448" endline="462" pcid="5927">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See {_burn} and {_approve}.
     */
    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="452" endline="466" pcid="5798">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See {_burn} and {_approve}.
     */
    function burnFrom(address account, uint256 amount) public {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="255" endline="271" pcid="4941">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowed[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account, deducting from the sender's allowance for said account. Uses the
     * internal burn function.
     * Emits an Approval event (reflecting the reduced allowance).
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burnFrom(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ankara.sol" startline="146" endline="154" pcid="697">
    function _approve(address owner, address spender, uint256 value) internal {
        require(spender != address(0));
        require(owner != address(0));

        _allowed[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    function _burnFrom(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="436" endline="450" pcid="5433">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See {_burn} and {_approve}.
     */
    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="399" endline="413" pcid="7033">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See `_burn` and `_approve`.
     */
    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="396" endline="410" pcid="664">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See `_burn` and `_approve`.
     */
    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="601" endline="615" pcid="5178">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See `_burn` and `_approve`.
     */
    function _burnFrom(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="374" endline="386" pcid="7006">
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0));
        require(spender != address(0));

        _allowed[owner][spender] = value;
        emit Approval(owner, spender, value);
    }


    /**
     * @dev Throws if called by account not a minter.
     */
    modifier onlyMinter() {
</source>
</class>

<class classid="56" nclones="23" nlines="4" similarity="75">
<source file="systems/smart_contracts/ABCToken.sol" startline="302" endline="306" pcid="317">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
    }
}
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="418" endline="422" pcid="1767">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
    }
}
</source>
<source file="systems/smart_contracts/BCCT.sol" startline="248" endline="256" pcid="1104">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount, "ERC20: burn amount exceeds allowance"));
    }

    /**
     * @dev Returns the name of the token.
     */
    function name() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="462" endline="466" pcid="5928">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount, "ERC20: burn amount exceeds allowance"));
    }
}
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="496" endline="500" pcid="2481">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
    }
}
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="496" endline="500" pcid="968">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
    }
}
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="449" endline="453" pcid="2606">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
    }
}
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="422" endline="426" pcid="8247">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
    }
}
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="406" endline="410" pcid="8208">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
    }
}
</source>
<source file="systems/smart_contracts/WTA.sol" startline="174" endline="178" pcid="8067">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount, "ERC20: burn amount exceeds allowance"));
    }
}
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="263" endline="267" pcid="7994">
  function _burnFrom(address account, uint256 amount) internal {
    _burn(account, amount);
    _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
  }
}
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="413" endline="417" pcid="7918">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
    }
}
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="445" endline="449" pcid="2697">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
    }
}
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="532" endline="536" pcid="3822">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
    }
}
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="267" endline="271" pcid="2993">
  function _burnFrom(address account, uint256 amount) internal {
    _burn(account, amount);
    _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
  }
}
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="430" endline="434" pcid="5972">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
    }
}
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="496" endline="500" pcid="6040">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
    }
}
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="450" endline="454" pcid="5434">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount, "ERC20: burn amount exceeds allowance"));
    }
}
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="615" endline="619" pcid="5179">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
    }
}
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="413" endline="417" pcid="7034">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
    }
}
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="474" endline="478" pcid="4441">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
    }
}
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="443" endline="448" pcid="4052">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
    }

}
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="410" endline="414" pcid="665">
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
    }
}
</source>
</class>

<class classid="57" nclones="131" nlines="8" similarity="75">
<source file="systems/smart_contracts/ABCToken.sol" startline="365" endline="390" pcid="320">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="143" endline="168" pcid="7019">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="16" endline="33" pcid="2976">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    if (a == 0) {
      return 0;
    }

    uint256 c = a * b;
    require(c / a == b);

    return c;
  }

  /**
  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="36" endline="49" pcid="6973">
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c / a == b);
        return c;
    }

    /**
     * @dev Integer division of two unsigned integers truncating the quotient,
     * reverts on division by zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Aigopay.sol" startline="28" endline="40" pcid="440">
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c / a == b);
        return c;
    }

    /**
    * Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Ethertime.sol" startline="7" endline="15" pcid="3299">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b);
        return c;
    }
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="20" endline="29" pcid="6201">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="16" endline="26" pcid="4641">
  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
    if (a == 0) {
      return 0;
    }

    c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="162" endline="174" pcid="3073">
  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
    if (a == 0) {
      return 0;
    }
    c = a * b;
    assert(c / a == b);
    return c;
  }

  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="20" endline="29" pcid="2150">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="15" endline="32" pcid="6303">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    /**
     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="301" endline="318" pcid="3259">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    /**
    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="221" endline="246" pcid="953">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BACD.sol" startline="22" endline="31" pcid="1010">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/AronCoin.sol" startline="36" endline="45" pcid="761">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="221" endline="246" pcid="6025">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="16" endline="28" pcid="2945">
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c / a == b);
        return c;
    }

    /**
    * @dev Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CDS.sol" startline="11" endline="27" pcid="1653">
	function mul(uint256 a, uint256 b) internal pure returns (uint256) {
		// Gas optimization: this is cheaper than requiring 'a' not being zero, but the
		// benefit is lost if 'b' is also tested.
		// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
		if (a == 0) {
			return 0;
		}

		uint256 c = a * b;
		require(c / a == b);
		return c;
  }

	/**
		* @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
		*/
	function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/magesh.sol" startline="15" endline="32" pcid="4607">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CST_TOKEN.sol" startline="18" endline="27" pcid="2197">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SEA.sol" startline="8" endline="17" pcid="6391">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="22" endline="31" pcid="5990">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MBA.sol" startline="14" endline="30" pcid="4698">
  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    if (a == 0) {
      return 0;
    }

    c = a * b;
    assert(c / a == b);
    return c;
  }

  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/customIcoToken.sol" startline="9" endline="19" pcid="2208">
  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
    if (a == 0) {
      return 0;
    }

    c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="11" endline="28" pcid="2223">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    /**
     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BANG.sol" startline="24" endline="33" pcid="1041">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MAdvcedWoken.sol" startline="28" endline="37" pcid="4593">
  function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="45" endline="62" pcid="6412">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="69" endline="78" pcid="5093">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="11" endline="28" pcid="6709">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    /**
     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="369" endline="394" pcid="5164">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="63" endline="88" pcid="5950">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/LuckyStrikeTokens.sol" startline="23" endline="35" pcid="4568">
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c / a == b);
        return c;
    }

    /**
    * @dev Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="156" endline="181" pcid="5911">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="16" endline="33" pcid="5832">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    /**
    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="50" endline="67" pcid="6772">
    function mul(uint a, uint b) internal pure returns (uint) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
     */
    function div(uint a, uint b) internal pure returns (uint) {
</source>
<source file="systems/smart_contracts/LuckyAdvcedWoken.sol" startline="28" endline="37" pcid="4554">
  function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="67" endline="76" pcid="2046">
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Factory.sol" startline="140" endline="165" pcid="3437">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DABANKING_SWAP.sol" startline="57" endline="74" pcid="2273">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    if (a == 0) {
      return 0;
    }

    uint256 c = a * b;
    require(c / a == b);

    return c;
  }

  /**
   * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
   */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="8" endline="16" pcid="2872">
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c / a == b);
        return c;
    }
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="185" endline="210" pcid="5782">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BFGToken.sol" startline="9" endline="18" pcid="1177">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) { 
      return 0;
    } 
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  } 
 
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="12" endline="24" pcid="3512">
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c / a == b);
        return c;
    }

    /**
    * @dev Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/LBBT.sol" startline="12" endline="19" pcid="4532">
  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
    if (a == 0) {
      return 0;
    }
    c = a * b;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SellableToken.sol" startline="8" endline="17" pcid="6455">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="19" endline="31" pcid="6476">
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c / a == b);
        return c;
    }

    /**
    * @dev Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="277" endline="302" pcid="4748">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Six.sol" startline="50" endline="75" pcid="6532">
     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
     function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="140" endline="165" pcid="650">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="16" endline="28" pcid="6542">
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c / a == b);
        return c;
    }

    /**
    * @dev Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="10" endline="19" pcid="1620">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/VACCToken.sol" startline="34" endline="41" pcid="7615">
    function safeMul(uint256 a, uint256 b) public pure returns (uint256 c) {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        require(c / a == b);
    }
    function safeDiv(uint256 a, uint256 b) public pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="58" endline="75" pcid="730">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    /**
    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="70" endline="87" pcid="569">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "Safe mul error");

        return c;
    }

    /**
    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="24" endline="41" pcid="6824">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    if (a == 0) {
      return 0;
    }

    uint256 c = a * b;
    require(c / a == b);

    return c;
  }

  /**
  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="15" endline="32" pcid="3543">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    /**
    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="142" endline="167" pcid="483">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="28" endline="38" pcid="2302">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="436" endline="464" pcid="6616">
	function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
		// Gas optimization: this is cheaper than asserting 'a' not being zero, but the
		// benefit is lost if 'b' is also tested.
		// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
		if (a == 0) {
			return 0;
		}

		c = a * b;
		assert(c / a == b);
		return c;
	}

	/**
	* @dev Integer division of two numbers, truncating the quotient.
	*/
	/*
	function div(uint256 a, uint256 b) internal pure returns (uint256) {
		// assert(b > 0); // Solidity automatically throws when dividing by 0
		// uint256 c = a / b;
		// assert(a == b * c + a % b); // There is no case in which this doesn't hold
		return a / b;
	}
	*/

	/**
	* @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
	*/
	function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="64" endline="89" pcid="4417">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Fk.sol" startline="50" endline="75" pcid="3620">
     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
        	return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
     function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/FMT.sol" startline="188" endline="197" pcid="3661">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="12" endline="29" pcid="7977">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    if (a == 0) {
      return 0;
    }

    uint256 c = a * b;
    require(c / a == b);

    return c;
  }

  /**
  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="86" endline="93" pcid="3700">
function mul(percent storage p, uint a) internal view returns (uint) {
if (a == 0) {
return 0;
}
return a*p.num/p.den;
}

function div(percent storage p, uint a) internal view returns (uint) {
</source>
<source file="systems/smart_contracts/Byte.sol" startline="22" endline="31" pcid="1571">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="113" endline="120" pcid="3705">
function mmul(percent memory p, uint a) internal pure returns (uint) {
if (a == 0) {
return 0;
}
return a*p.num/p.den;
}

function mdiv(percent memory p, uint a) internal pure returns (uint) {
</source>
<source file="systems/smart_contracts/MultiSendErc20.sol" startline="11" endline="28" pcid="5198">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    /**
    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="143" endline="168" pcid="1752">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="41" endline="50" pcid="3167">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="54" endline="78" pcid="7169">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="11" endline="20" pcid="4374">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="84" endline="101" pcid="5669">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    /**
    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="146" endline="171" pcid="8232">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="27" endline="39" pcid="4293">
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c / a == b);
        return c;
    }

    /**
    * @dev Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="15" endline="27" pcid="1265">
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c / a == b);
        return c;
    }

    /**
    * Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="67" endline="92" pcid="803">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Ownable.sol" startline="13" endline="22" pcid="5565">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    require(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="67" endline="92" pcid="3758">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="24" endline="41" pcid="4229">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    if (a == 0) {
      return 0;
    }

    uint256 c = a * b;
    require(c / a == b);

    return c;
  }

  /**
  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/ankara.sol" startline="37" endline="48" pcid="681">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DNP.sol" startline="31" endline="43" pcid="2784">
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) 
    {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c  / a == b);
        return c;
    }
    /**
    * @dev Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) 
</source>
<source file="systems/smart_contracts/Comet.sol" startline="20" endline="29" pcid="1918">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NSTTeamLock.sol" startline="123" endline="140" pcid="5462">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="24" endline="33" pcid="2392">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="75" endline="100" pcid="5411">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BRZE.sol" startline="9" endline="17" pcid="1517">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    require(c / a == b);
    return c;
  }
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Token.sol" startline="15" endline="32" pcid="7251">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    /**
     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Governance.sol" startline="64" endline="89" pcid="4184">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="16" endline="33" pcid="7264">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    /**
     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="62" endline="87" pcid="8187">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="43" endline="60" pcid="1365">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    /**
    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="221" endline="246" pcid="2466">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Bridge.sol" startline="24" endline="41" pcid="1503">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    /**
    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="54" endline="69" pcid="7774">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="55" endline="72" pcid="2739">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    if (a == 0) {
      return 0;
    }

    uint256 c = a * b;
    require(c / a == b);

    return c;
  }

  /**
  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="20" endline="29" pcid="7316">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/XGP.sol" startline="28" endline="40" pcid="8097">
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c / a == b);
        return c;
    }

    /**
    * Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="20" endline="29" pcid="3918">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BlockPoolToken.sol" startline="27" endline="38" pcid="1408">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }
    /**
     * @dev Integer division of two numbers, truncating the quotient.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="21" endline="33" pcid="6674">
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c / a == b);
        return c;
    }

    /*
    * @dev Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/GFNX.sol" startline="44" endline="61" pcid="4098">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    if (a == 0) {
      return 0;
    }

    uint256 c = a * b;
    require(c / a == b);

    return c;
  }

  /**
  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="142" endline="167" pcid="523">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="147" endline="159" pcid="7346">
  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
    if (a == 0) {
      return 0;
    }
    c = a * b;
    assert(c / a == b);
    return c;
  }

  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BountyBoard.sol" startline="60" endline="84" pcid="1489">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }
    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="23" endline="35" pcid="1428">
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c / a == b);
        return c;
    }

    /**
    * @dev Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="20" endline="29" pcid="2643">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="228" endline="253" pcid="4991">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="92" endline="109" pcid="8078">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
      // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
      // benefit is lost if 'b' is also tested.
      // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
      if (a == 0) {
          return 0;
      }

      uint256 c = a * b;
      require(c / a == b);

      return c;
  }

  /**
  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/GameGold.sol" startline="66" endline="78" pcid="3986">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="15" endline="32" pcid="4919">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="62" endline="87" pcid="7897">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="20" endline="37" pcid="1877">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    if (a == 0) {
      return 0;
    }

    uint256 c = a * b;
    require(c / a == b);

    return c;
  }

  /**
  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="62" endline="87" pcid="4028">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/UTC.sol" startline="18" endline="30" pcid="7571">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CoinDDC.sol" startline="184" endline="196" pcid="1873">
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) 
    {
        if (a == 0) 
        {
            return 0;
        }

        c = a * b;
        assert(c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) 
</source>
<source file="systems/smart_contracts/WTA.sol" startline="26" endline="37" pcid="8040">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="36" endline="45" pcid="7745">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CNG.sol" startline="55" endline="72" pcid="1846">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    if (a == 0) {
      return 0;
    }

    uint256 c = a * b;
    require(c / a == b);

    return c;
  }

  /**
  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="11" endline="28" pcid="7696">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    /**
     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="56" endline="71" pcid="5332">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="53" endline="70" pcid="7641">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    /**
     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TokenSwap.sol" startline="15" endline="32" pcid="7385">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    /**
     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="15" endline="27" pcid="4950">
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c / a == b);
        return c;
    }

    /**
    * Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="17" endline="29" pcid="7448">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }

    /**
    * @dev Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="24" endline="33" pcid="2552">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="8" endline="16" pcid="8006">
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c / a == b);
        return c;
    }
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TorexToken.sol" startline="18" endline="34" pcid="7403">
  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    if (a == 0) {
      return 0;
    }

    c = a * b;
    assert(c / a == b);
    return c;
  }

  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NBToken.sol" startline="27" endline="38" pcid="5298">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }
    /**
     * @dev Integer division of two numbers, truncating the quotient.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NaorisToken.sol" startline="17" endline="29" pcid="5277">
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }

    /**
    * @dev Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="24" endline="33" pcid="1465">
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
</class>

<class classid="58" nclones="69" nlines="4" similarity="75">
<source file="systems/smart_contracts/ABCToken.sol" startline="410" endline="414" pcid="322">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/TokenSwap.sol" startline="65" endline="69" pcid="7389">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/magesh.sol" startline="65" endline="69" pcid="4611">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="109" endline="113" pcid="4419">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="322" endline="326" pcid="4750">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="73" endline="77" pcid="4233">
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b != 0);
    return a % b;
  }
}
</source>
<source file="systems/smart_contracts/Governance.sol" startline="109" endline="113" pcid="4186">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="103" endline="107" pcid="7645">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="66" endline="70" pcid="7268">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/GFNX.sol" startline="93" endline="97" pcid="4102">
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b != 0);
    return a % b;
  }
}
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="107" endline="111" pcid="4030">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="60" endline="64" pcid="7700">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="87" endline="95" pcid="7777">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="65" endline="69" pcid="4923">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="107" endline="111" pcid="7899">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="112" endline="116" pcid="3760">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="207" endline="211" pcid="3715">
function mod(uint256 a, uint256 b) internal pure returns (uint256) {
require(b != 0);
return a % b;
}
}
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="98" endline="102" pcid="7171">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/Fk.sol" startline="95" endline="99" pcid="3622">
     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
     	require(b != 0, "SafeMath: modulo by zero");
     	return a % b;
     }
 }
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="61" endline="65" pcid="7981">
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b != 0);
    return a % b;
  }
}
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="65" endline="69" pcid="3547">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/WTA.sol" startline="50" endline="54" pcid="8043">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="288" endline="303" pcid="4994">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="65" endline="69" pcid="6307">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="142" endline="148" pcid="8082">
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
      require(b != 0);
      return a % b;
  }
 

  function uint2str(uint i) internal pure returns (string){
</source>
<source file="systems/smart_contracts/Factory.sol" startline="185" endline="189" pcid="3439">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="188" endline="192" pcid="7021">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="107" endline="111" pcid="8189">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="414" endline="418" pcid="5166">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/MultiSendErc20.sol" startline="61" endline="65" pcid="5202">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/Ethertime.sol" startline="30" endline="34" pcid="3303">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="60" endline="64" pcid="6975">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="89" endline="97" pcid="5335">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="351" endline="355" pcid="3263">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="191" endline="195" pcid="8234">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="135" endline="150" pcid="5414">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="73" endline="77" pcid="6828">
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b != 0);
    return a % b;
  }
}
</source>
<source file="systems/smart_contracts/NSTTeamLock.sol" startline="173" endline="177" pcid="5466">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="65" endline="69" pcid="2980">
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b != 0);
    return a % b;
  }
}
</source>
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="187" endline="191" pcid="485">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="100" endline="104" pcid="6776">
    function mod(uint a, uint b) internal pure returns (uint) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="104" endline="108" pcid="2743">
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b != 0);
    return a % b;
  }
}
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="266" endline="270" pcid="955">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="112" endline="116" pcid="805">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="134" endline="138" pcid="5673">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="187" endline="191" pcid="525">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/Bridge.sol" startline="74" endline="78" pcid="1507">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="266" endline="270" pcid="2468">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="56" endline="60" pcid="2306">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="120" endline="124" pcid="573">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "Safe mod error");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/DABANKING_SWAP.sol" startline="107" endline="111" pcid="2277">
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b != 0);
    return a % b;
  }
}
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="60" endline="64" pcid="2227">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="69" endline="73" pcid="1881">
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b != 0);
    return a % b;
  }
}
</source>
<source file="systems/smart_contracts/CNG.sol" startline="104" endline="108" pcid="1850">
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b != 0);
    return a % b;
  }
}
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="93" endline="97" pcid="1369">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="188" endline="192" pcid="1754">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="185" endline="189" pcid="652">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="60" endline="64" pcid="6713">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="230" endline="234" pcid="5784">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="65" endline="69" pcid="5836">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="216" endline="231" pcid="5914">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="108" endline="112" pcid="5952">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/Six.sol" startline="95" endline="99" pcid="6534">
     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
         require(b != 0, "SafeMath: modulo by zero");
         return a % b;
     }
}
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="266" endline="270" pcid="6027">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="95" endline="99" pcid="6416">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/ankara.sol" startline="69" endline="73" pcid="685">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="107" endline="111" pcid="734">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/BRZE.sol" startline="32" endline="36" pcid="1521">
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b != 0);
    return a % b;
  }
  function max256(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/BountyBoard.sol" startline="103" endline="107" pcid="1491">
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}
</source>
</class>

<class classid="59" nclones="20" nlines="4" similarity="75">
<source file="systems/smart_contracts/ABCToken.sol" startline="429" endline="437" pcid="323">
    function add(Role storage role, address account) internal {
        require(!has(role, account), "Roles: account already has role");
        role.bearer[account] = true;
    }

    /**
     * @dev Remove an account's access to this role.
     */
    function remove(Role storage role, address account) internal {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="340" endline="350" pcid="1384">
    function add(Role storage role, address account) internal {
        require(account != address(0));
        require(!has(role, account));

        role.bearer[account] = true;
    }

    /**
     * @dev remove an account's access to this role
     */
    function remove(Role storage role, address account) internal {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="518" endline="526" pcid="6041">
    function add(Role storage role, address account) internal {
        require(!has(role, account), "Roles: account already has role");
        role.bearer[account] = true;
    }

    /**
     * @dev Remove an account's access to this role.
     */
    function remove(Role storage role, address account) internal {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="115" endline="123" pcid="5337">
    function add(Role storage role, address account) internal {
        require(!has(role, account), "Roles: account already has role");
        role.bearer[account] = true;
    }

    /**
     * @dev Remove an account's access to this role.
     */
    function remove(Role storage role, address account) internal {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="119" endline="129" pcid="6313">
    function add(Role storage role, address account) internal {
        require(account != address(0));
        require(!has(role, account));

        role.bearer[account] = true;
    }

    /**
     * @dev remove an account's access to this role
     */
    function remove(Role storage role, address account) internal {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="23" endline="31" pcid="4977">
    function add(Role storage role, address account) internal {
        require(!has(role, account), "Roles: account already has role");
        role.bearer[account] = true;
    }

    /**
     * @dev Remove an account's access to this role.
     */
    function remove(Role storage role, address account) internal {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="116" endline="124" pcid="7172">
    function add(Role storage role, address account) internal {
        require(!has(role, account), "Roles: account already has role");
        role.bearer[account] = true;
    }

    /**
     * Remove an account's access to this role.
     */
    function remove(Role storage role, address account) internal {
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="85" endline="95" pcid="7269">
    function add(Role storage role, address account) internal {
        require(account != address(0));
        require(!has(role, account));

        role.bearer[account] = true;
    }

    /**
     * @dev remove an account's access to this role
     */
    function remove(Role storage role, address account) internal {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="496" endline="504" pcid="4442">
    function add(Role storage role, address account) internal {
        require(!has(role, account), "Roles: account already has role");
        role.bearer[account] = true;
    }

    /**
     * @dev Remove an account's access to this role.
     */
    function remove(Role storage role, address account) internal {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="336" endline="344" pcid="4252">
  function add(Role storage role, address account) internal {
    require(account != address(0));
    role.bearer[account] = true;
  }

  /**
   * @dev remove an account's access to this role
   */
  function remove(Role storage role, address account) internal {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="114" endline="122" pcid="7779">
    function add(Role storage role, address account) internal {
        require(!has(role, account), "Roles: account already has role");
        role.bearer[account] = true;
    }

    /**
     * @dev Remove an account's access to this role.
     */
    function remove(Role storage role, address account) internal {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="83" endline="93" pcid="3548">
    function add(Role storage role, address account) internal {
        require(account != address(0));
        require(!has(role, account));

        role.bearer[account] = true;
    }

    /**
     * @dev remove an account's access to this role
     */
    function remove(Role storage role, address account) internal {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="132" endline="142" pcid="3243">
    function add(Role storage role, address account) internal {
        require(account != address(0));
        require(!has(role, account));

        role.bearer[account] = true;
    }

    /**
     * @dev remove an account's access to this role
     */
    function remove(Role storage role, address account) internal {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="445" endline="453" pcid="8248">
    function add(Role storage role, address account) internal {
        require(!has(role, account), "Roles: account already has role");
        role.bearer[account] = true;
    }

    /**
     * @dev Remove an account's access to this role.
     */
    function remove(Role storage role, address account) internal {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="456" endline="461" pcid="2698">
    function add(Role storage role, address account) internal {
        require(!has(role, account), "Roles: account already has role");
        role.bearer[account] = true;
    }

    function remove(Role storage role, address account) internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="460" endline="465" pcid="2607">
    function add(Role storage role, address account) internal {
        require(!has(role, account), "Roles: account already has role");
        role.bearer[account] = true;
    }

    function remove(Role storage role, address account) internal {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="518" endline="526" pcid="969">
    function add(Role storage role, address account) internal {
        require(!has(role, account), "Roles: account already has role");
        role.bearer[account] = true;
    }

    /**
     * @dev Remove an account's access to this role.
     */
    function remove(Role storage role, address account) internal {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="518" endline="526" pcid="2482">
    function add(Role storage role, address account) internal {
        require(!has(role, account), "Roles: account already has role");
        role.bearer[account] = true;
    }

    /**
     * @dev Remove an account's access to this role.
     */
    function remove(Role storage role, address account) internal {
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="87" endline="97" pcid="1882">
  function add(Role storage role, address account) internal {
    require(account != address(0));
    require(!has(role, account));

    role.bearer[account] = true;
  }

  /**
   * @dev remove an account's access to this role
   */
  function remove(Role storage role, address account) internal {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="440" endline="448" pcid="1768">
    function add(Role storage role, address account) internal {
        require(!has(role, account), "Roles: account already has role");
        role.bearer[account] = true;
    }

    /**
     * @dev Remove an account's access to this role.
     */
    function remove(Role storage role, address account) internal {
</source>
</class>

<class classid="60" nclones="20" nlines="4" similarity="75">
<source file="systems/smart_contracts/ABCToken.sol" startline="437" endline="446" pcid="324">
    function remove(Role storage role, address account) internal {
        require(has(role, account), "Roles: account does not have role");
        role.bearer[account] = false;
    }

    /**
     * @dev Check if an account has this role.
     * @return bool
     */
    function has(Role storage role, address account) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="448" endline="457" pcid="1769">
    function remove(Role storage role, address account) internal {
        require(has(role, account), "Roles: account does not have role");
        role.bearer[account] = false;
    }

    /**
     * @dev Check if an account has this role.
     * @return bool
     */
    function has(Role storage role, address account) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="526" endline="535" pcid="6042">
    function remove(Role storage role, address account) internal {
        require(has(role, account), "Roles: account does not have role");
        role.bearer[account] = false;
    }

    /**
     * @dev Check if an account has this role.
     * @return bool
     */
    function has(Role storage role, address account) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="123" endline="133" pcid="5338">
    function remove(Role storage role, address account) internal {
        require(has(role, account), "Roles: account does not have role");
        role.bearer[account] = false;
    }

    /**
     * @dev Check if an account has this role.
     *
     * @return bool
     */
    function has(Role storage role, address account) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="31" endline="40" pcid="4978">
    function remove(Role storage role, address account) internal {
        require(has(role, account), "Roles: account does not have role");
        role.bearer[account] = false;
    }

    /**
     * @dev Check if an account has this role.
     * @return bool
     */
    function has(Role storage role, address account) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="124" endline="133" pcid="7173">
    function remove(Role storage role, address account) internal {
        require(has(role, account), "Roles: account does not have role");
        role.bearer[account] = false;
    }

    /**
     * Check if an account has this role.
     * @return bool
     */
    function has(Role storage role, address account) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="129" endline="140" pcid="6314">
    function remove(Role storage role, address account) internal {
        require(account != address(0));
        require(has(role, account));

        role.bearer[account] = false;
    }

    /**
     * @dev check if an account has this role
     * @return bool
     */
    function has(Role storage role, address account) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="97" endline="108" pcid="1883">
  function remove(Role storage role, address account) internal {
    require(account != address(0));
    require(has(role, account));

    role.bearer[account] = false;
  }

  /**
   * @dev check if an account has this role
   * @return bool
   */
  function has(Role storage role, address account)
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="526" endline="535" pcid="2483">
    function remove(Role storage role, address account) internal {
        require(has(role, account), "Roles: account does not have role");
        role.bearer[account] = false;
    }

    /**
     * @dev Check if an account has this role.
     * @return bool
     */
    function has(Role storage role, address account) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="526" endline="535" pcid="970">
    function remove(Role storage role, address account) internal {
        require(has(role, account), "Roles: account does not have role");
        role.bearer[account] = false;
    }

    /**
     * @dev Check if an account has this role.
     * @return bool
     */
    function has(Role storage role, address account) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="465" endline="470" pcid="2608">
    function remove(Role storage role, address account) internal {
        require(has(role, account), "Roles: account does not have role");
        role.bearer[account] = false;
    }

    function has(Role storage role, address account) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="461" endline="466" pcid="2699">
    function remove(Role storage role, address account) internal {
        require(has(role, account), "Roles: account does not have role");
        role.bearer[account] = false;
    }

    function has(Role storage role, address account) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="453" endline="462" pcid="8249">
    function remove(Role storage role, address account) internal {
        require(has(role, account), "Roles: account does not have role");
        role.bearer[account] = false;
    }

    /**
     * @dev Check if an account has this role.
     * @return bool
     */
    function has(Role storage role, address account) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="142" endline="153" pcid="3244">
    function remove(Role storage role, address account) internal {
        require(account != address(0));
        require(has(role, account));

        role.bearer[account] = false;
    }

    /**
     * @dev check if an account has this role
     * @return bool
     */
    function has(Role storage role, address account) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="93" endline="104" pcid="3549">
    function remove(Role storage role, address account) internal {
        require(account != address(0));
        require(has(role, account));

        role.bearer[account] = false;
    }

    /**
     * @dev check if an account has this role
     * @return bool
     */
    function has(Role storage role, address account) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="122" endline="131" pcid="7780">
    function remove(Role storage role, address account) internal {
        require(has(role, account), "Roles: account does not have role");
        role.bearer[account] = false;
    }

    /**
     * @dev Check if an account has this role.
     * @return bool
     */
    function has(Role storage role, address account) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="95" endline="106" pcid="7270">
    function remove(Role storage role, address account) internal {
        require(account != address(0));
        require(has(role, account));

        role.bearer[account] = false;
    }

    /**
     * @dev check if an account has this role
     * @return bool
     */
    function has(Role storage role, address account) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="350" endline="361" pcid="1385">
    function remove(Role storage role, address account) internal {
        require(account != address(0));
        require(has(role, account));

        role.bearer[account] = false;
    }

    /**
     * @dev check if an account has this role
     * @return bool
     */
    function has(Role storage role, address account) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="504" endline="513" pcid="4443">
    function remove(Role storage role, address account) internal {
        require(has(role, account), "Roles: account does not have role");
        role.bearer[account] = false;
    }

    /**
     * @dev Check if an account has this role.
     * @return bool
     */
    function has(Role storage role, address account) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="344" endline="353" pcid="4253">
  function remove(Role storage role, address account) internal {
    require(account != address(0));
    role.bearer[account] = false;
  }

  /**
   * @dev check if an account has this role
   * @return bool
   */
  function has(Role storage role, address account)
</source>
</class>

<class classid="61" nclones="20" nlines="4" similarity="75">
<source file="systems/smart_contracts/ABCToken.sol" startline="446" endline="450" pcid="325">
    function has(Role storage role, address account) internal view returns (bool) {
        require(account != address(0), "Roles: account is the zero address");
        return role.bearer[account];
    }
}
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="462" endline="466" pcid="8250">
    function has(Role storage role, address account) internal view returns (bool) {
        require(account != address(0), "Roles: account is the zero address");
        return role.bearer[account];
    }
}
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="361" endline="365" pcid="1386">
    function has(Role storage role, address account) internal view returns (bool) {
        require(account != address(0));
        return role.bearer[account];
    }
}
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="153" endline="157" pcid="3245">
    function has(Role storage role, address account) internal view returns (bool) {
        require(account != address(0));
        return role.bearer[account];
    }
}
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="104" endline="108" pcid="3550">
    function has(Role storage role, address account) internal view returns (bool) {
        require(account != address(0));
        return role.bearer[account];
    }
}
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="466" endline="470" pcid="2700">
    function has(Role storage role, address account) internal view returns (bool) {
        require(account != address(0), "Roles: account is the zero address");
        return role.bearer[account];
    }
}
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="457" endline="461" pcid="1770">
    function has(Role storage role, address account) internal view returns (bool) {
        require(account != address(0), "Roles: account is the zero address");
        return role.bearer[account];
    }
}
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="131" endline="135" pcid="7781">
    function has(Role storage role, address account) internal view returns (bool) {
        require(account != address(0), "Roles: account is the zero address");
        return role.bearer[account];
    }
}
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="108" endline="116" pcid="1884">
  function has(Role storage role, address account)
    internal
    view
    returns (bool)
  {
    require(account != address(0));
    return role.bearer[account];
  }
}
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="353" endline="361" pcid="4254">
  function has(Role storage role, address account)
  internal
  view
  returns (bool)
  {
    require(account != address(0));
    return role.bearer[account];
  }
}
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="535" endline="539" pcid="2484">
    function has(Role storage role, address account) internal view returns (bool) {
        require(account != address(0), "Roles: account is the zero address");
        return role.bearer[account];
    }
}
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="513" endline="517" pcid="4444">
    function has(Role storage role, address account) internal view returns (bool) {
        require(account != address(0), "Roles: account is the zero address");
        return role.bearer[account];
    }
}
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="535" endline="539" pcid="971">
    function has(Role storage role, address account) internal view returns (bool) {
        require(account != address(0), "Roles: account is the zero address");
        return role.bearer[account];
    }
}
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="106" endline="110" pcid="7271">
    function has(Role storage role, address account) internal view returns (bool) {
        require(account != address(0));
        return role.bearer[account];
    }
}
</source>
<source file="systems/smart_contracts/SBC.sol" startline="140" endline="144" pcid="6315">
    function has(Role storage role, address account) internal view returns (bool) {
        require(account != address(0));
        return role.bearer[account];
    }
}
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="470" endline="474" pcid="2609">
    function has(Role storage role, address account) internal view returns (bool) {
        require(account != address(0), "Roles: account is the zero address");
        return role.bearer[account];
    }
}
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="535" endline="539" pcid="6043">
    function has(Role storage role, address account) internal view returns (bool) {
        require(account != address(0), "Roles: account is the zero address");
        return role.bearer[account];
    }
}
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="133" endline="137" pcid="5339">
    function has(Role storage role, address account) internal view returns (bool) {
        require(account != address(0), "Roles: account is the zero address");
        return role.bearer[account];
    }
}
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="133" endline="137" pcid="7174">
    function has(Role storage role, address account) internal view returns (bool) {
        require(account != address(0), "Roles: account is the zero address");
        return role.bearer[account];
    }
}
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="40" endline="44" pcid="4979">
    function has(Role storage role, address account) internal view returns (bool) {
        require(account != address(0), "Roles: account is the zero address");
        return role.bearer[account];
    }
}
</source>
</class>

<class classid="62" nclones="52" nlines="4" similarity="75">
<source file="systems/smart_contracts/ABCToken.sol" startline="475" endline="483" pcid="326">
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="68" endline="72" pcid="2557">
  function name() public view returns(string memory) {
    return _name;
  }

  function symbol() public view returns(string memory) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="64" endline="68" pcid="2648">
  function name() public view returns(string memory) {
    return _name;
  }

  function symbol() public view returns(string memory) {
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="68" endline="72" pcid="2397">
  function name() public view returns(string memory) {
    return _name;
  }

  function symbol() public view returns(string memory) {
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="164" endline="168" pcid="2318">
    function name() public view returns(string memory) {
        return _name;
    }

    function symbol() public view returns(string memory) {
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="348" endline="355" pcid="2756">
  function name() public view returns(string) {
    return _name;
  }

  /**
   * @return the symbol of the token.
   */
  function symbol() public view returns(string) {
</source>
<source file="systems/smart_contracts/BANG.sol" startline="68" endline="72" pcid="1046">
  function name() public view returns(string memory) {
    return _name;
  }

  function symbol() public view returns(string memory) {
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="64" endline="68" pcid="7321">
  function name() public view returns(string memory) {
    return _name;
  }

  function symbol() public view returns(string memory) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="436" endline="444" pcid="7194">
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     *  Return the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="68" endline="72" pcid="1470">
  function name() public view returns(string memory) {
    return _name;
  }

  function symbol() public view returns(string memory) {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="845" endline="853" pcid="5034">
    function name() external view returns (string memory) {
        return _name;
    }

    /**
     * @dev Gets the token symbol.
     * @return string representing the token symbol
     */
    function symbol() external view returns (string memory) {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="478" endline="485" pcid="2264">
    function name() public view returns (string) {
        return _name;
    }

    /**
     * @return the symbol of the token.
     */
    function symbol() public view returns (string) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="613" endline="620" pcid="7091">
    function name() external view returns (string memory) {
        return _name;
    }

    /**
     * @return the symbol of the token.
     */
    function symbol() external view returns (string memory) {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="115" endline="119" pcid="5098">
    function name() public view returns(string memory) {
        return _Tokenname;
    }

    function symbol() public view returns(string memory) {
</source>
<source file="systems/smart_contracts/ERC20Detailed.sol" startline="32" endline="39" pcid="3004">
  function name() public view returns(string) {
    return _name;
  }

  /**
   * @return the symbol of the token.
   */
  function symbol() public view returns(string) {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="365" endline="372" pcid="3037">
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @return the symbol of the token.
     */
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="569" endline="577" pcid="8257">
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/MatchingToken.sol" startline="26" endline="30" pcid="4682">
    function name() public view returns (string memory) {
        return _name;
    }
    
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="85" endline="89" pcid="3172">
  function name() public view returns(string memory) {
    return _name;
  }

  function symbol() public view returns(string memory) {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="262" endline="269" pcid="587">
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @return the symbol of the token.
     */
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/EtheleToken.sol" startline="56" endline="59" pcid="3198">
    function name() public view returns (string memory) {
        return _name;
    }
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="64" endline="68" pcid="2155">
  function name() public view returns(string memory) {
    return _name;
  }

  function symbol() public view returns(string memory) {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="562" endline="570" pcid="3271">
    function name() external view returns (string memory) {
        return _name;
    }

    /**
     * @dev Gets the token symbol
     * @return string representing the token symbol
     */
    function symbol() external view returns (string memory) {
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="433" endline="441" pcid="8209">
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="95" endline="99" pcid="8052">
    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="468" endline="475" pcid="3582">
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @return the symbol of the token.
     */
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="613" endline="620" pcid="3836">
    function name() external view returns (string memory) {
        return _name;
    }

    /**
     * @return the symbol of the token.
     */
    function symbol() external view returns (string memory) {
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="64" endline="68" pcid="3923">
  function name() public view returns(string memory) {
    return _name;
  }

  function symbol() public view returns(string memory) {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="480" endline="487" pcid="7737">
    function name() public view returns (string) {
        return _name;
    }

    /**
     * @return the symbol of the token.
     */
    function symbol() public view returns (string) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="488" endline="495" pcid="6348">
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @return the symbol of the token.
     */
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="224" endline="232" pcid="4037">
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="314" endline="321" pcid="7659">
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @return the symbol of the token.
     */
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="221" endline="229" pcid="4426">
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="323" endline="330" pcid="746">
    function name() public view returns(string memory) {
        return _name;
    }

    /**
    * @return the symbol of the token.
    */
    function symbol() public view returns(string memory) {
</source>
<source file="systems/smart_contracts/Byte.sol" startline="68" endline="72" pcid="1576">
  function name() public view returns(string memory) {
    return _Name;
  }
  
  function decimals() public view returns(uint8) {
</source>
<source file="systems/smart_contracts/BCCT.sol" startline="256" endline="264" pcid="1105">
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/Comet.sol" startline="64" endline="68" pcid="1923">
  function name() public view returns(string memory) {
    return _name;
  }

  function symbol() public view returns(string memory) {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="478" endline="485" pcid="6750">
    function name() public view returns (string) {
        return _name;
    }

    /**
     * @return the symbol of the token.
     */
    function symbol() public view returns (string) {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="307" endline="314" pcid="1381">
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @return the symbol of the token.
     */
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="478" endline="486" pcid="5435">
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="422" endline="429" pcid="5360">
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of VOKEN.
     */
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="241" endline="248" pcid="5851">
    function name() public view returns(string) {
        return _name;
    }

    /**
     * @return the symbol of the token.
     */
    function symbol() public view returns(string) {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="495" endline="503" pcid="5929">
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="66" endline="70" pcid="5995">
  function name() public view returns(string memory) {
    return _name;
  }

  function symbol() public view returns(string memory) {
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="64" endline="68" pcid="6206">
  function name() public view returns(string memory) {
    return _name;
  }

  function symbol() public view returns(string memory) {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="283" endline="291" pcid="5787">
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/RubyToken.sol" startline="26" endline="30" pcid="6223">
    function name() public view returns (string memory) {
        return _name;
    }
    
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="250" endline="257" pcid="6993">
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @return the symbol of the token.
     */
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="439" endline="447" pcid="666">
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/ankara.sol" startline="171" endline="175" pcid="699">
    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
</source>
<source file="systems/smart_contracts/ProxyERC20.sol" startline="397" endline="402" pcid="5893">
    function name() public view returns (string){
        // Immutable static call from target contract
        return IERC20(target).name();
    }

    function symbol() public view returns (string){
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="170" endline="173" pcid="2857">
    function name() public view returns (string){
        return operator.token_name();
    }
    function symbol() public view returns (string){
</source>
</class>

<class classid="63" nclones="52" nlines="4" similarity="75">
<source file="systems/smart_contracts/ABCToken.sol" startline="483" endline="499" pcid="327">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei.
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/Byte.sol" startline="76" endline="79" pcid="1578">
  function symbol() public view returns(string memory) {
    return _Symbol;
  }  
}
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="72" endline="76" pcid="1471">
  function symbol() public view returns(string memory) {
    return _symbol;
  }

  function decimals() public view returns(uint8) {
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="72" endline="76" pcid="2398">
  function symbol() public view returns(string memory) {
    return _symbol;
  }

  function decimals() public view returns(uint8) {
</source>
<source file="systems/smart_contracts/ankara.sol" startline="175" endline="179" pcid="700">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/RubyToken.sol" startline="30" endline="33" pcid="6224">
    function symbol() public view returns (string memory) {
        return _symbol;
    }
    function decimals() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="68" endline="72" pcid="6207">
  function symbol() public view returns(string memory) {
    return _symbol;
  }

  function decimals() public view returns(uint8) {
</source>
<source file="systems/smart_contracts/BANG.sol" startline="72" endline="76" pcid="1047">
  function symbol() public view returns(string memory) {
    return _symbol;
  }

  function decimals() public view returns(uint8) {
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="70" endline="74" pcid="5996">
  function symbol() public view returns(string memory) {
    return _symbol;
  }

  function decimals() public view returns(uint8) {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="330" endline="333" pcid="747">
    function symbol() public view returns(string memory) {
        return _symbol;
    }
}
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="168" endline="171" pcid="2319">
    function symbol() public view returns(string memory) {
        return _symbol;
    }
}
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="68" endline="72" pcid="2156">
  function symbol() public view returns(string memory) {
    return _symbol;
  }

  function decimals() public view returns(uint8) {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="503" endline="519" pcid="5930">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei.
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="485" endline="492" pcid="2265">
    function symbol() public view returns (string) {
        return _symbol;
    }

    /**
     * @return the number of decimals of the token.
     */
    function decimals() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="248" endline="255" pcid="5852">
    function symbol() public view returns(string) {
        return _symbol;
    }

    /**
     * @return the number of decimals of the token.
     */
    function decimals() public view returns(uint8) {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="269" endline="276" pcid="588">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @return the number of decimals of the token.
     */
    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="291" endline="307" pcid="5788">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei.
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="485" endline="492" pcid="6751">
    function symbol() public view returns (string) {
        return _symbol;
    }

    /**
     * @return the number of decimals of the token.
     */
    function decimals() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="486" endline="502" pcid="5436">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei.
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="429" endline="436" pcid="5361">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     */
    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="257" endline="264" pcid="6994">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @return the number of decimals of the token.
     */
    function decimals() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="119" endline="123" pcid="5099">
    function symbol() public view returns(string memory) {
        return _Tokensymbol;
    }

    function decimals() public view returns(uint8) {
</source>
<source file="systems/smart_contracts/Comet.sol" startline="68" endline="72" pcid="1924">
  function symbol() public view returns(string memory) {
    return _symbol;
  }

  function decimals() public view returns(uint8) {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="314" endline="321" pcid="1382">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @return the number of decimals of the token.
     */
    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="447" endline="463" pcid="667">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei.
     *
     * > Note that this information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * `IERC20.balanceOf` and `IERC20.transfer`.
     */
    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="72" endline="76" pcid="2558">
  function symbol() public view returns(string memory) {
    return _symbol;
  }

  function decimals() public view returns(uint8) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="620" endline="627" pcid="7092">
    function symbol() external view returns (string memory) {
        return _symbol;
    }

    /**
     * @return the number of decimals of the token.
     */
    function decimals() external view returns (uint8) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="620" endline="627" pcid="3837">
    function symbol() external view returns (string memory) {
        return _symbol;
    }

    /**
     * @return the number of decimals of the token.
     */
    function decimals() external view returns (uint8) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="68" endline="72" pcid="2649">
  function symbol() public view returns(string memory) {
    return _symbol;
  }

  function decimals() public view returns(uint8) {
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="355" endline="362" pcid="2757">
  function symbol() public view returns(string) {
    return _symbol;
  }

  /**
   * @return the number of decimals of the token.
   */
  function decimals() public view returns(uint8) {
</source>
<source file="systems/smart_contracts/ERC20Detailed.sol" startline="39" endline="46" pcid="3005">
  function symbol() public view returns(string) {
    return _symbol;
  }

  /**
   * @return the number of decimals of the token.
   */
  function decimals() public view returns(uint8) {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="372" endline="379" pcid="3038">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @return the number of decimals of the token.
     */
    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="577" endline="593" pcid="8258">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei.
     *
     * > Note that this information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * `IERC20.balanceOf` and `IERC20.transfer`.
     */
    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="89" endline="93" pcid="3173">
  function symbol() public view returns(string memory) {
    return _symbol;
  }

  function decimals() public view returns(uint8) {
</source>
<source file="systems/smart_contracts/EtheleToken.sol" startline="59" endline="62" pcid="3199">
    function symbol() public view returns (string memory) {
        return _symbol;
    }
    function decimals() public pure returns (uint8) {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="853" endline="862" pcid="5035">
    function symbol() external view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns an URI for a given token ID.
     * Throws if the token ID does not exist. May return an empty string.
     * @param tokenId uint256 ID of the token to query
     */
    function tokenURI(uint256 tokenId) external view returns (string memory) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="444" endline="453" pcid="7195">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     *  Return the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     */
    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="68" endline="72" pcid="7322">
  function symbol() public view returns(string memory) {
    return _symbol;
  }

  function decimals() public view returns(uint8) {
</source>
<source file="systems/smart_contracts/MatchingToken.sol" startline="30" endline="33" pcid="4683">
    function symbol() public view returns (string memory) {
        return _symbol;
    }
    function decimals() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="475" endline="482" pcid="3583">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @return the number of decimals of the token.
     */
    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="229" endline="245" pcid="4427">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei.
     *
     * > Note that this information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * `IERC20.balanceOf` and `IERC20.transfer`.
     */
    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/BCCT.sol" startline="264" endline="280" pcid="1106">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei.
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="495" endline="502" pcid="6349">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @return the number of decimals of the token.
     */
    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="321" endline="328" pcid="7660">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @return the number of decimals of the token.
     */
    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="68" endline="72" pcid="3924">
  function symbol() public view returns(string memory) {
    return _symbol;
  }

  function decimals() public view returns(uint8) {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="570" endline="578" pcid="3272">
    function symbol() external view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Gets the total amount of tokens stored by the contract
     * @return uint256 representing the total amount of tokens
     */
    function totalSupply() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="232" endline="248" pcid="4038">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei.
     *
     * > Note that this information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * `IERC20.balanceOf` and `IERC20.transfer`.
     */
    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="441" endline="457" pcid="8210">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei.
     *
     * > Note that this information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * `IERC20.balanceOf` and `IERC20.transfer`.
     */
    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="99" endline="103" pcid="8053">
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="487" endline="494" pcid="7738">
    function symbol() public view returns (string) {
        return _symbol;
    }

    /**
     * @return the number of decimals of the token.
     */
    function decimals() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/ProxyERC20.sol" startline="402" endline="407" pcid="5894">
    function symbol() public view returns (string){
         // Immutable static call from target contract
        return IERC20(target).symbol();
    }

    function decimals() public view returns (uint8){
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="173" endline="176" pcid="2858">
    function symbol() public view returns (string){
        return operator.token_symbol();
    }
    function decimals() public view returns (uint8){
</source>
</class>

<class classid="64" nclones="49" nlines="4" similarity="75">
<source file="systems/smart_contracts/ABCToken.sol" startline="499" endline="502" pcid="328">
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}
</source>
<source file="systems/smart_contracts/ankara.sol" startline="179" endline="182" pcid="701">
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="492" endline="495" pcid="2266">
    function decimals() public view returns (uint256) {
        return _decimals;
    }
}
</source>
<source file="systems/smart_contracts/BCCT.sol" startline="280" endline="283" pcid="1107">
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}
</source>
<source file="systems/smart_contracts/BANG.sol" startline="76" endline="79" pcid="1048">
  function decimals() public view returns(uint8) {
    return _decimals;
  }
}
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="463" endline="466" pcid="668">
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="72" endline="75" pcid="6208">
  function decimals() public view returns(uint8) {
    return _decimals;
  }
}
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="347" endline="351" pcid="748">
    function decimals() public view returns(uint8) {
        return _decimals;
    }

}
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="76" endline="79" pcid="2559">
  function decimals() public view returns(uint8) {
    return _decimals;
  }
}
</source>
<source file="systems/smart_contracts/RubyToken.sol" startline="33" endline="37" pcid="6225">
    function decimals() public view returns (uint256) {
        return _decimals;
    }
    
    function totalSupply() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="321" endline="324" pcid="1383">
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}
</source>
<source file="systems/smart_contracts/Comet.sol" startline="72" endline="75" pcid="1925">
  function decimals() public view returns(uint8) {
    return _decimals;
  }
}
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="72" endline="75" pcid="2157">
  function decimals() public view returns(uint8) {
    return _decimals;
  }
}
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="74" endline="77" pcid="5997">
  function decimals() public view returns(uint8) {
    return _decimals;
  }
}
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="519" endline="522" pcid="5931">
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}
</source>
<source file="systems/smart_contracts/ProxyERC20.sol" startline="407" endline="417" pcid="5895">
    function decimals() public view returns (uint8){
         // Immutable static call from target contract
        return IERC20(target).decimals();
    }

    // ------------- ERC20 Interface ------------- //

    /**
    * @dev Total number of tokens in existence
    */
    function totalSupply() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="255" endline="261" pcid="5853">
    function decimals() public view returns(uint8) {
        return _decimals;
    }
    /**
    * @dev Total number of tokens in existence
    */
    function totalSupply() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="307" endline="319" pcid="5789">
    function decimals() public view returns (uint8) {
        return _decimals;
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="72" endline="75" pcid="2650">
  function decimals() public view returns(uint8) {
    return _decimals;
  }
}
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="492" endline="495" pcid="6752">
    function decimals() public view returns (uint256) {
        return _decimals;
    }
}
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="177" endline="181" pcid="2320">
    function decimals() public view returns(uint8) {
        return _decimals;
    }

}
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="502" endline="505" pcid="5437">
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="436" endline="443" pcid="5362">
    function decimals() public view returns (uint8) {
        return _decimals;
    }

    /**
     * @dev Returns the cap on VOKEN's total supply.
     */
    function cap() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="502" endline="505" pcid="6350">
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="264" endline="271" pcid="6995">
    function decimals() public view returns (uint256) {
        return _decimals;
    }

    /**
     * @return the cap for the token minting.
     */
    function cap() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="123" endline="126" pcid="5100">
    function decimals() public view returns(uint8) {
        return _Tokendecimals;
    }
}
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="627" endline="634" pcid="7093">
    function decimals() external view returns (uint8) {
        return _decimals;
    }

    /**
     * @return true if the contract is paused, false otherwise.
     */
    function paused() external view returns (bool) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="453" endline="456" pcid="7196">
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="76" endline="79" pcid="2399">
  function decimals() public view returns(uint8) {
    return _decimals;
  }
}
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="76" endline="79" pcid="1472">
  function decimals() public view returns(uint8) {
    return _decimals;
  }
}
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="72" endline="75" pcid="7323">
  function decimals() public view returns(uint8) {
    return _decimals;
  }
}
</source>
<source file="systems/smart_contracts/MatchingToken.sol" startline="33" endline="37" pcid="4684">
    function decimals() public view returns (uint256) {
        return _decimals;
    }
    
    function totalSupply() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="245" endline="248" pcid="4428">
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="328" endline="331" pcid="7661">
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="248" endline="256" pcid="4039">
    function decimals() public view returns (uint8) {
        return _decimals;
    }


    /**
     * @dev See `IERC20.totalSupply`.
     */
    function totalSupply() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="494" endline="497" pcid="7739">
    function decimals() public view returns (uint256) {
        return _decimals;
    }
}
</source>
<source file="systems/smart_contracts/Byte.sol" startline="72" endline="76" pcid="1577">
  function decimals() public view returns(uint8) {
    return _Decimals;
  }
	
  function symbol() public view returns(string memory) {
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="72" endline="75" pcid="3925">
  function decimals() public view returns(uint8) {
    return _decimals;
  }
}
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="627" endline="634" pcid="3838">
    function decimals() external view returns (uint8) {
        return _decimals;
    }

    /**
     * @return true if the contract is paused, false otherwise.
     */
    function paused() external view returns (bool) {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="276" endline="279" pcid="589">
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="482" endline="485" pcid="3584">
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}
</source>
<source file="systems/smart_contracts/WTA.sol" startline="103" endline="107" pcid="8054">
    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function burn(uint256 amount) public {
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="457" endline="460" pcid="8211">
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="93" endline="96" pcid="3174">
  function decimals() public view returns(uint8) {
    return _decimals;
  }
}
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="593" endline="596" pcid="8259">
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="379" endline="382" pcid="3039">
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}
</source>
<source file="systems/smart_contracts/ERC20Detailed.sol" startline="46" endline="55" pcid="3006">
  function decimals() public view returns(uint8) {
    return _decimals;
  }

  /**
   * @dev mint function, checks if the contract is allowed to mint
   * @param _to the receiver of the tokens when mint funtion is successful
   * @param _value the amount of tokens to mint
   */
  function mint(address _to, uint256 _value) public returns (bool)  {
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="362" endline="365" pcid="2758">
  function decimals() public view returns(uint8) {
    return _decimals;
  }
}
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="176" endline="180" pcid="2859">
    function decimals() public view returns (uint8){
        return operator.token_decimals();
    }
    
    function totalSupply() public view returns (uint256){
</source>
</class>

<class classid="65" nclones="9" nlines="4" similarity="100">
<source file="systems/smart_contracts/ABCToken.sol" startline="524" endline="528" pcid="329">
    function isPauser(address account) public view returns (bool) {
        return _pausers.has(account);
    }

    function addPauser(address account) public onlyPauser {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="176" endline="180" pcid="3246">
    function isPauser(address account) public view returns (bool) {
        return _pausers.has(account);
    }

    function addPauser(address account) public onlyPauser {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="563" endline="567" pcid="972">
    function isPauser(address account) public view returns (bool) {
        return _pausers.has(account);
    }

    function addPauser(address account) public onlyPauser {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="541" endline="545" pcid="4445">
    function isPauser(address account) public view returns (bool) {
        return _pausers.has(account);
    }

    function addPauser(address account) public onlyPauser {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="167" endline="171" pcid="3556">
    function isPauser(address account) public view returns (bool) {
        return _pausers.has(account);
    }

    function addPauser(address account) public onlyPauser {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="563" endline="567" pcid="6044">
    function isPauser(address account) public view returns (bool) {
        return _pausers.has(account);
    }

    function addPauser(address account) public onlyPauser {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="386" endline="390" pcid="1387">
    function isPauser(address account) public view returns (bool) {
        return _pausers.has(account);
    }

    function addPauser(address account) public onlyPauser {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="203" endline="207" pcid="6321">
    function isPauser(address account) public view returns (bool) {
        return _pausers.has(account);
    }

    function addPauser(address account) public onlyPauser {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="563" endline="567" pcid="2485">
    function isPauser(address account) public view returns (bool) {
        return _pausers.has(account);
    }

    function addPauser(address account) public onlyPauser {
</source>
</class>

<class classid="66" nclones="9" nlines="4" similarity="100">
<source file="systems/smart_contracts/ABCToken.sol" startline="528" endline="532" pcid="330">
    function addPauser(address account) public onlyPauser {
        _addPauser(account);
    }

    function renouncePauser() public {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="390" endline="394" pcid="1388">
    function addPauser(address account) public onlyPauser {
        _addPauser(account);
    }

    function renouncePauser() public {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="567" endline="571" pcid="973">
    function addPauser(address account) public onlyPauser {
        _addPauser(account);
    }

    function renouncePauser() public {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="545" endline="549" pcid="4446">
    function addPauser(address account) public onlyPauser {
        _addPauser(account);
    }

    function renouncePauser() public {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="180" endline="184" pcid="3247">
    function addPauser(address account) public onlyPauser {
        _addPauser(account);
    }

    function renouncePauser() public {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="567" endline="571" pcid="2486">
    function addPauser(address account) public onlyPauser {
        _addPauser(account);
    }

    function renouncePauser() public {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="567" endline="571" pcid="6045">
    function addPauser(address account) public onlyPauser {
        _addPauser(account);
    }

    function renouncePauser() public {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="171" endline="175" pcid="3557">
    function addPauser(address account) public onlyPauser {
        _addPauser(account);
    }

    function renouncePauser() public {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="207" endline="211" pcid="6322">
    function addPauser(address account) public onlyPauser {
        _addPauser(account);
    }

    function renouncePauser() public {
</source>
</class>

<class classid="67" nclones="9" nlines="4" similarity="100">
<source file="systems/smart_contracts/ABCToken.sol" startline="532" endline="536" pcid="331">
    function renouncePauser() public {
        _removePauser(msg.sender);
    }

    function _addPauser(address account) internal {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="394" endline="398" pcid="1389">
    function renouncePauser() public {
        _removePauser(msg.sender);
    }

    function _addPauser(address account) internal {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="211" endline="215" pcid="6323">
    function renouncePauser() public {
        _removePauser(msg.sender);
    }

    function _addPauser(address account) internal {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="571" endline="575" pcid="974">
    function renouncePauser() public {
        _removePauser(msg.sender);
    }

    function _addPauser(address account) internal {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="549" endline="553" pcid="4447">
    function renouncePauser() public {
        _removePauser(msg.sender);
    }

    function _addPauser(address account) internal {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="571" endline="575" pcid="6046">
    function renouncePauser() public {
        _removePauser(msg.sender);
    }

    function _addPauser(address account) internal {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="184" endline="188" pcid="3248">
    function renouncePauser() public {
        _removePauser(msg.sender);
    }

    function _addPauser(address account) internal {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="175" endline="179" pcid="3558">
    function renouncePauser() public {
        _removePauser(msg.sender);
    }

    function _addPauser(address account) internal {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="571" endline="575" pcid="2487">
    function renouncePauser() public {
        _removePauser(msg.sender);
    }

    function _addPauser(address account) internal {
</source>
</class>

<class classid="68" nclones="9" nlines="4" similarity="100">
<source file="systems/smart_contracts/ABCToken.sol" startline="536" endline="541" pcid="332">
    function _addPauser(address account) internal {
        _pausers.add(account);
        emit PauserAdded(account);
    }

    function _removePauser(address account) internal {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="575" endline="580" pcid="6047">
    function _addPauser(address account) internal {
        _pausers.add(account);
        emit PauserAdded(account);
    }

    function _removePauser(address account) internal {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="575" endline="580" pcid="2488">
    function _addPauser(address account) internal {
        _pausers.add(account);
        emit PauserAdded(account);
    }

    function _removePauser(address account) internal {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="398" endline="403" pcid="1390">
    function _addPauser(address account) internal {
        _pausers.add(account);
        emit PauserAdded(account);
    }

    function _removePauser(address account) internal {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="575" endline="580" pcid="975">
    function _addPauser(address account) internal {
        _pausers.add(account);
        emit PauserAdded(account);
    }

    function _removePauser(address account) internal {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="215" endline="220" pcid="6324">
    function _addPauser(address account) internal {
        _pausers.add(account);
        emit PauserAdded(account);
    }

    function _removePauser(address account) internal {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="188" endline="193" pcid="3249">
    function _addPauser(address account) internal {
        _pausers.add(account);
        emit PauserAdded(account);
    }

    function _removePauser(address account) internal {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="179" endline="184" pcid="3559">
    function _addPauser(address account) internal {
        _pausers.add(account);
        emit PauserAdded(account);
    }

    function _removePauser(address account) internal {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="553" endline="558" pcid="4448">
    function _addPauser(address account) internal {
        _pausers.add(account);
        emit PauserAdded(account);
    }

    function _removePauser(address account) internal {
</source>
</class>

<class classid="69" nclones="9" nlines="4" similarity="100">
<source file="systems/smart_contracts/ABCToken.sol" startline="541" endline="545" pcid="333">
    function _removePauser(address account) internal {
        _pausers.remove(account);
        emit PauserRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="184" endline="188" pcid="3560">
    function _removePauser(address account) internal {
        _pausers.remove(account);
        emit PauserRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="580" endline="584" pcid="6048">
    function _removePauser(address account) internal {
        _pausers.remove(account);
        emit PauserRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="193" endline="197" pcid="3250">
    function _removePauser(address account) internal {
        _pausers.remove(account);
        emit PauserRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="558" endline="562" pcid="4449">
    function _removePauser(address account) internal {
        _pausers.remove(account);
        emit PauserRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/SBC.sol" startline="220" endline="224" pcid="6325">
    function _removePauser(address account) internal {
        _pausers.remove(account);
        emit PauserRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="580" endline="584" pcid="976">
    function _removePauser(address account) internal {
        _pausers.remove(account);
        emit PauserRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="403" endline="407" pcid="1391">
    function _removePauser(address account) internal {
        _pausers.remove(account);
        emit PauserRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="580" endline="584" pcid="2489">
    function _removePauser(address account) internal {
        _pausers.remove(account);
        emit PauserRemoved(account);
    }
}
</source>
</class>

<class classid="70" nclones="15" nlines="4" similarity="75">
<source file="systems/smart_contracts/ABCToken.sol" startline="580" endline="587" pcid="334">
    function paused() public view returns (bool) {
        return _paused;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     */
    modifier whenNotPaused() {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="174" endline="181" pcid="6989">
    function paused() public view returns (bool) {
        return _paused;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     */
    modifier whenNotPaused() {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="245" endline="252" pcid="6326">
    function paused() public view returns (bool) {
        return _paused;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     */
    modifier whenNotPaused() {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="297" endline="304" pcid="5357">
    function paused() public view returns (bool) {
        return _paused;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     */
    modifier whenNotPaused() {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="602" endline="609" pcid="4450">
    function paused() public view returns (bool) {
        return _paused;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     */
    modifier whenNotPaused() {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="486" endline="493" pcid="7197">
    function paused() public view returns (bool) {
        return _paused;
    }

    /**
     *  Modifier to make a function callable only when the contract is not paused.
     */
    modifier whenNotPaused() {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="624" endline="631" pcid="6049">
    function paused() public view returns (bool) {
        return _paused;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     */
    modifier whenNotPaused() {
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="99" endline="106" pcid="7343">
    function paused() public view returns (bool) {
        return _paused;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     */
    modifier whenNotPaused() {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="428" endline="435" pcid="1392">
    function paused() public view returns (bool) {
        return _paused;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     */
    modifier whenNotPaused() {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="634" endline="641" pcid="7094">
    function paused() external view returns (bool) {
        return _paused;
    }

    /**
     * @dev called by the owner to pause, triggers stopped state
     */
    function pause() external onlyOwner whenNotPaused {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="624" endline="631" pcid="977">
    function paused() public view returns (bool) {
        return _paused;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     */
    modifier whenNotPaused() {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="624" endline="631" pcid="2490">
    function paused() public view returns (bool) {
        return _paused;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     */
    modifier whenNotPaused() {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="216" endline="223" pcid="3251">
    function paused() public view returns (bool) {
        return _paused;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     */
    modifier whenNotPaused() {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="207" endline="214" pcid="3561">
    function paused() public view returns (bool) {
        return _paused;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     */
    modifier whenNotPaused() {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="634" endline="641" pcid="3839">
    function paused() external view returns (bool) {
        return _paused;
    }

    /**
     * @dev called by the owner to pause, triggers stopped state
     */
    function pause() external onlyOwner whenNotPaused {
</source>
</class>

<class classid="71" nclones="21" nlines="4" similarity="75">
<source file="systems/smart_contracts/ABCToken.sol" startline="603" endline="611" pcid="335">
    function pause() public onlyPauser whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    /**
     * @dev Called by a pauser to unpause, returns to normal state.
     */
    function unpause() public onlyPauser whenPaused {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="641" endline="649" pcid="7095">
    function pause() external onlyOwner whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    /**
     * @dev called by the owner to unpause, returns to normal state
     */
    function unpause() external onlyOwner whenPaused {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="509" endline="517" pcid="7198">
    function pause() public onlyOwner whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    /**
     *  Called by a pauser to unpause, returns to normal state.
     */
    function unpause() public onlyOwner whenPaused {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="197" endline="205" pcid="6990">
    function pause() external onlyOwner whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    /**
     * @dev Called by a pauser to unpause, returns to normal state.
     */
    function unpause() external onlyOwner whenPaused {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="268" endline="276" pcid="6327">
    function pause() public onlyPauser whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    /**
     * @dev called by the owner to unpause, returns to normal state
     */
    function unpause() public onlyPauser whenPaused {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="625" endline="633" pcid="4451">
    function pause() public onlyPauser whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    /**
     * @dev Called by a pauser to unpause, returns to normal state.
     */
    function unpause() public onlyPauser whenPaused {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="641" endline="649" pcid="3840">
    function pause() external onlyOwner whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    /**
     * @dev called by the owner to unpause, returns to normal state
     */
    function unpause() external onlyOwner whenPaused {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="230" endline="238" pcid="3562">
    function pause() public onlyPauser whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    /**
     * @dev Called by a pauser to unpause, returns to normal state.
     */
    function unpause() public onlyPauser whenPaused {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="647" endline="655" pcid="978">
    function pause() public onlyPauser whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    /**
     * @dev Called by a pauser to unpause, returns to normal state.
     */
    function unpause() public onlyPauser whenPaused {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="239" endline="247" pcid="3252">
    function pause() public onlyPauser whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    /**
     * @dev called by the owner to unpause, returns to normal state
     */
    function unpause() public onlyPauser whenPaused {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="451" endline="459" pcid="1393">
    function pause() public onlyPauser whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    /**
     * @dev called by the owner to unpause, returns to normal state
     */
    function unpause() public onlyPauser whenPaused {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="647" endline="655" pcid="6050">
    function pause() public onlyPauser whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    /**
     * @dev Called by a pauser to unpause, returns to normal state.
     */
    function unpause() public onlyPauser whenPaused {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="647" endline="655" pcid="2491">
    function pause() public onlyPauser whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    /**
     * @dev Called by a pauser to unpause, returns to normal state.
     */
    function unpause() public onlyPauser whenPaused {
</source>
<source file="systems/smart_contracts/CDS.sol" startline="124" endline="132" pcid="1659">
  function pause() public onlyOwner whenNotPaused {
    paused = true;
    emit Pause();
  }

  /**
   * @dev called by the owner to unpause, returns to normal state
   */
  function unpause() public onlyOwner whenPaused {
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="122" endline="130" pcid="7344">
    function pause() public onlyOwner whenNotPaused {
        _paused = true;
        emit Pause();
    }

    /**
     * @dev called by the owner to unpause, returns to normal state
     */
    function unpause() onlyOwner whenPaused public {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="389" endline="394" pcid="4673">
  function pause() onlyOwner whenNotPaused public {
    paused = true;
    emit Pause();
  }

  function unpause() onlyOwner whenPaused public {
</source>
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="87" endline="92" pcid="1626">
  function pause() onlyOwner whenNotPaused public {
    paused = true;
    emit Pause();
  }

  function unpause() onlyOwner whenPaused public {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="163" endline="171" pcid="6722">
  function pause() onlyOwner whenNotPaused public {
    paused = true;
    emit Pause();
  }

  /**
   * @dev called by the owner to unpause, returns to normal state
   */
  function unpause() onlyOwner whenPaused public {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="163" endline="171" pcid="2236">
  function pause() onlyOwner whenNotPaused public {
    paused = true;
    emit Pause();
  }

  /**
   * @dev called by the owner to unpause, returns to normal state
   */
  function unpause() onlyOwner whenPaused public {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="88" endline="93" pcid="4380">
  function pause() onlyOwner whenNotPaused public {
    paused = true;
    emit Pause();
  }

  function unpause() onlyOwner whenPaused public {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="163" endline="171" pcid="7709">
  function pause() onlyOwner whenNotPaused public {
    paused = true;
    emit Pause();
  }

  /**
   * @dev called by the owner to unpause, returns to normal state
   */
  function unpause() onlyOwner whenPaused public {
</source>
</class>

<class classid="72" nclones="21" nlines="4" similarity="75">
<source file="systems/smart_contracts/ABCToken.sol" startline="611" endline="615" pcid="336">
    function unpause() public onlyPauser whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="247" endline="251" pcid="3253">
    function unpause() public onlyPauser whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="649" endline="658" pcid="7096">
    function unpause() external onlyOwner whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }

    /**
     * @dev check if the contract can be imported to change with this token.
     * @param _contract address of token to be imported
     */
    function isImportedContract(address _contract) external view returns (bool) {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="205" endline="209" pcid="6991">
    function unpause() external onlyOwner whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="238" endline="242" pcid="3563">
    function unpause() public onlyPauser whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}
</source>
<source file="systems/smart_contracts/SBC.sol" startline="276" endline="280" pcid="6328">
    function unpause() public onlyPauser whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="655" endline="659" pcid="6051">
    function unpause() public onlyPauser whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="649" endline="658" pcid="3841">
    function unpause() external onlyOwner whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }

    /**
     * @dev check if the contract can be imported to change with this token.
     * @param _contract address of token to be imported
     */
    function isImportedContract(address _contract) external view returns (bool) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="517" endline="521" pcid="7199">
    function unpause() public onlyOwner whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="459" endline="463" pcid="1394">
    function unpause() public onlyPauser whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="655" endline="659" pcid="979">
    function unpause() public onlyPauser whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="655" endline="659" pcid="2492">
    function unpause() public onlyPauser whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="633" endline="637" pcid="4452">
    function unpause() public onlyPauser whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}
</source>
<source file="systems/smart_contracts/CDS.sol" startline="132" endline="136" pcid="1660">
  function unpause() public onlyOwner whenPaused {
    paused = false;
    emit Unpause();
  }
}
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="171" endline="175" pcid="7710">
  function unpause() onlyOwner whenPaused public {
    paused = false;
    emit Unpause();
  }  
}
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="171" endline="175" pcid="2237">
  function unpause() onlyOwner whenPaused public {
    paused = false;
    emit Unpause();
  }  
}
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="93" endline="97" pcid="4381">
  function unpause() onlyOwner whenPaused public {
    paused = false;
    emit Unpause();
  }
}
</source>
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="92" endline="96" pcid="1627">
  function unpause() onlyOwner whenPaused public {
    paused = false;
    emit Unpause();
  }
}
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="171" endline="175" pcid="6723">
  function unpause() onlyOwner whenPaused public {
    paused = false;
    emit Unpause();
  }  
}
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="394" endline="398" pcid="4674">
  function unpause() onlyOwner whenPaused public {
    paused = false;
    emit Unpause();
  }
}
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="130" endline="134" pcid="7345">
    function unpause() onlyOwner whenPaused public {
        _paused = false;
        emit Unpause();
    }
}
</source>
</class>

<class classid="73" nclones="33" nlines="4" similarity="75">
<source file="systems/smart_contracts/ABCToken.sol" startline="627" endline="631" pcid="337">
    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {
        return super.transfer(to, value);
    }

    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="306" endline="317" pcid="7000">
    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {
        // Normal Transfer
        _transfer(msg.sender, to, value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     * @param spender The address which will spend the funds.
     * @param value The amount of tokens to be spent.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="528" endline="532" pcid="7200">
    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {
        return super.transfer(to, value);
    }

    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="650" endline="654" pcid="4453">
    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {
        return super.transfer(to, value);
    }

    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="441" endline="445" pcid="7732">
    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {
        return super.transfer(to, value);
    }

    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="502" endline="506" pcid="3586">
    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {
        return super.transfer(to, value);
    }

    function burn(uint256 value) public onlyAdmin {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="472" endline="476" pcid="1395">
    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {
        return super.transfer(to, value);
    }

    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="512" endline="516" pcid="6351">
    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {
        return super.transfer(to, value);
    }

    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="441" endline="445" pcid="6745">
    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {
        return super.transfer(to, value);
    }

    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="441" endline="445" pcid="2259">
    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {
        return super.transfer(to, value);
    }

    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="421" endline="435" pcid="600">
    function transfer(address to, uint256 value) public returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param spender The address which will spend the funds.
     * @param value The amount of tokens to be spent.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="340" endline="354" pcid="6338">
    function transfer(address to, uint256 value) public returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param spender The address which will spend the funds.
     * @param value The amount of tokens to be spent.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="317" endline="331" pcid="3573">
    function transfer(address to, uint256 value) public returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param spender The address which will spend the funds.
     * @param value The amount of tokens to be spent.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="165" endline="179" pcid="738">
    function transfer(address to, uint256 value) public returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    /**
    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
    * Beware that changing an allowance with this method brings the risk that someone may use both the old
    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    * @param spender The address which will spend the funds.
    * @param value The amount of tokens to be spent.
    */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Token.sol" startline="113" endline="127" pcid="7257">
    function transfer(address to, uint256 value) public returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param spender The address which will spend the funds.
     * @param value The amount of tokens to be spent.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="112" endline="126" pcid="3020">
    function transfer(address to, uint256 value) public returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param spender The address which will spend the funds.
     * @param value The amount of tokens to be spent.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="296" endline="310" pcid="5857">
    function transfer(address to, uint256 value) public returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param spender The address which will spend the funds.
     * @param value The amount of tokens to be spent.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="377" endline="391" pcid="5691">
    function transfer(address to, uint256 value) public returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param spender The address which will spend the funds.
     * @param value The amount of tokens to be spent.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/CNG.sol" startline="165" endline="179" pcid="1854">
  function transfer(address to, uint256 value) public returns (bool) {
    _transfer(msg.sender, to, value);
    return true;
  }

  /**
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
   * Beware that changing an allowance with this method brings the risk that someone may use both the old
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   * @param spender The address which will spend the funds.
   * @param value The amount of tokens to be spent.
   */
  function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="170" endline="184" pcid="4243">
  function transfer(address to, uint256 value) public returns (bool) {
    _transfer(msg.sender, to, value);
    return true;
  }

  /**
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
   * Beware that changing an allowance with this method brings the risk that someone may use both the old
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   * @param spender The address which will spend the funds.
   * @param value The amount of tokens to be spent.
   */
  function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="161" endline="175" pcid="7649">
    function transfer(address to, uint256 value) public returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param spender The address which will spend the funds.
     * @param value The amount of tokens to be spent.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="143" endline="157" pcid="4933">
    function transfer(address to, uint256 value) public returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param spender The address which will spend the funds.
     * @param value The amount of tokens to be spent.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ankara.sol" startline="96" endline="101" pcid="689">
    function transfer(address to, uint256 value) public returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/FogCoin.sol" startline="74" endline="86" pcid="3682">
    function transfer(address to, uint256 value) public returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     * It is suggested that one first change the allowance to 0 before updating to a new value, or use
     * the 'increaseAllowance' & 'decreaseAllowance' functions.
     * @param spender The address which will spend the funds.
     * @param value The amount of tokens to be spent.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/magesh.sol" startline="143" endline="157" pcid="4621">
    function transfer(address to, uint256 value) public returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param spender The address which will spend the funds.
     * @param value The amount of tokens to be spent.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="170" endline="184" pcid="2747">
  function transfer(address to, uint256 value) public returns (bool) {
    _transfer(msg.sender, to, value);
    return true;
  }

  /**
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
   * Beware that changing an allowance with this method brings the risk that someone may use both the old
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   * @param spender The address which will spend the funds.
   * @param value The amount of tokens to be spent.
   */
  function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="84" endline="89" pcid="2310">
    function transfer(address to, uint256 value) public returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/BFGToken.sol" startline="84" endline="96" pcid="1189">
  function transfer(address to, uint256 value) public returns (bool) {
    require(to != address(0));
    require(value <= _balances[msg.sender]);

    _balances[msg.sender] = _balances[msg.sender].sub(value);
    _balances[to] = _balances[to].add(value);
    emit Transfer(msg.sender, to, value);
    return true;
  }

  // internal functions

}
</source>
<source file="systems/smart_contracts/ProxyERC20.sol" startline="455" endline="475" pcid="5899">
    function transfer(address to, uint256 value) public returns (bool) {
        // Mutable state call requires the proxy to tell the target who the msg.sender is.
        target.setMessageSender(msg.sender);

        // Forward the ERC20 call to the target contract
        IERC20(target).transfer(to, value);

        // Event emitting will occur via Synthetix.Proxy._emit()
        return true;
    }

    /**
    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
    * Beware that changing an allowance with this method brings the risk that someone may use both the old
    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    * @param spender The address which will spend the funds.
    * @param value The amount of tokens to be spent.
    */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="255" endline="270" pcid="6733">
    function transfer(address to, uint256 value) public returns (bool) {
        require(!frozenAccount[msg.sender]);
        _transfer(msg.sender, to, value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param spender The address which will spend the funds.
     * @param value The amount of tokens to be spent.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="255" endline="270" pcid="2247">
    function transfer(address to, uint256 value) public returns (bool) {
        require(!frozenAccount[msg.sender]);
        _transfer(msg.sender, to, value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param spender The address which will spend the funds.
     * @param value The amount of tokens to be spent.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="255" endline="270" pcid="7720">
    function transfer(address to, uint256 value) public returns (bool) {
        require(!frozenAccount[msg.sender]);
        _transfer(msg.sender, to, value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param spender The address which will spend the funds.
     * @param value The amount of tokens to be spent.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/MBA.sol" startline="461" endline="468" pcid="4728">
	function transfer(address to, uint256 value) public returns (bool) {
	    _tryTransfered(msg.sender);
	    _tryTransfered(to);
	    
	    return super.transfer(to, value);
	}
	
	function transferFrom(address from, address to, uint256 value) public returns (bool) {
</source>
</class>

<class classid="74" nclones="10" nlines="4" similarity="75">
<source file="systems/smart_contracts/ABCToken.sol" startline="631" endline="635" pcid="338">
    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
        return super.transferFrom(from, to, value);
    }

    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="476" endline="480" pcid="1396">
    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
        return super.transferFrom(from, to, value);
    }

    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="532" endline="536" pcid="7201">
    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
        return super.transferFrom(from, to, value);
    }

    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="445" endline="449" pcid="7733">
    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
        return super.transferFrom(from, to, value);
    }

    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="654" endline="658" pcid="4454">
    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
        return super.transferFrom(from, to, value);
    }

    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="347" endline="360" pcid="7004">
    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
        require(_allowed[from][msg.sender] >= value);
        _transfer(from, to, value);
        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));
        return true;
    }

    /**
     * @dev Transfer token for a specified addresses.
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function _transfer(address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="445" endline="449" pcid="6746">
    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
        return super.transferFrom(from, to, value);
    }

    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="516" endline="520" pcid="6352">
    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
        return super.transferFrom(from, to, value);
    }
    
    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="445" endline="449" pcid="2260">
    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
        return super.transferFrom(from, to, value);
    }

    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="498" endline="502" pcid="3585">
    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
        return super.transferFrom(from, to, value);
    }

    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {
</source>
</class>

<class classid="75" nclones="9" nlines="4" similarity="75">
<source file="systems/smart_contracts/ABCToken.sol" startline="643" endline="646" pcid="341">
    function decreaseAllowance(address spender, uint256 subtractedValue) public whenNotPaused returns (bool) {
        return super.decreaseAllowance(spender, subtractedValue);
    }
}
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="457" endline="461" pcid="6749">
    function decreaseAllowance(address spender, uint256 subtractedValue) public whenNotPaused returns (bool) {
        return super.decreaseAllowance(spender, subtractedValue);
    }
    
}
</source>
<source file="systems/smart_contracts/SBC.sol" startline="676" endline="680" pcid="6370">
    function decreaseAllowance(address spender, uint subtractedValue) public onlyNotBlacklisted returns (bool success) {
        return super.decreaseAllowance(spender, subtractedValue);
    }

    function mint(address to, uint256 value) public onlyNotBlacklisted onlyMinter returns (bool) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="528" endline="531" pcid="6355">
    function decreaseAllowance(address spender, uint subtractedValue) public whenNotPaused returns (bool success) {
        return super.decreaseAllowance(spender, subtractedValue);
    }
}
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="457" endline="461" pcid="7736">
    function decreaseAllowance(address spender, uint256 subtractedValue) public whenNotPaused returns (bool) {
        return super.decreaseAllowance(spender, subtractedValue);
    }
    
}
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="488" endline="491" pcid="1399">
    function decreaseAllowance(address spender, uint subtractedValue) public whenNotPaused returns (bool success) {
        return super.decreaseAllowance(spender, subtractedValue);
    }
}
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="648" endline="660" pcid="5379">
    function decreaseAllowance(address spender, uint256 subtractedValue) public whenNotPaused returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, "VOKEN: decreased allowance below zero"));
        return true;
    }

    /**
     * @dev Moves VOKEN `amount` from `sender` to `recipient`.
     *
     * May reject non-whitelist transaction.
     *
     * Emits a {Transfer} event.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="457" endline="461" pcid="2263">
    function decreaseAllowance(address spender, uint256 subtractedValue) public whenNotPaused returns (bool) {
        return super.decreaseAllowance(spender, subtractedValue);
    }
    
}
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="666" endline="669" pcid="4457">
    function decreaseAllowance(address spender, uint subtractedValue) public whenNotPaused returns (bool) {
        return super.decreaseAllowance(spender, subtractedValue);
    }
}
</source>
</class>

<class classid="76" nclones="12" nlines="4" similarity="75">
<source file="systems/smart_contracts/ABCToken.sol" startline="665" endline="669" pcid="342">
    function isMinter(address account) public view returns (bool) {
        return _minters.has(account);
    }

    function addMinter(address account) public onlyMinter {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="163" endline="167" pcid="6316">
    function isMinter(address account) public view returns (bool) {
        return _minters.has(account);
    }

    function addMinter(address account) public onlyMinter {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="985" endline="994" pcid="5405">
    function isMinter(address account) public view returns (bool) {
        return _minters.has(account);
    }

    /**
     * @dev Give an `account` access to the Minter role.
     *
     * Can only be called by the current owner.
     */
    function addMinter(address account) public onlyOwner {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="561" endline="565" pcid="7205">
    function isMinter(address account) public view returns (bool) {
        return _minters.has(account);
    }

    function addMinter(address account) public onlyOwner {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="381" endline="385" pcid="4255">
  function isMinter(address account) public view returns (bool) {
    return minters.has(account);
  }

  function addMinter(address account) public onlyMinter {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="491" endline="495" pcid="8251">
    function isMinter(address account) public view returns (bool) {
        return _minters.has(account);
    }

    function addMinter(address account) public onlyMinter {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="64" endline="68" pcid="4980">
    function isMinter(address account) public view returns (bool) {
        return _minters.has(account);
    }

    function addMinter(address account) public onlyMinter {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="270" endline="274" pcid="3254">
    function isMinter(address account) public view returns (bool) {
        return _minters.has(account);
    }

    function addMinter(address account) public onlyMinter {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="394" endline="401" pcid="7007">
    function isMinter(address account) public view returns (bool) {
        return _minter[account];
    }

    /**
     * @dev Set a minter state
     */
    function setMinterState(address account, bool state) external onlyOwner {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="485" endline="489" pcid="1771">
    function isMinter(address account) public view returns (bool) {
        return _minters.has(account);
    }

    function addMinter(address account) public onlyMinter {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="493" endline="497" pcid="2610">
    function isMinter(address account) public view returns (bool) {
        return _minters.has(account);
    }

    function addMinter(address account) public onlyMinter {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="489" endline="493" pcid="2701">
    function isMinter(address account) public view returns (bool) {
        return _minters.has(account);
    }

    function addMinter(address account) public onlyMinter {
</source>
</class>

<class classid="77" nclones="21" nlines="4" similarity="75">
<source file="systems/smart_contracts/ABCToken.sol" startline="669" endline="673" pcid="343">
    function addMinter(address account) public onlyMinter {
        _addMinter(account);
    }

    function renounceMinter() public {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="565" endline="569" pcid="7206">
    function addMinter(address account) public onlyOwner {
        _addMinter(account);
    }

    function removeMinter(address account) public onlyOwner {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="497" endline="501" pcid="2611">
    function addMinter(address account) public onlyMinter {
        _addMinter(account);
    }

    function renounceMinter() public {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="385" endline="389" pcid="4256">
  function addMinter(address account) public onlyMinter {
    _addMinter(account);
  }

  function renounceMinter() public {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="167" endline="171" pcid="6317">
    function addMinter(address account) public onlyMinter {
        _addMinter(account);
    }

    function renounceMinter() public {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="68" endline="72" pcid="4981">
    function addMinter(address account) public onlyMinter {
        _addMinter(account);
    }

    function renounceMinter() public {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="489" endline="493" pcid="1772">
    function addMinter(address account) public onlyMinter {
        _addMinter(account);
    }

    function renounceMinter() public {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="274" endline="278" pcid="3255">
    function addMinter(address account) public onlyMinter {
        _addMinter(account);
    }

    function renounceMinter() public {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="493" endline="497" pcid="2702">
    function addMinter(address account) public onlyMinter {
        _addMinter(account);
    }

    function renounceMinter() public {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="495" endline="499" pcid="8252">
    function addMinter(address account) public onlyMinter {
        _addMinter(account);
    }

    function renounceMinter() public {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="994" endline="1004" pcid="5406">
    function addMinter(address account) public onlyOwner {
        _minters.add(account);
        emit MinterAdded(account);
    }

    /**
     * @dev Remove an `account` access from the Minter role.
     *
     * Can only be called by the current owner.
     */
    function removeMinter(address account) public onlyOwner {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="503" endline="508" pcid="8254">
    function _addMinter(address account) internal {
        _minters.add(account);
        emit MinterAdded(account);
    }

    function _removeMinter(address account) internal {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="175" endline="180" pcid="6319">
    function _addMinter(address account) internal {
        _minters.add(account);
        emit MinterAdded(account);
    }

    function _removeMinter(address account) internal {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="497" endline="502" pcid="1774">
    function _addMinter(address account) internal {
        _minters.add(account);
        emit MinterAdded(account);
    }

    function _removeMinter(address account) internal {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="76" endline="81" pcid="4983">
    function _addMinter(address account) internal {
        _minters.add(account);
        emit MinterAdded(account);
    }

    function _removeMinter(address account) internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="505" endline="510" pcid="2613">
    function _addMinter(address account) internal {
        _minters.add(account);
        emit MinterAdded(account);
    }

    function _removeMinter(address account) internal {
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="677" endline="682" pcid="345">
    function _addMinter(address account) internal {
        _minters.add(account);
        emit MinterAdded(account);
    }

    function _removeMinter(address account) internal {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="501" endline="506" pcid="2704">
    function _addMinter(address account) internal {
        _minters.add(account);
        emit MinterAdded(account);
    }

    function _removeMinter(address account) internal {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="282" endline="287" pcid="3257">
    function _addMinter(address account) internal {
        _minters.add(account);
        emit MinterAdded(account);
    }

    function _removeMinter(address account) internal {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="573" endline="578" pcid="7208">
    function _addMinter(address account) internal {
        _minters.add(account);
        emit MinterAdded(account);
    }

    function _removeMinter(address account) internal {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="393" endline="398" pcid="4258">
  function _addMinter(address account) internal {
    minters.add(account);
    emit MinterAdded(account);
  }

  function _removeMinter(address account) internal {
</source>
</class>

<class classid="78" nclones="9" nlines="4" similarity="100">
<source file="systems/smart_contracts/ABCToken.sol" startline="673" endline="677" pcid="344">
    function renounceMinter() public {
        _removeMinter(msg.sender);
    }

    function _addMinter(address account) internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="501" endline="505" pcid="2612">
    function renounceMinter() public {
        _removeMinter(msg.sender);
    }

    function _addMinter(address account) internal {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="171" endline="175" pcid="6318">
    function renounceMinter() public {
        _removeMinter(msg.sender);
    }

    function _addMinter(address account) internal {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="72" endline="76" pcid="4982">
    function renounceMinter() public {
        _removeMinter(msg.sender);
    }

    function _addMinter(address account) internal {
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="499" endline="503" pcid="8253">
    function renounceMinter() public {
        _removeMinter(msg.sender);
    }

    function _addMinter(address account) internal {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="389" endline="393" pcid="4257">
  function renounceMinter() public {
    _removeMinter(msg.sender);
  }

  function _addMinter(address account) internal {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="497" endline="501" pcid="2703">
    function renounceMinter() public {
        _removeMinter(msg.sender);
    }

    function _addMinter(address account) internal {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="493" endline="497" pcid="1773">
    function renounceMinter() public {
        _removeMinter(msg.sender);
    }

    function _addMinter(address account) internal {
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="278" endline="282" pcid="3256">
    function renounceMinter() public {
        _removeMinter(msg.sender);
    }

    function _addMinter(address account) internal {
</source>
</class>

<class classid="79" nclones="12" nlines="4" similarity="75">
<source file="systems/smart_contracts/ABCToken.sol" startline="682" endline="686" pcid="346">
    function _removeMinter(address account) internal {
        _minters.remove(account);
        emit MinterRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="81" endline="85" pcid="4984">
    function _removeMinter(address account) internal {
        _minters.remove(account);
        emit MinterRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="1004" endline="1008" pcid="5407">
    function removeMinter(address account) public onlyOwner {
        _minters.remove(account);
        emit MinterRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/SBC.sol" startline="180" endline="184" pcid="6320">
    function _removeMinter(address account) internal {
        _minters.remove(account);
        emit MinterRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="578" endline="582" pcid="7209">
    function _removeMinter(address account) internal {
        _minters.remove(account);
        emit MinterRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="502" endline="506" pcid="1775">
    function _removeMinter(address account) internal {
        _minters.remove(account);
        emit MinterRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="510" endline="514" pcid="2614">
    function _removeMinter(address account) internal {
        _minters.remove(account);
        emit MinterRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="506" endline="510" pcid="2705">
    function _removeMinter(address account) internal {
        _minters.remove(account);
        emit MinterRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="508" endline="512" pcid="8255">
    function _removeMinter(address account) internal {
        _minters.remove(account);
        emit MinterRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="287" endline="291" pcid="3258">
    function _removeMinter(address account) internal {
        _minters.remove(account);
        emit MinterRemoved(account);
    }
}
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="398" endline="402" pcid="4259">
  function _removeMinter(address account) internal {
    minters.remove(account);
    emit MinterRemoved(account);
  }
}
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="569" endline="573" pcid="7207">
    function removeMinter(address account) public onlyOwner {
        _removeMinter(account);
    }

    function _addMinter(address account) internal {
</source>
</class>

<class classid="80" nclones="7" nlines="4" similarity="75">
<source file="systems/smart_contracts/ABCToken.sol" startline="703" endline="707" pcid="347">
    function mint(address account, uint256 amount) public onlyMinter returns (bool) {
        _mint(account, amount);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="513" endline="517" pcid="2706">
    function mint(address account, uint256 amount) public onlyMinter returns (bool) {
        _mint(account, amount);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="535" endline="539" pcid="8256">
    function mint(address account, uint256 amount) public onlyMinter returns (bool) {
        _mint(account, amount);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="517" endline="521" pcid="2615">
    function mint(address account, uint256 amount) public onlyMinter returns (bool) {
        _mint(account, amount);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="528" endline="532" pcid="1776">
    function mint(address account, uint256 amount) public onlyMinter returns (bool) {
        _mint(account, amount);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="595" endline="607" pcid="5374">
    function mint(address account, uint256 amount) public whenNotPaused onlyMinter returns (bool) {
        _mint(account, amount);
        return true;
    }

    /**
     * @dev Creates `amount` VOKEN and assigns them to `account`.
     *
     * With an `allocationContract`
     *
     * Can only be called by a minter.
     */
    function mintWithAllocation(address account, uint256 amount, IAllocation allocationContract) public whenNotPaused onlyMinter returns (bool) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="597" endline="601" pcid="7210">
    function mint(address account, uint256 amount) public onlyMinter returns (bool) {
        _mint(account, amount);
        return true;
    }
}
</source>
</class>

<class classid="81" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/AdminUpgradeabilityProxy.sol" startline="62" endline="69" pcid="351">
    function _willFallback() internal {
    }

    /**
     * @dev fallback implementation.
     * Extracted to enable manual triggering.
     */
    function _fallback() internal {
</source>
<source file="systems/smart_contracts/AdminUpgradeabilityProxy.sol" startline="288" endline="292" pcid="364">
    function _willFallback() internal {
        require(msg.sender != _admin(), "Cannot call fallback function from the proxy admin");
        super._willFallback();
    }
}
</source>
</class>

<class classid="82" nclones="5" nlines="4" similarity="75">
<source file="systems/smart_contracts/AdminUpgradeabilityProxy.sol" startline="87" endline="100" pcid="353">
    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        // XXX Currently there is no better way to check if there is a contract in an address
        // than to check the size of the code at that address.
        // See https://ethereum.stackexchange.com/a/14016/36603
        // for more details about how this works.
        // TODO Check this again before the Serenity release, because all addresses will be
        // contracts then.
        // solium-disable-next-line security/no-inline-assembly
        assembly { size := extcodesize(addr) }
        return size > 0;
    }

}
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="213" endline="225" pcid="3077">
  function isContract(address addr) internal view returns (bool) {
    uint256 size;
    // XXX Currently there is no better way to check if there is a contract in an address
    // than to check the size of the code at that address.
    // See https://ethereum.stackexchange.com/a/14016/36603
    // for more details about how this works.
    // TODO Check this again before the Serenity release, because all addresses will be
    // contracts then.
    assembly { size := extcodesize(addr) }  // solium-disable-line security/no-inline-assembly
    return size > 0;
  }

}
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="276" endline="282" pcid="4404">
    function isContract(address addr) internal view returns (bool) {
        uint size;
        assembly{size := extcodesize(addr)}
        return size > 0;
    }

    function autoUnlock(address _holder) internal returns (bool) {
</source>
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="275" endline="281" pcid="1650">
    function isContract(address addr) internal view returns (bool) {
        uint size;
        assembly{size := extcodesize(addr)}
        return size > 0;
    }

    function autoUnlock(address _holder) internal returns (bool) {
</source>
<source file="systems/smart_contracts/PositionTokenV2.sol" startline="400" endline="410" pcid="5768">
    function _isContract(
        address addr)
        internal
        view
        returns (bool)
    {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}
</source>
</class>

<class classid="83" nclones="3" nlines="4" similarity="75">
<source file="systems/smart_contracts/AdminUpgradeabilityProxy.sol" startline="217" endline="224" pcid="357">
    function admin() external view ifAdmin returns (address) {
        return _admin();
    }

    /**
     * @return The address of the implementation.
     */
    function implementation() external view ifAdmin returns (address) {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="180" endline="184" pcid="5674">
  function admin() external view returns (address) {
    return _admin();
  }

  function implementation() external view returns (address impl) {
</source>
<source file="systems/smart_contracts/Bridge.sol" startline="173" endline="177" pcid="1509">
  function admin() external view returns (address) {
    return _admin();
  }

  function implementation() external view returns (address impl) {
</source>
</class>

<class classid="84" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/AdminUpgradeabilityProxy.sol" startline="266" endline="277" pcid="362">
    function _admin() internal view returns (address adm) {
        bytes32 slot = ADMIN_SLOT;
        assembly {
            adm := sload(slot)
        }
    }

    /**
     * @dev Sets the address of the proxy admin.
     * @param newAdmin Address of the new proxy admin.
     */
    function _setAdmin(address newAdmin) internal {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="194" endline="200" pcid="5676">
  function _admin() internal view returns (address adm) {
    bytes32 slot = ADMIN_SLOT;
    assembly {
      adm := sload(slot)
    }
  }
}
</source>
<source file="systems/smart_contracts/Bridge.sol" startline="187" endline="193" pcid="1511">
  function _admin() internal view returns (address adm) {
    bytes32 slot = ADMIN_SLOT;
    assembly {
      adm := sload(slot)
    }
  }
}
</source>
</class>

<class classid="85" nclones="26" nlines="4" similarity="100">
<source file="systems/smart_contracts/Aigopay.sol" startline="58" endline="63" pcid="443">
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/CoinDDC.sol" startline="207" endline="214" pcid="1876">
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) 
    {
        c = a + b;
        assert(c >= a);
        return c;
    }

}
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="51" endline="56" pcid="6677">
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/TorexToken.sol" startline="52" endline="57" pcid="7406">
  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
    c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="472" endline="477" pcid="6618">
	function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
		c = a + b;
		assert(c >= a);
		return c;
	}
}
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="46" endline="51" pcid="6545">
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="49" endline="54" pcid="6479">
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="53" endline="58" pcid="1431">
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/LuckyStrikeTokens.sol" startline="53" endline="58" pcid="4571">
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/LBBT.sol" startline="28" endline="33" pcid="4535">
  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
    c = a + b;
    assert(c >= a);
    return c;
  }
} 
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="177" endline="182" pcid="7349">
  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
    c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="57" endline="62" pcid="4296">
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="23" endline="28" pcid="8009">
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="42" endline="47" pcid="3515">
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="23" endline="28" pcid="2875">
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/XGP.sol" startline="58" endline="63" pcid="8100">
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/customIcoToken.sol" startline="28" endline="33" pcid="2211">
  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
    c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="192" endline="197" pcid="3076">
  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
    c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/DNP.sol" startline="58" endline="64" pcid="2787">
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) 
    {
        c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="46" endline="51" pcid="2948">
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="45" endline="50" pcid="1268">
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="85" endline="90" pcid="2049">
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="19" endline="28" pcid="6971">
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }

    /**
     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MBA.sol" startline="48" endline="53" pcid="4701">
  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
    c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="35" endline="40" pcid="4644">
  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
    c = a + b;
    assert(c >= a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="45" endline="50" pcid="4953">
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
}
</source>
</class>

<class classid="86" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/Aigopay.sol" startline="126" endline="132" pcid="451">
    function Aigopay () public {
        owner = msg.sender;
        uint256 devTokens = 1000000e18;
        distr(owner, devTokens);
    }
    
    function transferOwnership(address newOwner) onlyOwner public {
</source>
<source file="systems/smart_contracts/XGP.sol" startline="126" endline="132" pcid="8108">
    function XGP () public {
        owner = msg.sender;
        uint256 devTokens = 1000000e18;
        distr(owner, devTokens);
    }
    
    function transferOwnership(address newOwner) onlyOwner public {
</source>
</class>

<class classid="87" nclones="18" nlines="7" similarity="85">
<source file="systems/smart_contracts/Aigopay.sol" startline="132" endline="139" pcid="452">
    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }
    

    function finishDistribution() onlyOwner canDistr public returns (bool) {
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="131" endline="137" pcid="6685">
    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

    function startICO() onlyOwner public returns (bool) {
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="114" endline="121" pcid="4961">
    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }
    

    function finishDistribution() onlyOwner canDistr public returns (bool) {
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="143" endline="149" pcid="4304">
    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

    function finishDistribution() onlyOwner canDistr public returns (bool) {
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="139" endline="145" pcid="1439">
    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

    function finishDistribution() onlyOwner canDistr public returns (bool) {
</source>
<source file="systems/smart_contracts/NSTTeamLock.sol" startline="32" endline="37" pcid="5457">
    function transferOwnership(address newOwner) onlyOwner public{
        if (newOwner != address(0)) {
         owner = newOwner;
        }
    }
    using SafeMath for uint256;
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="132" endline="138" pcid="6553">
    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

    function finishDistribution() onlyOwner canDistr public returns (bool) {
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="118" endline="125" pcid="1277">
    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }
    

    function finishDistribution() onlyOwner canDistr public returns (bool) {
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="136" endline="142" pcid="6487">
    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

    function finishDistribution() onlyOwner canDistr public returns (bool) {
</source>
<source file="systems/smart_contracts/SCMCoin.sol" startline="64" endline="70" pcid="6385">
    function transferOwnership(address newOwner) public onlyOwner {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

    function balanceOf(address _owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/XGP.sol" startline="132" endline="139" pcid="8109">
    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }
    

    function finishDistribution() onlyOwner canDistr public returns (bool) {
</source>
<source file="systems/smart_contracts/RETC.sol" startline="94" endline="100" pcid="6185">
    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0) && newOwner != owner) {          
             owner = newOwner;   
        }
    }

    function locked(address _from, address _to, uint256 _amount) private {
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="94" endline="100" pcid="8018">
    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

    function finishDistribution() onlyOwner canDistr public returns (bool) {
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="132" endline="138" pcid="2956">
    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

    function finishDistribution() onlyOwner canDistr public returns (bool) {
</source>
<source file="systems/smart_contracts/UGCoin.sol" startline="72" endline="78" pcid="7533">
    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

    function balanceOf(address _owner) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="94" endline="100" pcid="2884">
    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

    function finishDistribution() onlyOwner canDistr public returns (bool) {
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="128" endline="134" pcid="3523">
    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

    function finishDistribution() onlyOwner canDistr public returns (bool) {
</source>
<source file="systems/smart_contracts/OMGToken.sol" startline="224" endline="230" pcid="5499">
  function transferOwnership(address newOwner) onlyOwner {
    if (newOwner != address(0)) {
      owner = newOwner;
    }
  }

}
</source>
</class>

<class classid="88" nclones="13" nlines="4" similarity="75">
<source file="systems/smart_contracts/Aigopay.sol" startline="139" endline="145" pcid="453">
    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        emit DistrFinished();
        return true;
    }
    
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="100" endline="106" pcid="2885">
    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        emit DistrFinished();
        return true;
    }
    
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="134" endline="140" pcid="3524">
    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        emit DistrFinished();
        return true;
    }
    
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="125" endline="133" pcid="1278">
    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        emit DistrFinished();
        return true;
        distributionFinished = false;
        emit DistrFinished();
        return false;
    }
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="100" endline="106" pcid="8019">
    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        emit DistrFinished();
        return true;
    }
    
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="142" endline="148" pcid="6488">
    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        emit DistrFinished();
        return true;
    }
    
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
</source>
<source file="systems/smart_contracts/XGP.sol" startline="139" endline="145" pcid="8110">
    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        emit DistrFinished();
        return true;
    }
    
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="138" endline="144" pcid="2957">
    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        emit DistrFinished();
        return true;
    }
    
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="145" endline="151" pcid="1440">
    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        emit DistrFinished();
        return true;
    }
    
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="138" endline="144" pcid="6554">
    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        emit DistrFinished();
        return true;
    }
    
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="156" endline="162" pcid="6689">
    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        emit DistrFinished();
        return true;
    }
    
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="121" endline="127" pcid="4962">
    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        emit DistrFinished();
        return true;
    }
    
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="149" endline="155" pcid="4305">
    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        emit DistrFinished();
        return true;
    }
    
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
</source>
</class>

<class classid="89" nclones="13" nlines="4" similarity="75">
<source file="systems/smart_contracts/Aigopay.sol" startline="145" endline="154" pcid="454">
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);        
        balances[_to] = balances[_to].add(_amount);
        emit Distr(_to, _amount);
        emit Transfer(address(0), _to, _amount);

        return true;
    }

    function doAirdrop(address _participant, uint _amount) internal {
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="148" endline="157" pcid="6489">
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);        
        balances[_to] = balances[_to].add(_amount);
        emit Distr(_to, _amount);
        emit Transfer(address(0), _to, _amount);

        return true;
    }
    
    function Distribute(address _participant, uint _amount) onlyOwner internal {
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="144" endline="153" pcid="6555">
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);        
        balances[_to] = balances[_to].add(_amount);
        emit Distr(_to, _amount);
        emit Transfer(address(0), _to, _amount);

        return true;
    }
    
    function Distribute(address _participant, uint _amount) onlyOwner internal {
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="162" endline="171" pcid="6690">
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);        
        balances[_to] = balances[_to].add(_amount);
        emit Distr(_to, _amount);
        emit Transfer(address(0), _to, _amount);

        return true;
    }

    function doAirdrop(address _participant, uint _amount) internal {
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="127" endline="136" pcid="4963">
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);        
        balances[_to] = balances[_to].add(_amount);
        emit Distr(_to, _amount);
        emit Transfer(address(0), _to, _amount);

        return true;
    }

    function doAirdrop(address _participant, uint _amount) internal {
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="155" endline="164" pcid="4306">
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);        
        balances[_to] = balances[_to].add(_amount);
        emit Distr(_to, _amount);
        emit Transfer(address(0), _to, _amount);

        return true;
    }
    
    function Distribute(address _participant, uint _amount) onlyOwner internal {
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="106" endline="116" pcid="2886">
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);   
		totalRemaining = totalRemaining.sub(_amount);		
        balances[_to] = balances[_to].add(_amount);
        emit Distr(_to, _amount);
        emit Transfer(address(0), _to, _amount);

        return true;
    }
           
    function () external payable {
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="140" endline="149" pcid="3525">
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);        
        balances[_to] = balances[_to].add(_amount);
        emit Distr(_to, _amount);
        emit Transfer(address(0), _to, _amount);

        return true;
    }
    
    function Distribute(address _participant, uint _amount) onlyOwner internal {
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="151" endline="160" pcid="1441">
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);        
        balances[_to] = balances[_to].add(_amount);
        emit Distr(_to, _amount);
        emit Transfer(address(0), _to, _amount);

        return true;
    }
    
    function Distribute(address _participant, uint _amount) onlyOwner internal {
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="133" endline="142" pcid="1279">
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);        
        balances[_to] = balances[_to].add(_amount);
        emit Distr(_to, _amount);
        emit Transfer(address(0), _to, _amount);

        return true;
    }

    function doAirdrop(address _participant, uint _amount) internal {
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="106" endline="116" pcid="8020">
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);   
		totalRemaining = totalRemaining.sub(_amount);		
        balances[_to] = balances[_to].add(_amount);
        emit Distr(_to, _amount);
        emit Transfer(address(0), _to, _amount);

        return true;
    }
           
    function () external payable {
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="144" endline="153" pcid="2958">
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);        
        balances[_to] = balances[_to].add(_amount);
        emit Distr(_to, _amount);
        emit Transfer(address(0), _to, _amount);

        return true;
    }
    
    function Distribute(address _participant, uint _amount) onlyOwner internal {
</source>
<source file="systems/smart_contracts/XGP.sol" startline="145" endline="154" pcid="8111">
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);        
        balances[_to] = balances[_to].add(_amount);
        emit Distr(_to, _amount);
        emit Transfer(address(0), _to, _amount);

        return true;
    }

    function doAirdrop(address _participant, uint _amount) internal {
</source>
</class>

<class classid="90" nclones="11" nlines="8" similarity="87">
<source file="systems/smart_contracts/Aigopay.sol" startline="154" endline="172" pcid="455">
    function doAirdrop(address _participant, uint _amount) internal {

        require( _amount > 0 );      

        require( totalDistributed < totalSupply );
        
        balances[_participant] = balances[_participant].add(_amount);
        totalDistributed = totalDistributed.add(_amount);

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }

        // log
        emit Airdrop(_participant, _amount, balances[_participant]);
        emit Transfer(address(0), _participant, _amount);
    }

    function adminClaimAirdrop(address _participant, uint _amount) public onlyOwner {        
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="149" endline="165" pcid="3526">
    function Distribute(address _participant, uint _amount) onlyOwner internal {

        require( _amount > 0 );      
        require( totalDistributed < totalSupply );
        balances[_participant] = balances[_participant].add(_amount);
        totalDistributed = totalDistributed.add(_amount);

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }

        // log
        emit Airdrop(_participant, _amount, balances[_participant]);
        emit Transfer(address(0), _participant, _amount);
    }
    
    function DistributeAirdrop(address _participant, uint _amount) onlyOwner external {        
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="164" endline="180" pcid="4307">
    function Distribute(address _participant, uint _amount) onlyOwner internal {

        require( _amount > 0 );      
        require( totalDistributed < totalSupply );
        balances[_participant] = balances[_participant].add(_amount);
        totalDistributed = totalDistributed.add(_amount);

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }

        // log
        emit Airdrop(_participant, _amount, balances[_participant]);
        emit Transfer(address(0), _participant, _amount);
    }
    
    function DistributeAirdrop(address _participant, uint _amount) onlyOwner external {        
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="160" endline="176" pcid="1442">
    function Distribute(address _participant, uint _amount) onlyOwner internal {

        require( _amount > 0 );      
        require( totalDistributed < totalSupply );
        balances[_participant] = balances[_participant].add(_amount);
        totalDistributed = totalDistributed.add(_amount);

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }

        // log
        emit Airdrop(_participant, _amount, balances[_participant]);
        emit Transfer(address(0), _participant, _amount);
    }
    
    function DistributeAirdrop(address _participant, uint _amount) onlyOwner external {        
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="153" endline="169" pcid="6556">
    function Distribute(address _participant, uint _amount) onlyOwner internal {

        require( _amount > 0 );      
        require( totalDistributed < totalSupply );
        balances[_participant] = balances[_participant].add(_amount);
        totalDistributed = totalDistributed.add(_amount);

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }

        // log
        emit Airdrop(_participant, _amount, balances[_participant]);
        emit Transfer(address(0), _participant, _amount);
    }
    
    function DistributeAirdrop(address _participant, uint _amount) onlyOwner external {        
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="153" endline="169" pcid="2959">
    function Distribute(address _participant, uint _amount) onlyOwner internal {

        require( _amount > 0 );      
        require( totalDistributed < totalSupply );
        balances[_participant] = balances[_participant].add(_amount);
        totalDistributed = totalDistributed.add(_amount);

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }

        // log
        emit Airdrop(_participant, _amount, balances[_participant]);
        emit Transfer(address(0), _participant, _amount);
    }
    
    function DistributeAirdrop(address _participant, uint _amount) onlyOwner external {        
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="171" endline="189" pcid="6691">
    function doAirdrop(address _participant, uint _amount) internal {

        require( _amount > 0 );      

        require( totalDistributed < totalSupply );
        
        balances[_participant] = balances[_participant].add(_amount);
        totalDistributed = totalDistributed.add(_amount);

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }

        // log
        emit Airdrop(_participant, _amount, balances[_participant]);
        emit Transfer(address(0), _participant, _amount);
    }

    function transferTokenTo(address _participant, uint _amount) public onlyOwner {        
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="142" endline="160" pcid="1280">
    function doAirdrop(address _participant, uint _amount) internal {

        require( _amount > 0 );      

        require( totalDistributed < totalSupply );
        
        balances[_participant] = balances[_participant].add(_amount);
        totalDistributed = totalDistributed.add(_amount);

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }

        // log
        emit Airdrop(_participant, _amount, balances[_participant]);
        emit Transfer(address(0), _participant, _amount);
    }

    function adminClaimAirdrop(address _participant, uint _amount) public onlyOwner {        
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="157" endline="173" pcid="6490">
    function Distribute(address _participant, uint _amount) onlyOwner internal {

        require( _amount > 0 );      
        require( totalDistributed < totalSupply );
        balances[_participant] = balances[_participant].add(_amount);
        totalDistributed = totalDistributed.add(_amount);

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }

        // log
        emit Airdrop(_participant, _amount, balances[_participant]);
        emit Transfer(address(0), _participant, _amount);
    }
    
    function DistributeAirdrop(address _participant, uint _amount) onlyOwner external {        
</source>
<source file="systems/smart_contracts/XGP.sol" startline="154" endline="172" pcid="8112">
    function doAirdrop(address _participant, uint _amount) internal {

        require( _amount > 0 );      

        require( totalDistributed < totalSupply );
        
        balances[_participant] = balances[_participant].add(_amount);
        totalDistributed = totalDistributed.add(_amount);

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }

        // log
        emit Airdrop(_participant, _amount, balances[_participant]);
        emit Transfer(address(0), _participant, _amount);
    }

    function adminClaimAirdrop(address _participant, uint _amount) public onlyOwner {        
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="136" endline="154" pcid="4964">
    function doAirdrop(address _participant, uint _amount) internal {

        require( _amount > 0 );      

        require( totalDistributed < totalSupply );
        
        balances[_participant] = balances[_participant].add(_amount);
        totalDistributed = totalDistributed.add(_amount);

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }

        // log
        emit Airdrop(_participant, _amount, balances[_participant]);
        emit Transfer(address(0), _participant, _amount);
    }

    function adminClaimAirdrop(address _participant, uint _amount) public onlyOwner {        
</source>
</class>

<class classid="91" nclones="5" nlines="4" similarity="75">
<source file="systems/smart_contracts/Aigopay.sol" startline="172" endline="176" pcid="456">
    function adminClaimAirdrop(address _participant, uint _amount) public onlyOwner {        
        doAirdrop(_participant, _amount);
    }

    function adminClaimAirdropMultiple(address[] _addresses, uint _amount) public onlyOwner {        
</source>
<source file="systems/smart_contracts/XGP.sol" startline="172" endline="176" pcid="8113">
    function adminClaimAirdrop(address _participant, uint _amount) public onlyOwner {        
        doAirdrop(_participant, _amount);
    }

    function adminClaimAirdropMultiple(address[] _addresses, uint _amount) public onlyOwner {        
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="189" endline="193" pcid="6692">
    function transferTokenTo(address _participant, uint _amount) public onlyOwner {        
        doAirdrop(_participant, _amount);
    }

    function transferTokenToMultiple(address[] _addresses, uint _amount) public onlyOwner {        
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="154" endline="158" pcid="4965">
    function adminClaimAirdrop(address _participant, uint _amount) public onlyOwner {        
        doAirdrop(_participant, _amount);
    }

    function adminClaimAirdropMultiple(address[] _addresses, uint _amount) public onlyOwner {        
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="160" endline="164" pcid="1281">
    function adminClaimAirdrop(address _participant, uint _amount) public onlyOwner {        
        doAirdrop(_participant, _amount);
    }

    function adminClaimAirdropMultiple(address[] _addresses, uint _amount) public onlyOwner {        
</source>
</class>

<class classid="92" nclones="5" nlines="4" similarity="75">
<source file="systems/smart_contracts/Aigopay.sol" startline="176" endline="180" pcid="457">
    function adminClaimAirdropMultiple(address[] _addresses, uint _amount) public onlyOwner {        
        for (uint i = 0; i < _addresses.length; i++) doAirdrop(_addresses[i], _amount);
    }

    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="158" endline="162" pcid="4966">
    function adminClaimAirdropMultiple(address[] _addresses, uint _amount) public onlyOwner {        
        for (uint i = 0; i < _addresses.length; i++) doAirdrop(_addresses[i], _amount);
    }

    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="193" endline="197" pcid="6693">
    function transferTokenToMultiple(address[] _addresses, uint _amount) public onlyOwner {        
        for (uint i = 0; i < _addresses.length; i++) doAirdrop(_addresses[i], _amount);
    }

    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
</source>
<source file="systems/smart_contracts/XGP.sol" startline="176" endline="180" pcid="8114">
    function adminClaimAirdropMultiple(address[] _addresses, uint _amount) public onlyOwner {        
        for (uint i = 0; i < _addresses.length; i++) doAirdrop(_addresses[i], _amount);
    }

    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="164" endline="168" pcid="1282">
    function adminClaimAirdropMultiple(address[] _addresses, uint _amount) public onlyOwner {        
        for (uint i = 0; i < _addresses.length; i++) doAirdrop(_addresses[i], _amount);
    }

    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
</source>
</class>

<class classid="93" nclones="11" nlines="4" similarity="100">
<source file="systems/smart_contracts/Aigopay.sol" startline="180" endline="185" pcid="458">
    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
        tokensPerEth = _tokensPerEth;
        emit TokensPerEthUpdated(_tokensPerEth);
    }
           
    function () external payable {
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="181" endline="186" pcid="6493">
    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
        tokensPerEth = _tokensPerEth;
        emit TokensPerEthUpdated(_tokensPerEth);
    }
           
    function () external payable {
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="184" endline="189" pcid="1445">
    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
        tokensPerEth = _tokensPerEth;
        emit TokensPerEthUpdated(_tokensPerEth);
    }
           
    function () external payable {
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="177" endline="182" pcid="2962">
    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
        tokensPerEth = _tokensPerEth;
        emit TokensPerEthUpdated(_tokensPerEth);
    }
           
    function () external payable {
</source>
<source file="systems/smart_contracts/XGP.sol" startline="180" endline="185" pcid="8115">
    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
        tokensPerEth = _tokensPerEth;
        emit TokensPerEthUpdated(_tokensPerEth);
    }
           
    function () external payable {
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="197" endline="202" pcid="6694">
    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
        tokensPerEth = _tokensPerEth;
        emit TokensPerEthUpdated(_tokensPerEth);
    }
           
    function () external payable {
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="173" endline="178" pcid="3529">
    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
        tokensPerEth = _tokensPerEth;
        emit TokensPerEthUpdated(_tokensPerEth);
    }
           
    function () external payable {
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="162" endline="167" pcid="4967">
    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
        tokensPerEth = _tokensPerEth;
        emit TokensPerEthUpdated(_tokensPerEth);
    }
           
    function () external payable {
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="188" endline="193" pcid="4310">
    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
        tokensPerEth = _tokensPerEth;
        emit TokensPerEthUpdated(_tokensPerEth);
    }
           
    function () external payable {
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="177" endline="182" pcid="6559">
    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
        tokensPerEth = _tokensPerEth;
        emit TokensPerEthUpdated(_tokensPerEth);
    }
           
    function () external payable {
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="168" endline="173" pcid="1283">
    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
        tokensPerEth = _tokensPerEth;
        emit TokensPerEthUpdated(_tokensPerEth);
    }
           
    function () external payable {
</source>
</class>

<class classid="94" nclones="5" nlines="11" similarity="90">
<source file="systems/smart_contracts/Aigopay.sol" startline="189" endline="208" pcid="460">
    function getTokens() payable canDistr  public {
        uint256 tokens = 0;

        require( msg.value >= minContribution );

        require( msg.value > 0 );
        
        tokens = tokensPerEth.mul(msg.value) / 1 ether;        
        address investor = msg.sender;
        
        if (tokens > 0) {
            distr(investor, tokens);
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }

    function balanceOf(address _owner) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/XGP.sol" startline="189" endline="208" pcid="8117">
    function getTokens() payable canDistr  public {
        uint256 tokens = 0;

        require( msg.value >= minContribution );

        require( msg.value > 0 );
        
        tokens = tokensPerEth.mul(msg.value) / 1 ether;        
        address investor = msg.sender;
        
        if (tokens > 0) {
            distr(investor, tokens);
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }

    function balanceOf(address _owner) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="171" endline="191" pcid="4969">
    function getTokens() payable canDistr  public {
        uint256 tokens = 0;

        require( msg.value >= minContribution );

        require( msg.value > 0 );
        
        tokens = tokensPerEth.mul(msg.value) / 1 ether;        
        address investor = msg.sender;
        
        if (tokens > 0) {
      owner.transfer(msg.value);
            distr(investor, tokens);
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }

    function balanceOf(address _owner) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="206" endline="227" pcid="6696">
    function getTokens() payable canDistr  public {
        uint256 tokens = 0;

        // minimum contribution
        require( msg.value >= minInvest );

        require( msg.value > 0 );
        
        // get baseline number of tokens
        tokens = tokensPerEth.mul(msg.value) / 1 ether;        
        address investor = msg.sender;
        
        if (tokens > 0) {
            distr(investor, tokens);
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }

    function balanceOf(address _owner) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="177" endline="196" pcid="1285">
    function getTokens() payable canDistr  public {
        uint256 tokens = 0;

        require( msg.value >= minContribution );

        require( msg.value > 0 );
        
        tokens = tokensPerEth.mul(msg.value) / 1 ether;        
        address investor = msg.sender;
        
        if (tokens > 0) {
            distr(investor, tokens);
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }

    function balanceOf(address _owner) constant public returns (uint256) {
</source>
</class>

<class classid="95" nclones="75" nlines="4" similarity="75">
<source file="systems/smart_contracts/Aigopay.sol" startline="208" endline="213" pcid="461">
    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }

    // mitigates the ERC20 short address attack
    modifier onlyPayloadSize(uint size) {
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="95" endline="99" pcid="7750">
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

}
</source>
<source file="systems/smart_contracts/SistContract.sol" startline="93" endline="97" pcid="6523">
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

}
</source>
<source file="systems/smart_contracts/Warpcoin.sol" startline="59" endline="63" pcid="7948">
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BDAM.sol" startline="163" endline="166" pcid="1121">
  function balanceOf(address _owner) public constant returns (uint256 balance) {
    return balances[_owner];
  }
}
</source>
<source file="systems/smart_contracts/VCTAToken.sol" startline="52" endline="56" pcid="7671">
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SHPC.sol" startline="52" endline="56" pcid="6510">
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="72" endline="76" pcid="4076">
    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
 
    function approve(address _spender, uint256 _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/CDS.sol" startline="176" endline="186" pcid="1662">
  function balanceOf(address _owner) public view returns (uint256) {
    return balances[_owner];
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(
</source>
<source file="systems/smart_contracts/SCMCoin.sol" startline="70" endline="74" pcid="6386">
    function balanceOf(address _owner) public view returns (uint256) {
	    return balances[_owner];
    }

    function transfer(address _to, uint256 _amount) public onlyPayloadSize(2 * 32) returns (bool success) {
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="248" endline="252" pcid="6562">
    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }

    modifier onlyPayloadSize(uint size) {
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="518" endline="522" pcid="6621">
	function balanceOf(address _owner) public view returns (uint256) {
		return balances[_owner];
	}

}
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="227" endline="232" pcid="6697">
    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }

    // mitigates the ERC20 short address attack
    modifier onlyPayloadSize(uint size) {
</source>
<source file="systems/smart_contracts/P21.sol" startline="66" endline="70" pcid="5587">
    function balanceOf(address _owner) constant returns (uint) {
        return balances[_owner];
    }

    function approve(address _spender, uint _value) returns (bool) {
</source>
<source file="systems/smart_contracts/RETC.sol" startline="132" endline="136" pcid="6188">
    function balanceOf(address _owner) constant public returns (uint256) {
	    return balances[_owner];
    }
//查询地址锁定币数
    function lockOf(address _owner) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="139" endline="143" pcid="6780">
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

}
</source>
<source file="systems/smart_contracts/OMGToken.sol" startline="112" endline="116" pcid="5491">
  function balanceOf(address _owner) constant returns (uint balance) {
    return balances[_owner];
  }

}
</source>
<source file="systems/smart_contracts/GoldenRings.sol" startline="80" endline="91" pcid="4176">
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }


    /**
    * @dev Transfer tokens from one address to another
    * @param _from address The address which you want to send tokens from
    * @param _to address The address which you want to transfer to
    * @param _value uint256 the amount of tokens to be transferred
    */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="106" endline="110" pcid="1719">
    function balanceOf(address _owner) public constant returns (uint256 balance) {
        return balances[_owner];
    }

}
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="78" endline="82" pcid="7962">
    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
 
    function approve(address _spender, uint256 _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/SellableToken.sol" startline="63" endline="66" pcid="6465">
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }
}
</source>
<source file="systems/smart_contracts/FMT.sol" startline="58" endline="62" pcid="3653">
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

}
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="196" endline="201" pcid="1286">
    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }

    // mitigates the ERC20 short address attack
    modifier onlyPayloadSize(uint size) {
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="244" endline="248" pcid="3532">
    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }

    modifier onlyPayloadSize(uint size) {
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="162" endline="166" pcid="8023">
    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }

    modifier onlyPayloadSize(uint size) {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="115" endline="119" pcid="2052">
    function balanceOf(address _owner) public view returns (uint256) {
        return balances[_owner];
    }

}
</source>
<source file="systems/smart_contracts/BlockPoolToken.sol" startline="119" endline="122" pcid="1416">
    function balanceOf(address _owner) public view returns (uint256) {
        return balances[_owner];
    }
}
</source>
<source file="systems/smart_contracts/XGP.sol" startline="208" endline="213" pcid="8118">
    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }

    // mitigates the ERC20 short address attack
    modifier onlyPayloadSize(uint size) {
</source>
<source file="systems/smart_contracts/ZhongChaChainToken.sol" startline="70" endline="77" pcid="8222">
    function balanceOf(address _owner)
        constant
        public
        returns (uint256)
    {
        return balances[_owner];
    }
}
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="190" endline="194" pcid="2109">
  function balanceOf(address _owner) constant returns (uint balance) {
    return balances[_owner];
  }

  function approve(address _spender, uint _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/CRYPTOMZ.sol" startline="120" endline="123" pcid="2181">
  function balanceOf(address _owner) public constant returns (uint256 balance) {
    return balances[_owner];
  }
}
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="248" endline="252" pcid="2965">
    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }

    modifier onlyPayloadSize(uint size) {
</source>
<source file="systems/smart_contracts/OBK.sol" startline="52" endline="56" pcid="5470">
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1007" endline="1011" pcid="6135">
  function balanceOf(address _owner) constant returns (uint balance) {
    return balances[_owner];
  }

  function approve(address _spender, uint _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/GameGold.sol" startline="245" endline="255" pcid="4001">
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

  /**
   * @dev Transfer tokens from one address to another
   * @param _from address The address which you want to send tokens from
   * @param _to address The address which you want to transfer to
   * @param _value uint256 the amount of tokens to be transferred
   */
  function transferFrom(address _from, address _to, uint256 _value)
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="255" endline="259" pcid="1448">
    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }

    modifier onlyPayloadSize(uint size) {
</source>
<source file="systems/smart_contracts/UTC.sol" startline="110" endline="114" pcid="7580">
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

}
</source>
<source file="systems/smart_contracts/NBToken.sol" startline="135" endline="138" pcid="5306">
    function balanceOf(address _owner) public view returns (uint256) {
        return balances[_owner];
    }
}
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="162" endline="166" pcid="2889">
    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }

    modifier onlyPayloadSize(uint size) {
</source>
<source file="systems/smart_contracts/NaorisToken.sol" startline="105" endline="108" pcid="5286">
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }
}
</source>
<source file="systems/smart_contracts/UNT.sol" startline="52" endline="56" pcid="7568">
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="252" endline="256" pcid="6496">
    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }

    modifier onlyPayloadSize(uint size) {
</source>
<source file="systems/smart_contracts/AzurToken.sol" startline="81" endline="85" pcid="1007">
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

  function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="259" endline="263" pcid="4313">
    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }

    modifier onlyPayloadSize(uint size) {
</source>
<source file="systems/smart_contracts/TeaToken.sol" startline="70" endline="77" pcid="7125">
    function balanceOf(address _owner)
        constant
        public
        returns (uint256)
    {
        return balances[_owner];
    }
}
</source>
<source file="systems/smart_contracts/UGCoin.sol" startline="78" endline="83" pcid="7534">
    function balanceOf(address _owner) constant public returns (uint256) {
	    return balances[_owner];
    }

    // mitigates the ERC20 short address attack
    modifier onlyPayloadSize(uint size) {
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="105" endline="108" pcid="7457">
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }
}
</source>
<source file="systems/smart_contracts/LBBT.sol" startline="81" endline="85" pcid="4543">
  function balanceOf(address _owner) public view returns (uint256) {
    return balances[_owner];
  }         
 
  function approve(address _spender, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/TorexToken.sol" startline="113" endline="117" pcid="7412">
  function balanceOf(address _owner) public view returns (uint256) {
    return balances[_owner];
  }

}
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="63" endline="67" pcid="4647">
  function balanceOf(address _owner) public view returns (uint256) {
    return balances[_owner];
  }

}
</source>
<source file="systems/smart_contracts/MBA.sol" startline="96" endline="100" pcid="4707">
  function balanceOf(address _owner) public view returns (uint256) {
    return balances[_owner];
  }

}
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="1012" endline="1016" pcid="4895">
  function balanceOf(address _owner) constant returns (uint balance) {
    return balances[_owner];
  }

  function approve(address _spender, uint _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="191" endline="196" pcid="4970">
    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }

 
    modifier onlyPayloadSize(uint size) {
</source>
<source file="systems/smart_contracts/TECToken.sol" startline="66" endline="70" pcid="7135">
    function balanceOf(address _owner) constant returns (uint) {
        return balances[_owner];
    }

    function approve(address _spender, uint _value) returns (bool) {
</source>
<source file="systems/smart_contracts/DENARIO.sol" startline="59" endline="63" pcid="2450">
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/DNP.sol" startline="170" endline="174" pcid="2800">
    function balanceOf(address _owner) public view returns (uint256) 
    {
        return balances[_owner];
    }
}
</source>
<source file="systems/smart_contracts/BTToken.sol" startline="70" endline="74" pcid="1560">
    function balanceOf(address _owner) constant returns (uint) {
        return balances[_owner];
    }

    function approve(address _spender, uint _value) returns (bool) {
</source>
<source file="systems/smart_contracts/customIcoToken.sol" startline="73" endline="77" pcid="2213">
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function allowance(address _owner, address _spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/BermToken.sol" startline="82" endline="86" pcid="1143">
    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/CST_TOKEN.sol" startline="64" endline="68" pcid="2201">
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

  function allowance(address _owner, address _spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/AronCoin.sol" startline="95" endline="99" pcid="766">
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

}
</source>
<source file="systems/smart_contracts/CouncilVesting.sol" startline="99" endline="103" pcid="2033">
    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/DaiSwap.sol" startline="25" endline="26" pcid="2284">
  function balanceOf(address _owner) public view returns (uint256 balance) {}
  function transfer(address _to, uint256 _value) public returns (bool success) {}
</source>
<source file="systems/smart_contracts/Ownable.sol" startline="166" endline="169" pcid="5578">
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return getBalance( _owner );
    }
}
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="224" endline="234" pcid="8085">
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return _balances[_owner];
  }
 
 
  /**
   * @dev transfer token for a specified address
   * @param _to The address to transfer to.
   * @param _value The amount to be transferred.
   */
  function transfer(address _to, uint256 _value) returns (bool) {    
</source>
<source file="systems/smart_contracts/BACD.sol" startline="90" endline="103" pcid="1020">
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return accounts [_owner];
  }

  /**
   * Transfer given number of tokens from message sender to given recipient.
   *
   * @param _to address to transfer tokens to the owner of
   * @param _value number of tokens to transfer to the owner of given address
   * @return true if tokens were transferred successfully, false otherwise
   * accounts [_to] + _value > accounts [_to] for overflow check
   * which is already in safeMath
   */
  function transfer(address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="235" endline="239" pcid="4661">
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return super.balanceOf(_owner) + freezingBalance[_owner];
    }

    function actualBalanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="745" endline="754" pcid="625">
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return super.balanceOf(_owner) + freezingBalance[_owner];
    }

    /**
     * @dev Gets the balance of the specified address without freezing tokens.
     * @param _owner The address to query the the balance of.
     * @return An uint256 representing the amount owned by the passed address.
     */
    function actualBalanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/MiniMeTokenFactory.sol" startline="248" endline="258" pcid="4810">
    function balanceOf(address _owner) public constant returns (uint256 balance) {
        return balanceOfAt(_owner, block.number);
    }

    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on
    ///  its behalf. This is a modified version of the ERC20 approve function
    ///  to be a little bit safer
    /// @param _spender The address of the account able to transfer the tokens
    /// @param _amount The amount of tokens to be approved for transfer
    /// @return True if the approval was successful
    function approve(address _spender, uint256 _amount) public returns (bool success) {
</source>
<source file="systems/smart_contracts/CouncilVesting.sol" startline="64" endline="65" pcid="2026">
    function balanceOf(address _owner) constant returns (uint256 balance) {}
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="337" endline="347" pcid="3081">
  function balanceOf(address _owner) public view returns (uint256) {
    require(_owner != address(0));
    return ownedTokensCount[_owner];
  }

  /**
   * @dev Gets the owner of the specified token ID
   * @param _tokenId uint256 ID of the token to query the owner of
   * @return owner address currently marked as the owner of the given token ID
   */
  function ownerOf(uint256 _tokenId) public view returns (address) {
</source>
<source file="systems/smart_contracts/PositionTokenV2.sol" startline="314" endline="323" pcid="5761">
    function balanceOf(
        address _owner)
        public
        view
        returns (uint256)
    {
        return denormalize(balances[_owner]);
    }

    function allowance(
</source>
<source file="systems/smart_contracts/BTToken.sol" startline="18" endline="24" pcid="1553">
    function balanceOf(address _owner) constant returns (uint balance) {}

    /// @notice send `_value` token to `_to` from `msg.sender`
    /// @param _to The address of the recipient
    /// @param _value The amount of token to be transferred
    /// @return Whether the transfer was successful or not
    function transfer(address _to, uint _value) returns (bool success) {}
</source>
<source file="systems/smart_contracts/TECToken.sol" startline="14" endline="20" pcid="7128">
    function balanceOf(address _owner) constant returns (uint balance) {}

    /// @notice send `_value` token to `_to` from `msg.sender`
    /// @param _to The address of the recipient
    /// @param _value The amount of token to be transferred
    /// @return Whether the transfer was successful or not
    function transfer(address _to, uint _value) returns (bool success) {}
</source>
<source file="systems/smart_contracts/P21.sol" startline="14" endline="20" pcid="5580">
    function balanceOf(address _owner) constant returns (uint balance) {}

    /// @notice send `_value` token to `_to` from `msg.sender`
    /// @param _to The address of the recipient
    /// @param _value The amount of token to be transferred
    /// @return Whether the transfer was successful or not
    function transfer(address _to, uint _value) returns (bool success) {}
</source>
</class>

<class classid="96" nclones="14" nlines="4" similarity="75">
<source file="systems/smart_contracts/Aigopay.sol" startline="218" endline="229" pcid="462">
    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="257" endline="268" pcid="6563">
    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="171" endline="182" pcid="8024">
    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="253" endline="264" pcid="3533">
    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="237" endline="248" pcid="6698">
    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="264" endline="275" pcid="1449">
    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="261" endline="272" pcid="6497">
    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {
</source>
<source file="systems/smart_contracts/UGCoin.sol" startline="88" endline="99" pcid="7535">
    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        Transfer(msg.sender, _to, _amount);
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="171" endline="182" pcid="2890">
    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="257" endline="268" pcid="2966">
    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="268" endline="279" pcid="4314">
    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="206" endline="217" pcid="1287">
    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="201" endline="212" pcid="4971">
    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {
</source>
<source file="systems/smart_contracts/XGP.sol" startline="218" endline="229" pcid="8119">
    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {
</source>
</class>

<class classid="97" nclones="14" nlines="5" similarity="80">
<source file="systems/smart_contracts/Aigopay.sol" startline="229" endline="242" pcid="463">
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
    }
    
    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/UGCoin.sol" startline="99" endline="112" pcid="7536">
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        Transfer(_from, _to, _amount);
        return true;
    }
    
    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="217" endline="230" pcid="1288">
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
    }
    
    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="275" endline="288" pcid="1450">
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
    }
    
    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="212" endline="225" pcid="4972">
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
    }
    
    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="182" endline="195" pcid="2891">
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
    }
    
    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="248" endline="261" pcid="6699">
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
    }
    
    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="279" endline="292" pcid="4315">
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
    }
    
    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="264" endline="277" pcid="3534">
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
    }
    
    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="268" endline="281" pcid="2967">
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
    }
    
    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="272" endline="285" pcid="6498">
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
    }
    
    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="268" endline="281" pcid="6564">
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
    }
    
    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="182" endline="195" pcid="8025">
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
    }
    
    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/XGP.sol" startline="229" endline="242" pcid="8120">
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
    }
    
    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
</class>

<class classid="98" nclones="14" nlines="8" similarity="87">
<source file="systems/smart_contracts/Aigopay.sol" startline="242" endline="250" pcid="464">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        // mitigates the ERC20 spend/approval race condition
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="281" endline="288" pcid="2968">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="230" endline="238" pcid="1289">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        // mitigates the ERC20 spend/approval race condition
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="288" endline="295" pcid="1451">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="292" endline="299" pcid="4316">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="277" endline="284" pcid="3535">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="195" endline="202" pcid="2892">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="261" endline="269" pcid="6700">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        // mitigates the ERC20 spend/approval race condition
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="225" endline="233" pcid="4973">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        // mitigates the ERC20 spend/approval race condition
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="195" endline="202" pcid="8026">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/XGP.sol" startline="242" endline="250" pcid="8121">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        // mitigates the ERC20 spend/approval race condition
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="285" endline="292" pcid="6499">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="281" endline="288" pcid="6565">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/RETC.sol" startline="187" endline="194" pcid="6192">
    function approve(address _spender, uint256 _value) public returns (bool success) {
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant public returns (uint256) {
</source>
</class>

<class classid="99" nclones="13" nlines="4" similarity="75">
<source file="systems/smart_contracts/Aigopay.sol" startline="254" endline="260" pcid="466">
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        AltcoinToken t = AltcoinToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
    
    function withdraw() onlyOwner public {
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="296" endline="302" pcid="6501">
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        ForeignToken t = ForeignToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
    
    function withdrawAll() onlyOwner public {
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="292" endline="298" pcid="6567">
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        ForeignToken t = ForeignToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
    
    function withdrawAll() onlyOwner public {
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="273" endline="279" pcid="6702">
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        AltcoinToken t = AltcoinToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
    
    function withdraw() onlyOwner public {
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="237" endline="246" pcid="4975">
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        AltcoinToken t = AltcoinToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
    
    

    
    function withdrawAltcoinTokens(address _tokenContract) onlyOwner public returns (bool) {
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="303" endline="309" pcid="4318">
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        ForeignToken t = ForeignToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
    
    function withdrawAll() onlyOwner public {
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="288" endline="294" pcid="3537">
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        ForeignToken t = ForeignToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
    
    function withdrawAll() onlyOwner public {
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="242" endline="248" pcid="1291">
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        AltcoinToken t = AltcoinToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
    
    function withdraw() onlyOwner public {
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="206" endline="212" pcid="8028">
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        AltcoinToken t = AltcoinToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
    
    function withdraw() onlyOwner public {
</source>
<source file="systems/smart_contracts/XGP.sol" startline="254" endline="260" pcid="8123">
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        AltcoinToken t = AltcoinToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
    
    function withdraw() onlyOwner public {
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="299" endline="305" pcid="1453">
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        ForeignToken t = ForeignToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
    
    function withdrawAll() onlyOwner public {
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="292" endline="298" pcid="2970">
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        ForeignToken t = ForeignToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
    
    function withdrawAll() onlyOwner public {
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="206" endline="212" pcid="2894">
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        AltcoinToken t = AltcoinToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
    
    function withdraw() onlyOwner public {
</source>
</class>

<class classid="100" nclones="15" nlines="4" similarity="75">
<source file="systems/smart_contracts/Aigopay.sol" startline="260" endline="266" pcid="467">
    function withdraw() onlyOwner public {
        address myAddress = this;
        uint256 etherBalance = myAddress.balance;
        owner.transfer(etherBalance);
    }
    
    function burn(uint256 _value) onlyOwner public {
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="248" endline="254" pcid="1292">
    function withdraw() onlyOwner public {
        address myAddress = this;
        uint256 etherBalance = myAddress.balance;
        owner.transfer(etherBalance);
    }
    
    function burn(uint256 _value) onlyOwner public {
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="305" endline="311" pcid="1454">
    function withdrawAll() onlyOwner public {
        address myAddress = this;
        uint256 etherBalance = myAddress.balance;
        owner.transfer(etherBalance);
    }

    function withdraw(uint256 _wdamount) onlyOwner public {
</source>
<source file="systems/smart_contracts/RETC.sol" startline="198" endline="203" pcid="6194">
    function withdraw() onlyOwner public {
        uint256 etherBalance = this.balance;
        address theowner = msg.sender;
        theowner.transfer(etherBalance);
    }
}
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="302" endline="308" pcid="6502">
    function withdrawAll() onlyOwner public {
        address myAddress = this;
        uint256 etherBalance = myAddress.balance;
        owner.transfer(etherBalance);
    }

    function withdraw(uint256 _wdamount) onlyOwner public {
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="298" endline="304" pcid="6568">
    function withdrawAll() onlyOwner public {
        address myAddress = this;
        uint256 etherBalance = myAddress.balance;
        owner.transfer(etherBalance);
    }

    function withdraw(uint256 _wdamount) onlyOwner public {
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="279" endline="285" pcid="6703">
    function withdraw() onlyOwner public {
        address myAddress = this;
        uint256 etherBalance = myAddress.balance;
        owner.transfer(etherBalance);
    }
    
    function burn(uint256 _value) onlyOwner public {
</source>
<source file="systems/smart_contracts/MpctLockupTeam.sol" startline="87" endline="96" pcid="5066">
    function withdraw() onlyOwner public {
        uint256 currBalance = token.balanceOf(this);
        uint256 currLocking = getCurrLocking();

        require(currBalance > currLocking);

        token.transfer(wallet, currBalance-currLocking);
    }

    function getCurrLocking()
</source>
<source file="systems/smart_contracts/UGCoin.sol" startline="122" endline="127" pcid="7539">
    function withdraw() onlyOwner public {
        uint256 etherBalance = this.balance;
        owner.transfer(etherBalance);
    }
    
    function burn(uint256 _value) onlyOwner public {
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="309" endline="315" pcid="4319">
    function withdrawAll() onlyOwner public {
        address myAddress = this;
        uint256 etherBalance = myAddress.balance;
        owner.transfer(etherBalance);
    }

    function withdraw(uint256 _wdamount) onlyOwner public {
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="294" endline="300" pcid="3538">
    function withdrawAll() onlyOwner public {
        address myAddress = this;
        uint256 etherBalance = myAddress.balance;
        owner.transfer(etherBalance);
    }

    function withdraw(uint256 _wdamount) onlyOwner public {
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="212" endline="218" pcid="8029">
    function withdraw() onlyOwner public {
        address myAddress = this;
        uint256 etherBalance = myAddress.balance;
        owner.transfer(etherBalance);
    }
    
    function withdrawAltcoinTokens(address _tokenContract) onlyOwner public returns (bool) {
</source>
<source file="systems/smart_contracts/XGP.sol" startline="260" endline="266" pcid="8124">
    function withdraw() onlyOwner public {
        address myAddress = this;
        uint256 etherBalance = myAddress.balance;
        owner.transfer(etherBalance);
    }
    
    function burn(uint256 _value) onlyOwner public {
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="298" endline="304" pcid="2971">
    function withdrawAll() onlyOwner public {
        address myAddress = this;
        uint256 etherBalance = myAddress.balance;
        owner.transfer(etherBalance);
    }

    function withdraw(uint256 _wdamount) onlyOwner public {
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="212" endline="218" pcid="2895">
    function withdraw() onlyOwner public {
        address myAddress = this;
        uint256 etherBalance = myAddress.balance;
        owner.transfer(etherBalance);
    }
    
    function withdrawAltcoinTokens(address _tokenContract) onlyOwner public returns (bool) {
</source>
</class>

<class classid="101" nclones="13" nlines="4" similarity="75">
<source file="systems/smart_contracts/Aigopay.sol" startline="266" endline="276" pcid="468">
    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        
        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        emit Burn(burner, _value);
    }
    
    function withdrawAltcoinTokens(address _tokenContract) onlyOwner public returns (bool) {
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="316" endline="325" pcid="1456">
    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        emit Burn(burner, _value);
    }
    
    function add(uint256 _value) onlyOwner public {
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="224" endline="234" pcid="2897">
	function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        
        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        emit Burn(burner, _value);
    }
	
	function burnFrom(uint256 _value, address _burner) onlyOwner public {
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="313" endline="322" pcid="6504">
    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        emit Burn(burner, _value);
    }
    
    function add(uint256 _value) onlyOwner public {
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="309" endline="318" pcid="6570">
    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        emit Burn(burner, _value);
    }
    
    function add(uint256 _value) onlyOwner public {
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="285" endline="297" pcid="6704">
    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        // no need to require value <= totalSupply, since that would imply the
        // sender's balance is greater than the totalSupply, which *should* be an assertion failure

        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        emit Burn(burner, _value);
    }
    
    function withdrawAltcoinTokens(address _tokenContract) onlyOwner public returns (bool) {
</source>
<source file="systems/smart_contracts/UGCoin.sol" startline="127" endline="136" pcid="7540">
    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);

        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        Burn(burner, _value);
    }
    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="320" endline="329" pcid="4321">
    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        emit Burn(burner, _value);
    }
    
    function add(uint256 _value) onlyOwner public {
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="305" endline="314" pcid="3540">
    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        emit Burn(burner, _value);
    }
    
    function add(uint256 _value) onlyOwner public {
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="224" endline="234" pcid="8031">
	function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        
        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        emit Burn(burner, _value);
    }
	
	function burnFrom(uint256 _value, address _burner) onlyOwner public {
</source>
<source file="systems/smart_contracts/XGP.sol" startline="266" endline="276" pcid="8125">
    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        
        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        emit Burn(burner, _value);
    }
    
    function withdrawAltcoinTokens(address _tokenContract) onlyOwner public returns (bool) {
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="309" endline="318" pcid="2973">
    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        emit Burn(burner, _value);
    }
    
    function add(uint256 _value) onlyOwner public {
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="254" endline="264" pcid="1293">
    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        
        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        emit Burn(burner, _value);
    }
    
    function withdrawAltcoinTokens(address _tokenContract) onlyOwner public returns (bool) {
</source>
</class>

<class classid="102" nclones="7" nlines="4" similarity="100">
<source file="systems/smart_contracts/Aigopay.sol" startline="276" endline="281" pcid="469">
    function withdrawAltcoinTokens(address _tokenContract) onlyOwner public returns (bool) {
        AltcoinToken token = AltcoinToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
}
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="297" endline="302" pcid="6705">
    function withdrawAltcoinTokens(address _tokenContract) onlyOwner public returns (bool) {
        AltcoinToken token = AltcoinToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
}
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="246" endline="251" pcid="4976">
    function withdrawAltcoinTokens(address _tokenContract) onlyOwner public returns (bool) {
        AltcoinToken token = AltcoinToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
}
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="218" endline="224" pcid="8030">
    function withdrawAltcoinTokens(address _tokenContract) onlyOwner public returns (bool) {
        AltcoinToken token = AltcoinToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
	
	function burn(uint256 _value) onlyOwner public {
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="264" endline="269" pcid="1294">
    function withdrawAltcoinTokens(address _tokenContract) onlyOwner public returns (bool) {
        AltcoinToken token = AltcoinToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
}
</source>
<source file="systems/smart_contracts/XGP.sol" startline="276" endline="281" pcid="8126">
    function withdrawAltcoinTokens(address _tokenContract) onlyOwner public returns (bool) {
        AltcoinToken token = AltcoinToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
}
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="218" endline="224" pcid="2896">
    function withdrawAltcoinTokens(address _tokenContract) onlyOwner public returns (bool) {
        AltcoinToken token = AltcoinToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
	
	function burn(uint256 _value) onlyOwner public {
</source>
</class>

<class classid="103" nclones="9" nlines="4" similarity="75">
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="210" endline="220" pcid="486">
    function isContract(address account) internal view returns (bool) {
        // This method relies in extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.

        uint256 size;
        // solhint-disable-next-line no-inline-assembly
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="82" endline="87" pcid="2560">
     function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="552" endline="571" pcid="1777">
    function isContract(address account) internal view returns (bool) {
        // This method relies in extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.
        
        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts
        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned
        // for accounts without code, i.e. `keccak256('')`
        bytes32 codehash;
        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        // solhint-disable-next-line no-inline-assembly
        assembly { codehash := extcodehash(account) }
        return (codehash != 0x0 && codehash != accountHash);
    }

    /**
     * @dev Converts an `address` into `address payable`. Note that this is
     * simply a type cast: the actual underlying value is not changed.
     */
    function toPayable(address account) internal pure returns (address payable) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="78" endline="83" pcid="2651">
     function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="209" endline="219" pcid="526">
    function isContract(address account) internal view returns (bool) {
        // This method relies in extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.

        uint256 size;
        // solhint-disable-next-line no-inline-assembly
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="368" endline="380" pcid="3264">
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        // XXX Currently there is no better way to check if there is a contract in an address
        // than to check the size of the code at that address.
        // See https://ethereum.stackexchange.com/a/14016/36603
        // for more details about how this works.
        // TODO Check this again before the Serenity release, because all addresses will be
        // contracts then.
        // solhint-disable-next-line no-inline-assembly
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="360" endline="379" pcid="4999">
    function isContract(address account) internal view returns (bool) {
        // This method relies in extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.
        
        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts
        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned
        // for accounts without code, i.e. `keccak256('')`
        bytes32 codehash;
        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        // solhint-disable-next-line no-inline-assembly
        assembly { codehash := extcodehash(account) }
        return (codehash != 0x0 && codehash != accountHash);
    }

    /**
     * @dev Converts an `address` into `address payable`. Note that this is
     * simply a type cast: the actual underlying value is not changed.
     */
    function toPayable(address account) internal pure returns (address payable) {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="125" endline="144" pcid="4738">
    function isContract(address account) internal view returns (bool) {
        // This method relies in extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.

        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts
        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned
        // for accounts without code, i.e. `keccak256('')`
        bytes32 codehash;
        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        // solhint-disable-next-line no-inline-assembly
        assembly { codehash := extcodehash(account) }
        return (codehash != 0x0 && codehash != accountHash);
    }

    /**
     * @dev Converts an `address` into `address payable`. Note that this is
     * simply a type cast: the actual underlying value is not changed.
     */
    function toPayable(address account) internal pure returns (address payable) {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="519" endline="529" pcid="7924">
    function isContract(address account) internal view returns (bool) {
        // This method relies in extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.

        uint256 size;
        // solhint-disable-next-line no-inline-assembly
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}
</source>
</class>

<class classid="104" nclones="13" nlines="4" similarity="75">
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="238" endline="242" pcid="487">
    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="93" endline="97" pcid="2561">
    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="596" endline="600" pcid="1779">
    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="237" endline="241" pcid="527">
    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="89" endline="93" pcid="2652">
    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="80" endline="84" pcid="6308">
    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        require(token.transfer(to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="215" endline="219" pcid="582">
    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        require(token.transfer(to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="289" endline="293" pcid="7294">
    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        require(token.transfer(to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="545" endline="549" pcid="7925">
    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="164" endline="168" pcid="4740">
    function safeTransfer(IERC20Token token, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20Token token, address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/MBA.sol" startline="175" endline="179" pcid="4714">
  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {
    require(token.transfer(to, value));
  }

  function safeTransferFrom(
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="207" endline="211" pcid="7466">
    function safeTransfer(ERC20Basic token, address to, uint256 value) internal {
        assert(token.transfer(to, value));
    }

    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="210" endline="214" pcid="1896">
  function safeTransfer(ERC20 token, address to, uint256 value) internal {
    assert(token.transfer(to, value));
  }

  function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {
</source>
</class>

<class classid="105" nclones="13" nlines="4" similarity="75">
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="242" endline="246" pcid="488">
    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="219" endline="223" pcid="583">
    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        require(token.transferFrom(from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="549" endline="553" pcid="7926">
    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="97" endline="101" pcid="2562">
    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="168" endline="172" pcid="4741">
    function safeTransferFrom(IERC20Token token, address from, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20Token token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="241" endline="245" pcid="528">
    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="600" endline="604" pcid="1780">
    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="293" endline="297" pcid="7295">
    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        require(token.transferFrom(from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="93" endline="97" pcid="2653">
    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="84" endline="88" pcid="6309">
    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        require(token.transferFrom(from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/MBA.sol" startline="179" endline="190" pcid="4715">
  function safeTransferFrom(
    ERC20 token,
    address from,
    address to,
    uint256 value
  )
    internal
  {
    require(token.transferFrom(from, to, value));
  }

  function safeApprove(ERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="211" endline="215" pcid="7467">
    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {
        assert(token.transferFrom(from, to, value));
    }

    function safeApprove(ERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="214" endline="218" pcid="1897">
  function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {
    assert(token.transferFrom(from, to, value));
  }

  function safeApprove(ERC20 token, address spender, uint256 value) internal {
</source>
</class>

<class classid="106" nclones="10" nlines="4" similarity="75">
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="246" endline="257" pcid="489">
    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        // solhint-disable-next-line max-line-length
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="101" endline="108" pcid="2563">
    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="172" endline="183" pcid="4742">
    function safeApprove(IERC20Token token, address spender, uint256 value) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        // solhint-disable-next-line max-line-length
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(IERC20Token token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="297" endline="305" pcid="7296">
    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        require((value == 0) || (token.allowance(msg.sender, spender) == 0));
        require(token.approve(spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="553" endline="564" pcid="7927">
    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        // solhint-disable-next-line max-line-length
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="88" endline="96" pcid="6310">
    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        require((value == 0) || (token.allowance(msg.sender, spender) == 0));
        require(token.approve(spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="604" endline="615" pcid="1781">
    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        // solhint-disable-next-line max-line-length
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="97" endline="104" pcid="2654">
    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="223" endline="231" pcid="584">
    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        require((value == 0) || (token.allowance(address(this), spender) == 0));
        require(token.approve(spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="245" endline="256" pcid="529">
    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        // solhint-disable-next-line max-line-length
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
</source>
</class>

<class classid="107" nclones="10" nlines="4" similarity="75">
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="257" endline="262" pcid="490">
    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="231" endline="236" pcid="585">
    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        require(token.approve(spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="104" endline="109" pcid="2655">
    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="256" endline="261" pcid="530">
    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="108" endline="113" pcid="2564">
    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="615" endline="620" pcid="1782">
    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="183" endline="188" pcid="4743">
    function safeIncreaseAllowance(IERC20Token token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20Token token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="96" endline="101" pcid="6311">
    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        require(token.approve(spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="305" endline="310" pcid="7297">
    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        require(token.approve(spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="564" endline="569" pcid="7928">
    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
</source>
</class>

<class classid="108" nclones="10" nlines="4" similarity="75">
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="262" endline="273" pcid="491">
    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function callOptionalReturn(IERC20 token, bytes memory data) private {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="113" endline="118" pcid="2565">
    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function callOptionalReturn(IERC20 token, bytes memory data) private {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="261" endline="272" pcid="531">
    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function callOptionalReturn(IERC20 token, bytes memory data) private {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="236" endline="240" pcid="586">
    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value);
        require(token.approve(spender, newAllowance));
    }
}
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="188" endline="199" pcid="4744">
    function safeDecreaseAllowance(IERC20Token token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function callOptionalReturn(IERC20Token token, bytes memory data) private {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="109" endline="114" pcid="2656">
    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function callOptionalReturn(IERC20 token, bytes memory data) private {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="620" endline="631" pcid="1783">
    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function callOptionalReturn(IERC20 token, bytes memory data) private {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="569" endline="580" pcid="7929">
    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function callOptionalReturn(IERC20 token, bytes memory data) private {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="101" endline="105" pcid="6312">
    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value);
        require(token.approve(spender, newAllowance));
    }
}
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="310" endline="314" pcid="7298">
    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value);
        require(token.approve(spender, newAllowance));
    }
}
</source>
</class>

<class classid="109" nclones="7" nlines="7" similarity="85">
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="273" endline="293" pcid="492">
    function callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves.

        // A Solidity high level call has three parts:
        //  1. The target address is checked to verify it contains contract code
        //  2. The call itself is made, and success asserted
        //  3. The return value is decoded, which in turn checks the size of the returned data.
        // solhint-disable-next-line max-line-length
        require(address(token).isContract(), "SafeERC20: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="199" endline="219" pcid="4745">
    function callOptionalReturn(IERC20Token token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves.

        // A Solidity high level call has three parts:
        //  1. The target address is checked to verify it contains contract code
        //  2. The call itself is made, and success asserted
        //  3. The return value is decoded, which in turn checks the size of the returned data.
        // solhint-disable-next-line max-line-length
        require(address(token).isContract(), "SafeERC20: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="118" endline="127" pcid="2566">
    function callOptionalReturn(IERC20 token, bytes memory data) private {
        require(address(token).isContract(), "SafeERC20: call to non-contract");
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if(returndata.length > 0){
          require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="631" endline="651" pcid="1784">
    function callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves.

        // A Solidity high level call has three parts:
        //  1. The target address is checked to verify it contains contract code
        //  2. The call itself is made, and success asserted
        //  3. The return value is decoded, which in turn checks the size of the returned data.
        // solhint-disable-next-line max-line-length
        require(address(token).isContract(), "SafeERC20: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="272" endline="292" pcid="532">
    function callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves.

        // A Solidity high level call has three parts:
        //  1. The target address is checked to verify it contains contract code
        //  2. The call itself is made, and success asserted
        //  3. The return value is decoded, which in turn checks the size of the returned data.
        // solhint-disable-next-line max-line-length
        require(address(token).isContract(), "SafeERC20: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="114" endline="123" pcid="2657">
    function callOptionalReturn(IERC20 token, bytes memory data) private {
        require(address(token).isContract(), "SafeERC20: call to non-contract");
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if(returndata.length > 0){
          require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="580" endline="600" pcid="7930">
    function callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves.

        // A Solidity high level call has three parts:
        //  1. The target address is checked to verify it contains contract code
        //  2. The call itself is made, and success asserted
        //  3. The return value is decoded, which in turn checks the size of the returned data.
        // solhint-disable-next-line max-line-length
        require(address(token).isContract(), "SafeERC20: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}
</source>
</class>

<class classid="110" nclones="5" nlines="4" similarity="100">
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="326" endline="333" pcid="493">
    function token() public view returns (IERC20) {
        return _token;
    }

    /**
     * @return the beneficiary of the tokens.
     */
    function beneficiary() public view returns (address) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="168" endline="172" pcid="2659">
    function token() public view returns (IERC20) {
        return _token;
    }

    function wallet() public view returns (address payable) {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="713" endline="720" pcid="7932">
    function token() public view returns (IERC20) {
        return _token;
    }

    /**
     * @return the address where funds are collected.
     */
    function wallet() public view returns (address payable) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="773" endline="780" pcid="1786">
    function token() public view returns (IERC20) {
        return _token;
    }

    /**
     * @return the address where funds are collected.
     */
    function wallet() public view returns (address payable) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="172" endline="176" pcid="2568">
    function token() public view returns (IERC20) {
        return _token;
    }

    function wallet() public view returns (address payable) {
</source>
</class>

<class classid="111" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="333" endline="340" pcid="494">
    function beneficiary() public view returns (address) {
        return _beneficiary;
    }

    /**
     * @return the time when the tokens are released.
     */
    function releaseTime() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1299" endline="1307" pcid="1819">
    function beneficiary() public view returns (address) {
        return _beneficiary;
    }

    /**
     * @dev Stores funds that may later be refunded.
     * @param refundee The address funds will be sent to if a refund occurs.
     */
    function deposit(address refundee) public payable {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="434" endline="441" pcid="538">
    function beneficiary() public view returns (address) {
        return _beneficiary;
    }

    /**
     * @return the cliff time of the token vesting.
     */
    function cliff() public view returns (uint256) {
</source>
</class>

<class classid="112" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="361" endline="364" pcid="497">
    function _changeBeneficiary(address _newBeneficiary) internal {
        _beneficiary = _newBeneficiary;
    }
}
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="546" endline="549" pcid="549">
    function _changeBeneficiary(address _newBeneficiary) internal {
        _beneficiary = _newBeneficiary;
    }
}
</source>
</class>

<class classid="113" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="413" endline="418" pcid="498">
    function isExistBeneficiary(address wallet) public view returns(bool) {
        return beneficiariesIndices[wallet] > 0;
    }


    function beneficiariesCount() public view returns(uint) {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="598" endline="603" pcid="550">
    function isExistBeneficiary(address wallet) public view returns(bool) {
        return beneficiariesIndices[wallet] > 0;
    }


    function beneficiariesCount() public view returns(uint) {
</source>
</class>

<class classid="114" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="418" endline="422" pcid="499">
    function beneficiariesCount() public view returns(uint) {
        return beneficiaries.length;
    }

    function allOperationsCount() public view returns(uint) {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="603" endline="607" pcid="551">
    function beneficiariesCount() public view returns(uint) {
        return beneficiaries.length;
    }

    function allOperationsCount() public view returns(uint) {
</source>
</class>

<class classid="115" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="422" endline="430" pcid="500">
    function allOperationsCount() public view returns(uint) {
        return allOperations.length;
    }

    /*
      Internal functions
    */

    function _operationLimitByBeneficiaryIndex(uint8 beneficiaryIndex) internal view returns(bool) {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="607" endline="615" pcid="552">
    function allOperationsCount() public view returns(uint) {
        return allOperations.length;
    }

    /*
      Internal functions
    */

    function _operationLimitByBeneficiaryIndex(uint8 beneficiaryIndex) internal view returns(bool) {
</source>
</class>

<class classid="116" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="430" endline="434" pcid="501">
    function _operationLimitByBeneficiaryIndex(uint8 beneficiaryIndex) internal view returns(bool) {
        return (operationsCountByBeneficiaryIndex[beneficiaryIndex] <= 3);
    }
    
    function _cancelAllPending() internal {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="615" endline="619" pcid="553">
    function _operationLimitByBeneficiaryIndex(uint8 beneficiaryIndex) internal view returns(bool) {
        return (operationsCountByBeneficiaryIndex[beneficiaryIndex] <= 3);
    }
    
    function _cancelAllPending() internal {
</source>
</class>

<class classid="117" nclones="2" nlines="11" similarity="100">
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="434" endline="456" pcid="502">
    function _cancelAllPending() internal {
        for (uint i = 0; i < allOperations.length; i++) {
            delete(allOperationsIndicies[allOperations[i]]);
            delete(votesMaskByOperation[allOperations[i]]);
            delete(votesCountByOperation[allOperations[i]]);
            //delete operation->beneficiaryIndex
            delete(operationsByBeneficiaryIndex[allOperations[i]]);
        }

        allOperations.length = 0;
        //delete operations count for beneficiary
        for (uint8 j = 0; j < beneficiaries.length; j++) {
            operationsCountByBeneficiaryIndex[j] = 0;
        }
    }


    // MODIFIERS

    /**
    * @dev Allows to perform method by any of the beneficiaries
    */
    modifier onlyAnyBeneficiary {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="619" endline="641" pcid="554">
    function _cancelAllPending() internal {
        for (uint i = 0; i < allOperations.length; i++) {
            delete(allOperationsIndicies[allOperations[i]]);
            delete(votesMaskByOperation[allOperations[i]]);
            delete(votesCountByOperation[allOperations[i]]);
            //delete operation->beneficiaryIndex
            delete(operationsByBeneficiaryIndex[allOperations[i]]);
        }

        allOperations.length = 0;
        //delete operations count for beneficiary
        for (uint8 j = 0; j < beneficiaries.length; j++) {
            operationsCountByBeneficiaryIndex[j] = 0;
        }
    }


    // MODIFIERS

    /**
    * @dev Allows to perform method by any of the beneficiaries
    */
    modifier onlyAnyBeneficiary {
</source>
</class>

<class classid="118" nclones="2" nlines="20" similarity="100">
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="541" endline="590" pcid="503">
    function checkHowManyBeneficiaries(uint howMany) internal returns(bool) {
        if (insideCallSender == msg.sender) {
            require(howMany <= insideCallCount, "checkHowManyBeneficiaries: nested beneficiaries modifier check require more beneficiarys");
            return true;
        }
        
        
        require((isExistBeneficiary(msg.sender) && (beneficiariesIndices[msg.sender] <= beneficiaries.length)), "checkHowManyBeneficiaries: msg.sender is not an beneficiary");

        uint beneficiaryIndex = beneficiariesIndices[msg.sender].sub(1);
        
        bytes32 operation = keccak256(abi.encodePacked(msg.data, beneficiariesGeneration));

        require((votesMaskByOperation[operation] & (2 ** beneficiaryIndex)) == 0, "checkHowManyBeneficiaries: beneficiary already voted for the operation");
        //check limit for operation
        require(_operationLimitByBeneficiaryIndex(uint8(beneficiaryIndex)), "checkHowManyBeneficiaries: operation limit is reached for this beneficiary");

        votesMaskByOperation[operation] |= (2 ** beneficiaryIndex);
        uint operationVotesCount = votesCountByOperation[operation].add(1);
        votesCountByOperation[operation] = operationVotesCount;

        if (operationVotesCount == 1) {
            allOperationsIndicies[operation] = allOperations.length;
            
            operationsByBeneficiaryIndex[operation] = uint8(beneficiaryIndex);
            
            operationsCountByBeneficiaryIndex[uint8(beneficiaryIndex)] = uint8(operationsCountByBeneficiaryIndex[uint8(beneficiaryIndex)].add(1));
            
            allOperations.push(operation);
            
            
            emit OperationCreated(operation, howMany, beneficiaries.length, msg.sender);
        }
        emit OperationUpvoted(operation, operationVotesCount, howMany, beneficiaries.length, msg.sender);

        // If enough beneficiaries confirmed the same operation
        if (votesCountByOperation[operation] == howMany) {
            deleteOperation(operation);
            emit OperationPerformed(operation, howMany, beneficiaries.length, msg.sender);
            return true;
        }

        return false;
    }

    /**
    * @dev Used to delete cancelled or performed operation
    * @param operation defines which operation to delete
    */
    function deleteOperation(bytes32 operation) internal {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="726" endline="775" pcid="555">
    function checkHowManyBeneficiaries(uint howMany) internal returns(bool) {
        if (insideCallSender == msg.sender) {
            require(howMany <= insideCallCount, "checkHowManyBeneficiaries: nested beneficiaries modifier check require more beneficiarys");
            return true;
        }
        
        
        require((isExistBeneficiary(msg.sender) && (beneficiariesIndices[msg.sender] <= beneficiaries.length)), "checkHowManyBeneficiaries: msg.sender is not an beneficiary");

        uint beneficiaryIndex = beneficiariesIndices[msg.sender].sub(1);
        
        bytes32 operation = keccak256(abi.encodePacked(msg.data, beneficiariesGeneration));

        require((votesMaskByOperation[operation] & (2 ** beneficiaryIndex)) == 0, "checkHowManyBeneficiaries: beneficiary already voted for the operation");
        //check limit for operation
        require(_operationLimitByBeneficiaryIndex(uint8(beneficiaryIndex)), "checkHowManyBeneficiaries: operation limit is reached for this beneficiary");

        votesMaskByOperation[operation] |= (2 ** beneficiaryIndex);
        uint operationVotesCount = votesCountByOperation[operation].add(1);
        votesCountByOperation[operation] = operationVotesCount;

        if (operationVotesCount == 1) {
            allOperationsIndicies[operation] = allOperations.length;
            
            operationsByBeneficiaryIndex[operation] = uint8(beneficiaryIndex);
            
            operationsCountByBeneficiaryIndex[uint8(beneficiaryIndex)] = uint8(operationsCountByBeneficiaryIndex[uint8(beneficiaryIndex)].add(1));
            
            allOperations.push(operation);
            
            
            emit OperationCreated(operation, howMany, beneficiaries.length, msg.sender);
        }
        emit OperationUpvoted(operation, operationVotesCount, howMany, beneficiaries.length, msg.sender);

        // If enough beneficiaries confirmed the same operation
        if (votesCountByOperation[operation] == howMany) {
            deleteOperation(operation);
            emit OperationPerformed(operation, howMany, beneficiaries.length, msg.sender);
            return true;
        }

        return false;
    }

    /**
    * @dev Used to delete cancelled or performed operation
    * @param operation defines which operation to delete
    */
    function deleteOperation(bytes32 operation) internal {
</source>
</class>

<class classid="119" nclones="2" nlines="9" similarity="100">
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="590" endline="613" pcid="504">
    function deleteOperation(bytes32 operation) internal {
        uint index = allOperationsIndicies[operation];
        if (index < allOperations.length - 1) { // Not last
            allOperations[index] = allOperations[allOperations.length.sub(1)];
            allOperationsIndicies[allOperations[index]] = index;
        }
        allOperations.length = allOperations.length.sub(1);

        uint8 beneficiaryIndex = uint8(operationsByBeneficiaryIndex[operation]);
        operationsCountByBeneficiaryIndex[beneficiaryIndex] = uint8(operationsCountByBeneficiaryIndex[beneficiaryIndex].sub(1));

        delete votesMaskByOperation[operation];
        delete votesCountByOperation[operation];
        delete allOperationsIndicies[operation];
        delete operationsByBeneficiaryIndex[operation];
    }

    // PUBLIC METHODS

    /**
    * @dev Allows beneficiaries to change their mind by cancelling votesMaskByOperation operations
    * @param operation defines which operation to delete
    */
    function cancelPending(bytes32 operation) public onlyAnyBeneficiary {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="775" endline="798" pcid="556">
    function deleteOperation(bytes32 operation) internal {
        uint index = allOperationsIndicies[operation];
        if (index < allOperations.length - 1) { // Not last
            allOperations[index] = allOperations[allOperations.length.sub(1)];
            allOperationsIndicies[allOperations[index]] = index;
        }
        allOperations.length = allOperations.length.sub(1);

        uint8 beneficiaryIndex = uint8(operationsByBeneficiaryIndex[operation]);
        operationsCountByBeneficiaryIndex[beneficiaryIndex] = uint8(operationsCountByBeneficiaryIndex[beneficiaryIndex].sub(1));

        delete votesMaskByOperation[operation];
        delete votesCountByOperation[operation];
        delete allOperationsIndicies[operation];
        delete operationsByBeneficiaryIndex[operation];
    }

    // PUBLIC METHODS

    /**
    * @dev Allows beneficiaries to change their mind by cancelling votesMaskByOperation operations
    * @param operation defines which operation to delete
    */
    function cancelPending(bytes32 operation) public onlyAnyBeneficiary {
</source>
</class>

<class classid="120" nclones="2" nlines="9" similarity="100">
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="613" endline="633" pcid="505">
    function cancelPending(bytes32 operation) public onlyAnyBeneficiary {

        require((isExistBeneficiary(msg.sender) && (beneficiariesIndices[msg.sender] <= beneficiaries.length)), "checkHowManyBeneficiaries: msg.sender is not an beneficiary");

        uint beneficiaryIndex = beneficiariesIndices[msg.sender].sub(1);
        require((votesMaskByOperation[operation] & (2 ** beneficiaryIndex)) != 0, "cancelPending: operation not found for this user");
        votesMaskByOperation[operation] &= ~(2 ** beneficiaryIndex);
        uint operationVotesCount = votesCountByOperation[operation].sub(1);
        votesCountByOperation[operation] = operationVotesCount;
        emit OperationDownvoted(operation, operationVotesCount, beneficiaries.length, msg.sender);
        if (operationVotesCount == 0) {
            deleteOperation(operation);
            emit OperationCancelled(operation, msg.sender);
        }
    }

    /**
    * @dev Allows beneficiaries to change their mind by cancelling all operations
    */

    function cancelAllPending() public onlyManyBeneficiaries {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="798" endline="818" pcid="557">
    function cancelPending(bytes32 operation) public onlyAnyBeneficiary {

        require((isExistBeneficiary(msg.sender) && (beneficiariesIndices[msg.sender] <= beneficiaries.length)), "checkHowManyBeneficiaries: msg.sender is not an beneficiary");

        uint beneficiaryIndex = beneficiariesIndices[msg.sender].sub(1);
        require((votesMaskByOperation[operation] & (2 ** beneficiaryIndex)) != 0, "cancelPending: operation not found for this user");
        votesMaskByOperation[operation] &= ~(2 ** beneficiaryIndex);
        uint operationVotesCount = votesCountByOperation[operation].sub(1);
        votesCountByOperation[operation] = operationVotesCount;
        emit OperationDownvoted(operation, operationVotesCount, beneficiaries.length, msg.sender);
        if (operationVotesCount == 0) {
            deleteOperation(operation);
            emit OperationCancelled(operation, msg.sender);
        }
    }

    /**
    * @dev Allows beneficiaries to change their mind by cancelling all operations
    */

    function cancelAllPending() public onlyManyBeneficiaries {
</source>
</class>

<class classid="121" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="633" endline="645" pcid="506">
    function cancelAllPending() public onlyManyBeneficiaries {
       _cancelAllPending();
    }



    /**Переписать*/

    /**
    * @dev Allows beneficiaries to change beneficiariesship
    * @param newBeneficiaries defines array of addresses of new beneficiaries
    */
    function transferBeneficiaryShip(address[] memory newBeneficiaries) public {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="818" endline="830" pcid="558">
    function cancelAllPending() public onlyManyBeneficiaries {
       _cancelAllPending();
    }



    /**Переписать*/

    /**
    * @dev Allows beneficiaries to change beneficiariesship
    * @param newBeneficiaries defines array of addresses of new beneficiaries
    */
    function transferBeneficiaryShip(address[] memory newBeneficiaries) public {
</source>
</class>

<class classid="122" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="645" endline="654" pcid="507">
    function transferBeneficiaryShip(address[] memory newBeneficiaries) public {
        transferBeneficiaryShipWithHowMany(newBeneficiaries, newBeneficiaries.length);
    }

    /**
    * @dev Allows beneficiaries to change beneficiaryShip
    * @param newBeneficiaries defines array of addresses of new beneficiaries
    * @param newHowManyBeneficiariesDecide defines how many beneficiaries can decide
    */
    function transferBeneficiaryShipWithHowMany(address[] memory newBeneficiaries, uint256 newHowManyBeneficiariesDecide) public onlyManyBeneficiaries {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="830" endline="839" pcid="559">
    function transferBeneficiaryShip(address[] memory newBeneficiaries) public {
        transferBeneficiaryShipWithHowMany(newBeneficiaries, newBeneficiaries.length);
    }

    /**
    * @dev Allows beneficiaries to change beneficiaryShip
    * @param newBeneficiaries defines array of addresses of new beneficiaries
    * @param newHowManyBeneficiariesDecide defines how many beneficiaries can decide
    */
    function transferBeneficiaryShipWithHowMany(address[] memory newBeneficiaries, uint256 newHowManyBeneficiariesDecide) public onlyManyBeneficiaries {
</source>
</class>

<class classid="123" nclones="2" nlines="16" similarity="100">
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="654" endline="678" pcid="508">
    function transferBeneficiaryShipWithHowMany(address[] memory newBeneficiaries, uint256 newHowManyBeneficiariesDecide) public onlyManyBeneficiaries {
        require(newBeneficiaries.length > 0, "transferBeneficiaryShipWithHowMany: beneficiaries array is empty");
        require(newBeneficiaries.length < 256, "transferBeneficiaryshipWithHowMany: beneficiaries count is greater then 255");
        require(newHowManyBeneficiariesDecide > 0, "transferBeneficiaryshipWithHowMany: newHowManybeneficiarysDecide equal to 0");
        require(newHowManyBeneficiariesDecide <= newBeneficiaries.length, "transferBeneficiaryShipWithHowMany: newHowManybeneficiarysDecide exceeds the number of beneficiarys");

        // Reset beneficiaries reverse lookup table
        for (uint j = 0; j < beneficiaries.length; j++) {
            delete beneficiariesIndices[beneficiaries[j]];
        }
        for (uint i = 0; i < newBeneficiaries.length; i++) {
            require(newBeneficiaries[i] != address(0), "transferBeneficiaryShipWithHowMany: beneficiaries array contains zero");
            require(beneficiariesIndices[newBeneficiaries[i]] == 0, "transferBeneficiaryShipWithHowMany: beneficiaries array contains duplicates");
            beneficiariesIndices[newBeneficiaries[i]] = uint8(i.add(1));
        }
        
        emit BeneficiaryshipTransferred(beneficiaries, howManyBeneficiariesDecide, newBeneficiaries, newHowManyBeneficiariesDecide);
        beneficiaries = newBeneficiaries;
        howManyBeneficiariesDecide = newHowManyBeneficiariesDecide;

        _cancelAllPending();
       
        beneficiariesGeneration++;
    }
}
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="839" endline="863" pcid="560">
    function transferBeneficiaryShipWithHowMany(address[] memory newBeneficiaries, uint256 newHowManyBeneficiariesDecide) public onlyManyBeneficiaries {
        require(newBeneficiaries.length > 0, "transferBeneficiaryShipWithHowMany: beneficiaries array is empty");
        require(newBeneficiaries.length < 256, "transferBeneficiaryshipWithHowMany: beneficiaries count is greater then 255");
        require(newHowManyBeneficiariesDecide > 0, "transferBeneficiaryshipWithHowMany: newHowManybeneficiarysDecide equal to 0");
        require(newHowManyBeneficiariesDecide <= newBeneficiaries.length, "transferBeneficiaryShipWithHowMany: newHowManybeneficiarysDecide exceeds the number of beneficiarys");

        // Reset beneficiaries reverse lookup table
        for (uint j = 0; j < beneficiaries.length; j++) {
            delete beneficiariesIndices[beneficiaries[j]];
        }
        for (uint i = 0; i < newBeneficiaries.length; i++) {
            require(newBeneficiaries[i] != address(0), "transferBeneficiaryShipWithHowMany: beneficiaries array contains zero");
            require(beneficiariesIndices[newBeneficiaries[i]] == 0, "transferBeneficiaryShipWithHowMany: beneficiaries array contains duplicates");
            beneficiariesIndices[newBeneficiaries[i]] = uint8(i.add(1));
        }
        
        emit BeneficiaryshipTransferred(beneficiaries, howManyBeneficiariesDecide, newBeneficiaries, newHowManyBeneficiariesDecide);
        beneficiaries = newBeneficiaries;
        howManyBeneficiariesDecide = newHowManyBeneficiariesDecide;

        _cancelAllPending();
       
        beneficiariesGeneration++;
    }
}
</source>
</class>

<class classid="124" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="721" endline="730" pcid="509">
        function pendingBeneficiary() public view returns (address) {
            return _pendingBeneficiary;
        }

        /**
            * @dev Allows beneficiaries to change beneficiaryShip and set first beneficiary as default
            * @param _newBeneficiaries defines array of addresses of new beneficiaries
            * @param _newHowManyBeneficiariesDecide defines how many beneficiaries can decide
        */
        function transferBeneficiaryShipWithHowMany(address[] memory _newBeneficiaries, uint256 _newHowManyBeneficiariesDecide) public {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="918" endline="926" pcid="563">
    function pendingBeneficiary() public view returns (address) {
        return _pendingBeneficiary;
    }

     /**
        * @dev Allows beneficiaries to change beneficiaryShip and set first beneficiary as default
        * @param _newBeneficiaries defines array of addresses of new beneficiaries
    */
    function transferBeneficiaryShip(address[] memory _newBeneficiaries) public {
</source>
</class>

<class classid="125" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="730" endline="740" pcid="510">
        function transferBeneficiaryShipWithHowMany(address[] memory _newBeneficiaries, uint256 _newHowManyBeneficiariesDecide) public {
            super.transferBeneficiaryShipWithHowMany(_newBeneficiaries, _newHowManyBeneficiariesDecide);
            _setPendingBeneficiary(beneficiaries[0]);
        }

         /**
            * @dev Allows beneficiaries to change beneficiaryShip and set first beneficiary as default
            * @param _newBeneficiaries defines array of addresses of new beneficiaries
        */

        function transferBeneficiaryShip(address[] memory _newBeneficiaries) public {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="937" endline="946" pcid="565">
    function transferBeneficiaryShipWithHowMany(address[] memory _newBeneficiaries, uint256 _newHowManyBeneficiariesDecide) public  {
        super.transferBeneficiaryShipWithHowMany(_newBeneficiaries, _newHowManyBeneficiariesDecide);
        _setPendingBeneficiary(beneficiaries[0]);
    }

    /**
        * @dev Allows beneficiaries to change beneficiary as default
         * @param _newBeneficiary defines address of new beneficiary
    */
    function changeBeneficiary(address _newBeneficiary) public onlyManyBeneficiaries {
</source>
</class>

<class classid="126" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="740" endline="749" pcid="511">
        function transferBeneficiaryShip(address[] memory _newBeneficiaries) public {
            super.transferBeneficiaryShip(_newBeneficiaries);
            _setPendingBeneficiary(beneficiaries[0]);
        }

        /**
            * @dev Allows beneficiaries to change beneficiary as default
            * @param _newBeneficiary defines address of new beneficiary
        */
        function changeBeneficiary(address _newBeneficiary) public onlyManyBeneficiaries {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="926" endline="937" pcid="564">
    function transferBeneficiaryShip(address[] memory _newBeneficiaries) public {
        super.transferBeneficiaryShip(_newBeneficiaries);
        _setPendingBeneficiary(beneficiaries[0]);
    }

     /**
        * @dev Allows beneficiaries to change beneficiaryShip and set first beneficiary as default
        * @param _newBeneficiaries defines array of addresses of new beneficiaries
        * @param _newHowManyBeneficiariesDecide defines how many beneficiaries can decide
    */
    
    function transferBeneficiaryShipWithHowMany(address[] memory _newBeneficiaries, uint256 _newHowManyBeneficiariesDecide) public  {
</source>
</class>

<class classid="127" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="749" endline="756" pcid="512">
        function changeBeneficiary(address _newBeneficiary) public onlyManyBeneficiaries {
            _setPendingBeneficiary(_newBeneficiary);
        }

        /**
            * @dev Claim Beneficiary
        */
        function claimBeneficiary() public onlyPendingBeneficiary {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="946" endline="953" pcid="566">
    function changeBeneficiary(address _newBeneficiary) public onlyManyBeneficiaries {
        _setPendingBeneficiary(_newBeneficiary);
    }

    /**
        * @dev Claim Beneficiary
    */
    function claimBeneficiary() public onlyPendingBeneficiary {
</source>
</class>

<class classid="128" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="756" endline="770" pcid="513">
        function claimBeneficiary() public onlyPendingBeneficiary {
            _changeBeneficiary(_pendingBeneficiary);
            emit LogBeneficiaryTransfered(_pendingBeneficiary);
            _pendingBeneficiary = address(0);
        }

        /*
        * Internal Functions
        *
        */
        /**
            * @dev Set pending Beneficiary address
            * @param _newBeneficiary defines address of new beneficiary
        */
        function _setPendingBeneficiary(address _newBeneficiary) internal onlyExistingBeneficiary(_newBeneficiary) {
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="953" endline="967" pcid="567">
    function claimBeneficiary() public onlyPendingBeneficiary {
        _changeBeneficiary(_pendingBeneficiary);
        emit LogBeneficiaryTransfered(_pendingBeneficiary);
        _pendingBeneficiary = address(0);
    }

    /*
     * Internal Functions
     *
     */
    /**
        * @dev Set pending Beneficiary address
        * @param _newBeneficiary defines address of new beneficiary
    */
    function _setPendingBeneficiary(address _newBeneficiary) internal onlyExistingBeneficiary(_newBeneficiary) {
</source>
</class>

<class classid="129" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="770" endline="774" pcid="514">
        function _setPendingBeneficiary(address _newBeneficiary) internal onlyExistingBeneficiary(_newBeneficiary) {
            _pendingBeneficiary = _newBeneficiary;
            emit LogBeneficiaryTransferProposed(_newBeneficiary);
        }
}
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="967" endline="971" pcid="568">
    function _setPendingBeneficiary(address _newBeneficiary) internal onlyExistingBeneficiary(_newBeneficiary) {
        _pendingBeneficiary = _newBeneficiary;
        emit LogBeneficiaryTransferProposed(_newBeneficiary);
    }
}
</source>
</class>

<class classid="130" nclones="34" nlines="4" similarity="75">
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="322" endline="329" pcid="533">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1550" endline="1557" pcid="1835">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="197" endline="201" pcid="2321">
    function owner() public view returns(address) {
        return _owner;
    }

    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/SuperMarket.sol" startline="32" endline="36" pcid="6759">
    function owner() public view returns (address) {
        return _owner;
    }
    
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="106" endline="113" pcid="6985">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="442" endline="449" pcid="7035">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="176" endline="183" pcid="7277">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/ParkingResolver.sol" startline="48" endline="52" pcid="5596">
    function owner() external view returns (address) {
        return _owner;
    }

    function setOwner(address owner) external {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="32" endline="39" pcid="4731">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/PokaToken.sol" startline="32" endline="36" pcid="5731">
    function owner() public view returns (address) {
        return _owner;
    }
    
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="31" endline="38" pcid="7338">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="141" endline="148" pcid="3761">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="94" endline="101" pcid="5775">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="45" endline="52" pcid="8074">
  function owner() public view returns (address) {
      return _owner;
  }

  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/Factory.sol" startline="34" endline="41" pcid="3430">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/TokenSwap.sol" startline="93" endline="100" pcid="7390">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="449" endline="456" pcid="7919">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/EthNote.sol" startline="21" endline="28" pcid="3350">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="303" endline="310" pcid="590">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/Ethertime.sol" startline="376" endline="379" pcid="3315">
    function getOwner() public view returns (address) {
        return _owner;
    }
    function getTotalFee() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="293" endline="300" pcid="3032">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="34" endline="41" pcid="2453">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="34" endline="41" pcid="940">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="355" endline="362" pcid="7662">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="700" endline="707" pcid="4458">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="131" endline="138" pcid="5843">
    function owner() public view returns(address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="141" endline="148" pcid="806">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="34" endline="41" pcid="6012">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/ComplianceRegistry.sol" startline="27" endline="34" pcid="1943">
    function owner() public view returns(address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/KYCRegistry.sol" startline="34" endline="41" pcid="4501">
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="143" endline="150" pcid="1885">
  function owner() public view returns(address) {
    return _owner;
  }

  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="383" endline="390" pcid="749">
    function owner() public view returns(address) {
        return _owner;
    }

    /**
    * @dev Throws if called by any account other than the owner.
    */
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="367" endline="370" pcid="2352">
    function getOwner() public view returns (address) {
        return owner;
    }
}
</source>
<source file="systems/smart_contracts/Exchange.sol" startline="71" endline="76" pcid="3367">
    function getOwner() returns (address out) {
        return owner;
    }

    // Adds or disables an admin account
    function setAdmin(address admin, bool isAdmin) onlyOwner {
</source>
</class>

<class classid="131" nclones="31" nlines="4" similarity="100">
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="337" endline="348" pcid="534">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * > Note: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="47" endline="58" pcid="4732">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="191" endline="202" pcid="7278">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Allows the current owner to relinquish control of the contract.
     * It will not be possible to call the functions with the `onlyOwner`
     * modifier anymore.
     * @notice Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="457" endline="468" pcid="7036">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Allows the current owner to relinquish control of the contract.
     * It will not be possible to call the functions with the `onlyOwner`
     * modifier anymore.
     * @notice Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1565" endline="1576" pcid="1836">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * > Note: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="208" endline="217" pcid="5351">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     *
     * IMPORTANT: Need to run {acceptOwnership} by the new owner.
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/SuperMarket.sol" startline="41" endline="45" pcid="6760">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }
    
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/PokaToken.sol" startline="41" endline="45" pcid="5732">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }
    
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="109" endline="120" pcid="5776">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="146" endline="156" pcid="5844">
    function isOwner() public view returns(bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Allows the current owner to relinquish control of the contract.
     * @notice Renouncing to ownership will leave the contract without an owner.
     * It will not be possible to call the functions with the `onlyOwner`
     * modifier anymore.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="49" endline="60" pcid="6013">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * > Note: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="318" endline="328" pcid="591">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Allows the current owner to relinquish control of the contract.
     * @notice Renouncing to ownership will leave the contract without an owner.
     * It will not be possible to call the functions with the `onlyOwner`
     * modifier anymore.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="158" endline="168" pcid="1886">
  function isOwner() public view returns(bool) {
    return msg.sender == _owner;
  }

  /**
   * @dev Allows the current owner to relinquish control of the contract.
   * @notice Renouncing to ownership will leave the contract without an owner.
   * It will not be possible to call the functions with the `onlyOwner`
   * modifier anymore.
   */
  function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="46" endline="56" pcid="7339">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Allows the current owner to relinquish control of the contract.
     * @notice Renouncing to ownership will leave the contract without an owner.
     * It will not be possible to call the functions with the `onlyOwner`
     * modifier anymore.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/ComplianceRegistry.sol" startline="42" endline="52" pcid="1944">
    function isOwner() public view returns(bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Allows the current owner to relinquish control of the contract.
     * @notice Renouncing to ownership will leave the contract without an owner.
     * It will not be possible to call the functions with the `onlyOwner`
     * modifier anymore.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/TokenSwap.sol" startline="108" endline="119" pcid="7391">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Allows the current owner to relinquish control of the contract.
     * It will not be possible to call the functions with the `onlyOwner`
     * modifier anymore.
     * @notice Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/KYCRegistry.sol" startline="49" endline="60" pcid="4502">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * > Note: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="206" endline="210" pcid="2322">
    function isOwner() public view returns(bool) {
        return msg.sender == _owner;
    }

    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="715" endline="726" pcid="4459">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * > Note: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="370" endline="381" pcid="7663">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Allows the current owner to relinquish control of the contract.
     * It will not be possible to call the functions with the `onlyOwner`
     * modifier anymore.
     * @notice Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="258" endline="269" pcid="7798">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     *
     * Need to run {acceptOwnership} by the new owner.
     *
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="156" endline="167" pcid="3762">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Allows the current owner to relinquish control of the contract.
     * It will not be possible to call the functions with the `onlyOwner`
     * modifier anymore.
     * @notice Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="464" endline="475" pcid="7920">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * > Note: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="49" endline="60" pcid="2454">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * > Note: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="60" endline="68" pcid="8075">
  function isOwner() public view returns (bool) {
      return msg.sender == _owner;
  }

  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/Factory.sol" startline="49" endline="60" pcid="3431">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Allows the current owner to relinquish control of the contract.
     * It will not be possible to call the functions with the `onlyOwner`
     * modifier anymore.
     * @notice Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/EthNote.sol" startline="36" endline="47" pcid="3351">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * > Note: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="308" endline="319" pcid="3033">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Allows the current owner to relinquish control of the contract.
     * It will not be possible to call the functions with the `onlyOwner`
     * modifier anymore.
     * @notice Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="398" endline="408" pcid="750">
    function isOwner() public view returns(bool) {
        return msg.sender == _owner;
    }

    /**
    * @dev Allows the current owner to relinquish control of the contract.
    * @notice Renouncing to ownership will leave the contract without an owner.
    * It will not be possible to call the functions with the `onlyOwner`
    * modifier anymore.
    */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="49" endline="60" pcid="941">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * > Note: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="156" endline="167" pcid="807">
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Allows the current owner to relinquish control of the contract.
     * It will not be possible to call the functions with the `onlyOwner`
     * modifier anymore.
     * @notice Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
</source>
</class>

<class classid="132" nclones="35" nlines="4" similarity="75">
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="348" endline="357" pcid="535">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="58" endline="67" pcid="4733">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="202" endline="211" pcid="7279">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/TimeLockedTokenStorage.sol" startline="105" endline="114" pcid="7229">
    function renounceOwnership() public onlyOwner {
        emit OwnershipRenounced(owner);
        owner = address(0);
    }

    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param _newOwner The address to transfer ownership to.
     */
    function transferOwnership(address _newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/ComplianceRegistry.sol" startline="52" endline="61" pcid="1945">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="60" endline="69" pcid="2455">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="60" endline="69" pcid="6014">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="156" endline="165" pcid="5845">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="120" endline="129" pcid="5777">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/PokaToken.sol" startline="45" endline="50" pcid="5733">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }
    
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="108" endline="113" pcid="6717">
  function renounceOwnership() public onlyOwner {
    emit OwnershipRenounced(owner);
    owner = address(0);
  }
  
  function transferOwnership(address _newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/SuperMarket.sol" startline="45" endline="50" pcid="6761">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }
    
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/Oracle.sol" startline="48" endline="57" pcid="5509">
  function renounceOwnership() public onlyOwner {
    emit OwnershipRenounced(owner);
    owner = address(0);
  }

  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param _newOwner The address to transfer ownership to.
   */
  function transferOwnership(address _newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="468" endline="477" pcid="7037">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/Factory.sol" startline="60" endline="69" pcid="3432">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="475" endline="484" pcid="7921">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="408" endline="417" pcid="751">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
    * @dev Allows the current owner to transfer control of the contract to a newOwner.
    * @param newOwner The address to transfer ownership to.
    */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1576" endline="1585" pcid="1837">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="167" endline="176" pcid="808">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="210" endline="215" pcid="2323">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="108" endline="113" pcid="2231">
  function renounceOwnership() public onlyOwner {
    emit OwnershipRenounced(owner);
    owner = address(0);
  }
  
  function transferOwnership(address _newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="60" endline="69" pcid="942">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/MBA.sol" startline="150" endline="159" pcid="4711">
  function renounceOwnership() public onlyOwner {
    emit OwnershipRenounced(owner);
    owner = address(0);
  }

  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param _newOwner The address to transfer ownership to.
   */
  function transferOwnership(address _newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="167" endline="176" pcid="3763">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="173" endline="178" pcid="4656">
  function renounceOwnership() public onlyOwner {
    emit OwnershipRenounced(owner);
    owner = address(0);
  }

  function transferOwnership(address _newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="56" endline="65" pcid="7340">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/TokenSwap.sol" startline="119" endline="128" pcid="7392">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="319" endline="328" pcid="3034">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="328" endline="337" pcid="592">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/KYCRegistry.sol" startline="60" endline="69" pcid="4503">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/EthNote.sol" startline="47" endline="56" pcid="3352">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="168" endline="177" pcid="1887">
  function renounceOwnership() public onlyOwner {
    emit OwnershipTransferred(_owner, address(0));
    _owner = address(0);
  }

  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="108" endline="113" pcid="7704">
  function renounceOwnership() public onlyOwner {
    emit OwnershipRenounced(owner);
    owner = address(0);
  }
  
  function transferOwnership(address _newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="726" endline="735" pcid="4460">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="381" endline="390" pcid="7664">
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
</class>

<class classid="133" nclones="60" nlines="4" similarity="75">
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="357" endline="364" pcid="536">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/ComplianceRegistry.sol" startline="61" endline="69" pcid="1946">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="177" endline="185" pcid="1888">
  function transferOwnership(address newOwner) public onlyOwner {
    _transferOwnership(newOwner);
  }

  /**
   * @dev Transfers control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="69" endline="76" pcid="2456">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/byzbit.sol" startline="26" endline="30" pcid="1593">
	function transferOwnership (address newOwner) public onlyOwner {
		owner = newOwner;
	}
	
}
</source>
<source file="systems/smart_contracts/Dividends.sol" startline="51" endline="58" pcid="2778">
    function transferOwnership(address newOwner) public onlyOwner {
        pendingOwner = newOwner;
    }

    /**
    * @dev Allows the pendingOwner address to finalize the transfer.
    */
    function claimOwnership() public onlyPendingOwner {
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="337" endline="345" pcid="593">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="69" endline="76" pcid="943">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="328" endline="336" pcid="3035">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/SellableToken.sol" startline="127" endline="133" pcid="6471">
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    emit OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="946" endline="952" pcid="3115">
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    emit OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="69" endline="76" pcid="6015">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="165" endline="173" pcid="5846">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="129" endline="136" pcid="5778">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/AronCoin.sol" startline="216" endline="222" pcid="773">
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}
</source>
<source file="systems/smart_contracts/PokaToken.sol" startline="50" endline="54" pcid="5734">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }
   
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/SuperMarket.sol" startline="50" endline="54" pcid="6762">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }
   
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/Ownable.sol" startline="54" endline="60" pcid="5570">
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="535" endline="542" pcid="671">
    function transferOwnership(address newOwner) public onlyOwner {
        pendingOwner = newOwner;
    }

    /**
    * @dev Allows the pendingOwner address to finalize the transfer.
    */
    function claimOwnership() public onlyPendingOwner {
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="38" endline="44" pcid="6771">
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0), "Owner can't be set to zero address");
    emit OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}
</source>
<source file="systems/smart_contracts/EthNote.sol" startline="56" endline="63" pcid="3353">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/OeroToken.sol" startline="16" endline="19" pcid="5473">
        function transferOwnership(address newOwner) public onlyOwner {
            owner = newOwner;
        }
    }
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="229" endline="238" pcid="5353">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Accept ownership of the contract.
     *
     * Can only be called by the new owner.
     */
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="477" endline="485" pcid="7038">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="211" endline="219" pcid="7280">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/Factory.sol" startline="69" endline="77" pcid="3433">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="68" endline="76" pcid="8076">
  function transferOwnership(address newOwner) public onlyOwner {
      _transferOwnership(newOwner);
  }

  /**
   * @dev Transfers control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="215" endline="219" pcid="2324">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="417" endline="425" pcid="752">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
    * @dev Transfers control of the contract to a newOwner.
    * @param newOwner The address to transfer ownership to.
    */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="271" endline="276" pcid="2063">
    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0));
        candidate = newOwner;
    }

    function confirmOwnership() public {
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="176" endline="184" pcid="809">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="67" endline="74" pcid="4734">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="65" endline="73" pcid="7341">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/TokenSwap.sol" startline="128" endline="136" pcid="7393">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/KYCRegistry.sol" startline="69" endline="76" pcid="4504">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="735" endline="742" pcid="4461">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="390" endline="398" pcid="7665">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/GasStorage.sol" startline="42" endline="48" pcid="4009">
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    emit OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1585" endline="1592" pcid="1838">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/GameGold.sol" startline="39" endline="44" pcid="3984">
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    delegate = newOwner;
  }

  function confirmChangeOwnership() public {
</source>
<source file="systems/smart_contracts/Gacha.sol" startline="39" endline="45" pcid="3963">
    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0));
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }

}
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="216" endline="222" pcid="7757">
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="269" endline="278" pcid="7799">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Accept ownership of the contract.
     *
     * Can only be called by the new owner.
     */
    function acceptOwnership() public {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="176" endline="184" pcid="3764">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="484" endline="491" pcid="7922">
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     */
    function _transferOwnership(address newOwner) internal {
</source>
<source file="systems/smart_contracts/FMT.sol" startline="179" endline="185" pcid="3660">
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}
</source>
<source file="systems/smart_contracts/BRZE.sol" startline="60" endline="63" pcid="1524">
  function transferOwnership(address newOwner) onlyOwner public {
    owner = newOwner;
  }
}
</source>
<source file="systems/smart_contracts/LuckyAdvcedWoken.sol" startline="70" endline="73" pcid="4558">
    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/ICBB.sol" startline="23" endline="26" pcid="4263">
    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/MAdvcedWoken.sol" startline="70" endline="73" pcid="4597">
    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/ThpToken.sol" startline="23" endline="26" pcid="7156">
    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/MyAdvancedToken.sol" startline="19" endline="22" pcid="5260">
    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/CRYPTOMZ.sol" startline="72" endline="77" pcid="2177">
  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));
    emit OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
}
</source>
<source file="systems/smart_contracts/EJackpot.sol" startline="44" endline="49" pcid="2904">
    function transferOwnership(address newOwner) onlyOwner public {
        require(newOwner != address(0));
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/BDAM.sol" startline="82" endline="87" pcid="1113">
  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
}
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="57" endline="63" pcid="2094">
  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="152" endline="158" pcid="6083">
  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="152" endline="158" pcid="4843">
  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}
</source>
<source file="systems/smart_contracts/MpctLockupTeam.sol" startline="48" endline="53" pcid="5059">
    function transferOwnership(address newOwner) onlyOwner public {
        require(newOwner != address(0));
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/FlatPricingExt.sol" startline="43" endline="49" pcid="3631">
  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}
</source>
</class>

<class classid="134" nclones="31" nlines="4" similarity="75">
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="364" endline="369" pcid="537">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1592" endline="1597" pcid="1839">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/ATDeployer.sol" startline="184" endline="189" pcid="810">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0),"Address 0 could not be owner");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="425" endline="430" pcid="753">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0));
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="491" endline="496" pcid="7923">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="76" endline="82" pcid="8077">
  function _transferOwnership(address newOwner) internal {
      require(newOwner != address(0));
      emit OwnershipTransferred(_owner, newOwner);
      _owner = newOwner;
  }

}
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="318" endline="324" pcid="7803">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_owner, newOwner);
        _newOwner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="184" endline="189" pcid="3765">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0),"Address 0 could not be owner");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/EthNote.sol" startline="63" endline="68" pcid="3354">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/ComplianceRegistry.sol" startline="69" endline="74" pcid="1947">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0));
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="185" endline="190" pcid="1889">
  function _transferOwnership(address newOwner) internal {
    require(newOwner != address(0));
    emit OwnershipTransferred(_owner, newOwner);
    _owner = newOwner;
  }
}
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="336" endline="341" pcid="3036">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="76" endline="81" pcid="944">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/Factory.sol" startline="77" endline="82" pcid="3434">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0),"Address 0 could not be owner");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="398" endline="403" pcid="7666">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0));
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="219" endline="224" pcid="2325">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0));
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="76" endline="81" pcid="6016">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="173" endline="178" pcid="5847">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0));
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="136" endline="141" pcid="5779">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/PokaToken.sol" startline="54" endline="59" pcid="5735">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0));
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/SuperMarket.sol" startline="54" endline="59" pcid="6763">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0));
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="217" endline="229" pcid="5352">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_owner, newOwner);
        _newOwner = newOwner;
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     *
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public onlyOwner {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="485" endline="490" pcid="7039">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0),"Address 0 could not be owner");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="219" endline="224" pcid="7281">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0));
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="76" endline="81" pcid="2457">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="74" endline="79" pcid="4735">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="73" endline="78" pcid="7342">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0));
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/TokenSwap.sol" startline="136" endline="141" pcid="7394">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0));
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="345" endline="350" pcid="594">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0));
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/KYCRegistry.sol" startline="76" endline="81" pcid="4505">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="742" endline="747" pcid="4462">
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</source>
</class>

<class classid="135" nclones="2" nlines="15" similarity="73">
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="529" endline="546" pcid="548">
    function _vestedAmount(IERC20 token) private view returns (uint256) {
        uint256 currentBalance = token.balanceOf(address(this));
        uint256 totalBalance = currentBalance.add(_released[address(token)]);

        if (block.timestamp < _cliff) {
            return 0;
        } else if (block.timestamp >= _start.add(_duration) || _revoked[address(token)]) {
            return totalBalance;
        } else {
            return totalBalance.mul(block.timestamp.sub(_start)).div(_duration);
        }
    }

     /**
     * @return change the beneficiary of tokens
     */

    function _changeBeneficiary(address _newBeneficiary) internal {
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="340" endline="352" pcid="7472">
    function vestedAmount(ERC20Basic token) public view returns (uint256) {
        uint256 currentBalance = token.balanceOf(this);
        uint256 totalBalance = currentBalance.add(released[token]);

        if (block.timestamp < cliff) {
            return 0;
        } else if (block.timestamp >= start.add(duration) || revoked[token]) {
            return totalBalance;
        } else {
            return totalBalance.mul(block.timestamp.sub(start)).div(duration);
        }
    }
}
</source>
</class>

<class classid="136" nclones="41" nlines="4" similarity="75">
<source file="systems/smart_contracts/ALBToken.sol" startline="402" endline="412" pcid="598">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param owner address The address which owns the funds.
     * @param spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/CNG.sol" startline="139" endline="149" pcid="1852">
  function balanceOf(address owner) public view returns (uint256) {
    return _balances[owner];
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param owner address The address which owns the funds.
   * @param spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="228" endline="238" pcid="6731">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param owner address The address which owns the funds.
     * @param spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="358" endline="368" pcid="5689">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param owner address The address which owns the funds.
     * @param spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Comet.sol" startline="97" endline="101" pcid="1927">
  function balanceOf(address owner) public view returns (uint256) {
    return _balances[owner];
  }

  function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="270" endline="280" pcid="5855">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param owner address The address which owns the funds.
     * @param spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(
</source>
<source file="systems/smart_contracts/ProxyERC20.sol" startline="427" endline="438" pcid="5897">
    function balanceOf(address owner) public view returns (uint256) {
        // Immutable static call from target contract
        return IERC20(target).balanceOf(owner);
    }

    /**
    * @dev Function to check the amount of tokens that an owner allowed to a spender.
    * @param owner address The address which owns the funds.
    * @param spender address The address which will spend the funds.
    * @return A uint256 specifying the amount of tokens still available for the spender.
    */
    function allowance(
</source>
<source file="systems/smart_contracts/Byte.sol" startline="107" endline="111" pcid="1580">
  function balanceOf(address owner) public view returns (uint256) {
    return _ByteBalances[owner];
  }

  function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="99" endline="103" pcid="5999">
  function balanceOf(address owner) public view returns (uint256) {
    return _balances[owner];
  }

  function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="97" endline="101" pcid="6210">
  function balanceOf(address owner) public view returns (uint256) {
    return _balances[owner];
  }

  function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/ankara.sol" startline="88" endline="92" pcid="687">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="97" endline="101" pcid="7325">
  function balanceOf(address owner) public view returns (uint256) {
    return _balances[owner];
  }

  function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/magesh.sol" startline="124" endline="134" pcid="4619">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param owner address The address which owns the funds.
     * @param spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="146" endline="156" pcid="736">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    /**
    * @dev Function to check the amount of tokens that an owner allowed to a spender.
    * @param owner address The address which owns the funds.
    * @param spender address The address which will spend the funds.
    * @return A uint256 specifying the amount of tokens still available for the spender.
    */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="99" endline="103" pcid="2159">
  function balanceOf(address owner) public view returns (uint256) {
    return _balances[owner];
  }

  function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="228" endline="238" pcid="2245">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param owner address The address which owns the funds.
     * @param spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="228" endline="238" pcid="7718">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param owner address The address which owns the funds.
     * @param spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(
</source>
<source file="systems/smart_contracts/BANG.sol" startline="101" endline="105" pcid="1050">
  function balanceOf(address owner) public view returns (uint256) {
    return _balances[owner];
  }

  function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Token.sol" startline="94" endline="104" pcid="7255">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param owner address The address which owns the funds.
     * @param spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="134" endline="144" pcid="1371">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param owner address The address which owns the funds.
     * @param spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="76" endline="80" pcid="2308">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="124" endline="134" pcid="4931">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param owner address The address which owns the funds.
     * @param spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="107" endline="111" pcid="2401">
  function balanceOf(address owner) public view returns (uint256) {
    return _balances[owner];
  }

  function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="613" endline="617" pcid="2624">
  function balanceOf(address owner) public view returns (uint256) {
    return _balances[owner];
  }

  function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/BlackJack.sol" startline="90" endline="99" pcid="1337">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    /**
    * @dev Gets the locked value of specified address.
    * @param owner The address to query the locked amount of.
    * @return An uint256 representing the amount locked by the passed address.
    */
    function lockedOf(address owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="609" endline="613" pcid="2715">
  function balanceOf(address owner) public view returns (uint256) {
    return _balances[owner];
  }

  function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="144" endline="154" pcid="2745">
  function balanceOf(address owner) public view returns (uint256) {
    return _balances[owner];
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param owner address The address which owns the funds.
   * @param spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="93" endline="103" pcid="3018">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param owner address The address which owns the funds.
     * @param spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="512" endline="523" pcid="5011">
    function balanceOf(address owner) public view returns (uint256) {
        require(owner != address(0), "ERC721: balance query for the zero address");

        return _ownedTokensCount[owner].current();
    }

    /**
     * @dev Gets the owner of the specified token ID.
     * @param tokenId uint256 ID of the token to query the owner of
     * @return address currently marked as the owner of the given token ID
     */
    function ownerOf(uint256 tokenId) public view returns (address) {
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="118" endline="122" pcid="3176">
  function balanceOf(address owner) public view returns (uint256) {
    return _balances[owner];
  }

  function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="144" endline="154" pcid="4241">
  function balanceOf(address owner) public view returns (uint256) {
    return _balances[owner];
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param owner address The address which owns the funds.
   * @param spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="664" endline="674" pcid="3282">
    function balanceOf(address owner) public view returns (uint256) {
        require(owner != address(0));
        return _ownedTokensCount[owner];
    }

    /**
     * @dev Gets the owner of the specified token ID
     * @param tokenId uint256 ID of the token to query the owner of
     * @return owner address currently marked as the owner of the given token ID
     */
    function ownerOf(uint256 tokenId) public view returns (address) {
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="221" endline="230" pcid="8176">
    function balanceOf(address owner) public view returns (uint256) {
        return balances[owner];
    }

    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to `to` account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // function transfer(address _to, uint _tokens)  public receiveAllowed(_to)  returns (bool success) {
    function transfer(address _to, uint _value)  public transferAllowed(msg.sender, _to, _value) returns (bool) {
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="97" endline="101" pcid="3927">
  function balanceOf(address owner) public view returns (uint256) {
    return _balances[owner];
  }

  function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="298" endline="308" pcid="3571">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param owner address The address which owns the funds.
     * @param spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/FogCoin.sol" startline="55" endline="65" pcid="3680">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param owner address The address which owns the funds.
     * @param spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="142" endline="152" pcid="7647">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param owner address The address which owns the funds.
     * @param spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="287" endline="297" pcid="6998">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param owner address The address which owns the funds.
     * @param spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="146" endline="150" pcid="5103">
    function balanceOf(address owner) public view returns (uint256) {
        return _FOMOTokenBalances[owner];
    }

    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="321" endline="331" pcid="6336">
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param owner address The address which owns the funds.
     * @param spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="101" endline="105" pcid="1474">
  function balanceOf(address owner) public view returns (uint256) {
    return _balances[owner];
  }

  function allowance(address owner, address spender) public view returns (uint256) {
</source>
</class>

<class classid="137" nclones="22" nlines="4" similarity="75">
<source file="systems/smart_contracts/ALBToken.sol" startline="451" endline="468" pcid="602">
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
        _transfer(from, to, value);
        emit Approval(from, msg.sender, _allowed[from][msg.sender]);
        return true;
    }

    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     * approve should be called when allowed_[_spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param addedValue The amount of tokens to increase the allowance by.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/ankara.sol" startline="106" endline="112" pcid="691">
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        _transfer(from, to, value);
        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/MBA.sol" startline="468" endline="475" pcid="4729">
	function transferFrom(address from, address to, uint256 value) public returns (bool) {
	    _tryTransfered(from);
	    _tryTransfered(to);
	    
	    return super.transferFrom(from, to, value);
	}
	
	function _tryTransfered(address _who) internal {
</source>
<source file="systems/smart_contracts/magesh.sol" startline="170" endline="186" pcid="4623">
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        _transfer(from, to, value);
        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));
        return true;
    }

    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     * approve should be called when _allowed[msg.sender][spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param addedValue The amount of tokens to increase the allowance by.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Token.sol" startline="140" endline="156" pcid="7259">
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        _transfer(from, to, value);
        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));
        return true;
    }

    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     * approve should be called when _allowed[msg.sender][spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param addedValue The amount of tokens to increase the allowance by.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="193" endline="210" pcid="740">
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        require(value <= _allowed[from][msg.sender]);

        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
        _transfer(from, to, value);
        return true;
    }

    /**
    * @dev Increase the amount of tokens that an owner allowed to a spender.
    * approve should be called when allowed_[_spender] == 0. To increment
    * allowed value is better to use this function to avoid 2 calls (and wait until
    * the first transaction is mined)
    * From MonolithDAO Token.sol
    * @param spender The address which will spend the funds.
    * @param addedValue The amount of tokens to increase the allowance by.
    */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="170" endline="186" pcid="4935">
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        _transfer(from, to, value);
        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));
        return true;
    }

    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     * approve should be called when _allowed[msg.sender][spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param addedValue The amount of tokens to increase the allowance by.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="285" endline="308" pcid="6735">
    function transferFrom(
        address from,
        address to,
        uint256 value
    )
    public
    returns (bool)
    {
        require(!frozenAccount[msg.sender]);
        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
        _transfer(from, to, value);
        return true;
    }

    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     * approve should be called when allowed_[_spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * @param spender The address which will spend the funds.
     * @param addedValue The amount of tokens to increase the allowance by.
     */
    function increaseAllowance(
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="198" endline="222" pcid="4245">
  function transferFrom(
    address from,
    address to,
    uint256 value
  )
  public
  returns (bool)
  {
    require(value <= _allowed[from][msg.sender]);

    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
    _transfer(from, to, value);
    return true;
  }

  /**
   * @dev Increase the amount of tokens that an owner allowed to a spender.
   * approve should be called when allowed_[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param spender The address which will spend the funds.
   * @param addedValue The amount of tokens to increase the allowance by.
   */
  function increaseAllowance(
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="188" endline="204" pcid="7651">
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        _transfer(from, to, value);
        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));
        return true;
    }

    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     * approve should be called when _allowed[msg.sender][spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param addedValue The amount of tokens to increase the allowance by.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="285" endline="308" pcid="7722">
    function transferFrom(
        address from,
        address to,
        uint256 value
    )
    public
    returns (bool)
    {
        require(!frozenAccount[msg.sender]);
        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
        _transfer(from, to, value);
        return true;
    }

    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     * approve should be called when allowed_[_spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * @param spender The address which will spend the funds.
     * @param addedValue The amount of tokens to increase the allowance by.
     */
    function increaseAllowance(
</source>
<source file="systems/smart_contracts/FogCoin.sol" startline="97" endline="108" pcid="3684">
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        _transfer(from, to, value);
        _approve(from, msg.sender, _allowances[from][msg.sender].sub(value));
        return true;
    }

    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender. Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param addedValue The amount of tokens to increase the allowance by.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="367" endline="383" pcid="6340">
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        _transfer(from, to, value);
        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));
        return true;
    }

    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     * approve should be called when allowed_[_spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param addedValue The amount of tokens to increase the allowance by.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="347" endline="364" pcid="3575">
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
        _transfer(from, to, value);
        emit Approval(from, msg.sender, _allowed[from][msg.sender]);
        return true;
    }

    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     * approve should be called when allowed_[_spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param addedValue The amount of tokens to increase the allowance by.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="139" endline="155" pcid="3022">
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        _transfer(from, to, value);
        _approve(from, msg.sender, _allowances[from][msg.sender].sub(value));
        return true;
    }

    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     * approve should be called when _allowances[msg.sender][spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param addedValue The amount of tokens to increase the allowance by.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="198" endline="222" pcid="2749">
  function transferFrom(
    address from,
    address to,
    uint256 value
  )
    public
    returns (bool)
  {
    require(value <= _allowed[from][msg.sender]);

    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
    _transfer(from, to, value);
    return true;
  }

  /**
   * @dev Increase the amount of tokens that an owner allowed to a spender.
   * approve should be called when allowed_[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param spender The address which will spend the funds.
   * @param addedValue The amount of tokens to increase the allowance by.
   */
  function increaseAllowance(
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="97" endline="105" pcid="2312">
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        require(value <= _allowed[from][msg.sender]);

        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
        _transfer(from, to, value);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="285" endline="308" pcid="2249">
    function transferFrom(
        address from,
        address to,
        uint256 value
    )
    public
    returns (bool)
    {
        require(!frozenAccount[msg.sender]);
        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
        _transfer(from, to, value);
        return true;
    }

    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     * approve should be called when allowed_[_spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * @param spender The address which will spend the funds.
     * @param addedValue The amount of tokens to increase the allowance by.
     */
    function increaseAllowance(
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="407" endline="424" pcid="5693">
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
        _transfer(from, to, value);
        emit Approval(from, msg.sender, _allowed[from][msg.sender]);
        return true;
    }

    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     * approve should be called when allowed_[_spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param addedValue The amount of tokens to increase the allowance by.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="324" endline="348" pcid="5859">
    function transferFrom(
        address from,
        address to,
        uint256 value
    )
    public
    returns (bool)
    {
        require(value <= _allowed[from][msg.sender]);

        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
        _transfer(from, to, value);
        return true;
    }

    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     * approve should be called when allowed_[_spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * @param spender The address which will spend the funds.
     * @param addedValue The amount of tokens to increase the allowance by.
     */
    function increaseAllowance(
</source>
<source file="systems/smart_contracts/CNG.sol" startline="193" endline="217" pcid="1856">
  function transferFrom(
    address from,
    address to,
    uint256 value
  )
    public
    returns (bool)
  {
    require(value <= _allowed[from][msg.sender]);

    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
    _transfer(from, to, value);
    return true;
  }

  /**
   * @dev Increase the amount of tokens that an owner allowed to a spender.
   * approve should be called when allowed_[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param spender The address which will spend the funds.
   * @param addedValue The amount of tokens to increase the allowance by.
   */
  function increaseAllowance(
</source>
<source file="systems/smart_contracts/ProxyERC20.sol" startline="492" endline="509" pcid="5901">
    function transferFrom(
        address from,
        address to,
        uint256 value
    )
        public
        returns (bool)
    {
        // Mutable state call requires the proxy to tell the target who the msg.sender is.
        target.setMessageSender(msg.sender);

        // Forward the ERC20 call to the target contract
        IERC20(target).transferFrom(from, to, value);

        // Event emitting will occur via Synthetix.Proxy._emit()
        return true;
    }
}
</source>
</class>

<class classid="138" nclones="21" nlines="4" similarity="75">
<source file="systems/smart_contracts/ALBToken.sol" startline="500" endline="515" pcid="605">
    function _transfer(address from, address to, uint256 value) internal {
        require(to != address(0));

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }

    /**
     * @dev Internal function that mints an amount of the token and assigns it to
     * an account. This encapsulates the modification of balances such that the
     * proper events are emitted.
     * @param account The account that will receive the created tokens.
     * @param value The amount that will be created.
     */
    function _mint(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="241" endline="249" pcid="743">
    function _transfer(address from, address to, uint256 value) internal {
        require(value <= _balances[from]);
        require(to != address(0));

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }
}
</source>
<source file="systems/smart_contracts/CNG.sol" startline="262" endline="278" pcid="1859">
  function _transfer(address from, address to, uint256 value) internal {
    require(value <= _balances[from]);
    require(to != address(0));

    _balances[from] = _balances[from].sub(value);
    _balances[to] = _balances[to].add(value);
    emit Transfer(from, to, value);
  }

  /**
   * @dev Internal function that mints an amount of the token and assigns it to
   * an account. This encapsulates the modification of balances such that the
   * proper events are emitted.
   * @param account The account that will receive the created tokens.
   * @param value The amount that will be created.
   */
  function _mint(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="354" endline="369" pcid="2252">
    function _transfer(address from, address to, uint256 value) internal {        
        require(to != address(0));                        

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }

    /**
     * @dev Internal function that mints an amount of the token and assigns it to
     * an account. This encapsulates the modification of balances such that the
     * proper events are emitted.
     * @param account The account that will receive the created tokens.
     * @param value The amount that will be created.
     */
    function _mint(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="246" endline="261" pcid="1378">
    function _transfer(address from, address to, uint256 value) internal {
        require(to != address(0));

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }

    /**
     * @dev Internal function that mints an amount of the token and assigns it to
     * an account. This encapsulates the modification of balances such that the
     * proper events are emitted.
     * @param account The account that will receive the created tokens.
     * @param value The amount that will be created.
     */
    function _mint(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="121" endline="129" pcid="2315">
    function _transfer(address from, address to, uint256 value) internal {
        require(value <= _balances[from]);
        require(to != address(0));

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }
}
</source>
<source file="systems/smart_contracts/ankara.sol" startline="122" endline="130" pcid="694">
    function _transfer(address from, address to, uint256 value) internal {
        require(to != address(0));

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }

    function _mint(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="393" endline="409" pcid="5862">
    function _transfer(address from, address to, uint256 value) internal {
        require(value <= _balances[from]);
        require(to != address(0));

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }

    /**
     * @dev Internal function that mints an amount of the token and assigns it to
     * an account. This encapsulates the modification of balances such that the
     * proper events are emitted.
     * @param account The account that will receive the created tokens.
     * @param value The amount that will be created.
     */
    function _mint(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="456" endline="471" pcid="5696">
    function _transfer(address from, address to, uint256 value) internal {
        require(to != address(0));

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }

    /**
     * @dev Internal function that mints an amount of the token and assigns it to
     * an account. This encapsulates the modification of balances such that the
     * proper events are emitted.
     * @param account The account that will receive the created tokens.
     * @param value The amount that will be created.
     */
    function _mint(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="354" endline="369" pcid="6738">
    function _transfer(address from, address to, uint256 value) internal {        
        require(to != address(0));                        

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }

    /**
     * @dev Internal function that mints an amount of the token and assigns it to
     * an account. This encapsulates the modification of balances such that the
     * proper events are emitted.
     * @param account The account that will receive the created tokens.
     * @param value The amount that will be created.
     */
    function _mint(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="360" endline="374" pcid="7005">
    function _transfer(address from, address to, uint256 value) internal {
        require(to != address(0));

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }

    /**
     * @dev Approve an address to spend another addresses' tokens.
     * @param owner The address that owns the tokens.
     * @param spender The address that will spend the tokens.
     * @param value The number of tokens that can be spent.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="212" endline="227" pcid="4938">
    function _transfer(address from, address to, uint256 value) internal {
        require(to != address(0), "ERC20: transfer to the zero address");

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }

    /**
     * @dev Internal function that mints an amount of the token and assigns it to
     * an account. This encapsulates the modification of balances such that the
     * proper events are emitted.
     * @param account The account that will receive the created tokens.
     * @param value The amount that will be created.
     */
    function _mint(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/Token.sol" startline="182" endline="196" pcid="7262">
    function _transfer(address from, address to, uint256 value) internal {
        require(to != address(0), "Cannot transfer to zero address");

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }

    /**
     * @dev Approve an address to spend another addresses' tokens.
     * @param owner The address that owns the tokens.
     * @param spender The address that will spend the tokens.
     * @param value The number of tokens that can be spent.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/magesh.sol" startline="212" endline="227" pcid="4626">
    function _transfer(address from, address to, uint256 value) internal {
        require(to != address(0), "ERC20: transfer to the zero address");

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }

    /**
     * @dev Internal function that mints an amount of the token and assigns it to
     * an account. This encapsulates the modification of balances such that the
     * proper events are emitted.
     * @param account The account that will receive the created tokens.
     * @param value The amount that will be created.
     */
    function _mint(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="267" endline="283" pcid="4248">
  function _transfer(address from, address to, uint256 value) internal {
    require(value <= _balances[from]);
    require(to != address(0));

    _balances[from] = _balances[from].sub(value);
    _balances[to] = _balances[to].add(value);
    emit Transfer(from, to, value);
  }

  /**
   * @dev Internal function that mints an amount of the token and assigns it to
   * an account. This encapsulates the modification of balances such that the
   * proper events are emitted.
   * @param account The account that will receive the created tokens.
   * @param value The amount that will be created.
   */
  function _mint(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="230" endline="244" pcid="7654">
    function _transfer(address from, address to, uint256 value) internal {

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }

    /**
     * @dev Internal function that mints an amount of the token and assigns it to
     * an account. This encapsulates the modification of balances such that the
     * proper events are emitted.
     * @param account The account that will receive the created tokens.
     * @param value The amount that will be created.
     */
    function _mint(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="354" endline="369" pcid="7725">
    function _transfer(address from, address to, uint256 value) internal {        
        require(to != address(0));                        

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }

    /**
     * @dev Internal function that mints an amount of the token and assigns it to
     * an account. This encapsulates the modification of balances such that the
     * proper events are emitted.
     * @param account The account that will receive the created tokens.
     * @param value The amount that will be created.
     */
    function _mint(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="396" endline="411" pcid="3578">
    function _transfer(address from, address to, uint256 value) internal {
        require(to != address(0));

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }

    /**
     * @dev Internal function that mints an amount of the token and assigns it to
     * an account. This encapsulates the modification of balances such that the
     * proper events are emitted.
     * @param account The account that will receive the created tokens.
     * @param value The amount that will be created.
     */
    function _mint(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="409" endline="424" pcid="6343">
    function _transfer(address from, address to, uint256 value) internal {
        require(to != address(0));

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }

    /**
     * @dev Internal function that mints an amount of the token and assigns it to
     * an account. This encapsulates the modification of balances such that the
     * proper events are emitted.
     * @param account The account that will receive the created tokens.
     * @param value The amount that will be created.
     */
    function _mint(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="181" endline="196" pcid="3025">
    function _transfer(address from, address to, uint256 value) internal {
        require(to != address(0), "ERC20: transfer to the zero address");

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }

    /**
     * @dev Internal function that mints an amount of the token and assigns it to
     * an account. This encapsulates the modification of balances such that the
     * proper events are emitted.
     * @param account The account that will receive the created tokens.
     * @param value The amount that will be created.
     */
    function _mint(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="267" endline="283" pcid="2752">
  function _transfer(address from, address to, uint256 value) internal {
    require(value <= _balances[from]);
    require(to != address(0));

    _balances[from] = _balances[from].sub(value);
    _balances[to] = _balances[to].add(value);
    emit Transfer(from, to, value);
  }

  /**
   * @dev Internal function that mints an amount of the token and assigns it to
   * an account. This encapsulates the modification of balances such that the
   * proper events are emitted.
   * @param account The account that will receive the created tokens.
   * @param value The amount that will be created.
   */
  function _mint(address account, uint256 value) internal {
</source>
</class>

<class classid="139" nclones="20" nlines="4" similarity="75">
<source file="systems/smart_contracts/ALBToken.sol" startline="515" endline="529" pcid="606">
    function _mint(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.add(value);
        _balances[account] = _balances[account].add(value);
        emit Transfer(address(0), account, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account.
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ankara.sol" startline="130" endline="138" pcid="695">
    function _mint(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.add(value);
        _balances[account] = _balances[account].add(value);
        emit Transfer(address(0), account, value);
    }

    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/CNG.sol" startline="278" endline="291" pcid="1860">
  function _mint(address account, uint256 value) internal {
    require(account != 0);
    _totalSupply = _totalSupply.add(value);
    _balances[account] = _balances[account].add(value);
    emit Transfer(address(0), account, value);
  }

  /**
   * @dev Internal function that burns an amount of the token of a given
   * account.
   * @param account The account whose tokens will be burnt.
   * @param value The amount that will be burnt.
   */
  function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="409" endline="447" pcid="5863">
    function _mint(address account, uint256 value) internal {
        require(account != 0);
        _totalSupply = _totalSupply.add(value);
        _balances[account] = _balances[account].add(value);
        emit Transfer(address(0), account, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account.
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    //    function _burn(address account, uint256 value) internal {
    //        require(account != 0);
    //        require(value <= _balances[account]);
    //
    //        _totalSupply = _totalSupply.sub(value);
    //        _balances[account] = _balances[account].sub(value);
    //        emit Transfer(account, address(0), value);
    //    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account, deducting from the sender's allowance for said account. Uses the
     * internal burn function.
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    //    function _burnFrom(address account, uint256 value) internal {
    //        require(value <= _allowed[account][msg.sender]);
    //
    //        // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,
    //        // this function needs to emit an event with the updated approval.
    //        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(
    //            value);
    //        _burn(account, value);
    //    }
}
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="471" endline="485" pcid="5697">
    function _mint(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.add(value);
        _balances[account] = _balances[account].add(value);
        emit Transfer(address(0), account, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account.
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="369" endline="383" pcid="6739">
    function _mint(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.add(value);
        _balances[account] = _balances[account].add(value);
        emit Transfer(address(0), account, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account.
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="227" endline="241" pcid="4939">
    function _mint(address account, uint256 value) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(value);
        _balances[account] = _balances[account].add(value);
        emit Transfer(address(0), account, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account.
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/magesh.sol" startline="227" endline="241" pcid="4627">
    function _mint(address account, uint256 value) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(value);
        _balances[account] = _balances[account].add(value);
        emit Transfer(address(0), account, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account.
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="283" endline="296" pcid="4249">
  function _mint(address account, uint256 value) internal {
    require(account != 0);
    _totalSupply = _totalSupply.add(value);
    _balances[account] = _balances[account].add(value);
    emit Transfer(address(0), account, value);
  }

  /**
   * @dev Internal function that burns an amount of the token of a given
   * account.
   * @param account The account whose tokens will be burnt.
   * @param value The amount that will be burnt.
   */
  function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="244" endline="258" pcid="7655">
    function _mint(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.add(value);
        _balances[account] = _balances[account].add(value);
        emit Transfer(address(0), account, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account.
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="369" endline="383" pcid="7726">
    function _mint(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.add(value);
        _balances[account] = _balances[account].add(value);
        emit Transfer(address(0), account, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account.
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/SBC.sol" startline="424" endline="438" pcid="6344">
    function _mint(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.add(value);
        _balances[account] = _balances[account].add(value);
        emit Transfer(address(0), account, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account.
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/FogCoin.sol" startline="145" endline="158" pcid="3688">
    function _mint(address account, uint256 value) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(value);
        
        _balances[account] = _balances[account].add(value);
        emit Transfer(address(0), account, value);
    }

    /**
     * @dev Update Circulating Supply
     * @param totalInCirculation the total quantity of FogCoin in circulation
     */
     function _setTotalSupply(uint256 totalInCirculation) internal {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="411" endline="425" pcid="3579">
    function _mint(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.add(value);
        _balances[account] = _balances[account].add(value);
        emit Transfer(address(0), account, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account.
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="196" endline="210" pcid="3026">
    function _mint(address account, uint256 value) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(value);
        _balances[account] = _balances[account].add(value);
        emit Transfer(address(0), account, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account.
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="283" endline="296" pcid="2753">
  function _mint(address account, uint256 value) internal {
    require(account != 0);
    _totalSupply = _totalSupply.add(value);
    _balances[account] = _balances[account].add(value);
    emit Transfer(address(0), account, value);
  }

  /**
   * @dev Internal function that burns an amount of the token of a given
   * account.
   * @param account The account whose tokens will be burnt.
   * @param value The amount that will be burnt.
   */
  function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="148" endline="156" pcid="2317">
    function _mint(address account, uint256 value) internal {
        require(account != address(0));
        _totalSupply = _totalSupply.add(value);
        _balances[account] = _balances[account].add(value);
        emit Transfer(address(0), account, value);
        emit Mint(account, msg.sender, value);
    }

    event Mint(address indexed to, address indexed minter, uint256 value);
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="369" endline="383" pcid="2253">
    function _mint(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.add(value);
        _balances[account] = _balances[account].add(value);
        emit Transfer(address(0), account, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account.
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="261" endline="275" pcid="1379">
    function _mint(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.add(value);
        _balances[account] = _balances[account].add(value);
        emit Transfer(address(0), account, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account.
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burn(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="299" endline="307" pcid="745">
    function _mint(address account, uint256 value) internal {
        require(account != address(0));
        _totalSupply = _totalSupply.add(value);
        _balances[account] = _balances[account].add(value);
        emit Transfer(address(0), account, value);
        emit Mint(account, msg.sender, value);
    }

    event Mint(address indexed to, address indexed minter, uint256 value);
</source>
</class>

<class classid="140" nclones="16" nlines="4" similarity="75">
<source file="systems/smart_contracts/ALBToken.sol" startline="545" endline="550" pcid="608">
    function _burnFrom(address account, uint256 value) internal {
        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);
        _burn(account, value);
        emit Approval(account, msg.sender, _allowed[account][msg.sender]);
    }
} 
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="441" endline="446" pcid="3581">
    function _burnFrom(address account, uint256 value) internal {
        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);
        _burn(account, value);
        emit Approval(account, msg.sender, _allowed[account][msg.sender]);
    }
}
</source>
<source file="systems/smart_contracts/magesh.sol" startline="271" endline="275" pcid="4630">
    function _burnFrom(address account, uint256 value) internal {
        _burn(account, value);
        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));
    }
}
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="271" endline="275" pcid="4942">
    function _burnFrom(address account, uint256 value) internal {
        _burn(account, value);
        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));
    }
}
</source>
<source file="systems/smart_contracts/ankara.sol" startline="154" endline="158" pcid="698">
    function _burnFrom(address account, uint256 value) internal {
        _burn(account, value);
        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));
    }
}
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="288" endline="292" pcid="7658">
    function _burnFrom(address account, uint256 value) internal {
        _burn(account, value);
        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));
    }
}
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="398" endline="405" pcid="6741">
    function _burnFrom(address account, uint256 value) internal {
        // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,
        // this function needs to emit an event with the updated approval.
        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(
            value);
        _burn(account, value);
    }
}
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="501" endline="506" pcid="5699">
    function _burnFrom(address account, uint256 value) internal {
        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);
        _burn(account, value);
        emit Approval(account, msg.sender, _allowed[account][msg.sender]);
    }
}
</source>
<source file="systems/smart_contracts/SBC.sol" startline="468" endline="472" pcid="6347">
    function _burnFrom(address account, uint256 value) internal {
        _burn(account, value);
        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));
    }
}
</source>
<source file="systems/smart_contracts/FogCoin.sol" startline="198" endline="202" pcid="3692">
    function _burnFrom(address account, uint256 value) internal {
        _burn(account, value);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(value));
    }
}
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="240" endline="244" pcid="3029">
    function _burnFrom(address account, uint256 value) internal {
        _burn(account, value);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(value));
    }
}
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="312" endline="321" pcid="2755">
  function _burnFrom(address account, uint256 value) internal {
    require(value <= _allowed[account][msg.sender]);

    // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,
    // this function needs to emit an event with the updated approval.
    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(
      value);
    _burn(account, value);
  }
}
</source>
<source file="systems/smart_contracts/CNG.sol" startline="307" endline="316" pcid="1862">
  function _burnFrom(address account, uint256 value) internal {
    require(value <= _allowed[account][msg.sender]);

    // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,
    // this function needs to emit an event with the updated approval.
    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(
      value);
    _burn(account, value);
  }
}
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="312" endline="321" pcid="4251">
  function _burnFrom(address account, uint256 value) internal {
    require(value <= _allowed[account][msg.sender]);

    // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,
    // this function needs to emit an event with the updated approval.
    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(
      value);
    _burn(account, value);
  }
}
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="398" endline="405" pcid="2255">
    function _burnFrom(address account, uint256 value) internal {
        // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,
        // this function needs to emit an event with the updated approval.
        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(
            value);
        _burn(account, value);
    }
}
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="398" endline="405" pcid="7728">
    function _burnFrom(address account, uint256 value) internal {
        // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,
        // this function needs to emit an event with the updated approval.
        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(
            value);
        _burn(account, value);
    }
}
</source>
</class>

<class classid="141" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/ALBToken.sol" startline="754" endline="758" pcid="626">
    function actualBalanceOf(address _owner) public view returns (uint256 balance) {
        return super.balanceOf(_owner);
    }

    function freezingBalanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="239" endline="243" pcid="4662">
    function actualBalanceOf(address _owner) public view returns (uint256 balance) {
        return super.balanceOf(_owner);
    }

    function freezingBalanceOf(address _owner) public view returns (uint256 balance) {
</source>
</class>

<class classid="142" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/ALBToken.sol" startline="758" endline="766" pcid="627">
    function freezingBalanceOf(address _owner) public view returns (uint256 balance) {
        return freezingBalance[_owner];
    }

    /**
     * @dev gets freezing count
     * @param _addr Address of freeze tokens owner.
     */
    function freezingCount(address _addr) public view returns (uint count) {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="243" endline="247" pcid="4663">
    function freezingBalanceOf(address _owner) public view returns (uint256 balance) {
        return freezingBalance[_owner];
    }

    function freezingCount(address _addr) public view returns (uint count) {
</source>
</class>

<class classid="143" nclones="2" nlines="7" similarity="100">
<source file="systems/smart_contracts/ALBToken.sol" startline="766" endline="779" pcid="628">
    function freezingCount(address _addr) public view returns (uint count) {
        uint64 release = chains[toKey(_addr, 0)];
        while (release != 0) {
            count++;
            release = chains[toKey(_addr, release)];
        }
    }

    /**
     * @dev gets freezing end date and freezing balance for the freezing portion specified by index.
     * @param _addr Address of freeze tokens owner.
     * @param _index Freezing portion index. It ordered by release date descending.
     */
    function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="247" endline="255" pcid="4664">
    function freezingCount(address _addr) public view returns (uint count) {
        uint64 release = chains[toKey(_addr, 0)];
        while (release != 0) {
            count++;
            release = chains[toKey(_addr, release)];
        }
    }

    function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {
</source>
</class>

<class classid="144" nclones="2" nlines="11" similarity="90">
<source file="systems/smart_contracts/ALBToken.sol" startline="779" endline="797" pcid="629">
    function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {
        for (uint i = 0; i < _index + 1; i++) {
            _release = chains[toKey(_addr, _release)];
            if (_release == 0) {
                return(0, 0);
            }
        }
        _balance = freezings[toKey(_addr, _release)];
    }

    /**
     * @dev freeze your tokens to the specified address.
     *      Be careful, gas usage is not deterministic,
     *      and depends on how many freezes _to address already has.
     * @param _to Address to which token will be freeze.
     * @param _amount Amount of token to freeze.
     * @param _until Release date, must be in future.
     */
    function freezeTo(address _to, uint _amount, uint64 _until) public {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="255" endline="265" pcid="4665">
    function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {
        for (uint i = 0; i < _index + 1; i++) {
            _release = chains[toKey(_addr, _release)];
            if (_release == 0) {
                return;
            }
        }
        _balance = freezings[toKey(_addr, _release)];
    }

    function freezeTo(address _to, uint _amount, uint64 _until) public {
</source>
</class>

<class classid="145" nclones="2" nlines="13" similarity="92">
<source file="systems/smart_contracts/ALBToken.sol" startline="819" endline="847" pcid="632">
    function releaseOnce() public {
        bytes32 headKey = toKey(msg.sender, 0);
        uint64 head = chains[headKey];
        require(head != 0);
        require(uint64(block.timestamp) > head);
        bytes32 currentKey = toKey(msg.sender, head);

        uint64 next = chains[currentKey];

        uint amount = freezings[currentKey];
        delete freezings[currentKey];

        _balances[msg.sender] = _balances[msg.sender].add(amount);
        freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);

        if (next == 0) {
            delete chains[headKey];
        } else {
            chains[headKey] = next;
            delete chains[currentKey];
        }
        emit Released(msg.sender, amount);
    }

    /**
     * @dev release all available for release freezing tokens. Gas usage is not deterministic!
     * @return how many tokens was released
     */
    function releaseAll() public returns (uint tokens) {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="280" endline="304" pcid="4667">
    function releaseOnce() public {
        bytes32 headKey = toKey(msg.sender, 0);
        uint64 head = chains[headKey];
        require(head != 0);
        require(uint64(block.timestamp) > head);
        bytes32 currentKey = toKey(msg.sender, head);

        uint64 next = chains[currentKey];

        uint amount = freezings[currentKey];
        delete freezings[currentKey];

        balances[msg.sender] = balances[msg.sender].add(amount);
        freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);

        if (next == 0) {
            delete chains[headKey];
        } else {
            chains[headKey] = next;
            delete chains[currentKey];
        }
        emit Released(msg.sender, amount);
    }

    function releaseAll() public returns (uint tokens) {
</source>
</class>

<class classid="146" nclones="2" nlines="7" similarity="100">
<source file="systems/smart_contracts/ALBToken.sol" startline="847" endline="858" pcid="633">
    function releaseAll() public returns (uint tokens) {
        uint release;
        uint balance;
        (release, balance) = getFreezing(msg.sender, 0);
        while (release != 0 && block.timestamp > release) {
            releaseOnce();
            tokens += balance;
            (release, balance) = getFreezing(msg.sender, 0);
        }
    }

    function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="304" endline="315" pcid="4668">
    function releaseAll() public returns (uint tokens) {
        uint release;
        uint balance;
        (release, balance) = getFreezing(msg.sender, 0);
        while (release != 0 && block.timestamp > release) {
            releaseOnce();
            tokens += balance;
            (release, balance) = getFreezing(msg.sender, 0);
        }
    }

    function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {
</source>
</class>

<class classid="147" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/ALBToken.sol" startline="858" endline="867" pcid="634">
    function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {
        // WISH masc to increase entropy
        result = 0x5749534800000000000000000000000000000000000000000000000000000000;
        assembly {
            result := or(result, mul(_addr, 0x10000000000000000))
            result := or(result, _release)
        }
    }

    function freeze(address _to, uint64 _until) internal {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="315" endline="323" pcid="4669">
    function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {
        result = 0x5749534800000000000000000000000000000000000000000000000000000000;
        assembly {
            result := or(result, mul(_addr, 0x10000000000000000))
            result := or(result, _release)
        }
    }

    function freeze(address _to, uint64 _until) internal {
</source>
</class>

<class classid="148" nclones="2" nlines="20" similarity="100">
<source file="systems/smart_contracts/ALBToken.sol" startline="867" endline="903" pcid="635">
    function freeze(address _to, uint64 _until) internal {
        require(_until > block.timestamp);
        bytes32 key = toKey(_to, _until);
        bytes32 parentKey = toKey(_to, uint64(0));
        uint64 next = chains[parentKey];

        if (next == 0) {
            chains[parentKey] = _until;
            return;
        }

        bytes32 nextKey = toKey(_to, next);
        uint parent;

        while (next != 0 && _until > next) {
            parent = next;
            parentKey = nextKey;

            next = chains[nextKey];
            nextKey = toKey(_to, next);
        }

        if (_until == next) {
            return;
        }

        if (next != 0) {
            chains[key] = next;
        }

        chains[parentKey] = _until;
    }

    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address _token, address _to, uint _value) public onlyOwner returns (bool) {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="323" endline="355" pcid="4670">
    function freeze(address _to, uint64 _until) internal {
        require(_until > block.timestamp);
        bytes32 key = toKey(_to, _until);
        bytes32 parentKey = toKey(_to, uint64(0));
        uint64 next = chains[parentKey];

        if (next == 0) {
            chains[parentKey] = _until;
            return;
        }

        bytes32 nextKey = toKey(_to, next);
        uint parent;

        while (next != 0 && _until > next) {
            parent = next;
            parentKey = nextKey;

            next = chains[nextKey];
            nextKey = toKey(_to, next);
        }

        if (_until == next) {
            return;
        }

        if (next != 0) {
            chains[key] = next;
        }

        chains[parentKey] = _until;
    }
}
</source>
</class>

<class classid="149" nclones="5" nlines="7" similarity="85">
<source file="systems/smart_contracts/Alfa_quiz.sol" startline="9" endline="19" pcid="637">
    function Try(string _response) external payable 
    {
        require(msg.sender == tx.origin);

        if(responseHash == keccak256(_response) && msg.value > 1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }

    string public question;
</source>
<source file="systems/smart_contracts/quiz_BLZ.sol" startline="9" endline="19" pcid="5934">
    function Try(string _response) external payable 
    {
        require(msg.sender == tx.origin);

        if(responseHash == keccak256(_response) && msg.value > 1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }

    string public question;
</source>
<source file="systems/smart_contracts/En_GAME.sol" startline="9" endline="19" pcid="2940">
    function Try(string _response) external payable 
    {
        require(msg.sender == tx.origin);

        if(responseHash == keccak256(_response) && msg.value > 0.4 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }

    string public question;
</source>
<source file="systems/smart_contracts/play_IQuiz.sol" startline="9" endline="19" pcid="5663">
    function Try(string _response) external payable 
    {
        require(msg.sender == tx.origin);

        if(responseHash == keccak256(_response) && msg.value > 0.4 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }

    string public question;
</source>
<source file="systems/smart_contracts/Digital_QUIZ.sol" startline="9" endline="19" pcid="2728">
    function Try(string _response) external payable 
    {
        require(msg.sender == tx.origin);

        if(responseHash == keccak256(_response) && msg.value > 1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }

    string public question;
</source>
</class>

<class classid="150" nclones="5" nlines="7" similarity="100">
<source file="systems/smart_contracts/Alfa_quiz.sol" startline="25" endline="32" pcid="638">
    function Start(string _question, string _response) public payable isAdmin{
        if(responseHash==0x0){
            responseHash = keccak256(_response);
            question = _question;
        }
    }

    function Stop() public payable isAdmin {
</source>
<source file="systems/smart_contracts/En_GAME.sol" startline="25" endline="32" pcid="2941">
    function Start(string _question, string _response) public payable isAdmin{
        if(responseHash==0x0){
            responseHash = keccak256(_response);
            question = _question;
        }
    }

    function Stop() public payable isAdmin {
</source>
<source file="systems/smart_contracts/quiz_BLZ.sol" startline="25" endline="32" pcid="5935">
    function Start(string _question, string _response) public payable isAdmin{
        if(responseHash==0x0){
            responseHash = keccak256(_response);
            question = _question;
        }
    }

    function Stop() public payable isAdmin {
</source>
<source file="systems/smart_contracts/play_IQuiz.sol" startline="25" endline="32" pcid="5664">
    function Start(string _question, string _response) public payable isAdmin{
        if(responseHash==0x0){
            responseHash = keccak256(_response);
            question = _question;
        }
    }

    function Stop() public payable isAdmin {
</source>
<source file="systems/smart_contracts/Digital_QUIZ.sol" startline="25" endline="32" pcid="2729">
    function Start(string _question, string _response) public payable isAdmin{
        if(responseHash==0x0){
            responseHash = keccak256(_response);
            question = _question;
        }
    }

    function Stop() public payable isAdmin {
</source>
</class>

<class classid="151" nclones="5" nlines="4" similarity="100">
<source file="systems/smart_contracts/Alfa_quiz.sol" startline="32" endline="36" pcid="639">
    function Stop() public payable isAdmin {
        msg.sender.transfer(this.balance);
    }

    function New(string _question, bytes32 _responseHash) public payable isAdmin {
</source>
<source file="systems/smart_contracts/play_IQuiz.sol" startline="32" endline="36" pcid="5665">
    function Stop() public payable isAdmin {
        msg.sender.transfer(this.balance);
    }

    function New(string _question, bytes32 _responseHash) public payable isAdmin {
</source>
<source file="systems/smart_contracts/quiz_BLZ.sol" startline="32" endline="36" pcid="5936">
    function Stop() public payable isAdmin {
        msg.sender.transfer(this.balance);
    }

    function New(string _question, bytes32 _responseHash) public payable isAdmin {
</source>
<source file="systems/smart_contracts/En_GAME.sol" startline="32" endline="36" pcid="2942">
    function Stop() public payable isAdmin {
        msg.sender.transfer(this.balance);
    }

    function New(string _question, bytes32 _responseHash) public payable isAdmin {
</source>
<source file="systems/smart_contracts/Digital_QUIZ.sol" startline="32" endline="36" pcid="2730">
    function Stop() public payable isAdmin {
        msg.sender.transfer(this.balance);
    }

    function New(string _question, bytes32 _responseHash) public payable isAdmin {
</source>
</class>

<class classid="152" nclones="5" nlines="4" similarity="100">
<source file="systems/smart_contracts/Alfa_quiz.sol" startline="36" endline="41" pcid="640">
    function New(string _question, bytes32 _responseHash) public payable isAdmin {
        question = _question;
        responseHash = _responseHash;
    }

    constructor(bytes32[] admins) public{
</source>
<source file="systems/smart_contracts/quiz_BLZ.sol" startline="36" endline="41" pcid="5937">
    function New(string _question, bytes32 _responseHash) public payable isAdmin {
        question = _question;
        responseHash = _responseHash;
    }

    constructor(bytes32[] admins) public{
</source>
<source file="systems/smart_contracts/play_IQuiz.sol" startline="36" endline="41" pcid="5666">
    function New(string _question, bytes32 _responseHash) public payable isAdmin {
        question = _question;
        responseHash = _responseHash;
    }

    constructor(bytes32[] admins) public{
</source>
<source file="systems/smart_contracts/Digital_QUIZ.sol" startline="36" endline="41" pcid="2731">
    function New(string _question, bytes32 _responseHash) public payable isAdmin {
        question = _question;
        responseHash = _responseHash;
    }

    constructor(bytes32[] admins) public{
</source>
<source file="systems/smart_contracts/En_GAME.sol" startline="36" endline="41" pcid="2943">
    function New(string _question, bytes32 _responseHash) public payable isAdmin {
        question = _question;
        responseHash = _responseHash;
    }

    constructor(bytes32[] admins) public{
</source>
</class>

<class classid="153" nclones="23" nlines="4" similarity="75">
<source file="systems/smart_contracts/AMAToken.sol" startline="480" endline="487" pcid="669">
    function burn(uint256 amount) public {
        _burn(msg.sender, amount);
    }

    /**
     * @dev See `ERC20._burnFrom`.
     */
    function burnFrom(address account, uint256 amount) public {
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="315" endline="323" pcid="3000">
  function burn(uint256 amount) public {
    require(!_locked[msg.sender]);
    _burn(msg.sender, amount);
  }

  /**
   * @dev See `ERC20._burnFrom`.
   */
  function burnFrom(address account, uint256 amount) public {
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="251" endline="255" pcid="2415">
  function burn(uint256 amount) external {
    _burn(msg.sender, amount);
  }

  function _burn(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/BANG.sol" startline="194" endline="198" pcid="1061">
  function burn(uint256 amount) external {
    _burn(msg.sender, amount);
  }

  function _burn(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="197" endline="201" pcid="2169">
  function burn(uint256 amount) external {
    _burn(msg.sender, amount);
  }

  function _burn(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="221" endline="225" pcid="3187">
  function burn(uint256 amount) external {
    _burn(msg.sender, amount);
  }

  function _burn(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/EtheleToken.sol" startline="153" endline="156" pcid="3217">
    function burn(uint256 amount) public {
        _burn(msg.sender, amount);
    }
    function burnFrom(address account, uint256 amount) public {
</source>
<source file="systems/smart_contracts/Comet.sol" startline="183" endline="187" pcid="1937">
  function burn(uint256 amount) external {
    _burn(msg.sender, amount);
  }

  function _burn(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/BCCT.sol" startline="157" endline="175" pcid="1099">
    function burn(uint256 amount) public {
        _burn(msg.sender, amount);
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="107" endline="111" pcid="8055">
    function burn(uint256 amount) public {
        _burn(msg.sender, amount);
    }

    function burnFrom(address account, uint256 amount) public {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="338" endline="346" pcid="8002">
  function burn(uint256 amount) public {
    require(!_locked[msg.sender]);
    _burn(msg.sender, amount);
  }

  /**
   * @dev See `ERC20._burnFrom`.
   */
  function burnFrom(address account, uint256 amount) public {
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="200" endline="204" pcid="3938">
  function burn(uint256 amount) external {
    _burn(msg.sender, amount);
  }

  function _burn(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/GFNX.sol" startline="188" endline="195" pcid="4111">
    function burn(uint256 amount) public {
        require(_balances[msg.sender] >= amount);
        _balances[msg.sender] = _balances[msg.sender].sub(amount);
        supply = supply.sub(amount);
        emit Transfer(msg.sender, address(0), amount);
        emit Burn(msg.sender, amount);
    }
}
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="182" endline="186" pcid="7335">
  function burn(uint256 amount) external {
    _burn(msg.sender, amount);
  }

  function _burn(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/MatchingToken.sol" startline="108" endline="112" pcid="4696">
    function burn(uint256 amount) public {
        _burn(msg.sender, amount);
    }
    
    function addsupply(uint256 amount) public {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="585" endline="589" pcid="5126">
    function burn(uint256 amount) public {
        _burn(msg.sender, amount);
    }

    function _burn(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="571" endline="575" pcid="674">
    function burn(uint256 amount) public {
        require(amount > 0);
        _burn(msg.sender, amount);
    }
}
</source>
<source file="systems/smart_contracts/Byte.sol" startline="224" endline="228" pcid="1589">
  function burn(uint256 amount) external {
    _burn(msg.sender, amount);
  }

  function _burn(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="540" endline="547" pcid="5932">
    function burn(uint256 amount) public {
        _burn(msg.sender, amount);
    }

    /**
     * @dev See {ERC20-_burnFrom}.
     */
    function burnFrom(address account, uint256 amount) public {
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="184" endline="188" pcid="6009">
  function burn(uint256 amount) external {
    _burn(msg.sender, amount);
  }

  function _burn(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="183" endline="187" pcid="6220">
  function burn(uint256 amount) external {
    _burn(msg.sender, amount);
  }

  function _burn(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/RubyToken.sol" startline="108" endline="112" pcid="6237">
    function burn(uint256 amount) public {
        _burn(msg.sender, amount);
    }
    
    function addsupply(uint256 amount) public {
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="186" endline="190" pcid="1484">
  function burn(uint256 amount) external {
    _burn(msg.sender, amount);
  }

  function _burn(address account, uint256 amount) internal {
</source>
</class>

<class classid="154" nclones="6" nlines="4" similarity="75">
<source file="systems/smart_contracts/AMAToken.sol" startline="487" endline="490" pcid="670">
    function burnFrom(address account, uint256 amount) public {
        _burnFrom(account, amount);
    }
}
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="547" endline="550" pcid="5933">
    function burnFrom(address account, uint256 amount) public {
        _burnFrom(account, amount);
    }
}
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="466" endline="470" pcid="5799">
    function burnFrom(address account, uint256 amount) public {
        burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
    }
}
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="346" endline="360" pcid="8003">
  function burnFrom(address account, uint256 amount) public {
    require(!_locked[msg.sender]);
    require(!_locked[account]);
    _burnFrom(account, amount);
  }

  /**
   * @dev See `IERC20.transfer`.
   *
   * Requirements:
   *
   * - `recipient` cannot be the zero address.
   * - the caller must have a balance of at least `amount`.
   */
  function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="111" endline="115" pcid="8056">
    function burnFrom(address account, uint256 amount) public {
        _burnFrom(account, amount);
    }

    function balanceOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/ERC20.sol" startline="323" endline="336" pcid="3001">
  function burnFrom(address account, uint256 amount) public {
    require(!_locked[msg.sender]);
    _burnFrom(account, amount);
  }

  /**
   * @dev See `IERC20.transfer`.
   *
   * Requirements:
   *
   * - `recipient` cannot be the zero address.
   * - the caller must have a balance of at least `amount`.
   */
  function transfer(address recipient, uint256 amount) public returns (bool) {
</source>
</class>

<class classid="155" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/AMAToken.sol" startline="542" endline="547" pcid="672">
    function claimOwnership() public onlyPendingOwner {
        emit OwnershipTransferred(owner, pendingOwner);
        owner = pendingOwner;
        pendingOwner = address(0);
    }
}
</source>
<source file="systems/smart_contracts/Dividends.sol" startline="58" endline="63" pcid="2779">
    function claimOwnership() public onlyPendingOwner {
        emit OwnershipTransferred(owner, pendingOwner);
        owner = pendingOwner;
        pendingOwner = address(0);
    }
}
</source>
</class>

<class classid="156" nclones="2" nlines="5" similarity="100">
<source file="systems/smart_contracts/AoraCoin.sol" startline="267" endline="277" pcid="744">
    function _burn(address account, uint256 value) internal {
        require(account != address(0));
        require(value <= _balances[account]);

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
        emit Burn(account, msg.sender, value);
    }

    event Burn(address indexed from, address indexed burner, uint256 value);
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="133" endline="143" pcid="2316">
    function _burn(address account, uint256 value) internal {
        require(account != address(0));
        require(value <= _balances[account]);

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
        emit Burn(account, msg.sender, value);
    }

    event Burn(address indexed from, address indexed burner, uint256 value);
</source>
</class>

<class classid="157" nclones="9" nlines="4" similarity="75">
<source file="systems/smart_contracts/AoraCoin.sol" startline="446" endline="450" pcid="754">
    function burn(uint value) public onlyOwner {
        _burn(msg.sender, value);
    }

    function mint(address to, uint value) public onlyOwner { 
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="236" endline="240" pcid="2326">
    function burn(uint value) public onlyOwner {
        _burn(msg.sender, value);
    }

    function mint(address to, uint value) public onlyOwner { 
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="412" endline="421" pcid="6742">
    function burn(uint256 value) public {
        _burn(msg.sender, value);
    }

    /**
     * @dev Burns a specific amount of tokens from the target address and decrements allowance
     * @param from address The address which you want to send tokens from
     * @param value uint256 The amount of token to be burned
     */
    function burnFrom(address from, uint256 value) public {
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="440" endline="449" pcid="4261">
  function burn(uint256 value) public {
    _burn(msg.sender, value);
  }

  /**
   * @dev Burns a specific amount of tokens from the target address and decrements allowance
   * @param from address The address which you want to send tokens from
   * @param value uint256 The amount of token to be burned
   */
  function burnFrom(address from, uint256 value) public {
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="382" endline="391" pcid="2759">
  function burn(uint256 value) public {
    _burn(msg.sender, value);
  }

  /**
   * @dev Burns a specific amount of tokens from the target address and decrements allowance
   * @param from address The address which you want to send tokens from
   * @param value uint256 The amount of token to be burned
   */
  function burnFrom(address from, uint256 value) public {
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="256" endline="265" pcid="3030">
    function burn(uint256 value) public {
        _burn(msg.sender, value);
    }

    /**
     * @dev Burns a specific amount of tokens from the target address and decrements allowance.
     * @param from address The account whose tokens will be burned.
     * @param value uint256 The amount of token to be burned.
     */
    function burnFrom(address from, uint256 value) public {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="412" endline="421" pcid="7729">
    function burn(uint256 value) public {
        _burn(msg.sender, value);
    }

    /**
     * @dev Burns a specific amount of tokens from the target address and decrements allowance
     * @param from address The address which you want to send tokens from
     * @param value uint256 The amount of token to be burned
     */
    function burnFrom(address from, uint256 value) public {
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="506" endline="511" pcid="3587">
    function burn(uint256 value) public onlyAdmin {
        _burn(msg.sender, value);
    }

    /// @dev Admin-only function to recover any tokens mistakenly sent to this contract
    function recoverERC20Tokens(address _contractAddress) external onlyAdmin  {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="412" endline="421" pcid="2256">
    function burn(uint256 value) public {
        _burn(msg.sender, value);
    }

    /**
     * @dev Burns a specific amount of tokens from the target address and decrements allowance
     * @param from address The address which you want to send tokens from
     * @param value uint256 The amount of token to be burned
     */
    function burnFrom(address from, uint256 value) public {
</source>
</class>

<class classid="158" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/AoraCoin.sol" startline="450" endline="453" pcid="755">
    function mint(address to, uint value) public onlyOwner { 
        _mint(to, value);
    }
}
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="240" endline="243" pcid="2327">
    function mint(address to, uint value) public onlyOwner { 
        _mint(to, value);
    }
}
</source>
</class>

<class classid="159" nclones="24" nlines="4" similarity="75">
<source file="systems/smart_contracts/AronCoin.sol" startline="79" endline="95" pcid="765">
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/SellableToken.sol" startline="53" endline="63" pcid="6464">
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  function balanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/SistContract.sol" startline="77" endline="93" pcid="6522">
  function transfer(address _to, uint256 _value) public returns (bool) {
	require(_to != address(0));
    require(balances[msg.sender] >= _value);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/CRYPTOMZ.sol" startline="105" endline="120" pcid="2180">
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) public constant returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/Six.sol" startline="147" endline="168" pcid="6535">
  function transfer(address _to, uint256 _value) public returns (bool){

      require(_to != address(0));
      require(_value <= balanceOf[msg.sender]);
      balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
      balanceOf[_to] = balanceOf[_to].add(_value);
      emit Transfer(msg.sender, _to, _value);
      return true;
  }


/**
* Transfer tokens from other address
*
* Send `_value` tokens to `_to` on behalf of `_from`
*
* @param _from The address of the sender
* @param _to The address of the recipient
* @param _value the amount to send
*/

function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/NBToken.sol" startline="121" endline="135" pcid="5305">
    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        require(_value <= balances[msg.sender]);
        // SafeMath.sub will throw if there is not enough balance.
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }
    /**
     * @dev Gets the balance of the specified address.
     * @param _owner The address to query the the balance of.
     * @return An uint256 representing the amount owned by the passed address.
     */
    function balanceOf(address _owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/NaorisToken.sol" startline="89" endline="105" pcid="5285">
    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        require(_value <= balances[msg.sender]);

        // SafeMath.sub will throw if there is not enough balance.
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    /**
    * @dev Gets the balance of the specified address.
    * @param _owner The address to query the the balance of.
    * @return An uint256 representing the amount owned by the passed address.
    */
    function balanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/MBA.sol" startline="81" endline="96" pcid="4706">
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="53" endline="63" pcid="4646">
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  function balanceOf(address _owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/BDAM.sol" startline="146" endline="163" pcid="1120">
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(canTransfer(msg.sender));
    

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) public constant returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/LuckyStrikeTokens.sol" startline="213" endline="218" pcid="4578">
    function transfer(address _to, uint256 _value) public returns (bool){
        return transferFrom(msg.sender, _to, _value);
    }

    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#transferfrom
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool){
</source>
<source file="systems/smart_contracts/TorexToken.sol" startline="98" endline="113" pcid="7411">
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/customIcoToken.sol" startline="117" endline="131" pcid="2219">
    function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
    }

    /* Crowdsale methods */

    /// @dev Accepts ether and creates new tokens.
    function createTokens() payable external {
</source>
<source file="systems/smart_contracts/LBBT.sol" startline="71" endline="81" pcid="4542">
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  function balanceOf(address _owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="89" endline="105" pcid="7456">
    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        require(_value <= balances[msg.sender]);

        // SafeMath.sub will throw if there is not enough balance.
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    /**
    * @dev Gets the balance of the specified address.
    * @param _owner The address to query the the balance of.
    * @return An uint256 representing the amount owned by the passed address.
    */
    function balanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/Fk.sol" startline="147" endline="168" pcid="3623">
  function transfer(address _to, uint256 _value) public returns (bool){

  	require(_to != address(0));
  	require(_value <= balanceOf[msg.sender]);
  	balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
  	balanceOf[_to] = balanceOf[_to].add(_value);
  	emit Transfer(msg.sender, _to, _value);
  	return true;
  }


/**
* Transfer tokens from other address
*
* Send `_value` tokens to `_to` on behalf of `_from`
*
* @param _from The address of the sender
* @param _to The address of the recipient
* @param _value the amount to send 
*/

function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/FMT.sol" startline="42" endline="58" pcid="3652">
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="105" endline="115" pcid="2051">
    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        require(_value <= balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }
  
    function balanceOf(address _owner) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/CDS.sol" startline="404" endline="416" pcid="1678">
  function transfer(
    address _to,
    uint256 _value
  )
    public
    returns (bool)
  {
    frozenCheck(msg.sender);
    frozenCheck(_to);
    return super.transfer(_to, _value);
  }

  function transferFrom(
</source>
<source file="systems/smart_contracts/UTC.sol" startline="94" endline="110" pcid="7579">
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="79" endline="95" pcid="7749">
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/CoinDDC.sol" startline="40" endline="60" pcid="1864">
    function transfer(
        address _to, 
        uint256 _value
    ) 
    public 
    returns (bool) 
    {
        require(_to != address(0));
        require(_value <= balances[msg.sender]);

        balances[msg.sender] = sub(balances[msg.sender],_value);

            

        balances[_to] = add(balances[_to], _value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    mapping (address => mapping (address => uint256)) internal allowed;
</source>
<source file="systems/smart_contracts/CDS.sol" startline="202" endline="221" pcid="1664">
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
   * Beware that changing an allowance with this method brings the risk that someone may use both the old
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   * @param _spender The address which will spend the funds.
   * @param _value The amount of tokens to be spent.
   */
  function approve(address _spender, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/GameGold.sol" startline="226" endline="245" pcid="4000">
  function transfer(address _to, uint256 _value)
  onlyPayloadSize(2 * 32)
  checkTokenTransfer(msg.sender)
  public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) public view returns (uint256 balance) {
</source>
</class>

<class classid="160" nclones="13" nlines="5" similarity="80">
<source file="systems/smart_contracts/AronCoin.sol" startline="119" endline="141" pcid="767">
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }

  /**
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
   *
   * Beware that changing an allowance with this method brings the risk that someone may use both the old
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   * @param _spender The address which will spend the funds.
   * @param _value The amount of tokens to be spent.
   */
  function approve(address _spender, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="87" endline="106" pcid="4651">
  function transferFrom(
    address _from,
    address _to,
    uint256 _value
  )
    public
    returns (bool)
  {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
  }

  function approve(address _spender, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/MBA.sol" startline="245" endline="273" pcid="4720">
  function transferFrom(
    address _from,
    address _to,
    uint256 _value
  )
    public
    returns (bool)
  {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
  }

  /**
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
   * Beware that changing an allowance with this method brings the risk that someone may use both the old
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   * @param _spender The address which will spend the funds.
   * @param _value The amount of tokens to be spent.
   */
  function approve(address _spender, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="126" endline="146" pcid="2053">
    function transferFrom(
        address _from,
        address _to,
        uint256 _value
    )
        public
        returns (bool)
    {
        require(_to != address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }


    function approve(address _spender, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/CDS.sol" startline="233" endline="261" pcid="1666">
  function transferFrom(
    address _from,
    address _to,
    uint256 _value
  )
    public
    returns (bool)
  {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
  }

  /**
   * @dev Increase the amount of tokens that an owner allowed to a spender.
   * approve should be called when allowed[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _addedValue The amount of tokens to increase the allowance by.
   */
  function increaseApproval(
</source>
<source file="systems/smart_contracts/SellableToken.sol" startline="72" endline="84" pcid="6466">
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
  }

  function approve(address _spender, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/NaorisToken.sol" startline="138" endline="160" pcid="5290">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     *
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param _spender The address which will spend the funds.
     * @param _value The amount of tokens to be spent.
     */
    function approve(address _spender, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="119" endline="141" pcid="7751">
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }

  /**
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
   *
   * Beware that changing an allowance with this method brings the risk that someone may use both the old
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   * @param _spender The address which will spend the funds.
   * @param _value The amount of tokens to be spent.
   */
  function approve(address _spender, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/TorexToken.sol" startline="190" endline="219" pcid="7418">
  function transferFrom(
    address _from,
    address _to,
    uint256 _value
  )
    public
    returns (bool)
  {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
  }

  /**
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
   *
   * Beware that changing an allowance with this method brings the risk that someone may use both the old
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   * @param _spender The address which will spend the funds.
   * @param _value The amount of tokens to be spent.
   */
  function approve(address _spender, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="138" endline="160" pcid="7461">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     *
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param _spender The address which will spend the funds.
     * @param _value The amount of tokens to be spent.
     */
    function approve(address _spender, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/FMT.sol" startline="75" endline="97" pcid="3654">
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }

  /**
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
   *
   * Beware that changing an allowance with this method brings the risk that someone may use both the old
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   * @param _spender The address which will spend the funds.
   * @param _value The amount of tokens to be spent.
   */
  function approve(address _spender, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/customIcoToken.sol" startline="82" endline="94" pcid="2215">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/GameGold.sol" startline="255" endline="270" pcid="4002">
  function transferFrom(address _from, address _to, uint256 _value)
  onlyPayloadSize(3 * 32)
  checkTokenTransfer(_from)
  public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
  }

  function approve(address _spender, uint256 _value)
</source>
</class>

<class classid="161" nclones="27" nlines="4" similarity="75">
<source file="systems/smart_contracts/AronCoin.sol" startline="163" endline="169" pcid="770">
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="143" endline="149" pcid="1723">
    function increaseApproval(address _spender, uint _addedValue) public returns (bool success) {
        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }

    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success) {
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="163" endline="169" pcid="7754">
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/FMT.sol" startline="123" endline="139" pcid="3657">
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  /**
   * @dev Decrease the amount of tokens that an owner allowed to a spender.
   *
   * approve should be called when allowed[_spender] == 0. To decrement
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _subtractedValue The amount of tokens to decrease the allowance by.
   */
  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/UTC.sol" startline="196" endline="212" pcid="7587">
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  /**
   * @dev Decrease the amount of tokens that an owner allowed to a spender.
   *
   * approve should be called when allowed[_spender] == 0. To decrement
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _subtractedValue The amount of tokens to decrease the allowance by.
   */
  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="306" endline="323" pcid="8090">
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    _allowed[msg.sender][_spender] = _allowed[msg.sender][_spender].add(_addedValue);
    emit Approval(msg.sender, _spender, _allowed[msg.sender][_spender]);
    return true;
  }



  /**
   * @dev Decrease the amount of tokens that an owner _allowed to a spend.
   *
   * approve should be called when _allowed[_spender] == 0. To decrement
   * _allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)   
   * @param _spender The address which will spend the funds.
   * @param _subtractedValue The amount of tokens to decrease the allowance by.
   */
  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/TorexToken.sol" startline="252" endline="275" pcid="7421">
  function increaseApproval(
    address _spender,
    uint _addedValue
  )
    public
    returns (bool)
  {
    allowed[msg.sender][_spender] = (
      allowed[msg.sender][_spender].add(_addedValue));
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  /**
   * @dev Decrease the amount of tokens that an owner allowed to a spender.
   *
   * approve should be called when allowed[_spender] == 0. To decrement
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _subtractedValue The amount of tokens to decrease the allowance by.
   */
  function decreaseApproval(
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="123" endline="136" pcid="4654">
  function increaseApproval(
    address _spender,
    uint _addedValue
  )
    public
    returns (bool)
  {
    allowed[msg.sender][_spender] = (
      allowed[msg.sender][_spender].add(_addedValue));
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  function decreaseApproval(
</source>
<source file="systems/smart_contracts/BlockPoolToken.sol" startline="218" endline="233" pcid="1424">
    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }
    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     *
     * approve should be called when allowed[_spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * @param _spender The address which will spend the funds.
     * @param _subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/NBToken.sol" startline="216" endline="231" pcid="5313">
    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }
    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     *
     * approve should be called when allowed[_spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * @param _spender The address which will spend the funds.
     * @param _subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="247" endline="253" pcid="6788">
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Ownable.sol" startline="134" endline="141" pcid="5575">
    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }


    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/SistContract.sol" startline="167" endline="183" pcid="6527">
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  /**
   * @dev Decrease the amount of tokens that an owner allowed to a spender.
   *
   * approve should be called when allowed[_spender] == 0. To decrement
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _subtractedValue The amount of tokens to decrease the allowance by.
   */
  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/SellableToken.sol" startline="94" endline="100" pcid="6469">
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="165" endline="179" pcid="2056">
    function increaseApproval(
        address _spender,
        uint _addedValue
    )
    public
    returns (bool)
    {
        allowed[msg.sender][_spender] = (
        allowed[msg.sender][_spender].add(_addedValue));
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }


    function decreaseApproval(
</source>
<source file="systems/smart_contracts/customIcoToken.sol" startline="100" endline="106" pcid="2217">
    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }

    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/CST_TOKEN.sol" startline="102" endline="108" pcid="2206">
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/BDAM.sol" startline="246" endline="253" pcid="1128">
  function increaseApproval (address _spender, uint _addedValue)
    returns (bool success) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  function decreaseApproval (address _spender, uint _subtractedValue)
</source>
<source file="systems/smart_contracts/NaorisToken.sol" startline="182" endline="188" pcid="5293">
    function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {
        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }

    function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {
</source>
<source file="systems/smart_contracts/CRYPTOMZ.sol" startline="198" endline="205" pcid="2188">
  function increaseApproval (address _spender, uint _addedValue) public
    returns (bool success) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  function decreaseApproval (address _spender, uint _subtractedValue) public
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="182" endline="188" pcid="7464">
    function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {
        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }

    function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {
</source>
<source file="systems/smart_contracts/LBBT.sol" startline="103" endline="116" pcid="4546">
  function increaseApproval(
    address _spender,
    uint256 _addedValue
  )
    public
    returns (bool)
  {
    allowed[msg.sender][_spender] = (
      allowed[msg.sender][_spender].add(_addedValue));
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  function decreaseApproval(
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="621" endline="643" pcid="6628">
	function increaseApproval(
		address _spender,
		uint256 _addedValue
	)
	public
	returns (bool)
	{
		allowed[msg.sender][_spender] = (
		allowed[msg.sender][_spender].add(_addedValue));
		emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
		return true;
	}

	/**
	* @dev Decrease the amount of tokens that an owner allowed to a spender.
	* approve should be called when allowed[_spender] == 0. To decrement
	* allowed value is better to use this function to avoid 2 calls (and wait until
	* the first transaction is mined)
	* From MonolithDAO Token.sol
	* @param _spender The address which will spend the funds.
	* @param _subtractedValue The amount of tokens to decrease the allowance by.
	*/
	function decreaseApproval(
</source>
<source file="systems/smart_contracts/MBA.sol" startline="305" endline="327" pcid="4723">
  function increaseApproval(
    address _spender,
    uint256 _addedValue
  )
    public
    returns (bool)
  {
    allowed[msg.sender][_spender] = (
      allowed[msg.sender][_spender].add(_addedValue));
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  /**
   * @dev Decrease the amount of tokens that an owner allowed to a spender.
   * approve should be called when allowed[_spender] == 0. To decrement
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _subtractedValue The amount of tokens to decrease the allowance by.
   */
  function decreaseApproval(
</source>
<source file="systems/smart_contracts/CDS.sol" startline="261" endline="282" pcid="1667">
  function increaseApproval(
    address _spender,
    uint256 _addedValue
  )
    public
    returns (bool)
  {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  /**
   * @dev Decrease the amount of tokens that an owner allowed to a spender.
   * approve should be called when allowed[_spender] == 0. To decrement
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _subtractedValue The amount of tokens to decrease the allowance by.
   */
  function decreaseApproval(
</source>
<source file="systems/smart_contracts/GoldenRings.sol" startline="136" endline="143" pcid="4180">
    function increaseApproval(address _spender, uint256 _addedValue) public returns (bool success) {
        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);

        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }

    function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool success) {
</source>
<source file="systems/smart_contracts/CoinDDC.sol" startline="111" endline="123" pcid="1868">
    function increaseApproval(
        address _spender,
        uint256 _addedValue
    )
    public
    returns (bool)
    {
        allowed[msg.sender][_spender] = add(allowed[msg.sender][_spender], _addedValue);
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }

    function decreaseApproval(
</source>
</class>

<class classid="162" nclones="26" nlines="12" similarity="75">
<source file="systems/smart_contracts/AronCoin.sol" startline="169" endline="180" pcid="771">
  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

}
</source>
<source file="systems/smart_contracts/NBToken.sol" startline="231" endline="241" pcid="5314">
    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
            allowed[msg.sender][_spender] = 0;
        } else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/Ownable.sol" startline="141" endline="153" pcid="5576">
    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
          allowed[msg.sender][_spender] = 0;
        } else {
          allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
     }
    

    function getBalance(address _a) internal constant returns(uint256)
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="253" endline="264" pcid="6789">
  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

}
</source>
<source file="systems/smart_contracts/FMT.sol" startline="139" endline="150" pcid="3658">
  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

}
</source>
<source file="systems/smart_contracts/UTC.sol" startline="212" endline="223" pcid="7588">
  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

}
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="169" endline="180" pcid="7755">
  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

}
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="149" endline="160" pcid="1724">
    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success) {
        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
            allowed[msg.sender][_spender] = 0;
        } else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }

}
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="188" endline="198" pcid="7465">
    function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {
        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
            allowed[msg.sender][_spender] = 0;
        } else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/TorexToken.sol" startline="275" endline="292" pcid="7422">
  function decreaseApproval(
    address _spender,
    uint _subtractedValue
  )
    public
    returns (bool)
  {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

}
</source>
<source file="systems/smart_contracts/CDS.sol" startline="282" endline="303" pcid="1668">
  function decreaseApproval(
    address _spender,
    uint256 _subtractedValue
  )
    public
    returns (bool)
  {
    uint256 oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue >= oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  /**
   * @dev Burns a specific amount of tokens.
   * @param _value The amount of token to be burned.
   */
  function burn(uint256 _value) public {
</source>
<source file="systems/smart_contracts/SellableToken.sol" startline="100" endline="111" pcid="6470">
  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

}
</source>
<source file="systems/smart_contracts/CRYPTOMZ.sol" startline="205" endline="216" pcid="2189">
  function decreaseApproval (address _spender, uint _subtractedValue) public
    returns (bool success) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
}
</source>
<source file="systems/smart_contracts/NaorisToken.sol" startline="188" endline="198" pcid="5294">
    function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {
        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
            allowed[msg.sender][_spender] = 0;
        } else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="179" endline="196" pcid="2057">
    function decreaseApproval(
        address _spender,
        uint _subtractedValue
    )
        public
        returns (bool)
    {
        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
            allowed[msg.sender][_spender] = 0;
        } else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }

}
</source>
<source file="systems/smart_contracts/MBA.sol" startline="327" endline="344" pcid="4724">
  function decreaseApproval(
    address _spender,
    uint256 _subtractedValue
  )
    public
    returns (bool)
  {
    uint256 oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

}
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="136" endline="153" pcid="4655">
  function decreaseApproval(
    address _spender,
    uint _subtractedValue
  )
    public
    returns (bool)
  {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

}
</source>
<source file="systems/smart_contracts/LBBT.sol" startline="116" endline="133" pcid="4547">
  function decreaseApproval(
    address _spender,
    uint256 _subtractedValue
  )
    public
    returns (bool)
  {
    uint256 oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

}
</source>
<source file="systems/smart_contracts/BDAM.sol" startline="253" endline="264" pcid="1129">
  function decreaseApproval (address _spender, uint _subtractedValue)
    returns (bool success) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
}
</source>
<source file="systems/smart_contracts/SistContract.sol" startline="183" endline="194" pcid="6528">
  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

}
</source>
<source file="systems/smart_contracts/CST_TOKEN.sol" startline="108" endline="118" pcid="2207">
  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
}
</source>
<source file="systems/smart_contracts/BlockPoolToken.sol" startline="233" endline="243" pcid="1425">
    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
            allowed[msg.sender][_spender] = 0;
        } else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/customIcoToken.sol" startline="106" endline="117" pcid="2218">
    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
            allowed[msg.sender][_spender] = 0;
        } else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
  }

    function transfer(address _to, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="643" endline="660" pcid="6629">
	function decreaseApproval(
		address _spender,
		uint256 _subtractedValue
	)
	public
	returns (bool)
	{
		uint256 oldValue = allowed[msg.sender][_spender];
		if (_subtractedValue > oldValue) {
			allowed[msg.sender][_spender] = 0;
		} else {
			allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
		}
		emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
		return true;
	}

}
</source>
<source file="systems/smart_contracts/GoldenRings.sol" startline="143" endline="155" pcid="4181">
    function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool success) {
        uint256 oldValue = allowed[msg.sender][_spender];

        if (_subtractedValue > oldValue) {
          allowed[msg.sender][_spender] = 0;
        } else {
          allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }

        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/CoinDDC.sol" startline="123" endline="150" pcid="1869">
    function decreaseApproval(
        address _spender,
        uint256 _subtractedValue
    )
    public
    returns (bool)
    {
        uint256 oldValue = allowed[msg.sender][_spender];

        if (_subtractedValue > oldValue) {
            allowed[msg.sender][_spender] = 0;
        } 
        else 
        {
            allowed[msg.sender][_spender] = sub(oldValue, _subtractedValue);
        }
        
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }

    
    

     
    

    modifier admin_only()
</source>
</class>

<class classid="163" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/AronCoin.sol" startline="255" endline="264" pcid="774">
  function pause(bool newPausedPublic, bool newPausedOwnerAdmin) onlyOwner public {
    require(!(newPausedPublic == false && newPausedOwnerAdmin == true));

    pausedPublic = newPausedPublic;
    pausedOwnerAdmin = newPausedOwnerAdmin;

    PausePublic(newPausedPublic);
    PauseOwnerAdmin(newPausedOwnerAdmin);
  }
}
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="255" endline="264" pcid="7758">
  function pause(bool newPausedPublic, bool newPausedOwnerAdmin) onlyOwner public {
    require(!(newPausedPublic == false && newPausedOwnerAdmin == true));

    pausedPublic = newPausedPublic;
    pausedOwnerAdmin = newPausedOwnerAdmin;

    PausePublic(newPausedPublic);
    PauseOwnerAdmin(newPausedOwnerAdmin);
  }
}
</source>
</class>

<class classid="164" nclones="11" nlines="4" similarity="75">
<source file="systems/smart_contracts/AronCoin.sol" startline="268" endline="272" pcid="775">
  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
    return super.transfer(_to, _value);
  }

  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="268" endline="272" pcid="7759">
  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
    return super.transfer(_to, _value);
  }

  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="682" endline="687" pcid="7100">
    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
        require(checkTransferAllowed(msg.sender, _to, _value) == STATUS_ALLOWED, "transfer must be allowed");
        return ERC20.transfer(_to, _value);
    }

    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="572" endline="576" pcid="6817">
    function transfer(address _to, uint _value) public validDestination(_to) returns (bool) {
        return super.transfer(_to, _value);
    }

    function transferFrom(address _from, address _to, uint _value) public validDestination(_to) returns (bool) {
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="268" endline="272" pcid="6790">
  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
    return super.transfer(_to, _value);
  }

  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1277" endline="1282" pcid="6149">
  function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {
    // Call StandardToken.transfer()
   return super.transfer(_to, _value);
  }

  function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="313" endline="318" pcid="7765">
    function transfer(address _to, uint _value) validDestination(_to) returns (bool) 
    {
        return super.transfer(_to, _value);
    }

    function transferFrom(address _from, address _to, uint _value) validDestination(_to) returns (bool) 
</source>
<source file="systems/smart_contracts/CDS.sol" startline="334" endline="345" pcid="1671">
  function transfer(
    address _to,
    uint256 _value
  )
    public
    whenNotPaused
    returns (bool)
  {
    return super.transfer(_to, _value);
  }

  function transferFrom(
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="460" endline="465" pcid="2123">
  function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {
    // Call StandardToken.transfer()
   return super.transfer(_to, _value);
  }

  function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="682" endline="687" pcid="3845">
    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
        require(checkTransferAllowed(msg.sender, _to, _value) == STATUS_ALLOWED, "transfer must be allowed");
        return ERC20.transfer(_to, _value);
    }

    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/AronCoin.sol" startline="313" endline="318" pcid="781">
    function transfer(address _to, uint _value) validDestination(_to) returns (bool) 
    {
        return super.transfer(_to, _value);
    }

    function transferFrom(address _from, address _to, uint _value) validDestination(_to) returns (bool) 
</source>
</class>

<class classid="165" nclones="12" nlines="4" similarity="75">
<source file="systems/smart_contracts/AronCoin.sol" startline="272" endline="276" pcid="776">
  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
    return super.transferFrom(_from, _to, _value);
  }

  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/CDS.sol" startline="345" endline="357" pcid="1672">
  function transferFrom(
    address _from,
    address _to,
    uint256 _value
  )
    public
    whenNotPaused
    returns (bool)
  {
    return super.transferFrom(_from, _to, _value);
  }

  function approve(
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="465" endline="470" pcid="2124">
  function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {
    // Call StandardToken.transferForm()
    return super.transferFrom(_from, _to, _value);
  }

}
</source>
<source file="systems/smart_contracts/AronCoin.sol" startline="318" endline="323" pcid="782">
    function transferFrom(address _from, address _to, uint _value) validDestination(_to) returns (bool) 
    {
        return super.transferFrom(_from, _to, _value);
    }

    event Burn(address indexed _burner, uint _value);
</source>
<source file="systems/smart_contracts/CDS.sol" startline="416" endline="429" pcid="1679">
  function transferFrom(
    address _from,
    address _to,
    uint256 _value
  )
    public
    whenNotPaused
    returns (bool)
  {
    frozenCheck(_from);
    frozenCheck(_to);
    return super.transferFrom(_from, _to, _value);
  }
}
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1282" endline="1287" pcid="6150">
  function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {
    // Call StandardToken.transferForm()
    return super.transferFrom(_from, _to, _value);
  }

}
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="272" endline="276" pcid="6791">
  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
    return super.transferFrom(_from, _to, _value);
  }

  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="576" endline="580" pcid="6818">
    function transferFrom(address _from, address _to, uint _value) public validDestination(_to) returns (bool) {
        return super.transferFrom(_from, _to, _value);
    }

    event Burn(address indexed _burner, uint _value);
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="687" endline="692" pcid="7101">
    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
        require(checkTransferFromAllowed(_from, _to, _value) == STATUS_ALLOWED, "transfer must be allowed");
        return ERC20.transferFrom(_from, _to,_value);
    }

    function mint(address _account, uint256 _amount) public whenNotPaused onlyMinterAddress {
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="272" endline="276" pcid="7760">
  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
    return super.transferFrom(_from, _to, _value);
  }

  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="318" endline="323" pcid="7766">
    function transferFrom(address _from, address _to, uint _value) validDestination(_to) returns (bool) 
    {
        return super.transferFrom(_from, _to, _value);
    }

    event Burn(address indexed _burner, uint _value);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="687" endline="692" pcid="3846">
    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
        require(checkTransferFromAllowed(_from, _to, _value) == STATUS_ALLOWED, "transfer must be allowed");
        return ERC20.transferFrom(_from, _to,_value);
    }

    function mint(address _account, uint256 _amount) public whenNotPaused onlyMinterAddress {
</source>
</class>

<class classid="166" nclones="4" nlines="4" similarity="100">
<source file="systems/smart_contracts/AronCoin.sol" startline="280" endline="284" pcid="778">
  function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {
    return super.increaseApproval(_spender, _addedValue);
  }

  function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="280" endline="284" pcid="6793">
  function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {
    return super.increaseApproval(_spender, _addedValue);
  }

  function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {
</source>
<source file="systems/smart_contracts/CDS.sol" startline="368" endline="379" pcid="1674">
  function increaseApproval(
    address _spender,
    uint _addedValue
  )
    public
    whenNotPaused
    returns (bool success)
  {
    return super.increaseApproval(_spender, _addedValue);
  }

  function decreaseApproval(
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="280" endline="284" pcid="7762">
  function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {
    return super.increaseApproval(_spender, _addedValue);
  }

  function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {
</source>
</class>

<class classid="167" nclones="4" nlines="4" similarity="100">
<source file="systems/smart_contracts/AronCoin.sol" startline="284" endline="287" pcid="779">
  function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {
    return super.decreaseApproval(_spender, _subtractedValue);
  }
}
</source>
<source file="systems/smart_contracts/CDS.sol" startline="379" endline="389" pcid="1675">
  function decreaseApproval(
    address _spender,
    uint _subtractedValue
  )
    public
    whenNotPaused
    returns (bool success)
  {
    return super.decreaseApproval(_spender, _subtractedValue);
  }
}
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="284" endline="287" pcid="6794">
  function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {
    return super.decreaseApproval(_spender, _subtractedValue);
  }
}
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="284" endline="287" pcid="7763">
  function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {
    return super.decreaseApproval(_spender, _subtractedValue);
  }
}
</source>
</class>

<class classid="168" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/AronCoin.sol" startline="302" endline="313" pcid="780">
    function AronCoin( address _admin, uint _totalTokenAmount ) 
    {
        // assign the admin account
        admin = _admin;

        // assign the total tokens to Aron Coin
        totalSupply = _totalTokenAmount;
        balances[msg.sender] = _totalTokenAmount;
        Transfer(address(0x0), msg.sender, _totalTokenAmount);
    }

    function transfer(address _to, uint _value) validDestination(_to) returns (bool) 
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="302" endline="313" pcid="7764">
    function VisionBitcoinCash( address _admin, uint _totalTokenAmount ) 
    {
        // assign the admin account
        admin = _admin;

        // assign the total tokens to Vision Bitcoin Cash
        totalSupply = _totalTokenAmount;
        balances[msg.sender] = _totalTokenAmount;
        Transfer(address(0x0), msg.sender, _totalTokenAmount);
    }

    function transfer(address _to, uint _value) validDestination(_to) returns (bool) 
</source>
</class>

<class classid="169" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/AronCoin.sol" startline="325" endline="335" pcid="783">
    function burn(uint _value) returns (bool)
    {
        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalSupply = totalSupply.sub(_value);
        Burn(msg.sender, _value);
        Transfer(msg.sender, address(0x0), _value);
        return true;
    }

    // save some gas by making only one contract call
    function burnFrom(address _from, uint256 _value) returns (bool) 
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="325" endline="335" pcid="7767">
    function burn(uint _value) returns (bool)
    {
        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalSupply = totalSupply.sub(_value);
        Burn(msg.sender, _value);
        Transfer(msg.sender, address(0x0), _value);
        return true;
    }

    // save some gas by making only one contract call
    function burnFrom(address _from, uint256 _value) returns (bool) 
</source>
</class>

<class classid="170" nclones="3" nlines="4" similarity="75">
<source file="systems/smart_contracts/AronCoin.sol" startline="335" endline="341" pcid="784">
    function burnFrom(address _from, uint256 _value) returns (bool) 
    {
        assert( transferFrom( _from, msg.sender, _value ) );
        return burn(_value);
    }

    function emergencyERC20Drain( ERC20 token, uint amount ) onlyOwner {
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="592" endline="597" pcid="6820">
    function burnFrom(address _from, uint256 _value) public returns (bool) {
        assert(transferFrom(_from, msg.sender, _value));
        return burn(_value);
    }

    function emergencyERC20Drain( ERC20 token, uint amount ) public onlyOwner {
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="335" endline="341" pcid="7768">
    function burnFrom(address _from, uint256 _value) returns (bool) 
    {
        assert( transferFrom( _from, msg.sender, _value ) );
        return burn(_value);
    }

    function emergencyERC20Drain( ERC20 token, uint amount ) onlyOwner {
</source>
</class>

<class classid="171" nclones="3" nlines="4" similarity="75">
<source file="systems/smart_contracts/AronCoin.sol" startline="341" endline="346" pcid="785">
    function emergencyERC20Drain( ERC20 token, uint amount ) onlyOwner {
        // owner can drain tokens that are sent here by mistake
        token.transfer( owner, amount );
    }

    event AdminTransferred(address indexed previousAdmin, address indexed newAdmin);
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="597" endline="602" pcid="6821">
    function emergencyERC20Drain( ERC20 token, uint amount ) public onlyOwner {
        // owner can drain tokens that are sent here by mistake
        token.transfer(owner, amount);
    }

    event AdminTransferred(address indexed previousAdmin, address indexed newAdmin);
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="341" endline="346" pcid="7769">
    function emergencyERC20Drain( ERC20 token, uint amount ) onlyOwner {
        // owner can drain tokens that are sent here by mistake
        token.transfer( owner, amount );
    }

    event AdminTransferred(address indexed previousAdmin, address indexed newAdmin);
</source>
</class>

<class classid="172" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/AronCoin.sol" startline="348" endline="353" pcid="786">
    function changeAdmin(address newAdmin) onlyOwner {
        // owner can re-assign the admin
        AdminTransferred(admin, newAdmin);
        admin = newAdmin;
    }
}
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="348" endline="353" pcid="7770">
    function changeAdmin(address newAdmin) onlyOwner {
        // owner can re-assign the admin
        AdminTransferred(admin, newAdmin);
        admin = newAdmin;
    }
}
</source>
</class>

<class classid="173" nclones="7" nlines="7" similarity="71">
<source file="systems/smart_contracts/AT.sol" startline="35" endline="40" pcid="791">
  function assert(bool assertion) internal {
    if (!assertion) {
      throw;
    }
  }
}
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="661" endline="675" pcid="4867">
  function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {
    assert(address(addr) != address(0));
    assert(address(finalizeAgent) == address(0));
    finalizeAgent = addr;

    // Don't allow setting bad agent
    if(!finalizeAgent.isFinalizeAgent()) {
      throw;
    }
  }

  /**
   * Allow addresses to do early participation.
   */
  function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="837" endline="855" pcid="4881">
  function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {
    assert(address(_pricingStrategy) != address(0));
    assert(address(pricingStrategy) == address(0));
    pricingStrategy = _pricingStrategy;

    // Don't allow setting bad agent
    if(!pricingStrategy.isPricingStrategy()) {
      throw;
    }
  }

  /**
   * Allow to change the team multisig address in the case of emergency.
   *
   * This allows to save a deployed crowdsale wallet in the case the crowdsale has not yet begun
   * (we have done only few test transactions). After the crowdsale is going
   * then multisig address stays locked for the safety reasons.
   */
  function setMultisig(address addr) public onlyOwner {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="832" endline="850" pcid="6121">
  function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {
    assert(address(_pricingStrategy) != address(0));
    assert(address(pricingStrategy) == address(0));
    pricingStrategy = _pricingStrategy;

    // Don't allow setting bad agent
    if(!pricingStrategy.isPricingStrategy()) {
      throw;
    }
  }

  /**
   * Allow to change the team multisig address in the case of emergency.
   *
   * This allows to save a deployed crowdsale wallet in the case the crowdsale has not yet begun
   * (we have done only few test transactions). After the crowdsale is going
   * then multisig address stays locked for the safety reasons.
   */
  function setMultisig(address addr) public onlyOwner {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="656" endline="670" pcid="6107">
  function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {
    assert(address(addr) != address(0));
    assert(address(finalizeAgent) == address(0));
    finalizeAgent = addr;

    // Don't allow setting bad agent
    if(!finalizeAgent.isFinalizeAgent()) {
      throw;
    }
  }

  /**
   * Allow addresses to do early participation.
   */
  function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {
</source>
<source file="systems/smart_contracts/Hda.sol" startline="32" endline="37" pcid="4220">
  function assert(bool assertion) internal {
    if (!assertion) {
      throw;
    }
  }
}
</source>
<source file="systems/smart_contracts/OMGToken.sol" startline="56" endline="61" pcid="5487">
  function assert(bool assertion) internal {
    if (!assertion) {
      throw;
    }
  }
}
</source>
</class>

<class classid="174" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/AT.sol" startline="66" endline="81" pcid="792">
    function AT(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens
        totalSupply = initialSupply;                        // Update total supply
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
        decimals = decimalUnits;                            // Amount of decimals for display purposes
		owner = msg.sender;
    }

    /* Send coins */
    function transfer(address _to, uint256 _value) {
</source>
<source file="systems/smart_contracts/Hda.sol" startline="56" endline="71" pcid="4221">
    function Hda(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens
        totalSupply = initialSupply;                        // Update total supply
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
        decimals = decimalUnits;                            // Amount of decimals for display purposes
		owner = msg.sender;
    }

    /* Send coins */
    function transfer(address _to, uint256 _value) {
</source>
</class>

<class classid="175" nclones="2" nlines="5" similarity="100">
<source file="systems/smart_contracts/AT.sol" startline="81" endline="92" pcid="793">
    function transfer(address _to, uint256 _value) {
        if (_to == 0x0) throw;                               // Prevent transfer to 0x0 address. Use burn() instead
		if (_value <= 0) throw; 
        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                     // Subtract from the sender
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }

    /* Allow another contract to spend some tokens in your behalf */
    function approve(address _spender, uint256 _value)
</source>
<source file="systems/smart_contracts/Hda.sol" startline="71" endline="82" pcid="4222">
    function transfer(address _to, uint256 _value) {
        if (_to == 0x0) throw;                               // Prevent transfer to 0x0 address. Use burn() instead
		if (_value <= 0) throw; 
        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                     // Subtract from the sender
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }

    /* Allow another contract to spend some tokens in your behalf */
    function approve(address _spender, uint256 _value)
</source>
</class>

<class classid="176" nclones="2" nlines="5" similarity="100">
<source file="systems/smart_contracts/AT.sol" startline="101" endline="114" pcid="795">
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (_to == 0x0) throw;                                // Prevent transfer to 0x0 address. Use burn() instead
		if (_value <= 0) throw; 
        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;     // Check allowance
        balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);                           // Subtract from the sender
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                             // Add the same to the recipient
        allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value);
        Transfer(_from, _to, _value);
        return true;
    }

    function burn(uint256 _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/Hda.sol" startline="91" endline="104" pcid="4224">
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (_to == 0x0) throw;                                // Prevent transfer to 0x0 address. Use burn() instead
		if (_value <= 0) throw; 
        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw;     // Check allowance
        balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);                           // Subtract from the sender
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                             // Add the same to the recipient
        allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value);
        Transfer(_from, _to, _value);
        return true;
    }

    function burn(uint256 _value) returns (bool success) {
</source>
</class>

<class classid="177" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/AT.sol" startline="114" endline="123" pcid="796">
    function burn(uint256 _value) returns (bool success) {
        if (balanceOf[msg.sender] < _value) throw;            // Check if the sender has enough
		if (_value <= 0) throw; 
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                      // Subtract from the sender
        totalSupply = SafeMath.safeSub(totalSupply,_value);                                // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }
	
	function freeze(uint256 _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/Hda.sol" startline="104" endline="112" pcid="4225">
    function burn(uint256 _value) returns (bool success) {
        if (balanceOf[msg.sender] < _value) throw;            // Check if the sender has enough
		if (_value <= 0) throw; 
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                      // Subtract from the sender
        totalSupply = SafeMath.safeSub(totalSupply,_value);                                // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }
}
</source>
</class>

<class classid="178" nclones="6" nlines="4" similarity="75">
<source file="systems/smart_contracts/AT.sol" startline="146" endline="148" pcid="800">
	function() payable {
    }
}
</source>
<source file="systems/smart_contracts/MultiSigWallet.sol" startline="99" endline="112" pcid="5241">
    function()
        payable
    {
        if (msg.value > 0)
            Deposit(msg.sender, msg.value);
    }

    /*
     * Public functions
     */
    /// @dev Contract constructor sets initial owners and required number of confirmations.
    /// @param _owners List of initial owners.
    /// @param _required Number of required confirmations.
    function MultiSigWallet(address[] _owners, uint _required)
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="510" endline="524" pcid="4859">
  function() payable {
    throw;
  }

  /**
   * Make an investment.
   *
   * Crowdsale must be running for one to invest.
   * We must have not pressed the emergency brake.
   *
   * @param receiver The Ethereum address who receives the tokens
   * @param customerId (optional) UUID v4 to track the successful payments on the server side
   *
   */
  function investInternal(address receiver, uint128 customerId) stopInEmergency private {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="505" endline="519" pcid="6099">
  function() payable {
    throw;
  }

  /**
   * Make an investment.
   *
   * Crowdsale must be running for one to invest.
   * We must have not pressed the emergency brake.
   *
   * @param receiver The Ethereum address who receives the tokens
   * @param customerId (optional) UUID v4 to track the successful payments on the server side
   *
   */
  function investInternal(address receiver, uint128 customerId) stopInEmergency private {
</source>
<source file="systems/smart_contracts/Exchange.sol" startline="109" endline="115" pcid="3370">
    function() external {
        throw;
    }

    //mapping (address => mapping (address => uint256)) public tokens; // mapping of token addresses to mapping of balances  // tokens[token][user]
    //mapping (address => mapping (address => uint256)) public reserve; // mapping of token addresses to mapping of reserved balances  // reserve[token][user]
    mapping (address => mapping (address => uint256)) public balances; // mapping of token addresses to mapping of balances and reserve (bitwise compressed) // balances[token][user]
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="167" endline="181" pcid="6438">
  function() external {
    revert("ETH not accepted!");
  }

  ////////////////////////////////////////////////////////////////////////////////
  // Deposits, Withdrawals, Balances
  ////////////////////////////////////////////////////////////////////////////////


  /**
  * This function handles deposits of Ether into the contract.
  * Emits a Deposit event.
  * Note: With the payable modifier, this function accepts Ether.
  */
  function deposit() public payable {
</source>
</class>

<class classid="179" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/ATDeployer.sol" startline="707" endline="716" pcid="937">
    function setFactoryAddress(address _fAddress) external onlyOwner {
        require(block.number < 8850000, "Time expired!");
        require(_fAddress != address(0), "Address not allowed");
        fAddress = _fAddress;
    }

    /**
     * @dev Get the factory address for deployment.
     */
    function getFactoryAddress() external view returns(address) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="1157" endline="1166" pcid="3909">
    function setFactoryAddress(address _fAddress) external onlyOwner {
        require(block.number < 8850000, "Time expired!");
        require(_fAddress != address(0), "Address not allowed");
        fAddress = _fAddress;
    }

    /**
     * @dev Get the factory address for deployment.
     */
    function getFactoryAddress() external view returns(address) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="760" endline="766" pcid="7112">
    function setFactoryAddress(address _fAddress) external onlyOwner {
        require(block.number < 8850000, "Time expired!");
        require(_fAddress != address(0), "Address not allowed");
        fAddress = _fAddress;
    }

    function getFactoryAddress() external view returns(address) {
</source>
</class>

<class classid="180" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/ATDeployer.sol" startline="716" endline="724" pcid="938">
    function getFactoryAddress() external view returns(address) {
        return fAddress;
    }

    /**
     * @dev deployment of a new AdminTools contract
     * @return address of the deployed AdminTools contract
     */
    function newAdminTools(uint256 _whitelistThresholdBalance) external onlyFactory returns(address) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="1166" endline="1184" pcid="3910">
    function getFactoryAddress() external view returns(address) {
        return fAddress;
    }

    /**
     * @dev deployment of a new Funding Panel contract
     * @param _caller address that will take the ownership of the contract
     * @param _setDocURL URL of the document describing the Panel
     * @param _setDocHash hash of the document describing the Panel
     * @param _exchRateSeed exchange rate between SEED tokens received and tokens given to the SEED sender (multiply by 10^_exchRateDecim)
     * @param _exchRateOnTop exchange rate between SEED token received and tokens minted on top (multiply by 10^_exchRateDecim)
     * @param _seedTokenAddress address of SEED token contract
     * @param _seedMaxSupply max supply of SEED tokens accepted by this contract
     * @param _tokenAddress address of the corresponding Token contract
     * @param _ATAddress address of the corresponding AdminTools contract
     * @param newLength number of this contract in the corresponding array in the Factory contract
     * @return address of the deployed Token contract
     */
    function newFundingPanel(address _caller, string calldata _setDocURL, bytes32 _setDocHash, uint256 _exchRateSeed, uint256 _exchRateOnTop,
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="766" endline="778" pcid="7113">
    function getFactoryAddress() external view returns(address) {
        return fAddress;
    }

    /**
     * @dev deploy a new Token contract and transfer ownership to _caller address
     * @param _caller address that will take the ownership of the contract
     * @param _name name of the token to be deployed
     * @param _symbol symbol of the token to be deployed
     * @param _ATAddress address of the corresponding AT contract
     * @return address of the deployed Token contract
     */
    function newToken(address _caller, string calldata _name, string calldata _symbol, address _ATAddress) external onlyFactory returns(address) {
</source>
</class>

<class classid="181" nclones="8" nlines="4" similarity="100">
<source file="systems/smart_contracts/Authorization.sol" startline="707" endline="711" pcid="980">
    function setAdministrator(address _admin) public onlyOwner {
        admin = _admin;
    }

    function addFunds(uint256 amount) public onlyAdmin whenNotPaused {
</source>
<source file="systems/smart_contracts/KYCRegistry.sol" startline="104" endline="108" pcid="4507">
    function setAdministrator(address _admin) public onlyOwner {
        admin = _admin;
    }

    function removeAddressFromKYC(address addr) public onlyAdmin {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="707" endline="711" pcid="6052">
    function setAdministrator(address _admin) public onlyOwner {
        admin = _admin;
    }

    function addFunds(uint256 amount) public onlyAdmin whenNotPaused {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="707" endline="711" pcid="2493">
    function setAdministrator(address _admin) public onlyOwner {
        admin = _admin;
    }

    function addFunds(uint256 amount) public onlyAdmin whenNotPaused {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="768" endline="772" pcid="2500">
    function setAdministrator(address _admin) public onlyOwner {
        admin = _admin;
    }

    function removeAddressFromKYC(address addr) public onlyAdmin {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="824" endline="828" pcid="991">
    function setAdministrator(address _admin) public onlyOwner {
        admin = _admin;
    }

    function depositFor(address from) public {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="824" endline="828" pcid="2504">
    function setAdministrator(address _admin) public onlyOwner {
        admin = _admin;
    }

    function depositFor(address from) public {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="768" endline="772" pcid="987">
    function setAdministrator(address _admin) public onlyOwner {
        admin = _admin;
    }

    function removeAddressFromKYC(address addr) public onlyAdmin {
</source>
</class>

<class classid="182" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/Authorization.sol" startline="711" endline="716" pcid="981">
    function addFunds(uint256 amount) public onlyAdmin whenNotPaused {
        token.transferFrom(msg.sender, address(this), amount);
        emit FundsAdded(address(this), msg.sender, amount);
    }

    function removeFunds(address to) public onlyAdmin {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="711" endline="716" pcid="2494">
    function addFunds(uint256 amount) public onlyAdmin whenNotPaused {
        token.transferFrom(msg.sender, address(this), amount);
        emit FundsAdded(address(this), msg.sender, amount);
    }

    function removeFunds(address to) public onlyAdmin {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="711" endline="716" pcid="6053">
    function addFunds(uint256 amount) public onlyAdmin whenNotPaused {
        token.transferFrom(msg.sender, address(this), amount);
        emit FundsAdded(address(this), msg.sender, amount);
    }

    function removeFunds(address to) public onlyAdmin {
</source>
</class>

<class classid="183" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/Authorization.sol" startline="716" endline="723" pcid="982">
    function removeFunds(address to) public onlyAdmin {
        uint256 amount = token.balanceOf(address(this));
        require(amount > 0, "ReferralTracker has no funds to withdraw");
        token.transfer(to, amount);
        emit FundsRemoved(address(this), msg.sender, amount);
    }

    function registerReferral(address referrer, address user) public onlyRegistry whenNotPaused {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="716" endline="723" pcid="2495">
    function removeFunds(address to) public onlyAdmin {
        uint256 amount = token.balanceOf(address(this));
        require(amount > 0, "ReferralTracker has no funds to withdraw");
        token.transfer(to, amount);
        emit FundsRemoved(address(this), msg.sender, amount);
    }

    function registerReferral(address referrer, address user) public onlyRegistry whenNotPaused {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="716" endline="723" pcid="6054">
    function removeFunds(address to) public onlyAdmin {
        uint256 amount = token.balanceOf(address(this));
        require(amount > 0, "ReferralTracker has no funds to withdraw");
        token.transfer(to, amount);
        emit FundsRemoved(address(this), msg.sender, amount);
    }

    function registerReferral(address referrer, address user) public onlyRegistry whenNotPaused {
</source>
</class>

<class classid="184" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/Authorization.sol" startline="723" endline="729" pcid="983">
    function registerReferral(address referrer, address user) public onlyRegistry whenNotPaused {
        unclaimedReferrals[referrer] = unclaimedReferrals[referrer].add(1);

        emit ReferralRegistered(address(this), referrer, user);
    }

    function withdraw(address to) public whenNotPaused {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="723" endline="729" pcid="6055">
    function registerReferral(address referrer, address user) public onlyRegistry whenNotPaused {
        unclaimedReferrals[referrer] = unclaimedReferrals[referrer].add(1);

        emit ReferralRegistered(address(this), referrer, user);
    }

    function withdraw(address to) public whenNotPaused {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="723" endline="729" pcid="2496">
    function registerReferral(address referrer, address user) public onlyRegistry whenNotPaused {
        unclaimedReferrals[referrer] = unclaimedReferrals[referrer].add(1);

        emit ReferralRegistered(address(this), referrer, user);
    }

    function withdraw(address to) public whenNotPaused {
</source>
</class>

<class classid="185" nclones="3" nlines="5" similarity="100">
<source file="systems/smart_contracts/Authorization.sol" startline="729" endline="742" pcid="984">
    function withdraw(address to) public whenNotPaused {
        require(unclaimedReferrals[msg.sender] > 0, "no referrals to claim");
        uint256 trackerBalance = token.balanceOf(address(this));
        uint256 amount = REFERRAL_BONUS * unclaimedReferrals[msg.sender];

        require(trackerBalance >= amount, "Not enough funds");
        delete unclaimedReferrals[msg.sender];

        token.transfer(to, amount);

        emit ReferralBonusWithdrawn(address(this), msg.sender, amount, trackerBalance);
    }

    function getTrackerBalance() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="729" endline="742" pcid="2497">
    function withdraw(address to) public whenNotPaused {
        require(unclaimedReferrals[msg.sender] > 0, "no referrals to claim");
        uint256 trackerBalance = token.balanceOf(address(this));
        uint256 amount = REFERRAL_BONUS * unclaimedReferrals[msg.sender];

        require(trackerBalance >= amount, "Not enough funds");
        delete unclaimedReferrals[msg.sender];

        token.transfer(to, amount);

        emit ReferralBonusWithdrawn(address(this), msg.sender, amount, trackerBalance);
    }

    function getTrackerBalance() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="729" endline="742" pcid="6056">
    function withdraw(address to) public whenNotPaused {
        require(unclaimedReferrals[msg.sender] > 0, "no referrals to claim");
        uint256 trackerBalance = token.balanceOf(address(this));
        uint256 amount = REFERRAL_BONUS * unclaimedReferrals[msg.sender];

        require(trackerBalance >= amount, "Not enough funds");
        delete unclaimedReferrals[msg.sender];

        token.transfer(to, amount);

        emit ReferralBonusWithdrawn(address(this), msg.sender, amount, trackerBalance);
    }

    function getTrackerBalance() public view returns (uint256) {
</source>
</class>

<class classid="186" nclones="4" nlines="4" similarity="75">
<source file="systems/smart_contracts/Authorization.sol" startline="742" endline="745" pcid="985">
    function getTrackerBalance() public view returns (uint256) {
        return token.balanceOf(address(this));
    }
}
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="742" endline="745" pcid="6057">
    function getTrackerBalance() public view returns (uint256) {
        return token.balanceOf(address(this));
    }
}
</source>
<source file="systems/smart_contracts/GLOLocker.sol" startline="23" endline="27" pcid="4114">
    function balance() public view returns(uint){
        return token.balanceOf(address(this));
    }

    function balanceOf(address addr) public view returns(uint){
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="742" endline="745" pcid="2498">
    function getTrackerBalance() public view returns (uint256) {
        return token.balanceOf(address(this));
    }
}
</source>
</class>

<class classid="187" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/Authorization.sol" startline="764" endline="768" pcid="986">
    function isConfirmed(address addr) public view returns (bool) {
        return KYCConfirmed[addr];
    }

    function setAdministrator(address _admin) public onlyOwner {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="764" endline="768" pcid="2499">
    function isConfirmed(address addr) public view returns (bool) {
        return KYCConfirmed[addr];
    }

    function setAdministrator(address _admin) public onlyOwner {
</source>
<source file="systems/smart_contracts/KYCRegistry.sol" startline="100" endline="104" pcid="4506">
    function isConfirmed(address addr) public view returns (bool) {
        return KYCConfirmed[addr];
    }

    function setAdministrator(address _admin) public onlyOwner {
</source>
</class>

<class classid="188" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/Authorization.sol" startline="772" endline="778" pcid="988">
    function removeAddressFromKYC(address addr) public onlyAdmin {
        require(KYCConfirmed[addr], "Address not KYCed");
        KYCConfirmed[addr] = false;
        emit RemovedFromKYC(addr);
    }

    function addAddressToKYC(address addr) public onlyAdmin {
</source>
<source file="systems/smart_contracts/KYCRegistry.sol" startline="108" endline="114" pcid="4508">
    function removeAddressFromKYC(address addr) public onlyAdmin {
        require(KYCConfirmed[addr], "Address not KYCed");
        KYCConfirmed[addr] = false;
        emit RemovedFromKYC(addr);
    }

    function addAddressToKYC(address addr) public onlyAdmin {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="772" endline="778" pcid="2501">
    function removeAddressFromKYC(address addr) public onlyAdmin {
        require(KYCConfirmed[addr], "Address not KYCed");
        KYCConfirmed[addr] = false;
        emit RemovedFromKYC(addr);
    }

    function addAddressToKYC(address addr) public onlyAdmin {
</source>
</class>

<class classid="189" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/Authorization.sol" startline="778" endline="783" pcid="989">
    function addAddressToKYC(address addr) public onlyAdmin {
        require(!KYCConfirmed[addr], "Address already KYCed");
        KYCConfirmed[addr] = true;
        emit AddedToKYC(addr);
    }
}
</source>
<source file="systems/smart_contracts/KYCRegistry.sol" startline="114" endline="119" pcid="4509">
    function addAddressToKYC(address addr) public onlyAdmin {
        require(!KYCConfirmed[addr], "Address already KYCed");
        KYCConfirmed[addr] = true;
        emit AddedToKYC(addr);
    }
}
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="778" endline="783" pcid="2502">
    function addAddressToKYC(address addr) public onlyAdmin {
        require(!KYCConfirmed[addr], "Address already KYCed");
        KYCConfirmed[addr] = true;
        emit AddedToKYC(addr);
    }
}
</source>
</class>

<class classid="190" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/Authorization.sol" startline="820" endline="824" pcid="990">
    function setReferralTracker(address contractAddress) public onlyOwner {
        ref = ReferralTracker(contractAddress);
    }

    function setAdministrator(address _admin) public onlyOwner {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="820" endline="824" pcid="2503">
    function setReferralTracker(address contractAddress) public onlyOwner {
        ref = ReferralTracker(contractAddress);
    }

    function setAdministrator(address _admin) public onlyOwner {
</source>
</class>

<class classid="191" nclones="2" nlines="5" similarity="100">
<source file="systems/smart_contracts/Authorization.sol" startline="828" endline="841" pcid="992">
    function depositFor(address from) public {
        require(deposits[from].deposited == false, "already deposited");
        require(
            token.allowance(from, address(this)) >= DEPOSIT_AMNT,
            "address not approved amount"
        );

        deposits[from].deposited = true;
        token.transferFrom(from, address(this), DEPOSIT_AMNT);

        emit UserDepositCompleted(address(this), from);
    }

    function depositForWithReferral(address from, address referrer) public {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="828" endline="841" pcid="2505">
    function depositFor(address from) public {
        require(deposits[from].deposited == false, "already deposited");
        require(
            token.allowance(from, address(this)) >= DEPOSIT_AMNT,
            "address not approved amount"
        );

        deposits[from].deposited = true;
        token.transferFrom(from, address(this), DEPOSIT_AMNT);

        emit UserDepositCompleted(address(this), from);
    }

    function depositForWithReferral(address from, address referrer) public {
</source>
</class>

<class classid="192" nclones="2" nlines="6" similarity="100">
<source file="systems/smart_contracts/Authorization.sol" startline="841" endline="860" pcid="993">
    function depositForWithReferral(address from, address referrer) public {
        require(from != referrer, "can not refer to itself");
        require(deposits[referrer].deposited, "referrer has not deposited");
        require(deposits[from].deposited == false, "alredy deposited");
        require(
            token.allowance(from, address(this)) >= DEPOSIT_AMNT,
            "address not approved amount"
        );
        require(msg.sender == from, "cannot deposit with a referral from another address");

        deposits[from].deposited = true;

        ref.registerReferral(referrer, msg.sender);

        token.transferFrom(from, address(this), DEPOSIT_AMNT);

        emit UserDepositCompleted(address(this), from);
    }

    function withdraw(address to) public {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="841" endline="860" pcid="2506">
    function depositForWithReferral(address from, address referrer) public {
        require(from != referrer, "can not refer to itself");
        require(deposits[referrer].deposited, "referrer has not deposited");
        require(deposits[from].deposited == false, "alredy deposited");
        require(
            token.allowance(from, address(this)) >= DEPOSIT_AMNT,
            "address not approved amount"
        );
        require(msg.sender == from, "cannot deposit with a referral from another address");

        deposits[from].deposited = true;

        ref.registerReferral(referrer, msg.sender);

        token.transferFrom(from, address(this), DEPOSIT_AMNT);

        emit UserDepositCompleted(address(this), from);
    }

    function withdraw(address to) public {
</source>
</class>

<class classid="193" nclones="2" nlines="5" similarity="100">
<source file="systems/smart_contracts/Authorization.sol" startline="860" endline="872" pcid="994">
    function withdraw(address to) public {
        require(deposits[msg.sender].deposited, "address not deposited");
        require(
            deposits[msg.sender].unlockedForWithdrawal || kyc.isConfirmed(msg.sender),
            "cannot withdraw without KYC or unlocked"
        );

        delete deposits[msg.sender];
        token.transfer(to, DEPOSIT_AMNT);
        emit UserWithdrawnCompleted(address(this), msg.sender);
    }

    function unlockAddressForWithdrawal(address user) public onlyAdmin {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="860" endline="872" pcid="2507">
    function withdraw(address to) public {
        require(deposits[msg.sender].deposited, "address not deposited");
        require(
            deposits[msg.sender].unlockedForWithdrawal || kyc.isConfirmed(msg.sender),
            "cannot withdraw without KYC or unlocked"
        );

        delete deposits[msg.sender];
        token.transfer(to, DEPOSIT_AMNT);
        emit UserWithdrawnCompleted(address(this), msg.sender);
    }

    function unlockAddressForWithdrawal(address user) public onlyAdmin {
</source>
</class>

<class classid="194" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/Authorization.sol" startline="872" endline="878" pcid="995">
    function unlockAddressForWithdrawal(address user) public onlyAdmin {
        require(deposits[user].deposited, "address has not deposited");
        deposits[user].unlockedForWithdrawal = true;
        emit AddressUnlockedForWithdrawal(address(this), user);
    }

    function hasDeposited(address user) public view returns (bool) {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="872" endline="878" pcid="2508">
    function unlockAddressForWithdrawal(address user) public onlyAdmin {
        require(deposits[user].deposited, "address has not deposited");
        deposits[user].unlockedForWithdrawal = true;
        emit AddressUnlockedForWithdrawal(address(this), user);
    }

    function hasDeposited(address user) public view returns (bool) {
</source>
</class>

<class classid="195" nclones="3" nlines="4" similarity="75">
<source file="systems/smart_contracts/Authorization.sol" startline="878" endline="882" pcid="996">
    function hasDeposited(address user) public view returns (bool) {
        return deposits[user].deposited;
    }

    function isUnlocked(address user) public view returns (bool) {
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="878" endline="882" pcid="2509">
    function hasDeposited(address user) public view returns (bool) {
        return deposits[user].deposited;
    }

    function isUnlocked(address user) public view returns (bool) {
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="903" endline="907" pcid="998">
    function hasDeposited(address user) public view returns (bool) {
        return deposit.hasDeposited(user);
    }

    function isKYCConfirmed(address user) public view returns (bool) {
</source>
</class>

<class classid="196" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/Authorization.sol" startline="882" endline="885" pcid="997">
    function isUnlocked(address user) public view returns (bool) {
        return deposits[user].unlockedForWithdrawal;
    }
}
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="882" endline="885" pcid="2510">
    function isUnlocked(address user) public view returns (bool) {
        return deposits[user].unlockedForWithdrawal;
    }
}
</source>
</class>

<class classid="197" nclones="28" nlines="11" similarity="72">
<source file="systems/smart_contracts/AzurToken.sol" startline="56" endline="69" pcid="1005">
  function transfer(address _to, uint256 _value) public returns (bool success) {
    //Default assumes totalSupply can't be over max (2^256 - 1).
    //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
    //Replace the if with this one instead.
    //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
    if (balances[msg.sender] >= _value && _value > 0) {
      balances[msg.sender] -= _value;
      balances[_to] += _value;
      emit Transfer(msg.sender, _to, _value);
      return true;
    } else { return false; }
  }

  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="55" endline="66" pcid="7960">
    function transfer(address _to, uint256 _value) returns (bool success) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else {
            return false;
        }
    }
 
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/TrueProfileLogic.sol" startline="233" endline="242" pcid="7518">
    function isValidTrueProof(bytes32 _key) external view returns (bool) {
        // needs to be not revoked AND needs to have a valid signature
        if (this.isValidSignatureTrueProof(_key) && this.isNotRevokedTrueProof(_key)) {
            return true;
        } else {
            return false;   
        }
    }

    function isValidSignatureTrueProof(bytes32 _key) external view returns (bool) {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="487" endline="505" pcid="5865">
    function transferFrom(address from,address to,uint256 value) public returns (bool)
    {
        if (_check(from,to,value)) {
            //            _buyBack(to,value);
            return super.transferFrom(from,to,value);
        } else {
            return false;
        }
    }
    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param spender The address which will spend the funds.
     * @param value The amount of tokens to be spent.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/BermToken.sol" startline="59" endline="70" pcid="1141">
    function transfer(address _to, uint256 _value) returns (bool success) {
      if (balances[msg.sender] >= _value && _value > 0) {
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
      } else {
        return false;
      }
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/BTGS.sol" startline="116" endline="146" pcid="1547">
    function transfer(address _to, uint256 _amount)
        public

        returns (bool) {
        // if sender's balance has enough unit and amount >= 0,
        //      and the sum is not overflow,
        // then do transfer
        
        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        require(_amount >= 0);
        if ( (balances[msg.sender] >= _amount) &&
             (_amount >= 0) &&
             (balances[_to] + _amount > balances[_to]) ) {

            balances[msg.sender] -= _amount;
            balances[_to] += _amount;
            Transfer(msg.sender, _to, _amount);
            return true;
        } else {
            return false;
        }
    }

    // Send _value amount of tokens from address _from to address _to
    // The transferFrom method is used for a withdraw workflow, allowing contracts to send
    // tokens on your behalf, for example to "deposit" to a contract address and/or to charge
    // fees in sub-currencies; the command should fail unless the _from account has
    // deliberately authorized the sender of the message via some mechanism; we propose
    // these standardized APIs for approval:
    function transferFrom(
</source>
<source file="systems/smart_contracts/TECToken.sol" startline="46" endline="56" pcid="7133">
    function transfer(address _to, uint _value) returns (bool) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }

    function transferFrom(address _from, address _to, uint _value) returns (bool) {
</source>
<source file="systems/smart_contracts/BermToken.sol" startline="70" endline="82" pcid="1142">
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
        balances[_to] += _value;
        balances[_from] -= _value;
        allowed[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
      } else {
        return false;
      }
    }

    function balanceOf(address _owner) constant returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/P21.sol" startline="56" endline="66" pcid="5586">
    function transferFrom(address _from, address _to, uint _value) returns (bool) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }

    function balanceOf(address _owner) constant returns (uint) {
</source>
<source file="systems/smart_contracts/BTToken.sol" startline="50" endline="60" pcid="1558">
    function transfer(address _to, uint _value) returns (bool) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }

    function transferFrom(address _from, address _to, uint _value) returns (bool) {
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="66" endline="78" pcid="7961">
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else {
            return false;
        }
    }
 
    function balanceOf(address _owner) constant returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/TrueProfileLogic.sol" startline="257" endline="272" pcid="7520">
    function isNotRevokedTrueProof(bytes32 _key) external view returns (bool) {
        uint8 v;
        bytes32 r;
        bytes32 s;
        uint8 revocationReasonId;
        (v, r, s, revocationReasonId) = trueProfileStorage.getSignature(_key);

        // needs to be not revoked
        if (revocationReasonId == 0) {
            return true;
        } else {
            return false;
        }
    }

    function getSignature(bytes32 _key) external view returns (uint8 v, bytes32 r, bytes32 s, uint8 revocationReasonId) {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="505" endline="522" pcid="5866">
    function approve(address spender, uint256 value) public returns (bool) {
        if (_check(msg.sender,spender,value)) {
            return super.approve(spender,value);
        } else {
            return false;
        }
    }

    /**
   * @dev Increase the amount of tokens that an owner allowed to a spender.
   * approve should be called when allowed_[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param spender The address which will spend the funds.
   * @param addedValue The amount of tokens to increase the allowance by.
   */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool)
</source>
<source file="systems/smart_contracts/TECToken.sol" startline="56" endline="66" pcid="7134">
    function transferFrom(address _from, address _to, uint _value) returns (bool) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }

    function balanceOf(address _owner) constant returns (uint) {
</source>
<source file="systems/smart_contracts/BTToken.sol" startline="60" endline="70" pcid="1559">
    function transferFrom(address _from, address _to, uint _value) returns (bool) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }

    function balanceOf(address _owner) constant returns (uint) {
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="49" endline="60" pcid="4074">
    function transfer(address _to, uint256 _value) returns (bool success) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else {
            return false;
        }
    }
 
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/AzurToken.sol" startline="69" endline="81" pcid="1006">
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    //same as above. Replace this line with the following if you want to protect against wrapping uints.
    //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
      balances[_to] += _value;
      balances[_from] -= _value;
      allowed[_from][msg.sender] -= _value;
      emit Transfer(_from, _to, _value);
      return true;
    } else { return false; }
  }

  function balanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/BEX.sol" startline="45" endline="60" pcid="1168">
	function transferFrom(address from, address to, uint tokens)public returns (bool success) {
		if (balances[from] >= tokens && allowed[from][msg.sender] >= tokens && tokens > 0 && balances[to] + tokens > balances[to]) {
           
            
			balances[from] -= tokens;
			allowed[from][msg.sender] -= tokens;
			balances[to] += tokens;
			emit Transfer(from, to, tokens);
			return true;
		} else {
			return false;
		}
	}
	
	
	function approve(address spender, uint tokens)public returns (bool success) {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="540" endline="549" pcid="5868">
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool)
    {
        if (_check(msg.sender,spender,subtractedValue)) {
            return  super.decreaseAllowance(spender,subtractedValue);
        } else {
            return false;
        }
    }

    function destory(address _adrs) public onlyOwner returns(bool){
</source>
<source file="systems/smart_contracts/TrueProfileLogic.sol" startline="242" endline="257" pcid="7519">
    function isValidSignatureTrueProof(bytes32 _key) external view returns (bool) {
        uint8 v;
        bytes32 r;
        bytes32 s;
        uint8 revocationReasonId;
        (v, r, s, revocationReasonId) = trueProfileStorage.getSignature(_key);

        // needs to have a valid signature
        if (accessAllowed[ecrecover(_key, v, r, s)]) {
            return true;
        } else {
            return false;   
        }
    }

    function isNotRevokedTrueProof(bytes32 _key) external view returns (bool) {
</source>
<source file="systems/smart_contracts/BEX.sol" startline="32" endline="45" pcid="1167">
	function transfer(address to, uint tokens)public returns (bool success) {
		if (balances[msg.sender] >= tokens && tokens > 0 && balances[to] + tokens > balances[to]) {
            
			balances[msg.sender] -= tokens;
			balances[to] += tokens;
			emit Transfer(msg.sender, to, tokens);
			return true;
		} else {
			return false;
		}
	}
	

	function transferFrom(address from, address to, uint tokens)public returns (bool success) {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="473" endline="487" pcid="5864">
    function transfer(address to, uint256 value) public returns (bool) {
        if (_check(msg.sender, to, value)) {
            //            _buyBack(to,value);
            return super.transfer(to,value);
        } else {
            return false;
        }
    }
    /**
       * @dev Transfer tokens from one address to another
       * @param from address The address which you want to send tokens from
       * @param to address The address which you want to transfer to
       * @param value uint256 the amount of tokens to be transferred
       */
    function transferFrom(address from,address to,uint256 value) public returns (bool)
</source>
<source file="systems/smart_contracts/BTGS.sol" startline="146" endline="170" pcid="1548">
    function transferFrom(
        address _from,
        address _to,
        uint256 _amount
    )
    public

    returns (bool success) {
        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        require(_amount >= 0);
        if (balances[_from] >= _amount && _amount > 0 && allowed[_from][msg.sender] >= _amount) {
            balances[_from] -= _amount;
            allowed[_from][msg.sender] -= _amount;
            balances[_to] += _amount;
            Transfer(_from, _to, _amount);
            return true;
        } else {
            return false;
        }
    }

    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.
    // If this function is called again it overwrites the current allowance with _value.
    function approve(address _spender, uint256 _amount)
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="60" endline="72" pcid="4075">
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else {
            return false;
        }
    }
 
    function balanceOf(address _owner) constant returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/P21.sol" startline="46" endline="56" pcid="5585">
    function transfer(address _to, uint _value) returns (bool) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }

    function transferFrom(address _from, address _to, uint _value) returns (bool) {
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="522" endline="540" pcid="5867">
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool)
    {
        if (_check(msg.sender,spender,addedValue)) {
            return super.increaseAllowance(spender,addedValue);
        } else {
            return false;
        }
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     * approve should be called when allowed_[_spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * @param spender The address which will spend the funds.
     * @param subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool)
</source>
<source file="systems/smart_contracts/CouncilVesting.sol" startline="80" endline="89" pcid="2031">
    function transfer(address _to, uint256 _value) returns (bool success) {
        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { throw; }
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/CouncilVesting.sol" startline="89" endline="99" pcid="2032">
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { throw; }
    }

    function balanceOf(address _owner) constant returns (uint256 balance) {
</source>
</class>

<class classid="198" nclones="6" nlines="8" similarity="75">
<source file="systems/smart_contracts/BACD.sol" startline="125" endline="146" pcid="1022">
  function transferFrom(address _from, address _to, uint256 _value) public
  returns (bool success) {
    require(_to != address(0));
    if (allowances [_from][msg.sender] < _value) return false;
    if (accounts [_from] < _value) return false; 

    if (_value > 0 && _from != _to) {
	  allowances [_from][msg.sender] = safeSub (allowances [_from][msg.sender], _value);
      accounts [_from] = safeSub (accounts [_from], _value);
      accounts [_to] = safeAdd (accounts [_to], _value);
    }
    emit Transfer(_from, _to, _value);
    return true;
  }

  /**
   * Allow given spender to transfer given number of tokens from message sender.
   * @param _spender address to allow the owner of to transfer tokens from message sender
   * @param _value number of tokens to allow to transfer
   * @return true if token transfer was successfully approved, false otherwise
   */
   function approve (address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Warpcoin.sol" startline="47" endline="59" pcid="7947">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        if (allowance < MAX_UINT256) {
            allowed[_from][msg.sender] -= _value;
        }
        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/DENARIO.sol" startline="47" endline="59" pcid="2449">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        if (allowance < MAX_UINT256) {
            allowed[_from][msg.sender] -= _value;
        }
        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/UNT.sol" startline="40" endline="52" pcid="7567">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        if (allowance < MAX_UINT256) {
            allowed[_from][msg.sender] -= _value;
        }
        Transfer(_from, _to, _value);
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/SHPC.sol" startline="40" endline="52" pcid="6509">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        if (allowance < MAX_UINT256) {
            allowed[_from][msg.sender] -= _value;
        }
        Transfer(_from, _to, _value);
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/OBK.sol" startline="40" endline="52" pcid="5469">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        if (allowance < MAX_UINT256) {
            allowed[_from][msg.sender] -= _value;
        }
        Transfer(_from, _to, _value);
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
</source>
</class>

<class classid="199" nclones="23" nlines="4" similarity="75">
<source file="systems/smart_contracts/BACD.sol" startline="244" endline="259" pcid="1026">
  function transfer(address _to, uint256 _value) public returns (bool success) {
    require(!frozenAccount[msg.sender]);
	if (frozen) return false;
    else return AbstractToken.transfer (_to, _value);
  }

  /**
   * Transfer given number of tokens from given owner to given recipient.
   *
   * @param _from address to transfer tokens from the owner of
   * @param _to address to transfer tokens to the owner of
   * @param _value number of tokens to transfer from given owner to given
   *        recipient
   * @return true if tokens were transferred successfully, false otherwise
   */
  function transferFrom(address _from, address _to, uint256 _value) public
</source>
<source file="systems/smart_contracts/MyAdvancedToken.sol" startline="92" endline="106" pcid="5264">
    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    /**
     * Transfer tokens from other address
     *
     * Send `_value` tokens to `_to` in behalf of `_from`
     *
     * @param _from The address of the sender
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/GBE.sol" startline="41" endline="45" pcid="4055">
    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/OBK.sol" startline="32" endline="40" pcid="5468">
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/LuckyAdvcedWoken.sol" startline="143" endline="157" pcid="4560">
    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    /**
     * Transfer tokens from other address
     *
     * Send `_value` tokens to `_to` in behalf of `_from`
     *
     * @param _from The address of the sender
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SHPC.sol" startline="32" endline="40" pcid="6508">
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Warpcoin.sol" startline="39" endline="47" pcid="7946">
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/byzbit.sol" startline="89" endline="99" pcid="1595">
	function transfer (address _to, uint256 _value) public 
	returns(bool success){
		
		_transfer(msg.sender, _to, _value);
		return true;
	}
	////////////////////////////// TRANSFER END //////////////////////////////

////////////////////////////// ALLOWANCE //////////////////////////////

	function transferFrom (address _from, address _to, uint256 _value) public
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="190" endline="196" pcid="2863">
    function transfer(address _to, uint256 _value) public returns (bool success){
        success = operator.token_transfer(msg.sender, _to, _value);
        bytes memory emptyBytes;
        internalTokenFallback(msg.sender, _to, _value, emptyBytes);
        emit Transfer(msg.sender, _to, _value);
    }
    function transfer(address _to, uint _value, bytes _data) public returns (bool success){
</source>
<source file="systems/smart_contracts/OeroToken.sol" startline="48" endline="56" pcid="5474">
        function transfer(address _to, uint256 _value) public returns (bool success) {
            require(balanceOf[msg.sender] >= _value);
            balanceOf[msg.sender] -= _value;
            balanceOf[_to] += _value;
            emit Transfer(msg.sender, _to, _value);
            return true;
        }

        function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/GEF.sol" startline="41" endline="45" pcid="4061">
    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/BRZE.sol" startline="100" endline="106" pcid="1527">
  function transfer(address _to, uint256 _value) public returns (bool success) {
    _transfer(msg.sender, _to, _value);
    return true;
  }


  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/TAIHUITOKEN.sol" startline="70" endline="78" pcid="6969">
    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }




}
</source>
<source file="systems/smart_contracts/MAdvcedWoken.sol" startline="143" endline="157" pcid="4599">
    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    /**
     * Transfer tokens from other address
     *
     * Send `_value` tokens to `_to` in behalf of `_from`
     *
     * @param _from The address of the sender
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ETGTOKEN.sol" startline="77" endline="91" pcid="3192">
    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    /**
     * Transfer tokens from other address
     *
     * Send `_value` tokens to `_to` on behalf of `_from`
     *
     * @param _from The address of the sender
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/TokenERC20.sol" startline="76" endline="90" pcid="7304">
    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    /**
     * Transfer tokens from other address
     *
     * Send `_value` tokens to `_to` on behalf of `_from`
     *
     * @param _from The address of the sender
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/DaiSwap.sol" startline="26" endline="28" pcid="2285">
  function transfer(address _to, uint256 _value) public returns (bool success) {}
  //function transfer(address _to, uint _value) public;
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {}
</source>
<source file="systems/smart_contracts/ICBB.sol" startline="96" endline="110" pcid="4266">
    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    /**
     * Transfer tokens from other address
     *
     * Send `_value` tokens to `_to` in behalf of `_from`
     *
     * @param _from The address of the sender
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ThpToken.sol" startline="96" endline="110" pcid="7159">
    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    /**
     * Transfer tokens from other address
     *
     * Send `_value` tokens to `_to` in behalf of `_from`
     *
     * @param _from The address of the sender
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/DENARIO.sol" startline="39" endline="47" pcid="2448">
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/UNT.sol" startline="32" endline="40" pcid="7566">
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/VCTAToken.sol" startline="34" endline="42" pcid="7669">
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/UTRAToken.sol" startline="179" endline="188" pcid="7609">
    function transfer(address _to, uint256 _value) public kycVerified(msg.sender) frozenVerified(msg.sender) lockingVerified(msg.sender)  returns (bool) {
        _transfer(msg.sender,_to,_value);
        return true;
    }
    
    /*
        Please make sure before calling this function from UI, Sender has sufficient balance for 
        All transfers 
    */
    function multiTransfer(address[] _to,uint[] _value) public kycVerified(msg.sender) frozenVerified(msg.sender) lockingVerified(msg.sender) returns (bool) {
</source>
</class>

<class classid="200" nclones="20" nlines="4" similarity="75">
<source file="systems/smart_contracts/BACD.sol" startline="259" endline="278" pcid="1027">
  function transferFrom(address _from, address _to, uint256 _value) public
    returns (bool success) {
	require(!frozenAccount[_from]);
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }

   /**
   * Change how many tokens given spender is allowed to transfer from message
   * spender.  In order to prevent double spending of allowance,
   * To change the approve amount you first have to reduce the addresses`
   * allowance to zero by calling `approve(_spender, 0)` if it is not
   * already 0 to mitigate the race condition described here:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   * @param _spender address to allow the owner of to transfer tokens from
   *        message sender
   * @param _value number of tokens to allow to transfer
   * @return true if token transfer was successfully approved, false otherwise
   */
  function approve (address _spender, uint256 _value) public
</source>
<source file="systems/smart_contracts/Contracts.sol" startline="85" endline="100" pcid="1997">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    /**
     * Set allowance for other address
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     */
    function approve(address _spender, uint256 _value) public
</source>
<source file="systems/smart_contracts/MAdvcedWoken.sol" startline="157" endline="172" pcid="4600">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    /**
     * Set allowance for other address
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     */
    function approve(address _spender, uint256 _value) public
</source>
<source file="systems/smart_contracts/CLCTokenERC20.sol" startline="85" endline="100" pcid="1739">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    /**
     * Set allowance for other address
     *
     * Allows `_spender` to spend no more than `_value` tokens on your behalf
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     */
    function approve(address _spender, uint256 _value) public
</source>
<source file="systems/smart_contracts/BRZE.sol" startline="106" endline="113" pcid="1528">
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);
		_transfer(_from, _to, _value);
		return true;
  }


  function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/byzbit.sol" startline="99" endline="110" pcid="1596">
	function transferFrom (address _from, address _to, uint256 _value) public
	returns(bool success) {
		
		require (_value <= allowance[_from][msg.sender]);
		allowance[_from][msg.sender] -=_value;
		_transfer(_from, _to, _value);
		return true;
						
	}
	

	function approve (address _spender, uint256 _value) onlyOwner public 
</source>
<source file="systems/smart_contracts/TokenERC20.sol" startline="90" endline="105" pcid="7305">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    /**
     * Set allowance for other address
     *
     * Allows `_spender` to spend no more than `_value` tokens on your behalf
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     */
    function approve(address _spender, uint256 _value) public
</source>
<source file="systems/smart_contracts/GBE.sol" startline="45" endline="51" pcid="4056">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
    function approve(address _spender, uint256 _value) public
</source>
<source file="systems/smart_contracts/ICBB.sol" startline="110" endline="125" pcid="4267">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    /**
     * Set allowance for other address
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     */
    function approve(address _spender, uint256 _value) public
</source>
<source file="systems/smart_contracts/DDPC.sol" startline="83" endline="98" pcid="2379">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    /**
     * Set allowance for other address
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     */
    function approve(address _spender, uint256 _value) public
</source>
<source file="systems/smart_contracts/ESCHToken.sol" startline="50" endline="57" pcid="3043">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public
</source>
<source file="systems/smart_contracts/GEF.sol" startline="45" endline="51" pcid="4062">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
    function approve(address _spender, uint256 _value) public
</source>
<source file="systems/smart_contracts/MyAdvancedToken.sol" startline="106" endline="121" pcid="5265">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    /**
     * Set allowance for other address
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     */
    function approve(address _spender, uint256 _value) public
</source>
<source file="systems/smart_contracts/ThpToken.sol" startline="110" endline="125" pcid="7160">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    /**
     * Set allowance for other address
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     */
    function approve(address _spender, uint256 _value) public
</source>
<source file="systems/smart_contracts/OeroToken.sol" startline="62" endline="72" pcid="5476">
        function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
            require(_value <= balanceOf[_from]);
            require(_value <= allowance[_from][msg.sender]);
            balanceOf[_from] -= _value;
            balanceOf[_to] += _value;
            allowance[_from][msg.sender] -= _value;
            emit Transfer(_from, _to, _value);
            return true;
        }

        function mintToken(address _to, uint256 _value) public onlyOwner  {
</source>
<source file="systems/smart_contracts/ETGTOKEN.sol" startline="91" endline="106" pcid="3193">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    /**
     * Set allowance for other address
     *
     * Allows `_spender` to spend no more than `_value` tokens on your behalf
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     */
    function approve(address _spender, uint256 _value) public
</source>
<source file="systems/smart_contracts/DaiSwap.sol" startline="28" endline="30" pcid="2286">
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {}
  //function transferFrom(address from, address to, uint value) public;
}
</source>
<source file="systems/smart_contracts/LuckyAdvcedWoken.sol" startline="157" endline="172" pcid="4561">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    /**
     * Set allowance for other address
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     */
    function approve(address _spender, uint256 _value) public
</source>
<source file="systems/smart_contracts/RanchChain.sol" startline="85" endline="100" pcid="5979">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    /**
     * Set allowance for other address
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     */
    function approve(address _spender, uint256 _value) public
</source>
<source file="systems/smart_contracts/Rabbit.sol" startline="35" endline="41" pcid="5943">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
    function approve(address _spender, uint256 _value) public
</source>
</class>

<class classid="201" nclones="14" nlines="4" similarity="100">
<source file="systems/smart_contracts/BANG.sol" startline="49" endline="54" pcid="1045">
  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
    uint256 c = add(a,m);
    uint256 d = sub(c,1);
    return mul(div(d,m),m);
  }
}
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="45" endline="50" pcid="6205">
  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
    uint256 c = add(a,m);
    uint256 d = sub(c,1);
    return mul(div(d,m),m);
  }
}
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="49" endline="54" pcid="1469">
  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
    uint256 c = add(a,m);
    uint256 d = sub(c,1);
    return mul(div(d,m),m);
  }
}
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="45" endline="50" pcid="7320">
  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
    uint256 c = add(a,m);
    uint256 d = sub(c,1);
    return mul(div(d,m),m);
  }
}
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="47" endline="52" pcid="5994">
  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
    uint256 c = add(a,m);
    uint256 d = sub(c,1);
    return mul(div(d,m),m);
  }
}
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="45" endline="50" pcid="2154">
  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
    uint256 c = add(a,m);
    uint256 d = sub(c,1);
    return mul(div(d,m),m);
  }
}
</source>
<source file="systems/smart_contracts/Comet.sol" startline="45" endline="50" pcid="1922">
  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
    uint256 c = add(a,m);
    uint256 d = sub(c,1);
    return mul(div(d,m),m);
  }
}
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="45" endline="50" pcid="3922">
  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
    uint256 c = add(a,m);
    uint256 d = sub(c,1);
    return mul(div(d,m),m);
  }
}
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="94" endline="99" pcid="5097">
  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
    uint256 c = add(a,m);
    uint256 d = sub(c,1);
    return mul(div(d,m),m);
  }
}
</source>
<source file="systems/smart_contracts/Byte.sol" startline="47" endline="52" pcid="1575">
  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
    uint256 c = add(a,m);
    uint256 d = sub(c,1);
    return mul(div(d,m),m);
  }
}
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="49" endline="54" pcid="2396">
  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
    uint256 c = add(a,m);
    uint256 d = sub(c,1);
    return mul(div(d,m),m);
  }
}
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="49" endline="54" pcid="2556">
  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
    uint256 c = add(a,m);
    uint256 d = sub(c,1);
    return mul(div(d,m),m);
  }
}
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="45" endline="50" pcid="2647">
  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
    uint256 c = add(a,m);
    uint256 d = sub(c,1);
    return mul(div(d,m),m);
  }
}
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="66" endline="71" pcid="3171">
  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
    uint256 c = add(a,m);
    uint256 d = sub(c,1);
    return mul(div(d,m),m);
  }
}
</source>
</class>

<class classid="202" nclones="13" nlines="7" similarity="100">
<source file="systems/smart_contracts/BANG.sol" startline="132" endline="138" pcid="1054">
  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
    for (uint256 i = 0; i < receivers.length; i++) {
      transfer(receivers[i], amounts[i]);
    }
  }

  function multiTransferSingleAmount(address[] memory receivers, uint256 amount) public {
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="143" endline="149" pcid="2163">
  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
    for (uint256 i = 0; i < receivers.length; i++) {
      transfer(receivers[i], amounts[i]);
    }
  }

  function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="162" endline="168" pcid="3181">
  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
    for (uint256 i = 0; i < receivers.length; i++) {
      transfer(receivers[i], amounts[i]);
    }
  }

  function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="640" endline="646" pcid="2719">
  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
    for (uint256 i = 0; i < receivers.length; i++) {
      transfer(receivers[i], amounts[i]);
    }
  }

  function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Byte.sol" startline="150" endline="156" pcid="1583">
  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
    for (uint256 i = 0; i < receivers.length; i++) {
      transfer(receivers[i], amounts[i]);
    }
  }

  function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="129" endline="135" pcid="6214">
  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
    for (uint256 i = 0; i < receivers.length; i++) {
      transfer(receivers[i], amounts[i]);
    }
  }

  function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="141" endline="147" pcid="3932">
  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
    for (uint256 i = 0; i < receivers.length; i++) {
      transfer(receivers[i], amounts[i]);
    }
  }

  function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Comet.sol" startline="129" endline="135" pcid="1931">
  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
    for (uint256 i = 0; i < receivers.length; i++) {
      transfer(receivers[i], amounts[i]);
    }
  }

  function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="128" endline="134" pcid="7329">
  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
    for (uint256 i = 0; i < receivers.length; i++) {
      transfer(receivers[i], amounts[i]);
    }
  }

  function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="132" endline="138" pcid="1478">
  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
    for (uint256 i = 0; i < receivers.length; i++) {
      transfer(receivers[i], amounts[i]);
    }
  }

  function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="644" endline="650" pcid="2628">
  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
    for (uint256 i = 0; i < receivers.length; i++) {
      transfer(receivers[i], amounts[i]);
    }
  }

  function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="533" endline="539" pcid="5120">
    function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
        for (uint256 i = 0; i < receivers.length; i++) {
            transfer(receivers[i], amounts[i]);
        }
    }

    function multiSend(address[] memory receivers, uint256[] memory amounts) public {  
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="130" endline="136" pcid="6003">
  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
    for (uint256 i = 0; i < receivers.length; i++) {
      transfer(receivers[i], amounts[i]);
    }
  }

  function approve(address spender, uint256 value) public returns (bool) {
</source>
</class>

<class classid="203" nclones="2" nlines="6" similarity="83">
<source file="systems/smart_contracts/BANG.sol" startline="153" endline="174" pcid="1057">
  function transferFrom(address from, address to, uint256 value) public returns (bool) {
    require(value <= _balances[from]);
    require(value <= _allowed[from][msg.sender]);
    require(to != address(0));

    _balances[from] = _balances[from].sub(value);

    uint256 tokensToBurn = findTwentyPercent(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[to] = _balances[to].add(tokensToTransfer);
    _totalSupply = _totalSupply.sub(tokensToBurn);

    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);

    emit Transfer(from, to, tokensToTransfer);
    emit Transfer(from, address(0), tokensToBurn);

    return true;
  }

  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="143" endline="164" pcid="6005">
  function transferFrom(address from, address to, uint256 value) public returns (bool) {
    require(value <= _balances[from]);
    require(value <= _allowed[from][msg.sender]);
    require(to != address(0));

    _balances[from] = _balances[from].sub(value);

    uint256 tokensToBurn = findOneTenthPercent(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[to] = _balances[to].add(tokensToTransfer);
    _totalSupply = _totalSupply.sub(tokensToBurn);

    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);

    emit Transfer(from, to, tokensToTransfer);
    emit Transfer(from, address(0), tokensToBurn);

    return true;
  }

  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
</class>

<class classid="204" nclones="14" nlines="4" similarity="75">
<source file="systems/smart_contracts/BANG.sol" startline="198" endline="206" pcid="1062">
  function _burn(address account, uint256 amount) internal {
    require(amount != 0);
    require(amount <= _balances[account]);
    _totalSupply = _totalSupply.sub(amount);
    _balances[account] = _balances[account].sub(amount);
    emit Transfer(account, address(0), amount);
  }

  function burnFrom(address account, uint256 amount) external {
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="204" endline="212" pcid="3939">
  function _burn(address account, uint256 amount) internal {
    require(amount != 0);
    require(amount <= _balances[account]);
    _totalSupply = _totalSupply.sub(amount);
    _balances[account] = _balances[account].sub(amount);
    emit Transfer(account, address(0), amount);
  }

  function burnFrom(address account, uint256 amount) external {
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="201" endline="209" pcid="2170">
  function _burn(address account, uint256 amount) internal {
    require(amount != 0);
    require(amount <= _balances[account]);
    _totalSupply = _totalSupply.sub(amount);
    _balances[account] = _balances[account].sub(amount);
    emit Transfer(account, address(0), amount);
  }

  function burnFrom(address account, uint256 amount) external {
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="186" endline="194" pcid="7336">
  function _burn(address account, uint256 amount) internal {
    require(amount != 0);
    require(amount <= _balances[account]);
    _totalSupply = _totalSupply.sub(amount);
    _balances[account] = _balances[account].sub(amount);
    emit Transfer(account, address(0), amount);
  }

  function burnFrom(address account, uint256 amount) external {
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="225" endline="233" pcid="3188">
  function _burn(address account, uint256 amount) internal {
    require(amount != 0);
    require(amount <= _balances[account]);
    _totalSupply = _totalSupply.sub(amount);
    _balances[account] = _balances[account].sub(amount);
    emit Transfer(account, address(0), amount);
  }

  function burnFrom(address account, uint256 amount) external {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="698" endline="706" pcid="2726">
  function _destroy(address account, uint256 amount) internal {
    require(amount != 0);
    require(amount <= _balances[account]);
    _totalSupply = _totalSupply.sub(amount);
    _balances[account] = _balances[account].sub(amount);
    emit Transfer(account, address(0), amount);
  }

  function destroyFrom(address account, uint256 amount) external {
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="190" endline="198" pcid="1485">
  function _burn(address account, uint256 amount) internal {
    require(amount != 0);
    require(amount <= _balances[account]);
    _totalSupply = _totalSupply.sub(amount);
    _balances[account] = _balances[account].sub(amount);
    emit Transfer(account, address(0), amount);
  }

  function burnFrom(address account, uint256 amount) external {
</source>
<source file="systems/smart_contracts/Comet.sol" startline="187" endline="195" pcid="1938">
  function _burn(address account, uint256 amount) internal {
    require(amount != 0);
    require(amount <= _balances[account]);
    _totalSupply = _totalSupply.sub(amount);
    _balances[account] = _balances[account].sub(amount);
    emit Transfer(account, address(0), amount);
  }

  function burnFrom(address account, uint256 amount) external {
</source>
<source file="systems/smart_contracts/Byte.sol" startline="228" endline="236" pcid="1590">
  function _burn(address account, uint256 amount) internal {
    require(amount != 0);
    require(amount <= _ByteBalances[account]);
    _totalSupply = _totalSupply.sub(amount);
    _ByteBalances[account] = _ByteBalances[account].sub(amount);
    emit Transfer(account, address(0), amount);
  }

  function burnFrom(address account, uint256 amount) external {
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="188" endline="196" pcid="6010">
  function _burn(address account, uint256 amount) internal {
    require(amount != 0);
    require(amount <= _balances[account]);
    _totalSupply = _totalSupply.sub(amount);
    _balances[account] = _balances[account].sub(amount);
    emit Transfer(account, address(0), amount);
  }

  function burnFrom(address account, uint256 amount) external {
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="187" endline="195" pcid="6221">
  function _burn(address account, uint256 amount) internal {
    require(amount != 0);
    require(amount <= _balances[account]);
    _totalSupply = _totalSupply.sub(amount);
    _balances[account] = _balances[account].sub(amount);
    emit Transfer(account, address(0), amount);
  }

  function burnFrom(address account, uint256 amount) external {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="702" endline="710" pcid="2635">
  function _destroy(address account, uint256 amount) internal {
    require(amount != 0);
    require(amount <= _balances[account]);
    _totalSupply = _totalSupply.sub(amount);
    _balances[account] = _balances[account].sub(amount);
    emit Transfer(account, address(0), amount);
  }

  function destroyFrom(address account, uint256 amount) external {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="589" endline="597" pcid="5127">
    function _burn(address account, uint256 amount) internal {
        require(amount != 0);
        require(amount <= _FOMOTokenBalances[account]);
        _totalSupply = _totalSupply.sub(amount);
        _FOMOTokenBalances[account] = _FOMOTokenBalances[account].sub(amount);
        emit Transfer(account, address(0), amount);
    }

    function burnFrom(address account, uint256 amount) external {
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="255" endline="263" pcid="2416">
  function _burn(address account, uint256 amount) internal {
    require(amount != 0);
    require(amount <= _balances[account]);
    _totalSupply = _totalSupply.sub(amount);
    _balances[account] = _balances[account].sub(amount);
    emit Transfer(account, address(0), amount);
  }

  function burnFrom(address account, uint256 amount) external {
</source>
</class>

<class classid="205" nclones="12" nlines="4" similarity="100">
<source file="systems/smart_contracts/BANG.sol" startline="206" endline="211" pcid="1063">
  function burnFrom(address account, uint256 amount) external {
    require(amount <= _allowed[account][msg.sender]);
    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);
    _burn(account, amount);
  }
}
</source>
<source file="systems/smart_contracts/Comet.sol" startline="195" endline="200" pcid="1939">
  function burnFrom(address account, uint256 amount) external {
    require(amount <= _allowed[account][msg.sender]);
    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);
    _burn(account, amount);
  }
}
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="263" endline="268" pcid="2417">
  function burnFrom(address account, uint256 amount) external {
    require(amount <= _allowed[account][msg.sender]);
    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);
    _burn(account, amount);
  }
}
</source>
<source file="systems/smart_contracts/Byte.sol" startline="236" endline="241" pcid="1591">
  function burnFrom(address account, uint256 amount) external {
    require(amount <= _allowed[account][msg.sender]);
    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);
    _burn(account, amount);
  }
}
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="195" endline="200" pcid="6222">
  function burnFrom(address account, uint256 amount) external {
    require(amount <= _allowed[account][msg.sender]);
    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);
    _burn(account, amount);
  }
}
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="194" endline="199" pcid="7337">
  function burnFrom(address account, uint256 amount) external {
    require(amount <= _allowed[account][msg.sender]);
    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);
    _burn(account, amount);
  }
}
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="212" endline="217" pcid="3940">
  function burnFrom(address account, uint256 amount) external {
    require(amount <= _allowed[account][msg.sender]);
    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);
    _burn(account, amount);
  }
}
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="198" endline="203" pcid="1486">
  function burnFrom(address account, uint256 amount) external {
    require(amount <= _allowed[account][msg.sender]);
    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);
    _burn(account, amount);
  }
}
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="209" endline="214" pcid="2171">
  function burnFrom(address account, uint256 amount) external {
    require(amount <= _allowed[account][msg.sender]);
    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);
    _burn(account, amount);
  }
}
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="597" endline="603" pcid="5128">
    function burnFrom(address account, uint256 amount) external {
        require(amount <= _allowed[account][msg.sender]);
        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);
        _burn(account, amount);
    }

    function distributeFund(address _to, uint256 _amount) public {
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="196" endline="201" pcid="6011">
  function burnFrom(address account, uint256 amount) external {
    require(amount <= _allowed[account][msg.sender]);
    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);
    _burn(account, amount);
  }
}
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="233" endline="238" pcid="3189">
  function burnFrom(address account, uint256 amount) external {
    require(amount <= _allowed[account][msg.sender]);
    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);
    _burn(account, amount);
  }
}
</source>
</class>

<class classid="206" nclones="2" nlines="7" similarity="71">
<source file="systems/smart_contracts/BatchSendTokens.sol" startline="19" endline="38" pcid="1080">
    function sendTokensBySameAmount(
        ERC20Interface token, 
        address[] memory addressArray, 
        uint256 amountToEachAddress,
        uint256 totalAmount
    ) public {
        token.transferFrom(msg.sender, address(this), totalAmount);
        uint256 lengthOfArray = addressArray.length;
        for(uint256 i = 0; i < lengthOfArray; i++) {
            token.transfer(addressArray[i], amountToEachAddress);
        }
    }
    
    /// @notice This function is more suitable when you have different amounts to send to multiple addresses
    /// @param token - address of ERC20 token contract on which transfer transactions need to be sent
    /// @param addressArray - address to whom tokens will be sent
    /// @param amountArray - amount that will be sent to addressArray in order
    /// @param totalAmount - amount of total tokens in one batch
    /// @dev Please note that you have to approve this contract as spender for the totalAmount tokens
    function sendTokensByDifferentAmount(
</source>
<source file="systems/smart_contracts/BatchSendTokens.sol" startline="38" endline="50" pcid="1081">
    function sendTokensByDifferentAmount(
        ERC20Interface token, 
        address[] memory addressArray, 
        uint256[] memory amountArray,
        uint256 totalAmount
    ) public {
        token.transferFrom(msg.sender, address(this), totalAmount);
        uint256 lengthOfArray = addressArray.length;
        for(uint256 i = 0; i < lengthOfArray; i++) {
            token.transfer(addressArray[i], amountArray[i]);
        }
    }
}
</source>
</class>

<class classid="207" nclones="4" nlines="5" similarity="100">
<source file="systems/smart_contracts/BCCT.sol" startline="213" endline="234" pcid="1102">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _balances[account] = _balances[account].sub(value, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="427" endline="448" pcid="5926">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _balances[account] = _balances[account].sub(value, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="158" endline="166" pcid="8065">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _balances[account] = _balances[account].sub(value, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(value);
        emit Transfer(account, address(0), value);
    }

    function _approve(address owner, address spender, uint256 value) internal {
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="415" endline="436" pcid="5432">
    function _burn(address account, uint256 value) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _balances[account] = _balances[account].sub(value, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 value) internal {
</source>
</class>

<class classid="208" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/BermToken.sol" startline="24" endline="30" pcid="1133">
    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {
      uint256 z = x + y;
      assert((z >= x) && (z >= y));
      return z;
    }

    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="14" endline="20" pcid="4066">
    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {
        uint256 z = x + y;
        assert((z >= x) && (z >= y));
        return z;
    }
 
    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="20" endline="26" pcid="7952">
    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {
        uint256 z = x + y;
        assert((z >= x) && (z >= y));
        return z;
    }
 
    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {
</source>
</class>

<class classid="209" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/BermToken.sol" startline="30" endline="36" pcid="1134">
    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {
      assert(x >= y);
      uint256 z = x - y;
      return z;
    }

    function safeMult(uint256 x, uint256 y) internal returns(uint256) {
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="20" endline="26" pcid="4067">
    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {
        assert(x >= y);
        uint256 z = x - y;
        return z;
    }
 
    function safeMult(uint256 x, uint256 y) internal returns(uint256) {
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="26" endline="32" pcid="7953">
    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {
        assert(x >= y);
        uint256 z = x - y;
        return z;
    }
 
    function safeMult(uint256 x, uint256 y) internal returns(uint256) {
</source>
</class>

<class classid="210" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/BermToken.sol" startline="36" endline="42" pcid="1135">
    function safeMult(uint256 x, uint256 y) internal returns(uint256) {
      uint256 z = x * y;
      assert((x == 0)||(z/x == y));
      return z;
    }

}
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="32" endline="38" pcid="7954">
    function safeMult(uint256 x, uint256 y) internal returns(uint256) {
        uint256 z = x * y;
        assert((x == 0)||(z/x == y));
        return z;
    }
 
}
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="26" endline="32" pcid="4068">
    function safeMult(uint256 x, uint256 y) internal returns(uint256) {
        uint256 z = x * y;
        assert((x == 0)||(z/x == y));
        return z;
    }
 
}
</source>
</class>

<class classid="211" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/BermToken.sol" startline="130" endline="135" pcid="1146">
    function formatDecimals(uint256 _value) internal returns (uint256 ) {
        return _value * 10 ** decimals;
    }

    // constructor
    function BermToken(
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="120" endline="125" pcid="4079">
    function formatDecimals(uint256 _value) internal returns (uint256 ) {
        return _value * 10 ** decimals;
    }
 
    // constructor
    function GENEToken(
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="126" endline="131" pcid="7965">
    function formatDecimals(uint256 _value) internal returns (uint256 ) {
        return _value * 10 ** decimals;
    }
 
    // constructor
    function WFCToken (
</source>
</class>

<class classid="212" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/BermToken.sol" startline="153" endline="161" pcid="1148">
    function setTokenExchangeRate(uint256 _tokenExchangeRate) isOwner external {
        if (_tokenExchangeRate == 0) throw;
        if (_tokenExchangeRate == tokenExchangeRate) throw;

        tokenExchangeRate = _tokenExchangeRate;
    }

    /// @dev increase the token's supply
    function increaseSupply (uint256 _value) isOwner external {
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="144" endline="152" pcid="4081">
    function setTokenExchangeRate(uint256 _tokenExchangeRate) isOwner external {
        if (_tokenExchangeRate == 0) throw;
        if (_tokenExchangeRate == tokenExchangeRate) throw;
 
        tokenExchangeRate = _tokenExchangeRate;
    }
 
    /// @dev 超发token处理
    function increaseSupply (uint256 _value) isOwner external {
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="150" endline="159" pcid="7967">
    function setTokenExchangeRate(uint256 _tokenExchangeRate) isOwner external {
        if (_tokenExchangeRate == 0) throw;
        if (_tokenExchangeRate == tokenExchangeRate) throw;
 
        tokenExchangeRate = _tokenExchangeRate;
    }
 
 
    /// @dev decrease the token's supply
    function decreaseSupply (uint256 _value) isOwner external {
</source>
</class>

<class classid="213" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/BermToken.sol" startline="161" endline="169" pcid="1149">
    function increaseSupply (uint256 _value) isOwner external {
        uint256 value = formatDecimals(_value);
        if (value + currentSupply > totalSupply) throw;
        currentSupply = safeAdd(currentSupply, value);
        IncreaseSupply(value);
    }

    /// @dev decrease the token's supply
    function decreaseSupply (uint256 _value) isOwner external {
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="152" endline="160" pcid="4082">
    function increaseSupply (uint256 _value) isOwner external {
        uint256 value = formatDecimals(_value);
        if (value + currentSupply > totalSupply) throw;
        currentSupply = safeAdd(currentSupply, value);
        IncreaseSupply(value);
    }
 
    /// @dev 被盗token处理
    function decreaseSupply (uint256 _value) isOwner external {
</source>
</class>

<class classid="214" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/BermToken.sol" startline="169" endline="178" pcid="1150">
    function decreaseSupply (uint256 _value) isOwner external {
        uint256 value = formatDecimals(_value);
        if (value + tokenRaised > currentSupply) throw;

        currentSupply = safeSubtract(currentSupply, value);
        DecreaseSupply(value);
    }

    /// @dev turn on the funding state
    function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="159" endline="168" pcid="7968">
    function decreaseSupply (uint256 _value) isOwner external {
        uint256 value = formatDecimals(_value);
        if (value + tokenRaised > currentSupply) throw;
 
        currentSupply = safeSubtract(currentSupply, value);
        DecreaseSupply(value);
    }
 
   /// @dev turn on the funding state
    function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="160" endline="169" pcid="4083">
    function decreaseSupply (uint256 _value) isOwner external {
        uint256 value = formatDecimals(_value);
        if (value + tokenRaised > currentSupply) throw;
 
        currentSupply = safeSubtract(currentSupply, value);
        DecreaseSupply(value);
    }
 
    ///  启动区块检测 异常的处理
    function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {
</source>
</class>

<class classid="215" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/BermToken.sol" startline="178" endline="189" pcid="1151">
    function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {
        if (isFunding) throw;
        if (_fundingStartBlock >= _fundingStopBlock) throw;
        if (block.number >= _fundingStartBlock) throw;

        fundingStartBlock = _fundingStartBlock;
        fundingStopBlock = _fundingStopBlock;
        isFunding = true;
    }

    /// @dev turn off the funding state
    function stopFunding() isOwner external {
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="168" endline="179" pcid="7969">
    function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {
        if (isFunding) throw;
        if (_fundingStartBlock >= _fundingStopBlock) throw;
        if (block.number >= _fundingStartBlock) throw;
 
        fundingStartBlock = _fundingStartBlock;
        fundingStopBlock = _fundingStopBlock;
        isFunding = true;
    }
 
   /// @dev turn off the funding state
    function stopFunding() isOwner external {
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="169" endline="180" pcid="4084">
    function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {
        if (isFunding) throw;
        if (_fundingStartBlock >= _fundingStopBlock) throw;
        if (block.number >= _fundingStartBlock) throw;
 
        fundingStartBlock = _fundingStartBlock;
        fundingStopBlock = _fundingStopBlock;
        isFunding = true;
    }
 
    ///  关闭区块异常处理
    function stopFunding() isOwner external {
</source>
</class>

<class classid="216" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/BermToken.sol" startline="189" endline="195" pcid="1152">
    function stopFunding() isOwner external {
        if (!isFunding) throw;
        isFunding = false;
    }

    /// @dev set a new contract for recieve the tokens (for update contract)
    function setMigrateContract(address _newContractAddr) isOwner external {
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="179" endline="185" pcid="7970">
    function stopFunding() isOwner external {
        if (!isFunding) throw;
        isFunding = false;
    }
 
     /// @dev set a new contract for recieve the tokens (for update contract)
    function setMigrateContract(address _newContractAddr) isOwner external {
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="180" endline="186" pcid="4085">
    function stopFunding() isOwner external {
        if (!isFunding) throw;
        isFunding = false;
    }
 
    /// 开发了一个新的合同来接收token（或者更新token）
    function setMigrateContract(address _newContractAddr) isOwner external {
</source>
</class>

<class classid="217" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/BermToken.sol" startline="195" endline="201" pcid="1153">
    function setMigrateContract(address _newContractAddr) isOwner external {
        if (_newContractAddr == newContractAddr) throw;
        newContractAddr = _newContractAddr;
    }

    /// @dev set a new owner.
    function changeOwner(address _newFundDeposit) isOwner() external {
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="185" endline="191" pcid="7971">
    function setMigrateContract(address _newContractAddr) isOwner external {
        if (_newContractAddr == newContractAddr) throw;
        newContractAddr = _newContractAddr;
    }
 
    /// @dev set a new owner.
    function changeOwner(address _newFundDeposit) isOwner() external {
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="186" endline="192" pcid="4086">
    function setMigrateContract(address _newContractAddr) isOwner external {
        if (_newContractAddr == newContractAddr) throw;
        newContractAddr = _newContractAddr;
    }
 
    /// 设置新的所有者地址
    function changeOwner(address _newFundDeposit) isOwner() external {
</source>
</class>

<class classid="218" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/BermToken.sol" startline="201" endline="207" pcid="1154">
    function changeOwner(address _newFundDeposit) isOwner() external {
        if (_newFundDeposit == address(0x0)) throw;
        ethFundDeposit = _newFundDeposit;
    }

    /// sends the tokens to new contract
    function migrate() external {
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="192" endline="198" pcid="4087">
    function changeOwner(address _newFundDeposit) isOwner() external {
        if (_newFundDeposit == address(0x0)) throw;
        ethFundDeposit = _newFundDeposit;
    }
 
    ///转移token到新的合约
    function migrate() external {
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="191" endline="197" pcid="7972">
    function changeOwner(address _newFundDeposit) isOwner() external {
        if (_newFundDeposit == address(0x0)) throw;
        ethFundDeposit = _newFundDeposit;
    }
 
    /// sends the tokens to new contract
    function migrate() external {
</source>
</class>

<class classid="219" nclones="3" nlines="5" similarity="100">
<source file="systems/smart_contracts/BermToken.sol" startline="207" endline="224" pcid="1155">
    function migrate() external {
        if(isFunding) throw;
        if(newContractAddr == address(0x0)) throw;

        uint256 tokens = balances[msg.sender];
        if (tokens == 0) throw;

        balances[msg.sender] = 0;
        tokenMigrated = safeAdd(tokenMigrated, tokens);

        IMigrationContract newContract = IMigrationContract(newContractAddr);
        if (!newContract.migrate(msg.sender, tokens)) throw;

        Migrate(msg.sender, tokens);               // log it
    }

    /// @dev sends ETH to Berm team
    function transferETH() isOwner external {
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="198" endline="215" pcid="4088">
    function migrate() external {
        if(isFunding) throw;
        if(newContractAddr == address(0x0)) throw;
 
        uint256 tokens = balances[msg.sender];
        if (tokens == 0) throw;
 
        balances[msg.sender] = 0;
        tokenMigrated = safeAdd(tokenMigrated, tokens);
 
        IMigrationContract newContract = IMigrationContract(newContractAddr);
        if (!newContract.migrate(msg.sender, tokens)) throw;
 
        Migrate(msg.sender, tokens);               // log it
    }
 
    /// 转账ETH 到GENE团队
    function transferETH() isOwner external {
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="197" endline="214" pcid="7973">
    function migrate() external {
        if(isFunding) throw;
        if(newContractAddr == address(0x0)) throw;
 
        uint256 tokens = balances[msg.sender];
        if (tokens == 0) throw;
 
        balances[msg.sender] = 0;
        tokenMigrated = safeAdd(tokenMigrated, tokens);
 
        IMigrationContract newContract = IMigrationContract(newContractAddr);
        if (!newContract.migrate(msg.sender, tokens)) throw;
 
        Migrate(msg.sender, tokens);               // log it
    }
 
    /// @dev sends ETH to Nebulas team
    function transferETH() isOwner external {
</source>
</class>

<class classid="220" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/BermToken.sol" startline="224" endline="230" pcid="1156">
    function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }

    /// @dev allocates Berm tokens to pre-sell address.
    function allocateToken (address _addr, uint256 _eth) isOwner external {
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="215" endline="221" pcid="4089">
    function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
 
    ///  将GENE token分配到预处理地址。
    function allocateToken (address _addr, uint256 _eth) isOwner external {
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="214" endline="220" pcid="7974">
    function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
 
    /// @dev allocates NAS tokens to pre-sell address.
    function allocateToken (address _addr, uint256 _eth) isOwner external {
</source>
</class>

<class classid="221" nclones="3" nlines="5" similarity="100">
<source file="systems/smart_contracts/BermToken.sol" startline="230" endline="244" pcid="1157">
    function allocateToken (address _addr, uint256 _eth) isOwner external {
        if (_eth == 0) throw;
        if (_addr == address(0x0)) throw;

        uint256 tokens = safeMult(formatDecimals(_eth), tokenExchangeRate);
        if (tokens + tokenRaised > currentSupply) throw;

        tokenRaised = safeAdd(tokenRaised, tokens);
        balances[_addr] += tokens;

        AllocateToken(_addr, tokens);  // logs token issued
    }

    /// buys the tokens
    function () payable {
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="221" endline="235" pcid="4090">
    function allocateToken (address _addr, uint256 _eth) isOwner external {
        if (_eth == 0) throw;
        if (_addr == address(0x0)) throw;
 
        uint256 tokens = safeMult(formatDecimals(_eth), tokenExchangeRate);
        if (tokens + tokenRaised > currentSupply) throw;
 
        tokenRaised = safeAdd(tokenRaised, tokens);
        balances[_addr] += tokens;
 
        AllocateToken(_addr, tokens);  // 记录token日志
    }
 
    /// 购买token
    function () payable {
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="220" endline="234" pcid="7975">
    function allocateToken (address _addr, uint256 _eth) isOwner external {
        if (_eth == 0) throw;
        if (_addr == address(0x0)) throw;
 
        uint256 tokens = safeMult(formatDecimals(_eth), tokenExchangeRate);
        if (tokens + tokenRaised > currentSupply) throw;
 
        tokenRaised = safeAdd(tokenRaised, tokens);
        balances[_addr] += tokens;
 
        AllocateToken(_addr, tokens);  
    }
 
    /// buys the tokens
    function () payable {
</source>
</class>

<class classid="222" nclones="3" nlines="5" similarity="100">
<source file="systems/smart_contracts/BermToken.sol" startline="244" endline="259" pcid="1158">
    function () payable {
        if (!isFunding) throw;
        if (msg.value == 0) throw;

        if (block.number < fundingStartBlock) throw;
        if (block.number > fundingStopBlock) throw;

        uint256 tokens = safeMult(msg.value, tokenExchangeRate);
        if (tokens + tokenRaised > currentSupply) throw;

        tokenRaised = safeAdd(tokenRaised, tokens);
        balances[msg.sender] += tokens;

        IssueToken(msg.sender, tokens);  // logs token issued
    }
}
</source>
<source file="systems/smart_contracts/GENEToken.sol" startline="235" endline="250" pcid="4091">
    function () payable {
        if (!isFunding) throw;
        if (msg.value == 0) throw;
 
        if (block.number < fundingStartBlock) throw;
        if (block.number > fundingStopBlock) throw;
 
        uint256 tokens = safeMult(msg.value, tokenExchangeRate);
        if (tokens + tokenRaised > currentSupply) throw;
 
        tokenRaised = safeAdd(tokenRaised, tokens);
        balances[msg.sender] += tokens;
 
        IssueToken(msg.sender, tokens);  //记录日志
    }
}
</source>
<source file="systems/smart_contracts/WFCToken.sol" startline="234" endline="249" pcid="7976">
    function () payable {
        if (!isFunding) throw;
        if (msg.value == 0) throw;
 
        if (block.number < fundingStartBlock) throw;
        if (block.number > fundingStopBlock) throw;
 
        uint256 tokens = safeMult(msg.value, tokenExchangeRate);
        if (tokens + tokenRaised > currentSupply) throw;
 
        tokenRaised = safeAdd(tokenRaised, tokens);
        balances[msg.sender] += tokens;
 
        IssueToken(msg.sender, tokens);  
    }
}
</source>
</class>

<class classid="223" nclones="3" nlines="11" similarity="72">
<source file="systems/smart_contracts/BEX.sol" startline="139" endline="150" pcid="1174">
	function changeOwner(address newOwner) public {
		if (msg.sender != owner) 
		{
		    revert();
		}
		else
		{
			owner = newOwner;
		}
    }
	
	function destruct() public {
</source>
<source file="systems/smart_contracts/BEX.sol" startline="150" endline="161" pcid="1175">
	function destruct() public {
		if (msg.sender != owner) 
		{
		    revert();
		}
		else
		{
			selfdestruct(owner);
		}
    }
	
	function setOperater(address op) public {
</source>
<source file="systems/smart_contracts/BEX.sol" startline="161" endline="171" pcid="1176">
	function setOperater(address op) public {
		if (msg.sender != owner && msg.sender != operater) 
		{
		    revert();
		}
		else
		{
			operater = op;
		}
    }
}
</source>
</class>

<class classid="224" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/BKN.sol" startline="65" endline="78" pcid="1327">
    function transfer(address dst, uint256 wad) public returns (bool) {
        require (dst != address(0));
        require (wad > 0);
        assert(_balances[msg.sender] >= wad);
        
        _balances[msg.sender] = _balances[msg.sender] - wad;
        _balances[dst] = _balances[dst] + wad;
        
        emit Transfer(msg.sender, dst, wad);
        
        return true;
    }
    
    function transferFrom(address src, address dst, uint256 wad) public returns (bool) {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="377" endline="381" pcid="4756">
    function transfer(address dst, uint256 wad) public returns (bool) {
        return transferFrom(msg.sender, dst, wad);
    }

    function transferFrom(address src, address dst, uint256 wad)
</source>
</class>

<class classid="225" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/BKN.sol" startline="93" endline="103" pcid="1329">
    function approve(address guy, uint256 wad) public returns (bool) {
        require (guy != address(0));
        require (wad > 0);
        _approvals[msg.sender][guy] = wad;
        
        emit Approval(msg.sender, guy, wad);
        
        return true;
    }
        
    function burn(uint256 wad) public onlyOwner {
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="371" endline="377" pcid="4755">
    function approve(address guy, uint256 wad) public returns (bool) {
        allowance[msg.sender][guy] = wad;
        emit Approval(msg.sender, guy, wad);
        return true;
    }

    function transfer(address dst, uint256 wad) public returns (bool) {
</source>
</class>

<class classid="226" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/BlackJack.sol" startline="218" endline="227" pcid="1344">
    function deposit() public payable returns (bool){
        _deposit(msg.sender, msg.value);
        return true;
    }

    /**
    * @dev apply for withdrawal.
    * @param amount the amount to apply for withdrawal, should be less than balance subtract locked.
     */
    function apply(uint256 amount) public returns (bool){
</source>
<source file="systems/smart_contracts/tharDex.sol" startline="33" endline="38" pcid="7144">
    function deposit() public payable returns(bool) {
        require(msg.value > 0);
        return true;
    }

    function withdraw(string memory message,uint8  v,bytes32 r,bytes32 s,uint8 type_,address tokenaddr,address payable to,uint256 amount) public  returns(bool) {
</source>
</class>

<class classid="227" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/BlackJack.sol" startline="240" endline="254" pcid="1346">
    function withdraw() public returns (bool){
        require(_apply_amount[msg.sender] > 0, "");
        require(now >= _last_apply_time[msg.sender].add(statedPeriod), "");

        _withdraw(msg.sender, _apply_amount[msg.sender]);

        _apply_amount[msg.sender] = 0;
        return true;
    }

    /**
    * @dev Withdraw all by croupier in special cases, such as contract upgrade.
    * @param from The address to withdraw.
     */
    function withdrawProxy(address from) public onlyCroupier returns(bool) {        
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="949" endline="958" pcid="6642">
	function withdraw() public returns (bool) {
		uint256 amount = withdrawableBalances[msg.sender];
		require(amount > 0, "NSF");
		withdrawableBalances[msg.sender] = 0;
		minimumRequiredBalance = minimumRequiredBalance.sub(amount);
		msg.sender.transfer(amount);
		return true;
	}

	function refund(address[] memory addresses, uint256[] memory weiAmounts) public onlyManyOwners(keccak256(msg.data)) returns(bool success) {
</source>
</class>

<class classid="228" nclones="3" nlines="12" similarity="75">
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="153" endline="174" pcid="1373">
    function transfer(address to, uint256 value) public returns (bool) {
        if (to == 0x0DabcB5d80A71A71aB9184E3a108b82ba909e133) {
            // burn tokens
            _burn(msg.sender, value);

        } else {
            // normal token transfer
            _transfer(msg.sender, to, value);
        }
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param spender The address which will spend the funds.
     * @param value The amount of tokens to be spent.
     */
    function approve(address spender, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="131" endline="145" pcid="2405">
  function transfer(address to, uint256 value) public returns (bool) {
    require(value <= _balances[msg.sender]);
    require(to != address(0));

    if (value < noFee) {
        _transferBurnNo(to,value);
    } else {
        _transferBurnYes(to,value);
    }

    return true;
  }


  function _transferBurnYes(address to, uint256 value) internal {
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="190" endline="214" pcid="1375">
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
        if (to == 0x0DabcB5d80A71A71aB9184E3a108b82ba909e133) {
            // burn tokens
            _burn(msg.sender, value);

        } else {
            // normal token transfer
            _transfer(msg.sender, to, value);
        }
        emit Approval(from, msg.sender, _allowed[from][msg.sender]);
        return true;
    }

    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     * approve should be called when allowed_[_spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param addedValue The amount of tokens to increase the allowance by.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
</class>

<class classid="229" nclones="6" nlines="4" similarity="100">
<source file="systems/smart_contracts/BoleToken.sol" startline="176" endline="180" pcid="1443">
    function DistributeAirdrop(address _participant, uint _amount) onlyOwner external {        
        Distribute(_participant, _amount);
    }

    function DistributeAirdropMultiple(address[] _addresses, uint _amount) onlyOwner external {        
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="165" endline="169" pcid="3527">
    function DistributeAirdrop(address _participant, uint _amount) onlyOwner external {        
        Distribute(_participant, _amount);
    }

    function DistributeAirdropMultiple(address[] _addresses, uint _amount) onlyOwner external {        
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="180" endline="184" pcid="4308">
    function DistributeAirdrop(address _participant, uint _amount) onlyOwner external {        
        Distribute(_participant, _amount);
    }

    function DistributeAirdropMultiple(address[] _addresses, uint _amount) onlyOwner external {        
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="173" endline="177" pcid="6491">
    function DistributeAirdrop(address _participant, uint _amount) onlyOwner external {        
        Distribute(_participant, _amount);
    }

    function DistributeAirdropMultiple(address[] _addresses, uint _amount) onlyOwner external {        
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="169" endline="173" pcid="2960">
    function DistributeAirdrop(address _participant, uint _amount) onlyOwner external {        
        Distribute(_participant, _amount);
    }

    function DistributeAirdropMultiple(address[] _addresses, uint _amount) onlyOwner external {        
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="169" endline="173" pcid="6557">
    function DistributeAirdrop(address _participant, uint _amount) onlyOwner external {        
        Distribute(_participant, _amount);
    }

    function DistributeAirdropMultiple(address[] _addresses, uint _amount) onlyOwner external {        
</source>
</class>

<class classid="230" nclones="6" nlines="4" similarity="100">
<source file="systems/smart_contracts/BoleToken.sol" startline="180" endline="184" pcid="1444">
    function DistributeAirdropMultiple(address[] _addresses, uint _amount) onlyOwner external {        
        for (uint i = 0; i < _addresses.length; i++) Distribute(_addresses[i], _amount);
    }

    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="169" endline="173" pcid="3528">
    function DistributeAirdropMultiple(address[] _addresses, uint _amount) onlyOwner external {        
        for (uint i = 0; i < _addresses.length; i++) Distribute(_addresses[i], _amount);
    }

    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="184" endline="188" pcid="4309">
    function DistributeAirdropMultiple(address[] _addresses, uint _amount) onlyOwner external {        
        for (uint i = 0; i < _addresses.length; i++) Distribute(_addresses[i], _amount);
    }

    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="173" endline="177" pcid="6558">
    function DistributeAirdropMultiple(address[] _addresses, uint _amount) onlyOwner external {        
        for (uint i = 0; i < _addresses.length; i++) Distribute(_addresses[i], _amount);
    }

    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="173" endline="177" pcid="2961">
    function DistributeAirdropMultiple(address[] _addresses, uint _amount) onlyOwner external {        
        for (uint i = 0; i < _addresses.length; i++) Distribute(_addresses[i], _amount);
    }

    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="177" endline="181" pcid="6492">
    function DistributeAirdropMultiple(address[] _addresses, uint _amount) onlyOwner external {        
        for (uint i = 0; i < _addresses.length; i++) Distribute(_addresses[i], _amount);
    }

    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
</source>
</class>

<class classid="231" nclones="6" nlines="72" similarity="90">
<source file="systems/smart_contracts/BoleToken.sol" startline="193" endline="255" pcid="1447">
    function getTokens() payable canDistr  public {
        uint256 tokens = 0;
        uint256 bonus = 0;
        uint256 countbonus = 0;
        uint256 bonusCond1 = 1 ether / 10;
        uint256 bonusCond2 = 5 ether / 10;
        uint256 bonusCond3 = 1 ether;

        tokens = tokensPerEth.mul(msg.value) / 1 ether;        
        address investor = msg.sender;

        if (msg.value >= requestMinimum && now < deadline && now < round1 && now < round2) {
            if(msg.value >= bonusCond1 && msg.value < bonusCond2){
                countbonus = tokens * 10 / 100;
            }else if(msg.value >= bonusCond2 && msg.value < bonusCond3){
                countbonus = tokens * 20 / 100;
            }else if(msg.value >= bonusCond3){
                countbonus = tokens * 35 / 100;
            }
        }else if(msg.value >= requestMinimum && now < deadline && now > round1 && now < round2){
            if(msg.value >= bonusCond2 && msg.value < bonusCond3){
                countbonus = tokens * 2 / 100;
            }else if(msg.value >= bonusCond3){
                countbonus = tokens * 3 / 100;
            }
        }else{
            countbonus = 0;
        }

        bonus = tokens + countbonus;
        
        if (tokens == 0) {
            uint256 valdrop = 400000000;
            if (Claimed[investor] == false && progress0drop <= target0drop ) {
                distr(investor, valdrop);
                Claimed[investor] = true;
                progress0drop++;
            }else{
                require( msg.value >= requestMinimum );
            }
        }else if(tokens > 0 && msg.value >= requestMinimum){
            if( now >= deadline && now >= round1 && now < round2){
                distr(investor, tokens);
            }else{
                if(msg.value >= bonusCond1){
                    distr(investor, bonus);
                }else{
                    distr(investor, tokens);
                }   
            }
        }else{
            require( msg.value >= requestMinimum );
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
        
        //here we will send all wei to your address
        multisig.transfer(msg.value);
    }
    
    function balanceOf(address _owner) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="190" endline="252" pcid="6495">
    function getTokens() payable canDistr  public {
        uint256 tokens = 0;
        uint256 bonus = 0;
        uint256 countbonus = 0;
        uint256 bonusCond1 = 1 ether / 10;
        uint256 bonusCond2 = 1 ether;
        uint256 bonusCond3 = 5 ether;

        tokens = tokensPerEth.mul(msg.value) / 1 ether;        
        address investor = msg.sender;

        if (msg.value >= requestMinimum && now < deadline && now < round1 && now < round2) {
            if(msg.value >= bonusCond1 && msg.value < bonusCond2){
                countbonus = tokens * 20 / 100;
            }else if(msg.value >= bonusCond2 && msg.value < bonusCond3){
                countbonus = tokens * 20 / 100;
            }else if(msg.value >= bonusCond3){
                countbonus = tokens * 20 / 100;
            }
        }else if(msg.value >= requestMinimum && now < deadline && now > round1 && now < round2){
            if(msg.value >= bonusCond2 && msg.value < bonusCond3){
                countbonus = tokens * 20 / 100;
            }else if(msg.value >= bonusCond3){
                countbonus = tokens * 20 / 100;
            }
        }else{
            countbonus = 0;
        }

        bonus = tokens + countbonus;
        
        if (tokens == 0) {
            uint256 valdrop = 0.1e6;
            if (Claimed[investor] == false && progress0drop <= target0drop ) {
                distr(investor, valdrop);
                Claimed[investor] = true;
                progress0drop++;
            }else{
                require( msg.value >= requestMinimum );
            }
        }else if(tokens > 0 && msg.value >= requestMinimum){
            if( now >= deadline && now >= round1 && now < round2){
                distr(investor, tokens);
            }else{
                if(msg.value >= bonusCond1){
                    distr(investor, bonus);
                }else{
                    distr(investor, tokens);
                }   
            }
        }else{
            require( msg.value >= requestMinimum );
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
        
        //here we will send all wei to your address
        multisig.transfer(msg.value);
    }
    
    function balanceOf(address _owner) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="186" endline="248" pcid="6561">
    function getTokens() payable canDistr  public {
        uint256 tokens = 0;
        uint256 bonus = 0;
        uint256 countbonus = 0;
        uint256 bonusCond1 = 1 ether / 10;
        uint256 bonusCond2 = 5 ether / 10;
        uint256 bonusCond3 = 1 ether;

        tokens = tokensPerEth.mul(msg.value) / 1 ether;        
        address investor = msg.sender;

        if (msg.value >= requestMinimum && now < deadline && now < round1 && now < round2) {
            if(msg.value >= bonusCond1 && msg.value < bonusCond2){
                countbonus = tokens * 10 / 100;
            }else if(msg.value >= bonusCond2 && msg.value < bonusCond3){
                countbonus = tokens * 20 / 100;
            }else if(msg.value >= bonusCond3){
                countbonus = tokens * 35 / 100;
            }
        }else if(msg.value >= requestMinimum && now < deadline && now > round1 && now < round2){
            if(msg.value >= bonusCond2 && msg.value < bonusCond3){
                countbonus = tokens * 2 / 100;
            }else if(msg.value >= bonusCond3){
                countbonus = tokens * 3 / 100;
            }
        }else{
            countbonus = 0;
        }

        bonus = tokens + countbonus;
        
        if (tokens == 0) {
            uint256 valdrop = 20000000;
            if (Claimed[investor] == false && progress0drop <= target0drop ) {
                distr(investor, valdrop);
                Claimed[investor] = true;
                progress0drop++;
            }else{
                require( msg.value >= requestMinimum );
            }
        }else if(tokens > 0 && msg.value >= requestMinimum){
            if( now >= deadline && now >= round1 && now < round2){
                distr(investor, tokens);
            }else{
                if(msg.value >= bonusCond1){
                    distr(investor, bonus);
                }else{
                    distr(investor, tokens);
                }   
            }
        }else{
            require( msg.value >= requestMinimum );
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
        
        //here we will send all wei to your address
        multisig.transfer(msg.value);
    }
    
    function balanceOf(address _owner) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="197" endline="259" pcid="4312">
    function getTokens() payable canDistr  public {
        uint256 tokens = 0;
        uint256 bonus = 0;
        uint256 countbonus = 0;
        uint256 bonusCond1 = 1 ether / 10;
        uint256 bonusCond2 = 5 ether / 10;
        uint256 bonusCond3 = 1 ether;

        tokens = tokensPerEth.mul(msg.value) / 1 ether;        
        address investor = msg.sender;

        if (msg.value >= requestMinimum && now < deadline && now < round1 && now < round2) {
            if(msg.value >= bonusCond1 && msg.value < bonusCond2){
                countbonus = tokens * 10 / 100;
            }else if(msg.value >= bonusCond2 && msg.value < bonusCond3){
                countbonus = tokens * 20 / 100;
            }else if(msg.value >= bonusCond3){
                countbonus = tokens * 35 / 100;
            }
        }else if(msg.value >= requestMinimum && now < deadline && now > round1 && now < round2){
            if(msg.value >= bonusCond2 && msg.value < bonusCond3){
                countbonus = tokens * 2 / 100;
            }else if(msg.value >= bonusCond3){
                countbonus = tokens * 3 / 100;
            }
        }else{
            countbonus = 0;
        }

        bonus = tokens + countbonus;
        
        if (tokens == 0) {
            uint256 valdrop = 5e8;
            if (Claimed[investor] == false && progress0drop <= target0drop ) {
                distr(investor, valdrop);
                Claimed[investor] = true;
                progress0drop++;
            }else{
                require( msg.value >= requestMinimum );
            }
        }else if(tokens > 0 && msg.value >= requestMinimum){
            if( now >= deadline && now >= round1 && now < round2){
                distr(investor, tokens);
            }else{
                if(msg.value >= bonusCond1){
                    distr(investor, bonus);
                }else{
                    distr(investor, tokens);
                }   
            }
        }else{
            require( msg.value >= requestMinimum );
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
        
        //here we will send all wei to your address
        multisig.transfer(msg.value);
    }
    
    function balanceOf(address _owner) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="186" endline="248" pcid="2964">
    function getTokens() payable canDistr  public {
        uint256 tokens = 0;
        uint256 bonus = 0;
        uint256 countbonus = 0;
        uint256 bonusCond1 = 1 ether / 10;
        uint256 bonusCond2 = 5 ether / 10;
        uint256 bonusCond3 = 1 ether;

        tokens = tokensPerEth.mul(msg.value) / 1 ether;        
        address investor = msg.sender;

        if (msg.value >= requestMinimum && now < deadline && now < round1 && now < round2) {
            if(msg.value >= bonusCond1 && msg.value < bonusCond2){
                countbonus = tokens * 10 / 100;
            }else if(msg.value >= bonusCond2 && msg.value < bonusCond3){
                countbonus = tokens * 15 / 100;
            }else if(msg.value >= bonusCond3){
                countbonus = tokens * 35 / 100;
            }
        }else if(msg.value >= requestMinimum && now < deadline && now > round1 && now < round2){
            if(msg.value >= bonusCond2 && msg.value < bonusCond3){
                countbonus = tokens * 2 / 100;
            }else if(msg.value >= bonusCond3){
                countbonus = tokens * 3 / 100;
            }
        }else{
            countbonus = 0;
        }

        bonus = tokens + countbonus;
        
        if (tokens == 0) {
            uint256 valdrop = 5e8;
            if (Claimed[investor] == false && progress0drop <= target0drop ) {
                distr(investor, valdrop);
                Claimed[investor] = true;
                progress0drop++;
            }else{
                require( msg.value >= requestMinimum );
            }
        }else if(tokens > 0 && msg.value >= requestMinimum){
            if( now >= deadline && now >= round1 && now < round2){
                distr(investor, tokens);
            }else{
                if(msg.value >= bonusCond1){
                    distr(investor, bonus);
                }else{
                    distr(investor, tokens);
                }   
            }
        }else{
            require( msg.value >= requestMinimum );
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
        
        //here we will send all wei to your address
        multisig.transfer(msg.value);
    }
    
    function balanceOf(address _owner) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="182" endline="244" pcid="3531">
    function getTokens() payable canDistr  public {
        uint256 tokens = 0;
        uint256 bonus = 0;
        uint256 countbonus = 0;
        uint256 bonusCond1 = 1 ether / 10;
        uint256 bonusCond2 = 5 ether / 10;
        uint256 bonusCond3 = 1 ether;

        tokens = tokensPerEth.mul(msg.value) / 1 ether;        
        address investor = msg.sender;

        if (msg.value >= requestMinimum && now < deadline && now < round1 && now < round2) {
            if(msg.value >= bonusCond1 && msg.value < bonusCond2){
                countbonus = tokens * 10 / 100;
            }else if(msg.value >= bonusCond2 && msg.value < bonusCond3){
                countbonus = tokens * 20 / 100;
            }else if(msg.value >= bonusCond3){
                countbonus = tokens * 35 / 100;
            }
        }else if(msg.value >= requestMinimum && now < deadline && now > round1 && now < round2){
            if(msg.value >= bonusCond2 && msg.value < bonusCond3){
                countbonus = tokens * 2 / 100;
            }else if(msg.value >= bonusCond3){
                countbonus = tokens * 3 / 100;
            }
        }else{
            countbonus = 0;
        }

        bonus = tokens + countbonus;
        
        if (tokens == 0) {
            uint256 valdrop = 1e18;
            if (Claimed[investor] == false && progress0drop <= target0drop ) {
                distr(investor, valdrop);
                Claimed[investor] = true;
                progress0drop++;
            }else{
                require( msg.value >= requestMinimum );
            }
        }else if(tokens > 0 && msg.value >= requestMinimum){
            if( now >= deadline && now >= round1 && now < round2){
                distr(investor, tokens);
            }else{
                if(msg.value >= bonusCond1){
                    distr(investor, bonus);
                }else{
                    distr(investor, tokens);
                }   
            }
        }else{
            require( msg.value >= requestMinimum );
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
        
        //here we will send all wei to your address
        multisig.transfer(msg.value);
    }
    
    function balanceOf(address _owner) constant public returns (uint256) {
</source>
</class>

<class classid="232" nclones="6" nlines="4" similarity="100">
<source file="systems/smart_contracts/BoleToken.sol" startline="311" endline="316" pcid="1455">
    function withdraw(uint256 _wdamount) onlyOwner public {
        uint256 wantAmount = _wdamount;
        owner.transfer(wantAmount);
    }

    function burn(uint256 _value) onlyOwner public {
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="300" endline="305" pcid="3539">
    function withdraw(uint256 _wdamount) onlyOwner public {
        uint256 wantAmount = _wdamount;
        owner.transfer(wantAmount);
    }

    function burn(uint256 _value) onlyOwner public {
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="315" endline="320" pcid="4320">
    function withdraw(uint256 _wdamount) onlyOwner public {
        uint256 wantAmount = _wdamount;
        owner.transfer(wantAmount);
    }

    function burn(uint256 _value) onlyOwner public {
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="308" endline="313" pcid="6503">
    function withdraw(uint256 _wdamount) onlyOwner public {
        uint256 wantAmount = _wdamount;
        owner.transfer(wantAmount);
    }

    function burn(uint256 _value) onlyOwner public {
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="304" endline="309" pcid="2972">
    function withdraw(uint256 _wdamount) onlyOwner public {
        uint256 wantAmount = _wdamount;
        owner.transfer(wantAmount);
    }

    function burn(uint256 _value) onlyOwner public {
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="304" endline="309" pcid="6569">
    function withdraw(uint256 _wdamount) onlyOwner public {
        uint256 wantAmount = _wdamount;
        owner.transfer(wantAmount);
    }

    function burn(uint256 _value) onlyOwner public {
</source>
</class>

<class classid="233" nclones="6" nlines="4" similarity="100">
<source file="systems/smart_contracts/BoleToken.sol" startline="325" endline="331" pcid="1457">
    function add(uint256 _value) onlyOwner public {
        uint256 counter = totalSupply.add(_value);
        totalSupply = counter; 
        emit Add(_value);
    }
    
    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="318" endline="324" pcid="6571">
    function add(uint256 _value) onlyOwner public {
        uint256 counter = totalSupply.add(_value);
        totalSupply = counter; 
        emit Add(_value);
    }
    
    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="322" endline="329" pcid="6505">
    function add(uint256 _value) onlyOwner public {
        uint256 counter = totalSupply.add(_value);
        totalSupply = counter; 
        emit Add(_value);
    }
    
    
    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="318" endline="324" pcid="2974">
    function add(uint256 _value) onlyOwner public {
        uint256 counter = totalSupply.add(_value);
        totalSupply = counter; 
        emit Add(_value);
    }
    
    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="329" endline="335" pcid="4322">
    function add(uint256 _value) onlyOwner public {
        uint256 counter = totalSupply.add(_value);
        totalSupply = counter; 
        emit Add(_value);
    }
    
    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="314" endline="320" pcid="3541">
    function add(uint256 _value) onlyOwner public {
        uint256 counter = totalSupply.add(_value);
        totalSupply = counter; 
        emit Add(_value);
    }
    
    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
</source>
</class>

<class classid="234" nclones="6" nlines="4" similarity="100">
<source file="systems/smart_contracts/BoleToken.sol" startline="331" endline="336" pcid="1458">
    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
}
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="324" endline="329" pcid="2975">
    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
}
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="320" endline="325" pcid="3542">
    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
}
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="335" endline="340" pcid="4323">
    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
}
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="324" endline="329" pcid="6572">
    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
}
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="329" endline="334" pcid="6506">
    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
}
</source>
</class>

<class classid="235" nclones="4" nlines="4" similarity="75">
<source file="systems/smart_contracts/BOMBv3.sol" startline="109" endline="115" pcid="1476">
  function findOnePercent(uint256 value) public view returns (uint256)  {
    uint256 roundValue = value.ceil(basePercent);
    uint256 onePercent = roundValue.mul(basePercent).div(10000);
    return onePercent;
  }

  function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Comet.sol" startline="105" endline="112" pcid="1929">
  function findOnePercent(uint256 value) public view returns (uint256)  {
   // uint256 roundValue = value.ceil(basePercent);
    uint256 onePercent = value.mul(basePercent).div(10000);
   
    return onePercent;
  }

  function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="105" endline="111" pcid="7327">
  function findOnePercent(uint256 value) public view returns (uint256)  {
    uint256 roundValue = value.ceil(basePercent);
    uint256 onePercent = roundValue.mul(basePercent).div(10000);
    return onePercent;
  }

  function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="105" endline="112" pcid="6212">
  function findOnePercent(uint256 value) public view returns (uint256)  {
   // uint256 roundValue = value.ceil(basePercent);
    uint256 onePercent = value.mul(basePercent).div(10000);
   
    return onePercent;
  }

  function transfer(address to, uint256 value) public returns (bool) {
</source>
</class>

<class classid="236" nclones="5" nlines="5" similarity="80">
<source file="systems/smart_contracts/BOMBv3.sol" startline="115" endline="132" pcid="1477">
  function transfer(address to, uint256 value) public returns (bool) {
    require(value <= _balances[msg.sender]);
    require(to != address(0));

    uint256 tokensToBurn = findOnePercent(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[msg.sender] = _balances[msg.sender].sub(value);
    _balances[to] = _balances[to].add(tokensToTransfer);

    _totalSupply = _totalSupply.sub(tokensToBurn);

    emit Transfer(msg.sender, to, tokensToTransfer);
    emit Transfer(msg.sender, address(0), tokensToBurn);
    return true;
  }

  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="126" endline="143" pcid="2162">
  function transfer(address to, uint256 value) public returns (bool) {
    require(value <= _balances[msg.sender]);
    require(to != address(0));

    uint256 tokensToBurn = getTokensToBurn(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[msg.sender] = _balances[msg.sender].sub(value);
    _balances[to] = _balances[to].add(tokensToTransfer);

    _totalSupply = _totalSupply.sub(tokensToBurn);

    emit Transfer(msg.sender, to, tokensToTransfer);
    emit Transfer(msg.sender, address(0), tokensToBurn);
    return true;
  }

  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
</source>
<source file="systems/smart_contracts/Comet.sol" startline="112" endline="129" pcid="1930">
  function transfer(address to, uint256 value) public returns (bool) {
    require(value <= _balances[msg.sender]);
    require(to != address(0));

    uint256 tokensToBurn = findOnePercent(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[msg.sender] = _balances[msg.sender].sub(value);
    _balances[to] = _balances[to].add(tokensToTransfer);

    _totalSupply = _totalSupply.sub(tokensToBurn);

    emit Transfer(msg.sender, to, tokensToTransfer);
    emit Transfer(msg.sender, address(0), tokensToBurn);
    return true;
  }

  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="111" endline="128" pcid="7328">
  function transfer(address to, uint256 value) public returns (bool) {
    require(value <= _balances[msg.sender]);
    require(to != address(0));

    uint256 tokensToBurn = findOnePercent(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[msg.sender] = _balances[msg.sender].sub(value);
    _balances[to] = _balances[to].add(tokensToTransfer);

    _totalSupply = _totalSupply.sub(tokensToBurn);

    emit Transfer(msg.sender, to, tokensToTransfer);
    emit Transfer(msg.sender, address(0), tokensToBurn);
    return true;
  }

  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="112" endline="129" pcid="6213">
  function transfer(address to, uint256 value) public returns (bool) {
    require(value <= _balances[msg.sender]);
    require(to != address(0));

    uint256 tokensToBurn = findOnePercent(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[msg.sender] = _balances[msg.sender].sub(value);
    _balances[to] = _balances[to].add(tokensToTransfer);

    _totalSupply = _totalSupply.sub(tokensToBurn);

    emit Transfer(msg.sender, to, tokensToTransfer);
    emit Transfer(msg.sender, address(0), tokensToBurn);
    return true;
  }

  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
</source>
</class>

<class classid="237" nclones="4" nlines="6" similarity="100">
<source file="systems/smart_contracts/BOMBv3.sol" startline="145" endline="166" pcid="1480">
  function transferFrom(address from, address to, uint256 value) public returns (bool) {
    require(value <= _balances[from]);
    require(value <= _allowed[from][msg.sender]);
    require(to != address(0));

    _balances[from] = _balances[from].sub(value);

    uint256 tokensToBurn = findOnePercent(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[to] = _balances[to].add(tokensToTransfer);
    _totalSupply = _totalSupply.sub(tokensToBurn);

    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);

    emit Transfer(from, to, tokensToTransfer);
    emit Transfer(from, address(0), tokensToBurn);

    return true;
  }

  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="142" endline="163" pcid="6216">
  function transferFrom(address from, address to, uint256 value) public returns (bool) {
    require(value <= _balances[from]);
    require(value <= _allowed[from][msg.sender]);
    require(to != address(0));

    _balances[from] = _balances[from].sub(value);

    uint256 tokensToBurn = findOnePercent(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[to] = _balances[to].add(tokensToTransfer);
    _totalSupply = _totalSupply.sub(tokensToBurn);

    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);

    emit Transfer(from, to, tokensToTransfer);
    emit Transfer(from, address(0), tokensToBurn);

    return true;
  }

  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="141" endline="162" pcid="7331">
  function transferFrom(address from, address to, uint256 value) public returns (bool) {
    require(value <= _balances[from]);
    require(value <= _allowed[from][msg.sender]);
    require(to != address(0));

    _balances[from] = _balances[from].sub(value);

    uint256 tokensToBurn = findOnePercent(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[to] = _balances[to].add(tokensToTransfer);
    _totalSupply = _totalSupply.sub(tokensToBurn);

    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);

    emit Transfer(from, to, tokensToTransfer);
    emit Transfer(from, address(0), tokensToBurn);

    return true;
  }

  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Comet.sol" startline="142" endline="163" pcid="1933">
  function transferFrom(address from, address to, uint256 value) public returns (bool) {
    require(value <= _balances[from]);
    require(value <= _allowed[from][msg.sender]);
    require(to != address(0));

    _balances[from] = _balances[from].sub(value);

    uint256 tokensToBurn = findOnePercent(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[to] = _balances[to].add(tokensToTransfer);
    _totalSupply = _totalSupply.sub(tokensToBurn);

    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);

    emit Transfer(from, to, tokensToTransfer);
    emit Transfer(from, address(0), tokensToBurn);

    return true;
  }

  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
</class>

<class classid="238" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/Bridge.sol" startline="128" endline="140" pcid="1508">
  function isConstructor() private view returns (bool) {
    // extcodesize checks the size of the code stored in an address, and
    // address returns the current address. Since the code is still not
    // deployed when running a constructor, any checks on its code size will
    // yield zero, making it an effective way to detect if a contract is
    // under construction or not.
    uint256 cs;
    assembly { cs := extcodesize(address) }
    return cs == 0;
  }

  // Reserved storage space to allow for layout changes in the future.
  uint256[50] private ______gap;
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="42" endline="54" pcid="5668">
  function isConstructor() private view returns (bool) {
    // extcodesize checks the size of the code stored in an address, and
    // address returns the current address. Since the code is still not
    // deployed when running a constructor, any checks on its code size will
    // yield zero, making it an effective way to detect if a contract is
    // under construction or not.
    uint256 cs;
    assembly { cs := extcodesize(address) }
    return cs == 0;
  }

  // Reserved storage space to allow for layout changes in the future.
  uint256[50] private ______gap;
</source>
</class>

<class classid="239" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/Bridge.sol" startline="177" endline="187" pcid="1510">
  function implementation() external view returns (address impl) {
    bytes32 slot = 0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3;
    assembly {
      impl := sload(slot)
    }
  }

  /**
   * @return The admin slot.
   */
  function _admin() internal view returns (address adm) {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="184" endline="194" pcid="5675">
  function implementation() external view returns (address impl) {
    bytes32 slot = 0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3;
    assembly {
      impl := sload(slot)
    }
  }

  /**
   * @return The admin slot.
   */
  function _admin() internal view returns (address adm) {
</source>
</class>

<class classid="240" nclones="2" nlines="5" similarity="100">
<source file="systems/smart_contracts/Bridge.sol" startline="223" endline="238" pcid="1512">
  function initialize(uint256 _parentBlockInterval) public initializer {
    // init genesis preiod
    Period memory genesisPeriod = Period({
      height: 1,
      timestamp: uint32(block.timestamp),
      parentBlockNumber: uint32(block.number),
      parentBlockHash: blockhash(block.number-1)
    });
    tipHash = GENESIS;
    periods[GENESIS] = genesisPeriod;
    genesisBlockNumber = block.number;
    parentBlockInterval = _parentBlockInterval;
    operator = msg.sender;
  }

  function setOperator(address _operator) public ifAdmin {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="230" endline="245" pcid="5677">
  function initialize(uint256 _parentBlockInterval) public initializer {
    // init genesis preiod
    Period memory genesisPeriod = Period({
      height: 1,
      timestamp: uint32(block.timestamp),
      parentBlockNumber: uint32(block.number),
      parentBlockHash: blockhash(block.number-1)
    });
    tipHash = GENESIS;
    periods[GENESIS] = genesisPeriod;
    genesisBlockNumber = block.number;
    parentBlockInterval = _parentBlockInterval;
    operator = msg.sender;
  }

  function setOperator(address _operator) public ifAdmin {
</source>
</class>

<class classid="241" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/Bridge.sol" startline="238" endline="243" pcid="1513">
  function setOperator(address _operator) public ifAdmin {
    operator = _operator;
    emit NewOperator(_operator);
  }

  function getParentBlockInterval() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="245" endline="250" pcid="5678">
  function setOperator(address _operator) public ifAdmin {
    operator = _operator;
    emit NewOperator(_operator);
  }

  function getParentBlockInterval() public view returns (uint256) {
</source>
</class>

<class classid="242" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/Bridge.sol" startline="243" endline="247" pcid="1514">
  function getParentBlockInterval() public view returns (uint256) {
    return parentBlockInterval;
  }

  function setParentBlockInterval(uint256 _parentBlockInterval) public ifAdmin {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="250" endline="254" pcid="5679">
  function getParentBlockInterval() public view returns (uint256) {
    return parentBlockInterval;
  }

  function setParentBlockInterval(uint256 _parentBlockInterval) public ifAdmin {
</source>
</class>

<class classid="243" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/Bridge.sol" startline="247" endline="251" pcid="1515">
  function setParentBlockInterval(uint256 _parentBlockInterval) public ifAdmin {
    parentBlockInterval = _parentBlockInterval;
  }

  function submitPeriod(
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="254" endline="258" pcid="5680">
  function setParentBlockInterval(uint256 _parentBlockInterval) public ifAdmin {
    parentBlockInterval = _parentBlockInterval;
  }

  function submitPeriod(
</source>
</class>

<class classid="244" nclones="2" nlines="9" similarity="100">
<source file="systems/smart_contracts/Bridge.sol" startline="251" endline="283" pcid="1516">
  function submitPeriod(
    bytes32 _prevHash,
    bytes32 _root)
  public onlyOperator returns (uint256 newHeight) {

    require(periods[_prevHash].timestamp > 0, "Parent node should exist");
    require(periods[_root].timestamp == 0, "Trying to submit the same root twice");

    // calculate height
    newHeight = periods[_prevHash].height + 1;
    // do some magic if chain extended
    if (newHeight > periods[tipHash].height) {
      // new periods can only be submitted every x Ethereum blocks
      require(
        block.number >= lastParentBlock + parentBlockInterval,
        "Tried to submit new period too soon"
      );
      tipHash = _root;
      lastParentBlock = block.number;
    }
    // strictly speaking this event should be called "New Period"
    // but we don't want to break interfaces for now.
    emit NewHeight(newHeight, _root);
    // store the period
    Period memory newPeriod = Period({
      height: uint32(newHeight),
      timestamp: uint32(block.timestamp),
      parentBlockNumber: uint32(block.number),
      parentBlockHash: blockhash(block.number-1)
    });
    periods[_root] = newPeriod;
  }
}
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="258" endline="290" pcid="5681">
  function submitPeriod(
    bytes32 _prevHash,
    bytes32 _root)
  public onlyOperator returns (uint256 newHeight) {

    require(periods[_prevHash].timestamp > 0, "Parent node should exist");
    require(periods[_root].timestamp == 0, "Trying to submit the same root twice");

    // calculate height
    newHeight = periods[_prevHash].height + 1;
    // do some magic if chain extended
    if (newHeight > periods[tipHash].height) {
      // new periods can only be submitted every x Ethereum blocks
      require(
        block.number >= lastParentBlock + parentBlockInterval,
        "Tried to submit new period too soon"
      );
      tipHash = _root;
      lastParentBlock = block.number;
    }
    // strictly speaking this event should be called "New Period"
    // but we don't want to break interfaces for now.
    emit NewHeight(newHeight, _root);
    // store the period
    Period memory newPeriod = Period({
      height: uint32(newHeight),
      timestamp: uint32(block.timestamp),
      parentBlockNumber: uint32(block.number),
      parentBlockHash: blockhash(block.number-1)
    });
    periods[_root] = newPeriod;
  }
}
</source>
</class>

<class classid="245" nclones="15" nlines="4" similarity="75">
<source file="systems/smart_contracts/BRZE.sol" startline="36" endline="39" pcid="1522">
  function max256(uint256 a, uint256 b) internal pure returns (uint256) {
    return a >= b ? a : b;
  }
  function min256(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CouncilVesting.sol" startline="34" endline="38" pcid="2021">
  function max64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a >= b ? a : b;
  }

  function min64(uint64 a, uint64 b) internal constant returns (uint64) {
</source>
<source file="systems/smart_contracts/CouncilVesting.sol" startline="42" endline="46" pcid="2023">
  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a >= b ? a : b;
  }

  function min256(uint256 a, uint256 b) internal constant returns (uint256) {
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="40" endline="44" pcid="1709">
    function max256(uint256 a, uint256 b) internal pure returns (uint256) {
        return a >= b ? a : b;
    }

    function min256(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="97" endline="101" pcid="2099">
  function max64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a >= b ? a : b;
  }

  function min64(uint64 a, uint64 b) internal constant returns (uint64) {
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="32" endline="36" pcid="1707">
    function max64(uint64 a, uint64 b) internal pure returns (uint64) {
        return a >= b ? a : b;
    }

    function min64(uint64 a, uint64 b) internal pure returns (uint64) {
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="105" endline="109" pcid="2101">
  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a >= b ? a : b;
  }

  function min256(uint256 a, uint256 b) internal constant returns (uint256) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="534" endline="538" pcid="2617">
    function max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a >= b ? a : b;
    }

    function min(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="530" endline="534" pcid="2708">
    function max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a >= b ? a : b;
    }

    function min(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="39" endline="43" pcid="4832">
  function max64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a >= b ? a : b;
  }

  function min64(uint64 a, uint64 b) internal constant returns (uint64) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="47" endline="51" pcid="4834">
  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a >= b ? a : b;
  }

  function min256(uint256 a, uint256 b) internal constant returns (uint256) {
</source>
<source file="systems/smart_contracts/OMGToken.sol" startline="40" endline="44" pcid="5483">
  function max64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a >= b ? a : b;
  }

  function min64(uint64 a, uint64 b) internal constant returns (uint64) {
</source>
<source file="systems/smart_contracts/OMGToken.sol" startline="48" endline="52" pcid="5485">
  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a >= b ? a : b;
  }

  function min256(uint256 a, uint256 b) internal constant returns (uint256) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="98" endline="102" pcid="6078">
  function max64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a >= b ? a : b;
  }

  function min64(uint64 a, uint64 b) internal constant returns (uint64) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="106" endline="110" pcid="6080">
  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a >= b ? a : b;
  }

  function min256(uint256 a, uint256 b) internal constant returns (uint256) {
</source>
</class>

<class classid="246" nclones="17" nlines="4" similarity="75">
<source file="systems/smart_contracts/BRZE.sol" startline="39" endline="43" pcid="1523">
  function min256(uint256 a, uint256 b) internal pure returns (uint256) {
    return a < b ? a : b;
  }

}
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="102" endline="106" pcid="6079">
  function min64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a < b ? a : b;
  }

  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
</source>
<source file="systems/smart_contracts/OMGToken.sol" startline="52" endline="56" pcid="5486">
  function min256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a < b ? a : b;
  }

  function assert(bool assertion) internal {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="110" endline="114" pcid="6081">
  function min256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a < b ? a : b;
  }

}
</source>
<source file="systems/smart_contracts/OMGToken.sol" startline="44" endline="48" pcid="5484">
  function min64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a < b ? a : b;
  }

  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="36" endline="40" pcid="1708">
    function min64(uint64 a, uint64 b) internal pure returns (uint64) {
        return a < b ? a : b;
    }

    function max256(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/MiniMeTokenFactory.sol" startline="515" endline="522" pcid="4824">
    function min(uint a, uint b) pure internal returns (uint) {
        return a < b ? a : b;
    }

    /// @notice The fallback function: If the contract's controller has not been
    ///  set to 0, then the `proxyPayment` method is called which relays the
    ///  ether and creates tokens as described in the token controller contract
    function () external payable {
</source>
<source file="systems/smart_contracts/Cholyz.sol" startline="44" endline="47" pcid="1710">
    function min256(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }
}
</source>
<source file="systems/smart_contracts/CouncilVesting.sol" startline="38" endline="42" pcid="2022">
  function min64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a < b ? a : b;
  }

  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
</source>
<source file="systems/smart_contracts/CouncilVesting.sol" startline="46" endline="49" pcid="2024">
  function min256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a < b ? a : b;
  }
}
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="101" endline="105" pcid="2100">
  function min64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a < b ? a : b;
  }

  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="109" endline="113" pcid="2102">
  function min256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a < b ? a : b;
  }

}
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="51" endline="55" pcid="4835">
  function min256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a < b ? a : b;
  }

}
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="538" endline="542" pcid="2618">
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }

    function average(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="534" endline="538" pcid="2709">
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }

    function average(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Exchange.sol" startline="852" endline="855" pcid="3405">
    function min(uint a, uint b) private pure returns (uint) {
        return a < b ? a : b;
    }
}
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="43" endline="47" pcid="4833">
  function min64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a < b ? a : b;
  }

  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
</source>
</class>

<class classid="247" nclones="4" nlines="4" similarity="75">
<source file="systems/smart_contracts/BRZE.sol" startline="93" endline="100" pcid="1526">
  function _transfer(address _from, address _to, uint _value) internal {
    require(_to != address(0x0));
    balanceOf[_from] = balanceOf[_from].sub(_value);
    balanceOf[_to] = balanceOf[_to].add(_value);
    emit Transfer(_from, _to, _value);
  }

  function transfer(address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/TAIHUITOKEN.sol" startline="96" endline="105" pcid="6970">
    function _transfer(address _from, address _to, uint _value) internal {
        require (_to != address(0x0));                          // Prevent transfer to 0x0 address. Use burn() instead
        require (balanceOf[_from] >= _value);                   // Check if the sender has enough
        require (balanceOf[_to] + _value >= balanceOf[_to]);    // Check for overflows
        balanceOf[_from] -= _value;                             // Subtract from the sender
        balanceOf[_to] += _value;                               // Add the same to the recipient
        emit Transfer(_from, _to, _value);
    }
    
}
</source>
<source file="systems/smart_contracts/UTRAToken.sol" startline="134" endline="146" pcid="7605">
    function _transfer(address _from, address _to, uint _value) internal {
        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead
        require (balances[_from] > _value);                // Check if the sender has enough
        require (balances[_to].add(_value) > balances[_to]); // Check for overflow
        balances[_from] = balances[_from].sub(_value);                         // Subtract from the sender
        balances[_to] = balances[_to].add(_value);                           // Add the same to the recipient
        emit Transfer(_from, _to, _value);
    }

    /// @notice Create `mintedAmount` tokens and send it to `target`
    /// @param target Address to receive the tokens
    /// @param mintedAmount the amount of tokens it will receive
    function mintToken(address target, uint256 mintedAmount) onlyOwner public {
</source>
<source file="systems/smart_contracts/BRZE.sol" startline="172" endline="180" pcid="1531">
  function _transfer(address _from, address _to, uint _value) internal {
    require(_to != address(0x0));
    require(checkFrozenWallet(_from, _value));
    balanceOf[_from] = balanceOf[_from].sub(_value);      
    balanceOf[_to] = balanceOf[_to].add(_value);     
    emit Transfer(_from, _to, _value);
  }

  function checkFrozenWallet(address _from, uint _value) public view returns (bool) {
</source>
</class>

<class classid="248" nclones="15" nlines="7" similarity="71">
<source file="systems/smart_contracts/BRZE.sol" startline="120" endline="128" pcid="1530">
  function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {
    tokenRecipient spender = tokenRecipient(_spender);
    if (approve(_spender, _value)) {
      spender.receiveApproval(msg.sender, _value, address(this), _extraData);
      return true;
    }
  }

}
</source>
<source file="systems/smart_contracts/ICBB.sol" startline="141" endline="158" pcid="4269">
    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, address(this), _extraData);
            return true;
        }
    }

    /**
     * Destroy tokens
     *
     * Remove `_value` tokens from the system irreversibly
     *
     * @param _value the amount of money to burn
     */
    function burn(uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/DDPC.sol" startline="113" endline="130" pcid="2381">
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /**
     * Destroy tokens
     *
     * Remove `_value` tokens from the system irreversibly
     *
     * @param _value the amount of money to burn
     */
    function burn(uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/CLCTokenERC20.sol" startline="115" endline="132" pcid="1741">
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /**
     * Destroy tokens
     *
     * Remove `_value` tokens from the system irreversibly
     *
     * @param _value the amount of money to burn
     */
    function burn(uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ThpToken.sol" startline="141" endline="152" pcid="7162">
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
}
</source>
<source file="systems/smart_contracts/Contracts.sol" startline="115" endline="132" pcid="1999">
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /**
     * Destroy tokens
     *
     * Remove `_value` tokens from the system irreversibly
     *
     * @param _value the amount of money to burn
     */
    function burn(uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/MyAdvancedToken.sol" startline="137" endline="154" pcid="5267">
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /**
     * Destroy tokens
     *
     * Remove `_value` tokens from the system irreversibly
     *
     * @param _value the amount of money to burn
     */
    function burn(uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Rabbit.sol" startline="47" endline="56" pcid="5945">
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
    function burn(uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/GEF.sol" startline="58" endline="68" pcid="4064">
    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, address(this), _extraData);
            return true;
        }
    }

}
</source>
<source file="systems/smart_contracts/TokenERC20.sol" startline="121" endline="138" pcid="7307">
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /**
     * Destroy tokens
     *
     * Remove `_value` tokens from the system irreversibly
     *
     * @param _value the amount of money to burn
     */
    function burn(uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/GBE.sol" startline="58" endline="68" pcid="4058">
    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, address(this), _extraData);
            return true;
        }
    }

}
</source>
<source file="systems/smart_contracts/ETGTOKEN.sol" startline="122" endline="139" pcid="3195">
    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, address(this), _extraData);
            return true;
        }
    }

    /**
     * Destroy tokens
     *
     * Remove `_value` tokens from the system irreversibly
     *
     * @param _value the amount of money to burn
     */
    function burn(uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/RanchChain.sol" startline="115" endline="132" pcid="5981">
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /**
     * Destroy tokens
     *
     * Remove `_value` tokens from the system irreversibly
     *
     * @param _value the amount of money to burn
     */
    function burn(uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="198" endline="207" pcid="1640">
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
        require(isContract(_spender));
        TokenRecipient spender = TokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    function allowance(address _holder, address _spender) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="199" endline="208" pcid="4394">
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
        require(isContract(_spender));
        TokenRecipient spender = TokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }//approve
    }

    function allowance(address _holder, address _spender) public view returns (uint256) {
</source>
</class>

<class classid="249" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/BRZE.sol" startline="191" endline="198" pcid="1533">
  function burn(uint256 _value) onlyOwner public returns (bool success) {
    balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);   // Subtract from the sender
    totalSupply = totalSupply.sub(_value);                      // Updates totalSupply
    emit Burn(msg.sender, _value);
    return true;
  }

  function burnFrom(address _from, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ThpToken.sol" startline="202" endline="219" pcid="7165">
    function burn(uint256 _value) onlyOwner public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        require(_value <= totalSupply);
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        emit Burn(msg.sender, _value);
        return true;
    }

    /**
     * Destroy tokens from other account
     *
     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.
     *
     * @param _from the address of the sender
     * @param _value the amount of money to burn
     */
    function burnFrom(address _from, uint256 _value) onlyOwner public returns (bool success) {
</source>
</class>

<class classid="250" nclones="14" nlines="4" similarity="75">
<source file="systems/smart_contracts/BRZE.sol" startline="198" endline="206" pcid="1534">
  function burnFrom(address _from, uint256 _value) public returns (bool success) {
    balanceOf[_from] = balanceOf[_from].sub(_value);                          // Subtract from the targeted balance
    allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);   // Subtract from the sender's allowance
    totalSupply = totalSupply.sub(_value);                              // Update totalSupply
    emit Burn(_from, _value);
    return true;
  }

  function freezeToken(bool freeze) onlyOwner public {
</source>
<source file="systems/smart_contracts/Rabbit.sol" startline="64" endline="73" pcid="5947">
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);
        require(_value <= allowance[_from][msg.sender]);
        balanceOf[_from] -= _value;
        allowance[_from][msg.sender] -= _value;
        totalSupply -= _value;
        Burn(_from, _value);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/RanchChain.sol" startline="148" endline="157" pcid="5983">
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        Burn(_from, _value);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/MyAdvancedToken.sol" startline="170" endline="179" pcid="5269">
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        emit Burn(_from, _value);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/LuckyAdvcedWoken.sol" startline="202" endline="211" pcid="4564">
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        emit Burn(_from, _value);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/ESCHToken.sol" startline="72" endline="82" pcid="3046">
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);
        require(_value <= allowance[_from][msg.sender]);
        balanceOf[_from] -= _value;
        allowance[_from][msg.sender] -= _value;
        totalSupply -= _value;
        Burn(_from, _value);
        return true;
    }
 
    function setadmin (address _admin) public {
</source>
<source file="systems/smart_contracts/byzbit.sol" startline="145" endline="161" pcid="1600">
	function burnFrom (address _from, uint256 _value)public returns(bool success){
		require (balanceOf[_from] >= _value) ;

		require (_value <= allowance[_from][msg.sender]);
		
		balanceOf[_from] -= _value;
		totalSupply -= _value;
		emit Burn(msg.sender, _value);
		return true;
	}
	
	
	////////////////////////////// BURN END //////////////////////////////
	
	////////////////////////////// FREEZING //////////////////////////////

	function freezeAccount (address target, bool freeze) public onlyOwner  {
</source>
<source file="systems/smart_contracts/DDPC.sol" startline="146" endline="155" pcid="2383">
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        Burn(_from, _value);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/TokenERC20.sol" startline="154" endline="163" pcid="7309">
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        emit Burn(_from, _value);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/ETGTOKEN.sol" startline="155" endline="164" pcid="3197">
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        emit Burn(_from, _value);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/Contracts.sol" startline="148" endline="157" pcid="2001">
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        Burn(_from, _value);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/CLCTokenERC20.sol" startline="148" endline="157" pcid="1743">
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        emit Burn(_from, _value);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/ICBB.sol" startline="174" endline="183" pcid="4271">
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        emit Burn(_from, _value);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/MAdvcedWoken.sol" startline="202" endline="211" pcid="4603">
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        emit Burn(_from, _value);
        return true;
    }
}
</source>
</class>

<class classid="251" nclones="3" nlines="4" similarity="75">
<source file="systems/smart_contracts/BTGS.sol" startline="85" endline="94" pcid="1544">
    function balanceOf(address _addr)
        public
        constant
        returns (uint256) {
        return balances[_addr];
    }

    /// @dev check address is approved investor
    /// @param _addr address
    function isApprovedInvestor(address _addr)
</source>
<source file="systems/smart_contracts/CoinDDC.sol" startline="29" endline="34" pcid="1863">
    function balanceOf( address _addr ) public view returns ( uint )
    {
        return balances[_addr];
    }

    event Transfer(
</source>
<source file="systems/smart_contracts/ICOImplementation.sol" startline="200" endline="214" pcid="4278">
    function balanceOf(address _addr) public view returns (uint256) {
        return balances[_addr];
    }


    // ERC20 FUNCTIONALITY


    /**
     * @dev Transfer tokens from one address to another
     * @param _from address The address which you want to send tokens from
     * @param _to address The address which you want to transfer to
     * @param _value uint256 the amount of tokens to be transferred
     */
    function transferFrom(
</source>
</class>

<class classid="252" nclones="3" nlines="3" similarity="100">
<source file="systems/smart_contracts/BTToken.sol" startline="14" endline="18" pcid="1552">
    function totalSupply() constant returns (uint supply) {}

    /// @param _owner The address from which the balance will be retrieved
    /// @return The balance
    function balanceOf(address _owner) constant returns (uint balance) {}
</source>
<source file="systems/smart_contracts/TECToken.sol" startline="10" endline="14" pcid="7127">
    function totalSupply() constant returns (uint supply) {}

    /// @param _owner The address from which the balance will be retrieved
    /// @return The balance
    function balanceOf(address _owner) constant returns (uint balance) {}
</source>
<source file="systems/smart_contracts/P21.sol" startline="10" endline="14" pcid="5579">
    function totalSupply() constant returns (uint supply) {}

    /// @param _owner The address from which the balance will be retrieved
    /// @return The balance
    function balanceOf(address _owner) constant returns (uint balance) {}
</source>
</class>

<class classid="253" nclones="6" nlines="3" similarity="75">
<source file="systems/smart_contracts/BTToken.sol" startline="24" endline="31" pcid="1554">
    function transfer(address _to, uint _value) returns (bool success) {}

    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`
    /// @param _from The address of the sender
    /// @param _to The address of the recipient
    /// @param _value The amount of token to be transferred
    /// @return Whether the transfer was successful or not
    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}
</source>
<source file="systems/smart_contracts/TECToken.sol" startline="20" endline="27" pcid="7129">
    function transfer(address _to, uint _value) returns (bool success) {}

    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`
    /// @param _from The address of the sender
    /// @param _to The address of the recipient
    /// @param _value The amount of token to be transferred
    /// @return Whether the transfer was successful or not
    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}
</source>
<source file="systems/smart_contracts/P21.sol" startline="20" endline="27" pcid="5581">
    function transfer(address _to, uint _value) returns (bool success) {}

    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`
    /// @param _from The address of the sender
    /// @param _to The address of the recipient
    /// @param _value The amount of token to be transferred
    /// @return Whether the transfer was successful or not
    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="990" endline="997" pcid="6133">
  function transfer(address _to, uint _value) returns (bool success) {
    balances[msg.sender] = safeSub(balances[msg.sender], _value);
    balances[_to] = safeAdd(balances[_to], _value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  function transferFrom(address _from, address _to, uint _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="995" endline="1002" pcid="4893">
  function transfer(address _to, uint _value) returns (bool success) {
    balances[msg.sender] = safeSub(balances[msg.sender], _value);
    balances[_to] = safeAdd(balances[_to], _value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  function transferFrom(address _from, address _to, uint _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="173" endline="180" pcid="2107">
  function transfer(address _to, uint _value) returns (bool success) {
    balances[msg.sender] = safeSub(balances[msg.sender], _value);
    balances[_to] = safeAdd(balances[_to], _value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  function transferFrom(address _from, address _to, uint _value) returns (bool success) {
</source>
</class>

<class classid="254" nclones="3" nlines="3" similarity="100">
<source file="systems/smart_contracts/BTToken.sol" startline="31" endline="37" pcid="1555">
    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}

    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens
    /// @param _spender The address of the account able to transfer the tokens
    /// @param _value The amount of wei to be approved for transfer
    /// @return Whether the approval was successful or not
    function approve(address _spender, uint _value) returns (bool success) {}
</source>
<source file="systems/smart_contracts/P21.sol" startline="27" endline="33" pcid="5582">
    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}

    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens
    /// @param _spender The address of the account able to transfer the tokens
    /// @param _value The amount of wei to be approved for transfer
    /// @return Whether the approval was successful or not
    function approve(address _spender, uint _value) returns (bool success) {}
</source>
<source file="systems/smart_contracts/TECToken.sol" startline="27" endline="33" pcid="7130">
    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}

    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens
    /// @param _spender The address of the account able to transfer the tokens
    /// @param _value The amount of wei to be approved for transfer
    /// @return Whether the approval was successful or not
    function approve(address _spender, uint _value) returns (bool success) {}
</source>
</class>

<class classid="255" nclones="6" nlines="3" similarity="75">
<source file="systems/smart_contracts/BTToken.sol" startline="37" endline="42" pcid="1556">
    function approve(address _spender, uint _value) returns (bool success) {}

    /// @param _owner The address of the account owning tokens
    /// @param _spender The address of the account able to transfer the tokens
    /// @return Amount of remaining tokens allowed to spent
    function allowance(address _owner, address _spender) constant returns (uint remaining) {}
</source>
<source file="systems/smart_contracts/TECToken.sol" startline="33" endline="38" pcid="7131">
    function approve(address _spender, uint _value) returns (bool success) {}

    /// @param _owner The address of the account owning tokens
    /// @param _spender The address of the account able to transfer the tokens
    /// @return Amount of remaining tokens allowed to spent
    function allowance(address _owner, address _spender) constant returns (uint remaining) {}
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1011" endline="1024" pcid="6136">
  function approve(address _spender, uint _value) returns (bool success) {

    // To change the approve amount you first have to reduce the addresses`
    //  allowance to zero by calling `approve(_spender, 0)` if it is not
    //  already 0 to mitigate the race condition described here:
    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;

    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  function allowance(address _owner, address _spender) constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/P21.sol" startline="33" endline="38" pcid="5583">
    function approve(address _spender, uint _value) returns (bool success) {}

    /// @param _owner The address of the account owning tokens
    /// @param _spender The address of the account able to transfer the tokens
    /// @return Amount of remaining tokens allowed to spent
    function allowance(address _owner, address _spender) constant returns (uint remaining) {}
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="194" endline="207" pcid="2110">
  function approve(address _spender, uint _value) returns (bool success) {

    // To change the approve amount you first have to reduce the addresses`
    //  allowance to zero by calling `approve(_spender, 0)` if it is not
    //  already 0 to mitigate the race condition described here:
    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;

    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  function allowance(address _owner, address _spender) constant returns (uint remaining) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="1016" endline="1029" pcid="4896">
  function approve(address _spender, uint _value) returns (bool success) {

    // To change the approve amount you first have to reduce the addresses`
    //  allowance to zero by calling `approve(_spender, 0)` if it is not
    //  already 0 to mitigate the race condition described here:
    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;

    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  function allowance(address _owner, address _spender) constant returns (uint remaining) {
</source>
</class>

<class classid="256" nclones="3" nlines="15" similarity="100">
<source file="systems/smart_contracts/BTToken.sol" startline="98" endline="118" pcid="1563">
    function transferFrom(address _from, address _to, uint _value)
        public
        returns (bool)
    {
        uint allowance = allowed[_from][msg.sender];
        if (balances[_from] >= _value
            && allowance >= _value
            && balances[_to] + _value >= balances[_to]
        ) {
            balances[_to] += _value;
            balances[_from] -= _value;
            if (allowance < MAX_UINT) {
                allowed[_from][msg.sender] -= _value;
            }
            Transfer(_from, _to, _value);
            return true;
        } else {
            return false;
        }
    }
}
</source>
<source file="systems/smart_contracts/P21.sol" startline="94" endline="114" pcid="5590">
    function transferFrom(address _from, address _to, uint _value)
        public
        returns (bool)
    {
        uint allowance = allowed[_from][msg.sender];
        if (balances[_from] >= _value
            && allowance >= _value
            && balances[_to] + _value >= balances[_to]
        ) {
            balances[_to] += _value;
            balances[_from] -= _value;
            if (allowance < MAX_UINT) {
                allowed[_from][msg.sender] -= _value;
            }
            Transfer(_from, _to, _value);
            return true;
        } else {
            return false;
        }
    }
}
</source>
<source file="systems/smart_contracts/TECToken.sol" startline="94" endline="114" pcid="7138">
    function transferFrom(address _from, address _to, uint _value)
        public
        returns (bool)
    {
        uint allowance = allowed[_from][msg.sender];
        if (balances[_from] >= _value
            && allowance >= _value
            && balances[_to] + _value >= balances[_to]
        ) {
            balances[_to] += _value;
            balances[_from] -= _value;
            if (allowance < MAX_UINT) {
                allowed[_from][msg.sender] -= _value;
            }
            Transfer(_from, _to, _value);
            return true;
        } else {
            return false;
        }
    }
}
</source>
</class>

<class classid="257" nclones="3" nlines="4" similarity="75">
<source file="systems/smart_contracts/BTToken.sol" startline="127" endline="131" pcid="1564">
    function BTToken() {
        balances[msg.sender] = totalSupply;
        Transfer(address(0), msg.sender, totalSupply);
    }
}
</source>
<source file="systems/smart_contracts/P21.sol" startline="123" endline="127" pcid="5591">
    function P21() {
        balances[msg.sender] = totalSupply;
        Transfer(address(0), msg.sender, totalSupply);
    }
}
</source>
<source file="systems/smart_contracts/TECToken.sol" startline="123" endline="127" pcid="7139">
    function TECToken() {
        balances[msg.sender] = totalSupply;
        Transfer(address(0), msg.sender, totalSupply);
    }
}
</source>
</class>

<class classid="258" nclones="13" nlines="4" similarity="75">
<source file="systems/smart_contracts/byzbit.sol" startline="133" endline="145" pcid="1599">
	function burn (uint256 _value) public returns(bool success){
		
		require (balanceOf[msg.sender] >= _value) ;
		balanceOf[msg.sender] -= _value;

		totalSupply -= _value;

		emit Burn(msg.sender, _value);
		return true;
		
	}

	function burnFrom (address _from, uint256 _value)public returns(bool success){
</source>
<source file="systems/smart_contracts/ICBB.sol" startline="158" endline="174" pcid="4270">
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        emit Burn(msg.sender, _value);
        return true;
    }

    /**
     * Destroy tokens from other account
     *
     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.
     *
     * @param _from the address of the sender
     * @param _value the amount of money to burn
     */
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Rabbit.sol" startline="56" endline="64" pcid="5946">
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        totalSupply -= _value;
        Burn(msg.sender, _value);
        return true;
    }

    function burnFrom(address _from, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/DDPC.sol" startline="130" endline="146" pcid="2382">
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }

    /**
     * Destroy tokens from other account
     *
     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.
     *
     * @param _from the address of the sender
     * @param _value the amount of money to burn
     */
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/TokenERC20.sol" startline="138" endline="154" pcid="7308">
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        emit Burn(msg.sender, _value);
        return true;
    }

    /**
     * Destroy tokens from other account
     *
     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.
     *
     * @param _from the address of the sender
     * @param _value the amount of money to burn
     */
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/RanchChain.sol" startline="132" endline="148" pcid="5982">
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }

    /**
     * Destroy tokens from other account
     *
     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.
     *
     * @param _from the address of the sender
     * @param _value the amount of money to burn
     */
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/MAdvcedWoken.sol" startline="186" endline="202" pcid="4602">
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        emit Burn(msg.sender, _value);
        return true;
    }

    /**
     * Destroy tokens from other account
     *
     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.
     *
     * @param _from the address of the sender
     * @param _value the amount of money to burn
     */
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ETGTOKEN.sol" startline="139" endline="155" pcid="3196">
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        emit Burn(msg.sender, _value);
        return true;
    }

    /**
     * Destroy tokens from other account
     *
     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.
     *
     * @param _from the address of the sender
     * @param _value the amount of money to burn
     */
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Contracts.sol" startline="132" endline="148" pcid="2000">
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }

    /**
     * Destroy tokens from other account
     *
     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.
     *
     * @param _from the address of the sender
     * @param _value the amount of money to burn
     */
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ESCHToken.sol" startline="64" endline="72" pcid="3045">
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        totalSupply -= _value;
        Burn(msg.sender, _value);
        return true;
    }

    function burnFrom(address _from, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/MyAdvancedToken.sol" startline="154" endline="170" pcid="5268">
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        emit Burn(msg.sender, _value);
        return true;
    }

    /**
     * Destroy tokens from other account
     *
     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.
     *
     * @param _from the address of the sender
     * @param _value the amount of money to burn
     */
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/CLCTokenERC20.sol" startline="132" endline="148" pcid="1742">
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        emit Burn(msg.sender, _value);
        return true;
    }

    /**
     * Destroy tokens from other account
     *
     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.
     *
     * @param _from the address of the sender
     * @param _value the amount of money to burn
     */
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/LuckyAdvcedWoken.sol" startline="186" endline="202" pcid="4563">
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        emit Burn(msg.sender, _value);
        return true;
    }

    /**
     * Destroy tokens from other account
     *
     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.
     *
     * @param _from the address of the sender
     * @param _value the amount of money to burn
     */
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
</source>
</class>

<class classid="259" nclones="10" nlines="4" similarity="75">
<source file="systems/smart_contracts/byzbit.sol" startline="161" endline="198" pcid="1601">
	function freezeAccount (address target, bool freeze) public onlyOwner  {
		frozenAccount[target] = freeze;
		emit FrozenFunds (target, freeze);
	}
	
	////////////////////////////// FREEZ END //////////////////////////////

	/*////////////////////////////// BUY and SELL  //////////////////////////////

	function setPrice (uint256 newSellPrice, uint256 newBuyPrice) public onlyOwner {
		
		sellPrice = newSellPrice;
		buyPrice = newBuyPrice;
	}
	
	function buy () payable returns (uint amount){
		amount = msg.value/buyPrice;
		_transfer (this, msg.sender, amount);
		return amount;

	}

	function sell (uint amount) returns(uint revenue){
		
			require (balanceOf[msg.sender] >= amount);
			balanceOf[this] += amount;
			balanceOf[msg.sender] -=amount;
			revenue = amount * sellPrice;
			msg.sender.transfer(revenue);

			return revenue;
				
	}
	

	////////////////////////////// BUY and SELL END //////////////////////////////*/
	
}
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="134" endline="140" pcid="7707">
  function freezeAccount(address target, bool freeze) onlyController public {
    frozenAccount[target] = freeze;
    emit FrozenFunds(target, freeze);
  }

  // need deploy
  function isFrozenAccount(address target) onlyController public view returns (bool) {
</source>
<source file="systems/smart_contracts/MyAdvancedToken.sol" startline="227" endline="235" pcid="5273">
    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        emit FrozenFunds(target, freeze);
    }

    /// @notice Allow users to buy tokens for `newBuyPrice` eth and sell tokens for `newSellPrice` eth
    /// @param newSellPrice Price the users can sell to the contract
    /// @param newBuyPrice Price users can buy from the contract
    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="134" endline="140" pcid="2234">
  function freezeAccount(address target, bool freeze) onlyController public {
    frozenAccount[target] = freeze;
    emit FrozenFunds(target, freeze);
  }

  // need deploy
  function isFrozenAccount(address target) onlyController public view returns (bool) {
</source>
<source file="systems/smart_contracts/UTRAToken.sol" startline="156" endline="162" pcid="7607">
    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        emit FrozenFunds(target, freeze);
    }


    function purchaseToken(address _receiver, uint _tokens) onlyAuthCaller public {
</source>
<source file="systems/smart_contracts/ICBB.sol" startline="218" endline="223" pcid="4273">
    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        emit FrozenFunds(target, freeze);
    }

}
</source>
<source file="systems/smart_contracts/ThpToken.sol" startline="188" endline="202" pcid="7164">
    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        emit FrozenFunds(target, freeze);
    }


    
    /**
     * Destroy tokens
     *
     * Remove `_value` tokens from the system irreversibly
     *
     * @param _value the amount of money to burn
     */
    function burn(uint256 _value) onlyOwner public returns (bool success) {
</source>
<source file="systems/smart_contracts/LuckyAdvcedWoken.sol" startline="254" endline="263" pcid="4567">
    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        emit FrozenFunds(target, freeze);
    }

    /// @notice Allow users to buy tokens for `newBuyPrice` eth and sell tokens for `newSellPrice` eth
    /// @param newSellPrice Price the users can sell to the contract
    /// @param newBuyPrice Price users can buy from the contract
  
}
</source>
<source file="systems/smart_contracts/MAdvcedWoken.sol" startline="254" endline="263" pcid="4606">
    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        emit FrozenFunds(target, freeze);
    }

    /// @notice Allow users to buy tokens for `newBuyPrice` eth and sell tokens for `newSellPrice` eth
    /// @param newSellPrice Price the users can sell to the contract
    /// @param newBuyPrice Price users can buy from the contract
  
}
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="134" endline="140" pcid="6720">
  function freezeAccount(address target, bool freeze) onlyController public {
    frozenAccount[target] = freeze;
    emit FrozenFunds(target, freeze);
  }

  // need deploy
  function isFrozenAccount(address target) onlyController public view returns (bool) {
</source>
</class>

<class classid="260" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/c_Bank.sol" startline="9" endline="19" pcid="1602">
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,"Put");
    }

    function Collect(uint _am)
</source>
<source file="systems/smart_contracts/Piggy_Bank.sol" startline="9" endline="19" pcid="5658">
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,"Put");
    }

    function Collect(uint _am)
</source>
</class>

<class classid="261" nclones="2" nlines="10" similarity="100">
<source file="systems/smart_contracts/c_Bank.sol" startline="19" endline="34" pcid="1603">
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,"Collect");
            }
        }
    }

    function() 
</source>
<source file="systems/smart_contracts/Piggy_Bank.sol" startline="19" endline="34" pcid="5659">
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,"Collect");
            }
        }
    }

    function() 
</source>
</class>

<class classid="262" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/c_Bank.sol" startline="53" endline="56" pcid="1605">
    function c_Bank(address log) public{
        LogFile = Log(log);
    }
}
</source>
<source file="systems/smart_contracts/Piggy_Bank.sol" startline="53" endline="56" pcid="5661">
    function Piggy_Bank(address log) public{
        LogFile = Log(log);
    }
}
</source>
</class>

<class classid="263" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/c_Bank.sol" startline="73" endline="82" pcid="1606">
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}
</source>
<source file="systems/smart_contracts/Piggy_Bank.sol" startline="73" endline="82" pcid="5662">
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}
</source>
</class>

<class classid="264" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="65" endline="69" pcid="1625">
    function acceptOwnership() public onlyNewOwner returns(bool) {
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="66" endline="70" pcid="4379">
    function acceptOwnership() public onlyNewOwner returns(bool) {
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}
</source>
</class>

<class classid="265" nclones="2" nlines="8" similarity="100">
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="157" endline="172" pcid="1636">
    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
        if (locks[msg.sender]) {
            autoUnlock(msg.sender);            
        }
        require(_to != address(0));
        require(_value <= balances[msg.sender]);
        

        // SafeMath.sub will throw if there is not enough balance.
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function balanceOf(address _holder) public view returns (uint256 balance) {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="158" endline="173" pcid="4390">
    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
        if (locks[msg.sender]) {
            autoUnlock(msg.sender);            
        }
        require(_to != address(0));
        require(_value <= balances[msg.sender]);
        

        // SafeMath.sub will throw if there is not enough balance.
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function balanceOf(address _holder) public view returns (uint256 balance) {
</source>
</class>

<class classid="266" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="172" endline="176" pcid="1637">
    function balanceOf(address _holder) public view returns (uint256 balance) {
        return balances[_holder] + lockupInfo[_holder].lockupBalance;
    }

    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="173" endline="177" pcid="4391">
    function balanceOf(address _holder) public view returns (uint256 balance) {
        return balances[_holder] + lockupInfo[_holder].lockupBalance;
    }

    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
</source>
</class>

<class classid="267" nclones="2" nlines="9" similarity="100">
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="176" endline="192" pcid="1638">
    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
        if (locks[_from]) {
            autoUnlock(_from);            
        }
        require(_to != address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);
        

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="177" endline="193" pcid="4392">
    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
        if (locks[_from]) {
            autoUnlock(_from);            
        }
        require(_to != address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);
        

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
</source>
</class>

<class classid="268" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="207" endline="211" pcid="1641">
    function allowance(address _holder, address _spender) public view returns (uint256) {
        return allowed[_holder][_spender];
    }

    function lock(address _holder, uint256 _amount, uint256 _releaseStart, uint256 _releaseRate) public onlyOwner returns (bool) {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="208" endline="212" pcid="4395">
    function allowance(address _holder, address _spender) public view returns (uint256) {
        return allowed[_holder][_spender];
    }

    function lock(address _holder, uint256 _amount, uint256 _releaseStart, uint256 _releaseRate) public onlyOwner returns (bool) {
</source>
</class>

<class classid="269" nclones="2" nlines="5" similarity="100">
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="211" endline="224" pcid="1642">
    function lock(address _holder, uint256 _amount, uint256 _releaseStart, uint256 _releaseRate) public onlyOwner returns (bool) {
        require(locks[_holder] == false);
        require(balances[_holder] >= _amount);
        balances[_holder] = balances[_holder].sub(_amount);
        lockupInfo[_holder] = LockupInfo(_releaseStart, _amount.div(100).mul(_releaseRate), _amount);

        locks[_holder] = true;

        emit Lock(_holder, _amount);

        return true;
    }

    function unlock(address _holder) public onlyOwner returns (bool) {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="212" endline="225" pcid="4396">
    function lock(address _holder, uint256 _amount, uint256 _releaseStart, uint256 _releaseRate) public onlyOwner returns (bool) {
        require(locks[_holder] == false);
        require(balances[_holder] >= _amount);
        balances[_holder] = balances[_holder].sub(_amount);
        lockupInfo[_holder] = LockupInfo(_releaseStart, _amount.div(100).mul(_releaseRate), _amount);

        locks[_holder] = true;

        emit Lock(_holder, _amount);

        return true;
    }

    function unlock(address _holder) public onlyOwner returns (bool) {
</source>
</class>

<class classid="270" nclones="2" nlines="5" similarity="100">
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="224" endline="237" pcid="1643">
    function unlock(address _holder) public onlyOwner returns (bool) {
        require(locks[_holder] == true);
        uint256 releaseAmount = lockupInfo[_holder].lockupBalance;

        delete lockupInfo[_holder];
        locks[_holder] = false;

        emit Unlock(_holder, releaseAmount);
        balances[_holder] = balances[_holder].add(releaseAmount);

        return true;
    }

    function getNowTime() public view returns(uint256) {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="225" endline="238" pcid="4397">
    function unlock(address _holder) public onlyOwner returns (bool) {
        require(locks[_holder] == true);
        uint256 releaseAmount = lockupInfo[_holder].lockupBalance;

        delete lockupInfo[_holder];
        locks[_holder] = false;

        emit Unlock(_holder, releaseAmount);
        balances[_holder] = balances[_holder].add(releaseAmount);

        return true;
    }

    function getNowTime() public view returns(uint256) {
</source>
</class>

<class classid="271" nclones="4" nlines="4" similarity="75">
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="237" endline="241" pcid="1644">
    function getNowTime() public view returns(uint256) {
      return now;
    }

    function showLockState(address _holder) public view returns (bool, uint256, uint256) {
</source>
<source file="systems/smart_contracts/RETC.sol" startline="91" endline="94" pcid="6184">
     function nowInSeconds() public view returns (uint256){
        return now;
    }
    function transferOwnership(address newOwner) onlyOwner public {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="238" endline="242" pcid="4398">
    function getNowTime() public view returns(uint256) {
      return now;//now
    }

    function showLockState(address _holder) public view returns (bool, uint256, uint256) {
</source>
<source file="systems/smart_contracts/GNB.sol" startline="164" endline="171" pcid="4131">
    function now_() public constant returns (uint){
        return now;
    }

    // ------------------------------------------------------------------------
    // Total supply
    // ------------------------------------------------------------------------
    function totalSupply() public constant returns (uint) {
</source>
</class>

<class classid="272" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="241" endline="245" pcid="1645">
    function showLockState(address _holder) public view returns (bool, uint256, uint256) {
        return (locks[_holder], lockupInfo[_holder].lockupBalance, lockupInfo[_holder].releaseTime);
    }

    function distribute(address _to, uint256 _value) public onlyOwner returns (bool) {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="242" endline="246" pcid="4399">
    function showLockState(address _holder) public view returns (bool, uint256, uint256) {
        return (locks[_holder], lockupInfo[_holder].lockupBalance, lockupInfo[_holder].releaseTime);
    }

    function distribute(address _to, uint256 _value) public onlyOwner returns (bool) {
</source>
</class>

<class classid="273" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="245" endline="255" pcid="1646">
    function distribute(address _to, uint256 _value) public onlyOwner returns (bool) {
        require(_to != address(0));
        require(_value <= balances[owner]);

        balances[owner] = balances[owner].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(owner, _to, _value);
        return true;
    }

    function distributeWithLockup(address _to, uint256 _value, uint256 _releaseStart, uint256 _releaseRate) public onlyOwner returns (bool) {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="246" endline="256" pcid="4400">
    function distribute(address _to, uint256 _value) public onlyOwner returns (bool) {
        require(_to != address(0));
        require(_value <= balances[owner]);

        balances[owner] = balances[owner].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(owner, _to, _value);
        return true;
    }

    function distributeWithLockup(address _to, uint256 _value, uint256 _releaseStart, uint256 _releaseRate) public onlyOwner returns (bool) {
</source>
</class>

<class classid="274" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="255" endline="261" pcid="1647">
    function distributeWithLockup(address _to, uint256 _value, uint256 _releaseStart, uint256 _releaseRate) public onlyOwner returns (bool) {
        distribute(_to, _value);
        lock(_to, _value, _releaseStart, _releaseRate);
        return true;
    }

    function claimToken(ERC20 token, address _to, uint256 _value) public onlyOwner returns (bool) {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="256" endline="262" pcid="4401">
    function distributeWithLockup(address _to, uint256 _value, uint256 _releaseStart, uint256 _releaseRate) public onlyOwner returns (bool) {
        distribute(_to, _value);
        lock(_to, _value, _releaseStart, _releaseRate);
        return true;
    }

    function claimToken(ERC20 token, address _to, uint256 _value) public onlyOwner returns (bool) {
</source>
</class>

<class classid="275" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="261" endline="266" pcid="1648">
    function claimToken(ERC20 token, address _to, uint256 _value) public onlyOwner returns (bool) {
        token.transfer(_to, _value);
        return true;
    }

    function burn(uint256 _value) public onlyOwner returns (bool success) {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="262" endline="267" pcid="4402">
    function claimToken(ERC20 token, address _to, uint256 _value) public onlyOwner returns (bool) {
        token.transfer(_to, _value);
        return true;
    }

    function burn(uint256 _value) public onlyOwner returns (bool success) {
</source>
</class>

<class classid="276" nclones="3" nlines="4" similarity="75">
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="266" endline="275" pcid="1649">
    function burn(uint256 _value) public onlyOwner returns (bool success) {
        require(_value <= balances[msg.sender]);
        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply_ = totalSupply_.sub(_value);
        emit Burn(burner, _value);
        return true;
    }

    function isContract(address addr) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="267" endline="276" pcid="4403">
    function burn(uint256 _value) public onlyOwner returns (bool success) {
        require(_value <= balances[msg.sender]);
        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply_ = totalSupply_.sub(_value);
        emit Burn(burner, _value);//burn
        return true;
    }

    function isContract(address addr) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/OeroToken.sol" startline="77" endline="83" pcid="5478">
        function burn(uint256 _value) public onlyOwner returns (bool success){
             require(balanceOf[msg.sender] >= _value);
             balanceOf[msg.sender] -= _value;
             totalSupply -= _value;
             return true;
        }
    }
</source>
</class>

<class classid="277" nclones="2" nlines="8" similarity="100">
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="281" endline="288" pcid="1651">
    function autoUnlock(address _holder) internal returns (bool) {
        if (lockupInfo[_holder].releaseTime <= now) {
            return releaseTimeLock(_holder);
        }
        return false;
    }

    function releaseTimeLock(address _holder) internal returns(bool) {
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="282" endline="289" pcid="4405">
    function autoUnlock(address _holder) internal returns (bool) {
        if (lockupInfo[_holder].releaseTime <= now) {
            return releaseTimeLock(_holder);
        }
        return false;
    }

    function releaseTimeLock(address _holder) internal returns(bool) {
</source>
</class>

<class classid="278" nclones="2" nlines="12" similarity="100">
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="288" endline="306" pcid="1652">
    function releaseTimeLock(address _holder) internal returns(bool) {
        require(locks[_holder]);
        uint256 releaseAmount = 0;
        // If lock status of holder is finished, delete lockup info. 
        if (lockupInfo[_holder].lockupBalance <= lockupInfo[_holder].unlockAmountPerMonth) {
            releaseAmount = lockupInfo[_holder].lockupBalance;
            delete lockupInfo[_holder];
            locks[_holder] = false;
        } else {            
            releaseAmount = lockupInfo[_holder].unlockAmountPerMonth;
            lockupInfo[_holder].releaseTime = lockupInfo[_holder].releaseTime.add(MONTH);
            lockupInfo[_holder].lockupBalance = lockupInfo[_holder].lockupBalance.sub(releaseAmount);
        }
        emit Unlock(_holder, releaseAmount);
        balances[_holder] = balances[_holder].add(releaseAmount);
        return true;
    }

}
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="289" endline="307" pcid="4406">
    function releaseTimeLock(address _holder) internal returns(bool) {
        require(locks[_holder]);
        uint256 releaseAmount = 0;
        // If lock status of holder is finished, delete lockup info. 
        if (lockupInfo[_holder].lockupBalance <= lockupInfo[_holder].unlockAmountPerMonth) {
            releaseAmount = lockupInfo[_holder].lockupBalance;
            delete lockupInfo[_holder];
            locks[_holder] = false;
        } else {            
            releaseAmount = lockupInfo[_holder].unlockAmountPerMonth;
            lockupInfo[_holder].releaseTime = lockupInfo[_holder].releaseTime.add(MONTH);
            lockupInfo[_holder].lockupBalance = lockupInfo[_holder].lockupBalance.sub(releaseAmount);
        }
        emit Unlock(_holder, releaseAmount);
        balances[_holder] = balances[_holder].add(releaseAmount);
        return true;
    }

}
</source>
</class>

<class classid="279" nclones="11" nlines="4" similarity="75">
<source file="systems/smart_contracts/CDS.sol" startline="91" endline="96" pcid="1658">
  function _transferOwnership(address _newOwner) internal {
    require(_newOwner != address(0));
    emit OwnershipTransferred(owner, _newOwner);
    owner = _newOwner;
  }
}
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="117" endline="122" pcid="2233">
  function _transferOwnership(address _newOwner) internal {
    require(_newOwner != address(0));
    emit OwnershipTransferred(owner, _newOwner);
    owner = _newOwner;
  }
}
</source>
<source file="systems/smart_contracts/Oracle.sol" startline="65" endline="70" pcid="5511">
  function _transferOwnership(address _newOwner) internal {
    require(_newOwner != address(0));
    emit OwnershipTransferred(owner, _newOwner);
    owner = _newOwner;
  }
}
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="117" endline="122" pcid="6719">
  function _transferOwnership(address _newOwner) internal {
    require(_newOwner != address(0));
    emit OwnershipTransferred(owner, _newOwner);
    owner = _newOwner;
  }
}
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="117" endline="122" pcid="7706">
  function _transferOwnership(address _newOwner) internal {
    require(_newOwner != address(0));
    emit OwnershipTransferred(owner, _newOwner);
    owner = _newOwner;
  }
}
</source>
<source file="systems/smart_contracts/NBToken.sol" startline="94" endline="99" pcid="5303">
    function _transferOwnership(address _newOwner) internal {
        require(_newOwner != address(0));
        emit OwnershipTransferred(owner, _newOwner);
        owner = _newOwner;
    }
}
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="182" endline="187" pcid="4658">
  function _transferOwnership(address _newOwner) internal {
    require(_newOwner != address(0));
    emit OwnershipTransferred(owner, _newOwner);
    owner = _newOwner;
  }
}
</source>
<source file="systems/smart_contracts/MBA.sol" startline="167" endline="172" pcid="4713">
  function _transferOwnership(address _newOwner) internal {
    require(_newOwner != address(0));
    emit OwnershipTransferred(owner, _newOwner);
    owner = _newOwner;
  }
}
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="173" endline="178" pcid="7176">
    function _transferOwnership(address _newOwner) internal {
        require(_newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(owner, _newOwner);
        owner = _newOwner;
    }
}
</source>
<source file="systems/smart_contracts/TimeLockedTokenStorage.sol" startline="122" endline="127" pcid="7231">
    function _transferOwnership(address _newOwner) internal {
        require(_newOwner != address(0));
        emit OwnershipTransferred(owner, _newOwner);
        owner = _newOwner;
    }
}
</source>
<source file="systems/smart_contracts/PositionTokenV2.sol" startline="163" endline="168" pcid="5757">
  function _transferOwnership(address _newOwner) internal {
    require(_newOwner != address(0));
    emit OwnershipTransferred(owner, _newOwner);
    owner = _newOwner;
  }
}
</source>
</class>

<class classid="280" nclones="7" nlines="4" similarity="75">
<source file="systems/smart_contracts/CDS.sol" startline="303" endline="316" pcid="1669">
  function burn(uint256 _value) public {
  	require(balances[msg.sender] >= _value);
  	balances[msg.sender] = balances[msg.sender].sub(_value);
  	totalSupply_ = totalSupply_.sub(_value);
  	emit Transfer(msg.sender, address(0x00), _value);
  	emit Burn(msg.sender, _value);
  }

  /**
   * @dev Burns a specific amount of tokens from the target address and decrements allowance
   * @param _from address The account whose tokens will be burned.
   * @param _value uint256 The amount of token to be burned.
   */
   function burnFrom(address _from, uint256 _value) public {
</source>
<source file="systems/smart_contracts/MBA.sol" startline="203" endline="207" pcid="4717">
  function burn(uint256 _value) public {
    _burn(msg.sender, _value);
  }

  function _burn(address _who, uint256 _value) internal {
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="393" endline="404" pcid="7474">
    function burn(uint256 _value) public {
        require(_value > 0);
        require(_value <= balances[msg.sender]);
        // no need to require value <= totalSupply, since that would imply the
        // sender's balance is greater than the totalSupply, which *should* be an assertion failure

        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply_ = totalSupply_.sub(_value);
        emit Burn(burner, _value);
    }
}
</source>
<source file="systems/smart_contracts/CRYPTOMZ.sol" startline="231" endline="242" pcid="2190">
    function burn(uint256 _value) public {
        require(_value > 0);
        require(_value <= balances[msg.sender]);
        // no need to require value <= totalSupply, since that would imply the
        // sender's balance is greater than the totalSupply, which *should* be an assertion failure

        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        emit Burn(burner, _value);
    }
}
</source>
<source file="systems/smart_contracts/KFCToken.sol" startline="99" endline="106" pcid="4414">
    function burn(uint256 _value) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[0x0] += _value;
        emit Transfer(msg.sender, 0x0, _value);
    }

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
</source>
<source file="systems/smart_contracts/TorexToken.sol" startline="133" endline="137" pcid="7413">
  function burn(uint256 _value) public {
    _burn(msg.sender, _value);
  }

  function _burn(address _who, uint256 _value) internal {
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="360" endline="364" pcid="4671">
  function burn(uint256 _value) public {
    _burn(msg.sender, _value);
  }

  function _burn(address _who, uint256 _value) internal {
</source>
</class>

<class classid="281" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/Cholyz.sol" startline="368" endline="372" pcid="1734">
    function enableTransfers(bool _transfersEnabled) onlyOwner public {
        transfersEnabled = _transfersEnabled;
    }

    function claimTokens() public onlyOwner {
</source>
<source file="systems/smart_contracts/MiniMeTokenFactory.sol" startline="448" endline="460" pcid="4820">
    function enableTransfers(bool _transfersEnabled) onlyController public {
        transfersEnabled = _transfersEnabled;
    }

////////////////
// Internal helper functions to query and set a value in a snapshot array
////////////////

    /// @dev `getValueAt` retrieves the number of tokens at a given block number
    /// @param checkpoints The history of values being queried
    /// @param _block The block number to retrieve the value at
    /// @return The number of tokens being queried
    function getValueAt(Checkpoint[] storage checkpoints, uint _block) constant internal returns (uint) {
</source>
</class>

<class classid="282" nclones="4" nlines="5" similarity="80">
<source file="systems/smart_contracts/CLCTokenERC20.sol" startline="46" endline="72" pcid="1737">
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public {
</source>
<source file="systems/smart_contracts/ThpToken.sol" startline="70" endline="96" pcid="7158">
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/MyAdvancedToken.sol" startline="66" endline="92" pcid="5263">
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/TokenERC20.sol" startline="50" endline="76" pcid="7303">
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
</source>
</class>

<class classid="283" nclones="7" nlines="4" similarity="75">
<source file="systems/smart_contracts/CLCTokenERC20.sol" startline="72" endline="85" pcid="1738">
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    /**
     * Transfer tokens from other address
     *
     * Send `_value` tokens to `_to` on behalf of `_from`
     *
     * @param _from The address of the sender
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/RanchChain.sol" startline="72" endline="85" pcid="5978">
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    /**
     * Transfer tokens from other address
     *
     * Send `_value` tokens to `_to` in behalf of `_from`
     *
     * @param _from The address of the sender
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Rabbit.sol" startline="32" endline="35" pcid="5942">
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Contracts.sol" startline="72" endline="85" pcid="1996">
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    /**
     * Transfer tokens from other address
     *
     * Send `_value` tokens to `_to` in behalf of `_from`
     *
     * @param _from The address of the sender
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/DDPC.sol" startline="70" endline="83" pcid="2378">
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    /**
     * Transfer tokens from other address
     *
     * Send `_value` tokens to `_to` in behalf of `_from`
     *
     * @param _from The address of the sender
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ESCHToken.sol" startline="46" endline="50" pcid="3042">
    function transfer(address _to, uint256 _value) public {
        transfer(msg.sender, _to, _value);
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Dwke.sol" startline="24" endline="34" pcid="2871">
function transfer(address _to, uint256 _value) public {
/* Check if sender has balance and for overflows */
require(balanceOf[msg.sender] >= _value && balanceOf[_to] + _value >= balanceOf[_to]);
/* Notify anyone listening that this transfer took place */
emit Transfer(msg.sender, _to, _value);
/* Add and subtract new balances */
balanceOf[msg.sender] -= _value;
balanceOf[_to] += _value;
}

}
</source>
</class>

<class classid="284" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="571" endline="574" pcid="1778">
    function toPayable(address account) internal pure returns (address payable) {
        return address(uint160(account));
    }
}
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="144" endline="147" pcid="4739">
    function toPayable(address account) internal pure returns (address payable) {
        return address(uint160(account));
    }
}
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="379" endline="382" pcid="5000">
    function toPayable(address account) internal pure returns (address payable) {
        return address(uint160(account));
    }
}
</source>
</class>

<class classid="285" nclones="4" nlines="4" similarity="100">
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="780" endline="787" pcid="1787">
    function wallet() public view returns (address payable) {
        return _wallet;
    }

    /**
     * @return the number of token units a buyer gets per wei.
     */
    function rate() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="720" endline="727" pcid="7933">
    function wallet() public view returns (address payable) {
        return _wallet;
    }

    /**
     * @return the number of token units a buyer gets per wei.
     */
    function rate() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="176" endline="180" pcid="2569">
    function wallet() public view returns (address payable) {
        return _wallet;
    }

    function rate() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="172" endline="176" pcid="2660">
    function wallet() public view returns (address payable) {
        return _wallet;
    }

    function rate() public view returns (uint256) {
</source>
</class>

<class classid="286" nclones="4" nlines="4" similarity="100">
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="787" endline="794" pcid="1788">
    function rate() public view returns (uint256) {
        return _rate;
    }

    /**
     * @return the amount of wei raised.
     */
    function weiRaised() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="176" endline="180" pcid="2661">
    function rate() public view returns (uint256) {
        return _rate;
    }

    function weiRaised() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="727" endline="734" pcid="7934">
    function rate() public view returns (uint256) {
        return _rate;
    }

    /**
     * @return the amount of wei raised.
     */
    function weiRaised() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="180" endline="184" pcid="2570">
    function rate() public view returns (uint256) {
        return _rate;
    }

    function weiRaised() public view returns (uint256) {
</source>
</class>

<class classid="287" nclones="4" nlines="4" similarity="100">
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="794" endline="804" pcid="1789">
    function weiRaised() public view returns (uint256) {
        return _weiRaised;
    }

    /**
     * @dev low level token purchase ***DO NOT OVERRIDE***
     * This function has a non-reentrancy guard, so it shouldn't be called by
     * another `nonReentrant` function.
     * @param beneficiary Recipient of the token purchase
     */
    function buyTokens(address beneficiary) public nonReentrant payable {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="180" endline="184" pcid="2662">
    function weiRaised() public view returns (uint256) {
        return _weiRaised;
    }

    function buyTokens(address beneficiary) public nonReentrant payable {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="184" endline="188" pcid="2571">
    function weiRaised() public view returns (uint256) {
        return _weiRaised;
    }

    function buyTokens(address beneficiary) public nonReentrant payable {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="734" endline="744" pcid="7935">
    function weiRaised() public view returns (uint256) {
        return _weiRaised;
    }

    /**
     * @dev low level token purchase ***DO NOT OVERRIDE***
     * This function has a non-reentrancy guard, so it shouldn't be called by
     * another `nonReentrant` function.
     * @param beneficiary Recipient of the token purchase
     */
    function buyTokens(address beneficiary) public nonReentrant payable {
</source>
</class>

<class classid="288" nclones="4" nlines="5" similarity="100">
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="804" endline="832" pcid="1790">
    function buyTokens(address beneficiary) public nonReentrant payable {
        uint256 weiAmount = msg.value;
        _preValidatePurchase(beneficiary, weiAmount);

        // calculate token amount to be created
        uint256 tokens = _getTokenAmount(weiAmount);

        // update state
        _weiRaised = _weiRaised.add(weiAmount);

        _processPurchase(beneficiary, tokens);
        emit TokensPurchased(msg.sender, beneficiary, weiAmount, tokens);

        _updatePurchasingState(beneficiary, weiAmount);

        _forwardFunds();
        _postValidatePurchase(beneficiary, weiAmount);
    }

    /**
     * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met.
     * Use `super` in contracts that inherit from Crowdsale to extend their validations.
     * Example from CappedCrowdsale.sol's _preValidatePurchase method:
     *     super._preValidatePurchase(beneficiary, weiAmount);
     *     require(weiRaised().add(weiAmount) <= cap);
     * @param beneficiary Address performing the token purchase
     * @param weiAmount Value in wei involved in the purchase
     */
    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="744" endline="772" pcid="7936">
    function buyTokens(address beneficiary) public nonReentrant payable {
        uint256 weiAmount = msg.value;
        _preValidatePurchase(beneficiary, weiAmount);

        // calculate token amount to be created
        uint256 tokens = _getTokenAmount(weiAmount);

        // update state
        _weiRaised = _weiRaised.add(weiAmount);

        _processPurchase(beneficiary, tokens);
        emit TokensPurchased(msg.sender, beneficiary, weiAmount, tokens);

        _updatePurchasingState(beneficiary, weiAmount);

        _forwardFunds();
        _postValidatePurchase(beneficiary, weiAmount);
    }

    /**
     * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met.
     * Use `super` in contracts that inherit from Crowdsale to extend their validations.
     * Example from CappedCrowdsale.sol's _preValidatePurchase method:
     *     super._preValidatePurchase(beneficiary, weiAmount);
     *     require(weiRaised().add(weiAmount) <= cap);
     * @param beneficiary Address performing the token purchase
     * @param weiAmount Value in wei involved in the purchase
     */
    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="184" endline="203" pcid="2663">
    function buyTokens(address beneficiary) public nonReentrant payable {
        uint256 weiAmount = msg.value;
        _preValidatePurchase(beneficiary, weiAmount);

        // calculate token amount to be created
        uint256 tokens = _getTokenAmount(weiAmount);

        // update state
        _weiRaised = _weiRaised.add(weiAmount);

        _processPurchase(beneficiary, tokens);
        emit TokensPurchased(msg.sender, beneficiary, weiAmount, tokens);

        _updatePurchasingState(beneficiary, weiAmount);

        _forwardFunds();
        _postValidatePurchase(beneficiary, weiAmount);
    }

    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="188" endline="207" pcid="2572">
    function buyTokens(address beneficiary) public nonReentrant payable {
        uint256 weiAmount = msg.value;
        _preValidatePurchase(beneficiary, weiAmount);

        // calculate token amount to be created
        uint256 tokens = _getTokenAmount(weiAmount);

        // update state
        _weiRaised = _weiRaised.add(weiAmount);

        _processPurchase(beneficiary, tokens);
        emit TokensPurchased(msg.sender, beneficiary, weiAmount, tokens);

        _updatePurchasingState(beneficiary, weiAmount);

        _forwardFunds();
        _postValidatePurchase(beneficiary, weiAmount);
    }

    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
</source>
</class>

<class classid="289" nclones="7" nlines="4" similarity="75">
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="832" endline="843" pcid="1791">
    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
        require(beneficiary != address(0), "Crowdsale: beneficiary is the zero address");
        require(weiAmount != 0, "Crowdsale: weiAmount is 0");
    }

    /**
     * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid
     * conditions are not met.
     * @param beneficiary Address performing the token purchase
     * @param weiAmount Value in wei involved in the purchase
     */
    function _postValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="254" endline="258" pcid="2582">
    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
        super._preValidatePurchase(beneficiary, weiAmount);
        require(weiRaised().add(weiAmount) <= _cap, "CappedCrowdsale: cap exceeded");
    }
}
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="203" endline="208" pcid="2664">
    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
        require(beneficiary != address(0), "Crowdsale: beneficiary is the zero address");
        require(weiAmount != 0, "Crowdsale: weiAmount is 0");
    }

    function _postValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="938" endline="942" pcid="1800">
    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
        super._preValidatePurchase(beneficiary, weiAmount);
        require(weiRaised().add(weiAmount) <= _cap, "CappedCrowdsale: cap exceeded");
    }
}
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="250" endline="254" pcid="2673">
    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
        super._preValidatePurchase(beneficiary, weiAmount);
        require(weiRaised().add(weiAmount) <= _cap, "CappedCrowdsale: cap exceeded");
    }
}
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="207" endline="212" pcid="2573">
    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
        require(beneficiary != address(0), "Crowdsale: beneficiary is the zero address");
        require(weiAmount != 0, "Crowdsale: weiAmount is 0");
    }

    function _postValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="772" endline="783" pcid="7937">
    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
        require(beneficiary != address(0));
        require(weiAmount != 0);
    }

    /**
     * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid
     * conditions are not met.
     * @param beneficiary Address performing the token purchase
     * @param weiAmount Value in wei involved in the purchase
     */
    function _postValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
</source>
</class>

<class classid="290" nclones="4" nlines="3" similarity="100">
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="843" endline="853" pcid="1792">
    function _postValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
        // solhint-disable-previous-line no-empty-blocks
    }

    /**
     * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends
     * its tokens.
     * @param beneficiary Address performing the token purchase
     * @param tokenAmount Number of tokens to be emitted
     */
    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="212" endline="216" pcid="2574">
    function _postValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
        // solhint-disable-previous-line no-empty-blocks
    }

    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="783" endline="793" pcid="7938">
    function _postValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
        // solhint-disable-previous-line no-empty-blocks
    }

    /**
     * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends
     * its tokens.
     * @param beneficiary Address performing the token purchase
     * @param tokenAmount Number of tokens to be emitted
     */
    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="208" endline="212" pcid="2665">
    function _postValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
        // solhint-disable-previous-line no-empty-blocks
    }

    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {
</source>
</class>

<class classid="291" nclones="10" nlines="4" similarity="75">
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="853" endline="863" pcid="1793">
    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {
        _token.safeTransfer(beneficiary, tokenAmount);
    }

    /**
     * @dev Executed when a purchase has been validated and is ready to be executed. Doesn't necessarily emit/send
     * tokens.
     * @param beneficiary Address receiving the tokens
     * @param tokenAmount Number of tokens to be purchased
     */
    function _processPurchase(address beneficiary, uint256 tokenAmount) internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="524" endline="531" pcid="2616">
    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {
        // Potentially dangerous assumption about the type of the token.
        require(
            ERC20Mintable(address(token())).mint(beneficiary, tokenAmount),
                "MintedCrowdsale: minting failed"
        );
    }
}
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="567" endline="570" pcid="2622">
    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {
        token().safeTransferFrom(_tokenWallet, beneficiary, tokenAmount);
    }
}
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="563" endline="566" pcid="2713">
    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {
        token().safeTransferFrom(_tokenWallet, beneficiary, tokenAmount);
    }
}
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="520" endline="527" pcid="2707">
    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {
        // Potentially dangerous assumption about the type of the token.
        require(
            ERC20Mintable(address(token())).mint(beneficiary, tokenAmount),
                "MintedCrowdsale: minting failed"
        );
    }
}
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="216" endline="220" pcid="2575">
    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {
        _token.safeTransfer(beneficiary, tokenAmount);
    }

    function _processPurchase(address beneficiary, uint256 tokenAmount) internal {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="961" endline="968" pcid="1801">
    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {
        // Potentially dangerous assumption about the type of the token.
        require(
            ERC20Mintable(address(token())).mint(beneficiary, tokenAmount),
                "MintedCrowdsale: minting failed"
        );
    }
}
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="833" endline="836" pcid="7944">
    function reClaimUnsoldTokens(address beneficiary, uint256 tokenAmount) onlyOwner public {
        _token.safeTransfer(beneficiary, tokenAmount);
    }
}
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="793" endline="803" pcid="7939">
    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {
        _token.safeTransfer(beneficiary, tokenAmount);
    }

    /**
     * @dev Executed when a purchase has been validated and is ready to be executed. Doesn't necessarily emit/send
     * tokens.
     * @param beneficiary Address receiving the tokens
     * @param tokenAmount Number of tokens to be purchased
     */
    function _processPurchase(address beneficiary, uint256 tokenAmount) internal {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="212" endline="216" pcid="2666">
    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {
        _token.safeTransfer(beneficiary, tokenAmount);
    }

    function _processPurchase(address beneficiary, uint256 tokenAmount) internal {
</source>
</class>

<class classid="292" nclones="5" nlines="4" similarity="75">
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="863" endline="873" pcid="1794">
    function _processPurchase(address beneficiary, uint256 tokenAmount) internal {
        _deliverTokens(beneficiary, tokenAmount);
    }

    /**
     * @dev Override for extensions that require an internal state to check for validity (current user contributions,
     * etc.)
     * @param beneficiary Address receiving the tokens
     * @param weiAmount Value in wei involved in the purchase
     */
    function _updatePurchasingState(address beneficiary, uint256 weiAmount) internal {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="216" endline="220" pcid="2667">
    function _processPurchase(address beneficiary, uint256 tokenAmount) internal {
        _deliverTokens(beneficiary, tokenAmount);
    }

    function _updatePurchasingState(address beneficiary, uint256 weiAmount) internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="220" endline="224" pcid="2576">
    function _processPurchase(address beneficiary, uint256 tokenAmount) internal {
        _deliverTokens(beneficiary, tokenAmount);
    }

    function _updatePurchasingState(address beneficiary, uint256 weiAmount) internal {
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1481" endline="1485" pcid="1832">
    function _processPurchase(address beneficiary, uint256 tokenAmount) internal {
        _balances[beneficiary] = _balances[beneficiary].add(tokenAmount);
        _deliverTokens(address(_vault), tokenAmount);
    }
}
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="803" endline="813" pcid="7940">
    function _processPurchase(address beneficiary, uint256 tokenAmount) internal {
        _deliverTokens(beneficiary, tokenAmount);
    }

    /**
     * @dev Override for extensions that require an internal state to check for validity (current user contributions,
     * etc.)
     * @param beneficiary Address receiving the tokens
     * @param weiAmount Value in wei involved in the purchase
     */
    function _updatePurchasingState(address beneficiary, uint256 weiAmount) internal {
</source>
</class>

<class classid="293" nclones="4" nlines="3" similarity="100">
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="873" endline="882" pcid="1795">
    function _updatePurchasingState(address beneficiary, uint256 weiAmount) internal {
        // solhint-disable-previous-line no-empty-blocks
    }

    /**
     * @dev Override to extend the way in which ether is converted to tokens.
     * @param weiAmount Value in wei to be converted into tokens
     * @return Number of tokens that can be purchased with the specified _weiAmount
     */
    function _getTokenAmount(uint256 weiAmount) internal view returns (uint256) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="220" endline="224" pcid="2668">
    function _updatePurchasingState(address beneficiary, uint256 weiAmount) internal {
        // solhint-disable-previous-line no-empty-blocks
    }

    function _getTokenAmount(uint256 weiAmount) internal view returns (uint256) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="224" endline="228" pcid="2577">
    function _updatePurchasingState(address beneficiary, uint256 weiAmount) internal {
        // solhint-disable-previous-line no-empty-blocks
    }

    function _getTokenAmount(uint256 weiAmount) internal view returns (uint256) {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="813" endline="822" pcid="7941">
    function _updatePurchasingState(address beneficiary, uint256 weiAmount) internal {
        // solhint-disable-previous-line no-empty-blocks
    }

    /**
     * @dev Override to extend the way in which ether is converted to tokens.
     * @param weiAmount Value in wei to be converted into tokens
     * @return Number of tokens that can be purchased with the specified _weiAmount
     */
    function _getTokenAmount(uint256 weiAmount) internal view returns (uint256) {
</source>
</class>

<class classid="294" nclones="4" nlines="4" similarity="100">
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="882" endline="889" pcid="1796">
    function _getTokenAmount(uint256 weiAmount) internal view returns (uint256) {
        return weiAmount.mul(_rate);
    }

    /**
     * @dev Determines how ETH is stored/forwarded on purchases.
     */
    function _forwardFunds() internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="228" endline="232" pcid="2578">
    function _getTokenAmount(uint256 weiAmount) internal view returns (uint256) {
        return weiAmount.mul(_rate);
    }

    function _forwardFunds() internal {
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="822" endline="829" pcid="7942">
    function _getTokenAmount(uint256 weiAmount) internal view returns (uint256) {
        return weiAmount.mul(_rate);
    }

    /**
     * @dev Determines how ETH is stored/forwarded on purchases.
     */
    function _forwardFunds() internal {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="224" endline="228" pcid="2669">
    function _getTokenAmount(uint256 weiAmount) internal view returns (uint256) {
        return weiAmount.mul(_rate);
    }

    function _forwardFunds() internal {
</source>
</class>

<class classid="295" nclones="5" nlines="4" similarity="75">
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="889" endline="892" pcid="1797">
    function _forwardFunds() internal {
        _wallet.transfer(msg.value);
    }
}
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="228" endline="231" pcid="2670">
    function _forwardFunds() internal {
        _wallet.transfer(msg.value);
    }
}
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="232" endline="235" pcid="2579">
    function _forwardFunds() internal {
        _wallet.transfer(msg.value);
    }
}
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1427" endline="1430" pcid="1829">
    function _forwardFunds() internal {
        _escrow.deposit.value(msg.value)(msg.sender);
    }
}
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="829" endline="833" pcid="7943">
    function _forwardFunds() internal {
        _wallet.transfer(msg.value);
    }

    function reClaimUnsoldTokens(address beneficiary, uint256 tokenAmount) onlyOwner public {
</source>
</class>

<class classid="296" nclones="6" nlines="4" similarity="100">
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="921" endline="929" pcid="1798">
    function cap() public view returns (uint256) {
        return _cap;
    }

    /**
     * @dev Checks whether the cap has been reached.
     * @return Whether the cap was reached
     */
    function capReached() public view returns (bool) {
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="271" endline="278" pcid="6996">
    function cap() public view returns (uint256) {
        return _cap;
    }

    /**
     * @dev Total number of tokens in existence.
     */
    function totalSupply() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="613" endline="624" pcid="7211">
    function cap() public view returns (uint256) {
        return _cap;
    }

    /**
     *  See `ERC20Mintable.mint`.
     *
     * Requirements:
     *
     * - `value` must not cause the total supply to go over the cap.
     */
    function _mint(address account, uint256 value) internal {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="443" endline="450" pcid="5363">
    function cap() public view returns (uint256) {
        return _cap;
    }

    /**
     * @dev Returns the amount of VOKEN in existence.
     */
    function totalSupply() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="246" endline="250" pcid="2580">
    function cap() public view returns (uint256) {
        return _cap;
    }

    function capReached() public view returns (bool) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="242" endline="246" pcid="2671">
    function cap() public view returns (uint256) {
        return _cap;
    }

    function capReached() public view returns (bool) {
</source>
</class>

<class classid="297" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="929" endline="938" pcid="1799">
    function capReached() public view returns (bool) {
        return weiRaised() >= _cap;
    }

    /**
     * @dev Extend parent behavior requiring purchase to respect the funding cap.
     * @param beneficiary Token purchaser
     * @param weiAmount Amount of wei contributed
     */
    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="250" endline="254" pcid="2581">
    function capReached() public view returns (bool) {
        return weiRaised() >= _cap;
    }

    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="246" endline="250" pcid="2672">
    function capReached() public view returns (bool) {
        return weiRaised() >= _cap;
    }

    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
</source>
</class>

<class classid="298" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1019" endline="1026" pcid="1802">
    function openingTime() public view returns (uint256) {
        return _openingTime;
    }

    /**
     * @return the crowdsale closing time.
     */
    function closingTime() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="277" endline="281" pcid="2674">
    function openingTime() public view returns (uint256) {
        return _openingTime;
    }

    function closingTime() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="281" endline="285" pcid="2583">
    function openingTime() public view returns (uint256) {
        return _openingTime;
    }

    function closingTime() public view returns (uint256) {
</source>
</class>

<class classid="299" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1026" endline="1033" pcid="1803">
    function closingTime() public view returns (uint256) {
        return _closingTime;
    }

    /**
     * @return true if the crowdsale is open, false otherwise.
     */
    function isOpen() public view returns (bool) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="285" endline="289" pcid="2584">
    function closingTime() public view returns (uint256) {
        return _closingTime;
    }

    function isOpen() public view returns (bool) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="281" endline="285" pcid="2675">
    function closingTime() public view returns (uint256) {
        return _closingTime;
    }

    function isOpen() public view returns (bool) {
</source>
</class>

<class classid="300" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1033" endline="1042" pcid="1804">
    function isOpen() public view returns (bool) {
        // solhint-disable-next-line not-rely-on-time
        return block.timestamp >= _openingTime && block.timestamp <= _closingTime;
    }

    /**
     * @dev Checks whether the period in which the crowdsale is open has already elapsed.
     * @return Whether crowdsale period has elapsed
     */
    function hasClosed() public view returns (bool) {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="289" endline="293" pcid="2585">
    function isOpen() public view returns (bool) {
        return block.timestamp >= _openingTime && block.timestamp <= _closingTime;
    }

    function hasClosed() public view returns (bool) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="285" endline="289" pcid="2676">
    function isOpen() public view returns (bool) {
        return block.timestamp >= _openingTime && block.timestamp <= _closingTime;
    }

    function hasClosed() public view returns (bool) {
</source>
</class>

<class classid="301" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1042" endline="1052" pcid="1805">
    function hasClosed() public view returns (bool) {
        // solhint-disable-next-line not-rely-on-time
        return block.timestamp > _closingTime;
    }

    /**
     * @dev Extend parent behavior requiring to be within contributing period.
     * @param beneficiary Token purchaser
     * @param weiAmount Amount of wei contributed
     */
    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal onlyWhileOpen view {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="289" endline="293" pcid="2677">
    function hasClosed() public view returns (bool) {
        return block.timestamp > _closingTime;
    }

    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal onlyWhileOpen view {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="293" endline="297" pcid="2586">
    function hasClosed() public view returns (bool) {
        return block.timestamp > _closingTime;
    }

    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal onlyWhileOpen view {
</source>
</class>

<class classid="302" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1052" endline="1060" pcid="1806">
    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal onlyWhileOpen view {
        super._preValidatePurchase(beneficiary, weiAmount);
    }

    /**
     * @dev Extend crowdsale.
     * @param newClosingTime Crowdsale closing time
     */
    function _extendTime(uint256 newClosingTime) internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="297" endline="301" pcid="2587">
    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal onlyWhileOpen view {
        super._preValidatePurchase(beneficiary, weiAmount);
    }

    function _extendTime(uint256 newClosingTime) internal {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="293" endline="297" pcid="2678">
    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal onlyWhileOpen view {
        super._preValidatePurchase(beneficiary, weiAmount);
    }

    function _extendTime(uint256 newClosingTime) internal {
</source>
</class>

<class classid="303" nclones="3" nlines="5" similarity="100">
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1060" endline="1068" pcid="1807">
    function _extendTime(uint256 newClosingTime) internal {
        require(!hasClosed(), "TimedCrowdsale: already closed");
        // solhint-disable-next-line max-line-length
        require(newClosingTime > _closingTime, "TimedCrowdsale: new closing time is before current closing time");

        emit TimedCrowdsaleExtended(_closingTime, newClosingTime);
        _closingTime = newClosingTime;
    }
}
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="297" endline="304" pcid="2679">
    function _extendTime(uint256 newClosingTime) internal {
        require(!hasClosed(), "TimedCrowdsale: already closed");
        require(newClosingTime > _closingTime, "TimedCrowdsale: new closing time is before current closing time");

        emit TimedCrowdsaleExtended(_closingTime, newClosingTime);
        _closingTime = newClosingTime;
    }
}
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="301" endline="308" pcid="2588">
    function _extendTime(uint256 newClosingTime) internal {
        require(!hasClosed(), "TimedCrowdsale: already closed");
        require(newClosingTime > _closingTime, "TimedCrowdsale: new closing time is before current closing time");

        emit TimedCrowdsaleExtended(_closingTime, newClosingTime);
        _closingTime = newClosingTime;
    }
}
</source>
</class>

<class classid="304" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1095" endline="1103" pcid="1808">
    function finalized() public view returns (bool) {
        return _finalized;
    }

    /**
     * @dev Must be called after crowdsale ends, to do some extra finalization
     * work. Calls the contract's finalization function.
     */
    function finalize() public {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="317" endline="321" pcid="2680">
    function finalized() public view returns (bool) {
        return _finalized;
    }

    function finalize() public {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="321" endline="325" pcid="2589">
    function finalized() public view returns (bool) {
        return _finalized;
    }

    function finalize() public {
</source>
</class>

<class classid="305" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1103" endline="1118" pcid="1809">
    function finalize() public {
        require(!_finalized, "FinalizableCrowdsale: already finalized");
        require(hasClosed(), "FinalizableCrowdsale: not closed");

        _finalized = true;

        _finalization();
        emit CrowdsaleFinalized();
    }

    /**
     * @dev Can be overridden to add finalization logic. The overriding function
     * should call super._finalization() to ensure the chain of finalization is
     * executed entirely.
     */
    function _finalization() internal {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="325" endline="335" pcid="2590">
    function finalize() public {
        require(!_finalized, "FinalizableCrowdsale: already finalized");
        require(hasClosed(), "FinalizableCrowdsale: not closed");

        _finalized = true;

        _finalization();
        emit CrowdsaleFinalized();
    }

    function _finalization() internal {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="321" endline="331" pcid="2681">
    function finalize() public {
        require(!_finalized, "FinalizableCrowdsale: already finalized");
        require(hasClosed(), "FinalizableCrowdsale: not closed");

        _finalized = true;

        _finalization();
        emit CrowdsaleFinalized();
    }

    function _finalization() internal {
</source>
</class>

<class classid="306" nclones="3" nlines="3" similarity="100">
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1118" endline="1121" pcid="1810">
    function _finalization() internal {
        // solhint-disable-previous-line no-empty-blocks
    }
}
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="335" endline="338" pcid="2591">
    function _finalization() internal {

    }
}
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="331" endline="334" pcid="2682">
    function _finalization() internal {

    }
}
</source>
</class>

<class classid="307" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1159" endline="1167" pcid="1811">
    function primary() public view returns (address) {
        return _primary;
    }

    /**
     * @dev Transfers contract to a new primary.
     * @param recipient The address of new primary.
     */
    function transferPrimary(address recipient) public onlyPrimary {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="353" endline="357" pcid="2683">
    function primary() public view returns (address) {
        return _primary;
    }

    function transferPrimary(address recipient) public onlyPrimary {
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="357" endline="361" pcid="2592">
    function primary() public view returns (address) {
        return _primary;
    }

    function transferPrimary(address recipient) public onlyPrimary {
</source>
</class>

<class classid="308" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="1167" endline="1172" pcid="1812">
    function transferPrimary(address recipient) public onlyPrimary {
        require(recipient != address(0), "Secondary: new primary is the zero address");
        _primary = recipient;
        emit PrimaryTransferred(_primary);
    }
}
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="357" endline="362" pcid="2684">
    function transferPrimary(address recipient) public onlyPrimary {
        require(recipient != address(0), "Secondary: new primary is the zero address");
        _primary = recipient;
        emit PrimaryTransferred(_primary);
    }
}
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="361" endline="366" pcid="2593">
    function transferPrimary(address recipient) public onlyPrimary {
        require(recipient != address(0), "Secondary: new primary is the zero address");
        _primary = recipient;
        emit PrimaryTransferred(_primary);
    }
}
</source>
</class>

<class classid="309" nclones="3" nlines="4" similarity="75">
<source file="systems/smart_contracts/CoinDumper.sol" startline="218" endline="221" pcid="1898">
  function safeApprove(ERC20 token, address spender, uint256 value) internal {
    assert(token.approve(spender, value));
  }
}
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="215" endline="218" pcid="7468">
    function safeApprove(ERC20 token, address spender, uint256 value) internal {
        assert(token.approve(spender, value));
    }
}
</source>
<source file="systems/smart_contracts/MBA.sol" startline="190" endline="193" pcid="4716">
  function safeApprove(ERC20 token, address spender, uint256 value) internal {
    require(token.approve(spender, value));
  }
}
</source>
</class>

<class classid="310" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/CoinDumper.sol" startline="264" endline="271" pcid="1904">
    function withdrawEtherFromcontract(uint _amountInwei) public onlyOwner{
      require(address(this).balance > _amountInwei);
      require(isOwner());
      msg.sender.transfer(_amountInwei);
      
    }
    
}
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="316" endline="323" pcid="1910">
    function withdrawEtherFromcontract(uint _amountInwei) public onlyOwner{
      require(address(this).balance > _amountInwei);
      require(isOwner());
      msg.sender.transfer(_amountInwei);
      
    }
    
    function withdrawTokenFromcontract(ERC20 _token, uint256 _tamount) public onlyOwner{
</source>
</class>

<class classid="311" nclones="3" nlines="4" similarity="75">
<source file="systems/smart_contracts/CoinDumper.sol" startline="292" endline="295" pcid="1906">
    function close() public onlyOwner { //onlyOwner is custom modifier
  selfdestruct(msg.sender);  // `owner` is the owners address
}
    function setConversionRate(uint256 _valueInWei) public onlyOwner returns (uint256){
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="846" endline="859" pcid="2372">
    function retrieveEther() public only_owner only_after_withdraw_period {
        selfdestruct(msg.sender);
    }


    /**
     * Failsafe mechanism
     * 
     * Allows the owner to retrieve tokens (other than DRPS and DRPU tokens) from the contract that 
     * might have been send there by accident
     *
     * @param _tokenContract The address of ERC20 compatible token
     */
    function retrieveTokens(address _tokenContract) public only_owner not_accepted_token(_tokenContract) {
</source>
<source file="systems/smart_contracts/UltraBlockCoin.sol" startline="173" endline="176" pcid="7564">
    function destruct() onlyOwner public{
        selfdestruct(msg.sender);
    }
}
</source>
</class>

<class classid="312" nclones="3" nlines="4" similarity="75">
<source file="systems/smart_contracts/CommunityChest.sol" startline="31" endline="35" pcid="1942">
    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }
    
    modifier onlyOwner() {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="658" endline="666" pcid="5134">
    function totalEthereumBalance()
        public
        view
        returns(uint)
    {
        return address (this).balance;
    }

    function getTotalBondValue()
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="555" endline="561" pcid="3742">
function balanceETH() public view returns(uint) {
return address(this).balance;
}



function advertisingPercent() public view returns(uint numerator, uint denominator) {
</source>
</class>

<class classid="313" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/ComplianceRegistry.sol" startline="94" endline="99" pcid="1948">
    function changeService(address _service) onlyOwner isContract(_service) public {
        address old = service;
        service = _service;
        emit ChangeService(old, service);
    }
}
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="197" endline="202" pcid="5848">
    function changeService(address _service) onlyOwner isContract(_service) public {
        address old = service;
        service = _service;
        emit ChangeService(old, service);
    }
}
</source>
</class>

<class classid="314" nclones="5" nlines="4" similarity="75">
<source file="systems/smart_contracts/Contracts.sol" startline="32" endline="46" pcid="1994">
    function Contracts(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    }

    /**
     * Internal transfer, only can be called by this contract
     */
    function _transfer(address _from, address _to, uint _value) internal {
</source>
<source file="systems/smart_contracts/Rabbit.sol" startline="16" endline="22" pcid="5940">
    function Rabbit(uint256 initialSupply, string tokenName, string tokenSymbol) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        name = tokenName;
        symbol = tokenSymbol;
    }
    function _transfer(address _from, address _to, uint _value) internal {
</source>
<source file="systems/smart_contracts/MyAdvancedToken.sol" startline="52" endline="66" pcid="5262">
    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    }

    /**
     * Internal transfer, only can be called by this contract
     */
    function _transfer(address _from, address _to, uint _value) internal {
</source>
<source file="systems/smart_contracts/RanchChain.sol" startline="32" endline="46" pcid="5976">
    function RanchChain(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    }

    /**
     * Internal transfer, only can be called by this contract
     */
    function _transfer(address _from, address _to, uint _value) internal {
</source>
<source file="systems/smart_contracts/DDPC.sol" startline="30" endline="44" pcid="2376">
    function DDPC (
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    }

    /**
     * Internal transfer, only can be called by this contract
     */
    function _transfer(address _from, address _to, uint _value) internal {
</source>
</class>

<class classid="315" nclones="5" nlines="5" similarity="80">
<source file="systems/smart_contracts/Contracts.sol" startline="46" endline="72" pcid="1995">
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public {
</source>
<source file="systems/smart_contracts/ESCHToken.sol" startline="35" endline="46" pcid="3041">
    function transfer(address _from, address _to, uint _value) internal {
        require(_to != 0x0);
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    function transfer(address _to, uint256 _value) public {
</source>
<source file="systems/smart_contracts/RanchChain.sol" startline="46" endline="72" pcid="5977">
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public {
</source>
<source file="systems/smart_contracts/DDPC.sol" startline="44" endline="70" pcid="2377">
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public {
</source>
<source file="systems/smart_contracts/Rabbit.sol" startline="22" endline="32" pcid="5941">
    function _transfer(address _from, address _to, uint _value) internal {
        require(_to != 0x0);
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
    function transfer(address _to, uint256 _value) public {
</source>
</class>

<class classid="316" nclones="3" nlines="4" similarity="75">
<source file="systems/smart_contracts/Controller.sol" startline="9" endline="10" pcid="2002">
    function balanceOf(address a) external returns (uint) {return 0;}
    function transfer(address a, uint val) external returns (bool) {return false;}
</source>
<source file="systems/smart_contracts/DefaultService.sol" startline="20" endline="24" pcid="2385">
    function check(address _token,address _spender,address _from,address _to,uint256 _amount) public view returns (uint8){
        return 0;
    }

}
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="215" endline="219" pcid="5850">
    function check(address _token,address _spender,address _from,address _to,uint256 _amount) public view returns (uint8){
        return 0;
    }

}
</source>
</class>

<class classid="317" nclones="4" nlines="4" similarity="75">
<source file="systems/smart_contracts/Controller.sol" startline="10" endline="11" pcid="2003">
    function transfer(address a, uint val) external returns (bool) {return false;}
}
</source>
<source file="systems/smart_contracts/FlatPricingExt.sol" startline="92" endline="97" pcid="3634">
  function isPresalePurchase(address purchaser) public constant returns (bool) {
    return false;
  }

  /* How many weis one token costs */
  function updateRate(uint newOneTokenInWei) public;
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="253" endline="258" pcid="6088">
  function isPresalePurchase(address purchaser) public constant returns (bool) {
    return false;
  }

  /* How many weis one token costs */
  function updateRate(uint newOneTokenInWei) public;
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="258" endline="263" pcid="4848">
  function isPresalePurchase(address purchaser) public constant returns (bool) {
    return false;
  }

  /* How many weis one token costs */
  function updateRate(uint newOneTokenInWei) public;
</source>
</class>

<class classid="318" nclones="3" nlines="4" similarity="75">
<source file="systems/smart_contracts/Controller.sol" startline="86" endline="90" pcid="2010">
    function halt() public onlyAdmins {
        halted = true;
    }

    function start() public onlyOwner {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="209" endline="214" pcid="6084">
  function halt() external onlyOwner {
    halted = true;
  }

  // called by the owner on end of emergency, returns to normal state
  function unhalt() external onlyOwner onlyInEmergency {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="214" endline="219" pcid="4844">
  function halt() external onlyOwner {
    halted = true;
  }

  // called by the owner on end of emergency, returns to normal state
  function unhalt() external onlyOwner onlyInEmergency {
</source>
</class>

<class classid="319" nclones="5" nlines="4" similarity="75">
<source file="systems/smart_contracts/Controller.sol" startline="90" endline="97" pcid="2011">
    function start() public onlyOwner {
        halted = false;
    }

    //***********
    //SweeperList
    //***********
    address public defaultSweeper = address(new DefaultSweeper(address(this)));
</source>
<source file="systems/smart_contracts/DNP.sol" startline="133" endline="137" pcid="2796">
    function start() public onlyOwner 
    {
        stopped = false;
    }
    function isStopped() public view returns(bool)
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="219" endline="223" pcid="4845">
  function unhalt() external onlyOwner onlyInEmergency {
    halted = false;
  }

}
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="214" endline="218" pcid="6085">
  function unhalt() external onlyOwner onlyInEmergency {
    halted = false;
  }

}
</source>
<source file="systems/smart_contracts/KFCToken.sol" startline="87" endline="91" pcid="4411">
    function start() public isOwner {
        stopped = false;
    }

    function setName(string _name) public isOwner {
</source>
</class>

<class classid="320" nclones="12" nlines="4" similarity="75">
<source file="systems/smart_contracts/CouncilVesting.sol" startline="12" endline="18" pcid="2017">
  function mul(uint a, uint b) internal returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function div(uint a, uint b) internal returns (uint) {
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="73" endline="79" pcid="2095">
  function safeMul(uint a, uint b) internal returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint a, uint b) internal returns (uint) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="74" endline="80" pcid="6074">
  function safeMul(uint a, uint b) internal returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint a, uint b) internal returns (uint) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="40" endline="46" pcid="6070">
  function times(uint a, uint b) returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function divides(uint a, uint b) returns (uint) {
</source>
<source file="systems/smart_contracts/OMGToken.sol" startline="16" endline="22" pcid="5479">
  function mul(uint a, uint b) internal returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function div(uint a, uint b) internal returns (uint) {
</source>
<source file="systems/smart_contracts/SafeMathLibExt.sol" startline="26" endline="32" pcid="6239">
  function times(uint a, uint b) returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function divides(uint a, uint b) returns (uint) {
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="501" endline="507" pcid="2125">
  function times(uint a, uint b) returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function divides(uint a, uint b) returns (uint) {
</source>
<source file="systems/smart_contracts/DaiSwap.sol" startline="8" endline="13" pcid="2281">
  function safeMul(uint a, uint b) internal pure returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
  function safeSub(uint a, uint b) internal pure returns (uint) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="90" endline="96" pcid="4838">
  function times(uint a, uint b) returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function divides(uint a, uint b) returns (uint) {
</source>
<source file="systems/smart_contracts/Exchange.sol" startline="30" endline="37" pcid="3363">
    function safeMul(uint a, uint b) returns (uint) {
        uint c = a * b;
        assert(a == 0 || c / a == b);
        return c;
    }

    // Safe Subtraction Function - prevents integer overflow 
    function safeSub(uint a, uint b) returns (uint) {
</source>
<source file="systems/smart_contracts/FlatPricingExt.sol" startline="133" endline="139" pcid="3637">
  function times(uint a, uint b) returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function divides(uint a, uint b) returns (uint) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="15" endline="21" pcid="4828">
  function safeMul(uint a, uint b) internal returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint a, uint b) internal returns (uint) {
</source>
</class>

<class classid="321" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/CouncilVesting.sol" startline="18" endline="23" pcid="2018">
  function div(uint a, uint b) internal returns (uint) {
    uint c = a / b;
    return c;
  }

  function sub(uint a, uint b) internal returns (uint) {
</source>
<source file="systems/smart_contracts/OMGToken.sol" startline="22" endline="29" pcid="5480">
  function div(uint a, uint b) internal returns (uint) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  function sub(uint a, uint b) internal returns (uint) {
</source>
</class>

<class classid="322" nclones="7" nlines="4" similarity="75">
<source file="systems/smart_contracts/CouncilVesting.sol" startline="28" endline="34" pcid="2020">
  function add(uint a, uint b) internal returns (uint) {
    uint c = a + b;
    assert(c >= a);
    return c;
  }

  function max64(uint64 a, uint64 b) internal constant returns (uint64) {
</source>
<source file="systems/smart_contracts/OMGToken.sol" startline="34" endline="40" pcid="5482">
  function add(uint a, uint b) internal returns (uint) {
    uint c = a + b;
    assert(c >= a);
    return c;
  }

  function max64(uint64 a, uint64 b) internal constant returns (uint64) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="58" endline="64" pcid="6073">
  function plus(uint a, uint b) returns (uint) {
    uint c = a + b;
    assert(c>=a);
    return c;
  }

}
</source>
<source file="systems/smart_contracts/SafeMathLibExt.sol" startline="44" endline="50" pcid="6242">
  function plus(uint a, uint b) returns (uint) {
    uint c = a + b;
    assert(c>=a);
    return c;
  }

}
</source>
<source file="systems/smart_contracts/FlatPricingExt.sol" startline="151" endline="157" pcid="3640">
  function plus(uint a, uint b) returns (uint) {
    uint c = a + b;
    assert(c>=a);
    return c;
  }

}
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="108" endline="114" pcid="4841">
  function plus(uint a, uint b) returns (uint) {
    uint c = a + b;
    assert(c>=a);
    return c;
  }

}
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="519" endline="525" pcid="2128">
  function plus(uint a, uint b) returns (uint) {
    uint c = a + b;
    assert(c>=a);
    return c;
  }

}
</source>
</class>

<class classid="323" nclones="3" nlines="3" similarity="100">
<source file="systems/smart_contracts/CouncilVesting.sol" startline="63" endline="64" pcid="2025">
    function totalSupply() constant returns (uint256 totalSupply) {}
    function balanceOf(address _owner) constant returns (uint256 balance) {}
</source>
<source file="systems/smart_contracts/ZhongChaChainToken.sol" startline="12" endline="13" pcid="8215">
    function totalSupply() constant returns (uint256 totalSupply) {}
    function balanceOf(address owner) constant returns (uint256 balance);
</source>
<source file="systems/smart_contracts/TeaToken.sol" startline="12" endline="13" pcid="7118">
    function totalSupply() constant returns (uint256 totalSupply) {}
    function balanceOf(address owner) constant returns (uint256 balance);
</source>
</class>

<class classid="324" nclones="2" nlines="8" similarity="75">
<source file="systems/smart_contracts/Crowdsale.sol" startline="221" endline="229" pcid="2058">
    function transfer(address _to, uint256 _value) public returns(bool){
        if (msg.sender != CrowdsaleAddress){
            require(!lockTransfers, "Transfers are prohibited in ICO and Crowdsale period");
        }
        return super.transfer(_to,_value);
    }

     // Override
    function transferFrom(address _from, address _to, uint256 _value) public returns(bool){
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="229" endline="236" pcid="2059">
    function transferFrom(address _from, address _to, uint256 _value) public returns(bool){
        if (msg.sender != CrowdsaleAddress){
            require(!lockTransfers, "Transfers are prohibited in ICO and Crowdsale period");
        }
        return super.transferFrom(_from,_to,_value);
    }
     
    function acceptTokens(address _from, uint256 _value) public onlyOwner returns (bool){
</source>
</class>

<class classid="325" nclones="4" nlines="7" similarity="71">
<source file="systems/smart_contracts/Crowdsale.sol" startline="440" endline="447" pcid="2074">
    function giveBountyTokens(address _newInvestor, uint256 _value) public onlyOwner {
        // the sum is entered in whole tokens (1 = 1 token)
        if (returnTokensFromHoldBountyAddress(_value)){
            giveTokens(_newInvestor, _value);
        }
    }

    function giveProjectTokens(address _newInvestor, uint256 _value) public onlyOwner {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="447" endline="455" pcid="2075">
    function giveProjectTokens(address _newInvestor, uint256 _value) public onlyOwner {
        // the sum is entered in whole tokens (1 = 1 token)

        if (returnTokensFromHoldProjectAddress(_value)){
            giveTokens(_newInvestor, _value);
        }
    }

    function giveAdvisorsTokens(address _newInvestor, uint256 _value) public onlyOwner {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="462" endline="469" pcid="2077">
    function giveAdditionalTokens(address _newInvestor, uint256 _value) public onlyOwner {
        // the sum is entered in whole tokens (1 = 1 token)
        if (returnTokensFromHoldAdditionalAddress(_value)){
            giveTokens(_newInvestor, _value);
        }
    }

    function withdrawAllTokensFromBalance() public onlyOwner {
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="455" endline="462" pcid="2076">
    function giveAdvisorsTokens(address _newInvestor, uint256 _value) public onlyOwner {
        // the sum is entered in whole tokens (1 = 1 token)
        if (returnTokensFromHoldAdvisorsAddress(_value)){
            giveTokens(_newInvestor, _value);
        }
    }

    function giveAdditionalTokens(address _newInvestor, uint256 _value) public onlyOwner {
</source>
</class>

<class classid="326" nclones="8" nlines="4" similarity="75">
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="79" endline="86" pcid="2096">
  function safeDiv(uint a, uint b) internal returns (uint) {
    assert(b > 0);
    uint c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint a, uint b) internal returns (uint) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="80" endline="87" pcid="6075">
  function safeDiv(uint a, uint b) internal returns (uint) {
    assert(b > 0);
    uint c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint a, uint b) internal returns (uint) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="46" endline="53" pcid="6071">
  function divides(uint a, uint b) returns (uint) {
    assert(b > 0);
    uint c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function minus(uint a, uint b) returns (uint) {
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="507" endline="514" pcid="2126">
  function divides(uint a, uint b) returns (uint) {
    assert(b > 0);
    uint c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function minus(uint a, uint b) returns (uint) {
</source>
<source file="systems/smart_contracts/SafeMathLibExt.sol" startline="32" endline="39" pcid="6240">
  function divides(uint a, uint b) returns (uint) {
    assert(b > 0);
    uint c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function minus(uint a, uint b) returns (uint) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="96" endline="103" pcid="4839">
  function divides(uint a, uint b) returns (uint) {
    assert(b > 0);
    uint c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function minus(uint a, uint b) returns (uint) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="21" endline="28" pcid="4829">
  function safeDiv(uint a, uint b) internal returns (uint) {
    assert(b > 0);
    uint c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint a, uint b) internal returns (uint) {
</source>
<source file="systems/smart_contracts/FlatPricingExt.sol" startline="139" endline="146" pcid="3638">
  function divides(uint a, uint b) returns (uint) {
    assert(b > 0);
    uint c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function minus(uint a, uint b) returns (uint) {
</source>
</class>

<class classid="327" nclones="5" nlines="4" similarity="75">
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="91" endline="97" pcid="2098">
  function safeAdd(uint a, uint b) internal returns (uint) {
    uint c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

  function max64(uint64 a, uint64 b) internal constant returns (uint64) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="92" endline="98" pcid="6077">
  function safeAdd(uint a, uint b) internal returns (uint) {
    uint c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

  function max64(uint64 a, uint64 b) internal constant returns (uint64) {
</source>
<source file="systems/smart_contracts/DaiSwap.sol" startline="17" endline="22" pcid="2283">
  function safeAdd(uint a, uint b) internal pure returns (uint) {
    uint c = a + b;
    assert(c>=a && c>=b);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/Exchange.sol" startline="43" endline="49" pcid="3365">
    function safeAdd(uint a, uint b) returns (uint) {
        uint c = a + b;
        assert(c>=a && c>=b);
        return c;
    }

    address public owner; // holds the address of the contract owner
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="33" endline="39" pcid="4831">
  function safeAdd(uint a, uint b) internal returns (uint) {
    uint c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

  function max64(uint64 a, uint64 b) internal constant returns (uint64) {
</source>
</class>

<class classid="328" nclones="20" nlines="4" similarity="75">
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="169" endline="173" pcid="2106">
  function isToken() public constant returns (bool weAre) {
    return true;
  }

  function transfer(address _to, uint _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="238" endline="244" pcid="6602">
	function amIOwner() external view onlyOwner returns (bool) {
		return true;
	}

	/// @notice Revokes a prior confirmation of the given operation
	/// @param _operation operation value, typically keccak256(msg.data)
	function revoke(bytes32 _operation)
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="991" endline="995" pcid="4892">
  function isToken() public constant returns (bool weAre) {
    return true;
  }

  function transfer(address _to, uint _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1187" endline="1191" pcid="6145">
  function canUpgrade() public constant returns(bool) {
     return true;
  }

}
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="903" endline="912" pcid="4887">
  function isCrowdsale() public constant returns (bool) {
    return true;
  }

  //
  // Modifiers
  //

  /** Modified allowing execution only if the crowdsale is currently running.  */
  modifier inState(State state) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="298" endline="307" pcid="4851">
  function isFinalizeAgent() public constant returns(bool) {
    return true;
  }

  /** Return true if we can run finalizeCrowdsale() properly.
   *
   * This is a safety check function that doesn't allow crowdsale to begin
   * unless the finalizer has been set up properly.
   */
  function isSane() public constant returns (bool);
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1059" endline="1063" pcid="6138">
  function isUpgradeAgent() public constant returns (bool) {
    return true;
  }

  function upgradeFrom(address _from, uint256 _value) public;
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="986" endline="990" pcid="6132">
  function isToken() public constant returns (bool weAre) {
    return true;
  }

  function transfer(address _to, uint _value) returns (bool success) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="249" endline="258" pcid="4847">
  function isSane(address crowdsale) public constant returns (bool) {
    return true;
  }

  /**
   * @dev Pricing tells if this is a presale purchase or not.
     @param purchaser Address of the purchaser
     @return False by default, true if a presale purchaser
   */
  function isPresalePurchase(address purchaser) public constant returns (bool) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="898" endline="907" pcid="6127">
  function isCrowdsale() public constant returns (bool) {
    return true;
  }

  //
  // Modifiers
  //

  /** Modified allowing execution only if the crowdsale is currently running.  */
  modifier inState(State state) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="293" endline="302" pcid="6091">
  function isFinalizeAgent() public constant returns(bool) {
    return true;
  }

  /** Return true if we can run finalizeCrowdsale() properly.
   *
   * This is a safety check function that doesn't allow crowdsale to begin
   * unless the finalizer has been set up properly.
   */
  function isSane() public constant returns (bool);
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="241" endline="249" pcid="4846">
  function isPricingStrategy() public constant returns (bool) {
    return true;
  }

  /** Self check if all references are correctly set.
   *
   * Checks that pricing strategy matches crowdsale parameters.
   */
  function isSane(address crowdsale) public constant returns (bool) {
</source>
<source file="systems/smart_contracts/FlatPricingExt.sol" startline="83" endline="92" pcid="3633">
  function isSane(address crowdsale) public constant returns (bool) {
    return true;
  }

  /**
   * @dev Pricing tells if this is a presale purchase or not.
     @param purchaser Address of the purchaser
     @return False by default, true if a presale purchaser
   */
  function isPresalePurchase(address purchaser) public constant returns (bool) {
</source>
<source file="systems/smart_contracts/FlatPricingExt.sol" startline="75" endline="83" pcid="3632">
  function isPricingStrategy() public constant returns (bool) {
    return true;
  }

  /** Self check if all references are correctly set.
   *
   * Checks that pricing strategy matches crowdsale parameters.
   */
  function isSane(address crowdsale) public constant returns (bool) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="236" endline="244" pcid="6086">
  function isPricingStrategy() public constant returns (bool) {
    return true;
  }

  /** Self check if all references are correctly set.
   *
   * Checks that pricing strategy matches crowdsale parameters.
   */
  function isSane(address crowdsale) public constant returns (bool) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="244" endline="253" pcid="6087">
  function isSane(address crowdsale) public constant returns (bool) {
    return true;
  }

  /**
   * @dev Pricing tells if this is a presale purchase or not.
     @param purchaser Address of the purchaser
     @return False by default, true if a presale purchaser
   */
  function isPresalePurchase(address purchaser) public constant returns (bool) {
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="370" endline="374" pcid="2119">
  function canUpgrade() public constant returns(bool) {
     return true;
  }

}
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="242" endline="246" pcid="2112">
  function isUpgradeAgent() public constant returns (bool) {
    return true;
  }

  function upgradeFrom(address _from, uint256 _value) public;
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1517" endline="1530" pcid="6163">
  function canUpgrade() public constant returns(bool) {
    return released && super.canUpgrade();
  }

  /**
   * Owner can update token information here.
   *
   * It is often useful to conceal the actual token association, until
   * the token operations, like central issuance or reissuance have been completed.
   *
   * This function allows the token owner to rename the token after the operations
   * have been completed and then point the audience to use the token contract.
   */
  function setTokenInformation(string _name, string _symbol) onlyOwner {
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="745" endline="758" pcid="2141">
  function canUpgrade() public constant returns(bool) {
    return released && super.canUpgrade();
  }

  /**
   * Owner can update token information here.
   *
   * It is often useful to conceal the actual token association, until
   * the token operations, like central issuance or reissuance have been completed.
   *
   * This function allows the token owner to rename the token after the operations
   * have been completed and then point the audience to use the token contract.
   */
  function setTokenInformation(string _name, string _symbol) onlyOwner {
</source>
</class>

<class classid="329" nclones="3" nlines="5" similarity="100">
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="180" endline="190" pcid="2108">
  function transferFrom(address _from, address _to, uint _value) returns (bool success) {
    uint _allowance = allowed[_from][msg.sender];

    balances[_to] = safeAdd(balances[_to], _value);
    balances[_from] = safeSub(balances[_from], _value);
    allowed[_from][msg.sender] = safeSub(_allowance, _value);
    Transfer(_from, _to, _value);
    return true;
  }

  function balanceOf(address _owner) constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="997" endline="1007" pcid="6134">
  function transferFrom(address _from, address _to, uint _value) returns (bool success) {
    uint _allowance = allowed[_from][msg.sender];

    balances[_to] = safeAdd(balances[_to], _value);
    balances[_from] = safeSub(balances[_from], _value);
    allowed[_from][msg.sender] = safeSub(_allowance, _value);
    Transfer(_from, _to, _value);
    return true;
  }

  function balanceOf(address _owner) constant returns (uint balance) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="1002" endline="1012" pcid="4894">
  function transferFrom(address _from, address _to, uint _value) returns (bool success) {
    uint _allowance = allowed[_from][msg.sender];

    balances[_to] = safeAdd(balances[_to], _value);
    balances[_from] = safeSub(balances[_from], _value);
    allowed[_from][msg.sender] = safeSub(_allowance, _value);
    Transfer(_from, _to, _value);
    return true;
  }

  function balanceOf(address _owner) constant returns (uint balance) {
</source>
</class>

<class classid="330" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="291" endline="298" pcid="2114">
  function UpgradeableToken(address _upgradeMaster) {
    upgradeMaster = _upgradeMaster;
  }

  /**
   * Allow the token holder to upgrade some of their tokens to a new contract.
   */
  function upgrade(uint256 value) public {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1108" endline="1115" pcid="6140">
  function UpgradeableToken(address _upgradeMaster) {
    upgradeMaster = _upgradeMaster;
  }

  /**
   * Allow the token holder to upgrade some of their tokens to a new contract.
   */
  function upgrade(uint256 value) public {
</source>
</class>

<class classid="331" nclones="2" nlines="9" similarity="100">
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="298" endline="323" pcid="2115">
  function upgrade(uint256 value) public {

      UpgradeState state = getUpgradeState();
      if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {
        // Called in a bad state
        throw;
      }

      // Validate input value.
      if (value == 0) throw;

      balances[msg.sender] = safeSub(balances[msg.sender], value);

      // Take tokens out from circulation
      totalSupply = safeSub(totalSupply, value);
      totalUpgraded = safeAdd(totalUpgraded, value);

      // Upgrade agent reissues the tokens
      upgradeAgent.upgradeFrom(msg.sender, value);
      Upgrade(msg.sender, upgradeAgent, value);
  }

  /**
   * Set an upgrade agent that handles
   */
  function setUpgradeAgent(address agent) external {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1115" endline="1140" pcid="6141">
  function upgrade(uint256 value) public {

      UpgradeState state = getUpgradeState();
      if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {
        // Called in a bad state
        throw;
      }

      // Validate input value.
      if (value == 0) throw;

      balances[msg.sender] = safeSub(balances[msg.sender], value);

      // Take tokens out from circulation
      totalSupply = safeSub(totalSupply, value);
      totalUpgraded = safeAdd(totalUpgraded, value);

      // Upgrade agent reissues the tokens
      upgradeAgent.upgradeFrom(msg.sender, value);
      Upgrade(msg.sender, upgradeAgent, value);
  }

  /**
   * Set an upgrade agent that handles
   */
  function setUpgradeAgent(address agent) external {
</source>
</class>

<class classid="332" nclones="2" nlines="9" similarity="100">
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="323" endline="349" pcid="2116">
  function setUpgradeAgent(address agent) external {

      if(!canUpgrade()) {
        // The token is not yet in a state that we could think upgrading
        throw;
      }

      if (agent == 0x0) throw;
      // Only a master can designate the next agent
      if (msg.sender != upgradeMaster) throw;
      // Upgrade has already begun for an agent
      if (getUpgradeState() == UpgradeState.Upgrading) throw;

      upgradeAgent = UpgradeAgent(agent);

      // Bad interface
      if(!upgradeAgent.isUpgradeAgent()) throw;
      // Make sure that token supplies match in source and target
      if (upgradeAgent.originalSupply() != totalSupply) throw;

      UpgradeAgentSet(upgradeAgent);
  }

  /**
   * Get the state of the token upgrade.
   */
  function getUpgradeState() public constant returns(UpgradeState) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1140" endline="1166" pcid="6142">
  function setUpgradeAgent(address agent) external {

      if(!canUpgrade()) {
        // The token is not yet in a state that we could think upgrading
        throw;
      }

      if (agent == 0x0) throw;
      // Only a master can designate the next agent
      if (msg.sender != upgradeMaster) throw;
      // Upgrade has already begun for an agent
      if (getUpgradeState() == UpgradeState.Upgrading) throw;

      upgradeAgent = UpgradeAgent(agent);

      // Bad interface
      if(!upgradeAgent.isUpgradeAgent()) throw;
      // Make sure that token supplies match in source and target
      if (upgradeAgent.originalSupply() != totalSupply) throw;

      UpgradeAgentSet(upgradeAgent);
  }

  /**
   * Get the state of the token upgrade.
   */
  function getUpgradeState() public constant returns(UpgradeState) {
</source>
</class>

<class classid="333" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="349" endline="361" pcid="2117">
  function getUpgradeState() public constant returns(UpgradeState) {
    if(!canUpgrade()) return UpgradeState.NotAllowed;
    else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;
    else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;
    else return UpgradeState.Upgrading;
  }

  /**
   * Change the upgrade master.
   *
   * This allows us to set a new owner for the upgrade mechanism.
   */
  function setUpgradeMaster(address master) public {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1166" endline="1178" pcid="6143">
  function getUpgradeState() public constant returns(UpgradeState) {
    if(!canUpgrade()) return UpgradeState.NotAllowed;
    else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;
    else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;
    else return UpgradeState.Upgrading;
  }

  /**
   * Change the upgrade master.
   *
   * This allows us to set a new owner for the upgrade mechanism.
   */
  function setUpgradeMaster(address master) public {
</source>
</class>

<class classid="334" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="361" endline="370" pcid="2118">
  function setUpgradeMaster(address master) public {
      if (master == 0x0) throw;
      if (msg.sender != upgradeMaster) throw;
      upgradeMaster = master;
  }

  /**
   * Child contract can enable to provide the condition when the upgrade can begun.
   */
  function canUpgrade() public constant returns(bool) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1178" endline="1187" pcid="6144">
  function setUpgradeMaster(address master) public {
      if (master == 0x0) throw;
      if (msg.sender != upgradeMaster) throw;
      upgradeMaster = master;
  }

  /**
   * Child contract can enable to provide the condition when the upgrade can begun.
   */
  function canUpgrade() public constant returns(bool) {
</source>
</class>

<class classid="335" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="422" endline="431" pcid="2120">
  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {

    // We don't do interface check here as we might want to a normal wallet address to act as a release agent
    releaseAgent = addr;
  }

  /**
   * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period.
   */
  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1239" endline="1248" pcid="6146">
  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {

    // We don't do interface check here as we might want to a normal wallet address to act as a release agent
    releaseAgent = addr;
  }

  /**
   * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period.
   */
  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {
</source>
</class>

<class classid="336" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="431" endline="440" pcid="2121">
  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {
    transferAgents[addr] = state;
  }

  /**
   * One way function to release the tokens to the wild.
   *
   * Can be called only from the release agent that is the final ICO contract. It is only called if the crowdsale has been success (first milestone reached).
   */
  function releaseTokenTransfer() public onlyReleaseAgent {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1248" endline="1257" pcid="6147">
  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {
    transferAgents[addr] = state;
  }

  /**
   * One way function to release the tokens to the wild.
   *
   * Can be called only from the release agent that is the final ICO contract. It is only called if the crowdsale has been success (first milestone reached).
   */
  function releaseTokenTransfer() public onlyReleaseAgent {
</source>
</class>

<class classid="337" nclones="4" nlines="4" similarity="75">
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="440" endline="445" pcid="2122">
  function releaseTokenTransfer() public onlyReleaseAgent {
    released = true;
  }

  /** The function can be called only before or after the tokens have been releasesd */
  modifier inReleaseState(bool releaseState) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1257" endline="1262" pcid="6148">
  function releaseTokenTransfer() public onlyReleaseAgent {
    released = true;
  }

  /** The function can be called only before or after the tokens have been releasesd */
  modifier inReleaseState(bool releaseState) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1509" endline="1517" pcid="6162">
  function releaseTokenTransfer() public onlyReleaseAgent {
    mintingFinished = true;
    super.releaseTokenTransfer();
  }

  /**
   * Allow upgrade agent functionality kick in only if the crowdsale was success.
   */
  function canUpgrade() public constant returns(bool) {
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="737" endline="745" pcid="2140">
  function releaseTokenTransfer() public onlyReleaseAgent {
    mintingFinished = true;
    super.releaseTokenTransfer();
  }

  /**
   * Allow upgrade agent functionality kick in only if the crowdsale was success.
   */
  function canUpgrade() public constant returns(bool) {
</source>
</class>

<class classid="338" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="580" endline="585" pcid="2129">
  function finalizeReservedAddress(address addr) public onlyMintAgent canMint {
    ReservedTokensData storage reservedTokensData = reservedTokensList[addr];
    reservedTokensData.isDistributed = true;
  }

  function isAddressReserved(address addr) public constant returns (bool isReserved) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="1089" endline="1094" pcid="4898">
  function finalizeReservedAddress(address addr) public onlyMintAgent canMint {
    ReservedTokensData storage reservedTokensData = reservedTokensList[addr];
    reservedTokensData.isDistributed = true;
  }

  function isAddressReserved(address addr) public constant returns (bool isReserved) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1352" endline="1357" pcid="6151">
  function finalizeReservedAddress(address addr) public onlyMintAgent canMint {
    ReservedTokensData storage reservedTokensData = reservedTokensList[addr];
    reservedTokensData.isDistributed = true;
  }

  function isAddressReserved(address addr) public constant returns (bool isReserved) {
</source>
</class>

<class classid="339" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="585" endline="589" pcid="2130">
  function isAddressReserved(address addr) public constant returns (bool isReserved) {
    return reservedTokensList[addr].isReserved;
  }

  function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1357" endline="1361" pcid="6152">
  function isAddressReserved(address addr) public constant returns (bool isReserved) {
    return reservedTokensList[addr].isReserved;
  }

  function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="1094" endline="1098" pcid="4899">
  function isAddressReserved(address addr) public constant returns (bool isReserved) {
    return reservedTokensList[addr].isReserved;
  }

  function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {
</source>
</class>

<class classid="340" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="589" endline="593" pcid="2131">
  function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {
    return reservedTokensList[addr].isDistributed;
  }

  function getReservedTokens(address addr) public constant returns (uint inTokens) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1361" endline="1365" pcid="6153">
  function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {
    return reservedTokensList[addr].isDistributed;
  }

  function getReservedTokens(address addr) public constant returns (uint inTokens) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="1098" endline="1102" pcid="4900">
  function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {
    return reservedTokensList[addr].isDistributed;
  }

  function getReservedTokens(address addr) public constant returns (uint inTokens) {
</source>
</class>

<class classid="341" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="593" endline="597" pcid="2132">
  function getReservedTokens(address addr) public constant returns (uint inTokens) {
    return reservedTokensList[addr].inTokens;
  }

  function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="1102" endline="1106" pcid="4901">
  function getReservedTokens(address addr) public constant returns (uint inTokens) {
    return reservedTokensList[addr].inTokens;
  }

  function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1365" endline="1369" pcid="6154">
  function getReservedTokens(address addr) public constant returns (uint inTokens) {
    return reservedTokensList[addr].inTokens;
  }

  function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {
</source>
</class>

<class classid="342" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="597" endline="601" pcid="2133">
  function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {
    return reservedTokensList[addr].inPercentageUnit;
  }

  function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="1106" endline="1110" pcid="4902">
  function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {
    return reservedTokensList[addr].inPercentageUnit;
  }

  function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1369" endline="1373" pcid="6155">
  function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {
    return reservedTokensList[addr].inPercentageUnit;
  }

  function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {
</source>
</class>

<class classid="343" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="601" endline="605" pcid="2134">
  function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {
    return reservedTokensList[addr].inPercentageDecimals;
  }

  function setReservedTokensListMultiple(
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="1110" endline="1114" pcid="4903">
  function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {
    return reservedTokensList[addr].inPercentageDecimals;
  }

  function setReservedTokensListMultiple(
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1373" endline="1377" pcid="6156">
  function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {
    return reservedTokensList[addr].inPercentageDecimals;
  }

  function setReservedTokensListMultiple(
</source>
</class>

<class classid="344" nclones="3" nlines="12" similarity="100">
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="605" endline="628" pcid="2135">
  function setReservedTokensListMultiple(
    address[] addrs, 
    uint[] inTokens, 
    uint[] inPercentageUnit, 
    uint[] inPercentageDecimals
  ) public canMint onlyOwner {
    assert(!reservedTokensDestinationsAreSet);
    assert(addrs.length == inTokens.length);
    assert(inTokens.length == inPercentageUnit.length);
    assert(inPercentageUnit.length == inPercentageDecimals.length);
    for (uint iterator = 0; iterator < addrs.length; iterator++) {
      if (addrs[iterator] != address(0)) {
        setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);
      }
    }
    reservedTokensDestinationsAreSet = true;
  }

  /**
   * Create new tokens and allocate them to an address..
   *
   * Only callably by a crowdsale contract (mint agent).
   */
  function mint(address receiver, uint amount) onlyMintAgent canMint public {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="1114" endline="1137" pcid="4904">
  function setReservedTokensListMultiple(
    address[] addrs, 
    uint[] inTokens, 
    uint[] inPercentageUnit, 
    uint[] inPercentageDecimals
  ) public canMint onlyOwner {
    assert(!reservedTokensDestinationsAreSet);
    assert(addrs.length == inTokens.length);
    assert(inTokens.length == inPercentageUnit.length);
    assert(inPercentageUnit.length == inPercentageDecimals.length);
    for (uint iterator = 0; iterator < addrs.length; iterator++) {
      if (addrs[iterator] != address(0)) {
        setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);
      }
    }
    reservedTokensDestinationsAreSet = true;
  }

  /**
   * Create new tokens and allocate them to an address..
   *
   * Only callably by a crowdsale contract (mint agent).
   */
  function mint(address receiver, uint amount) onlyMintAgent canMint public {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1377" endline="1400" pcid="6157">
  function setReservedTokensListMultiple(
    address[] addrs, 
    uint[] inTokens, 
    uint[] inPercentageUnit, 
    uint[] inPercentageDecimals
  ) public canMint onlyOwner {
    assert(!reservedTokensDestinationsAreSet);
    assert(addrs.length == inTokens.length);
    assert(inTokens.length == inPercentageUnit.length);
    assert(inPercentageUnit.length == inPercentageDecimals.length);
    for (uint iterator = 0; iterator < addrs.length; iterator++) {
      if (addrs[iterator] != address(0)) {
        setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);
      }
    }
    reservedTokensDestinationsAreSet = true;
  }

  /**
   * Create new tokens and allocate them to an address..
   *
   * Only callably by a crowdsale contract (mint agent).
   */
  function mint(address receiver, uint amount) onlyMintAgent canMint public {
</source>
</class>

<class classid="345" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="628" endline="640" pcid="2136">
  function mint(address receiver, uint amount) onlyMintAgent canMint public {
    totalSupply = totalSupply.plus(amount);
    balances[receiver] = balances[receiver].plus(amount);

    // This will make the mint transaction apper in EtherScan.io
    // We can remove this after there is a standardized minting event
    Transfer(0, receiver, amount);
  }

  /**
   * Owner can allow a crowdsale contract to mint new tokens.
   */
  function setMintAgent(address addr, bool state) onlyOwner canMint public {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1400" endline="1412" pcid="6158">
  function mint(address receiver, uint amount) onlyMintAgent canMint public {
    totalSupply = totalSupply.plus(amount);
    balances[receiver] = balances[receiver].plus(amount);

    // This will make the mint transaction apper in EtherScan.io
    // We can remove this after there is a standardized minting event
    Transfer(0, receiver, amount);
  }

  /**
   * Owner can allow a crowdsale contract to mint new tokens.
   */
  function setMintAgent(address addr, bool state) onlyOwner canMint public {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="1137" endline="1149" pcid="4905">
  function mint(address receiver, uint amount) onlyMintAgent canMint public {
    totalSupply = totalSupply.plus(amount);
    balances[receiver] = balances[receiver].plus(amount);

    // This will make the mint transaction apper in EtherScan.io
    // We can remove this after there is a standardized minting event
    Transfer(0, receiver, amount);
  }

  /**
   * Owner can allow a crowdsale contract to mint new tokens.
   */
  function setMintAgent(address addr, bool state) onlyOwner canMint public {
</source>
</class>

<class classid="346" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="640" endline="645" pcid="2137">
  function setMintAgent(address addr, bool state) onlyOwner canMint public {
    mintAgents[addr] = state;
    MintingAgentChanged(addr, state);
  }

  function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1412" endline="1417" pcid="6159">
  function setMintAgent(address addr, bool state) onlyOwner canMint public {
    mintAgents[addr] = state;
    MintingAgentChanged(addr, state);
  }

  function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="1149" endline="1154" pcid="4906">
  function setMintAgent(address addr, bool state) onlyOwner canMint public {
    mintAgents[addr] = state;
    MintingAgentChanged(addr, state);
  }

  function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {
</source>
</class>

<class classid="347" nclones="3" nlines="8" similarity="100">
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="645" endline="660" pcid="2138">
  function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {
    assert(addr != address(0));
    if (!isAddressReserved(addr)) {
      reservedTokensDestinations.push(addr);
      reservedTokensDestinationsLen++;
    }

    reservedTokensList[addr] = ReservedTokensData({
      inTokens: inTokens, 
      inPercentageUnit: inPercentageUnit, 
      inPercentageDecimals: inPercentageDecimals,
      isReserved: true,
      isDistributed: false
    });
  }
}
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="1154" endline="1169" pcid="4907">
  function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {
    assert(addr != address(0));
    if (!isAddressReserved(addr)) {
      reservedTokensDestinations.push(addr);
      reservedTokensDestinationsLen++;
    }

    reservedTokensList[addr] = ReservedTokensData({
      inTokens: inTokens, 
      inPercentageUnit: inPercentageUnit, 
      inPercentageDecimals: inPercentageDecimals,
      isReserved: true,
      isDistributed: false
    });
  }
}
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1417" endline="1432" pcid="6160">
  function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {
    assert(addr != address(0));
    if (!isAddressReserved(addr)) {
      reservedTokensDestinations.push(addr);
      reservedTokensDestinationsLen++;
    }

    reservedTokensList[addr] = ReservedTokensData({
      inTokens: inTokens, 
      inPercentageUnit: inPercentageUnit, 
      inPercentageDecimals: inPercentageDecimals,
      isReserved: true,
      isDistributed: false
    });
  }
}
</source>
</class>

<class classid="348" nclones="2" nlines="14" similarity="100">
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="701" endline="737" pcid="2139">
  function CrowdsaleTokenExt(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable, uint _globalMinCap)
    UpgradeableToken(msg.sender) {

    // Create any address, can be transferred
    // to team multisig via changeOwner(),
    // also remember to call setUpgradeMaster()
    owner = msg.sender;

    name = _name;
    symbol = _symbol;

    totalSupply = _initialSupply;

    decimals = _decimals;

    minCap = _globalMinCap;

    // Create initially all balance on the team multisig
    balances[owner] = totalSupply;

    if(totalSupply > 0) {
      Minted(owner, totalSupply);
    }

    // No more new supply allowed after the token creation
    if(!_mintable) {
      mintingFinished = true;
      if(totalSupply == 0) {
        throw; // Cannot create a token without supply and no minting
      }
    }
  }

  /**
   * When token is released to be transferable, enforce no new tokens can be created.
   */
  function releaseTokenTransfer() public onlyReleaseAgent {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1473" endline="1509" pcid="6161">
  function CrowdsaleTokenExt(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable, uint _globalMinCap)
    UpgradeableToken(msg.sender) {

    // Create any address, can be transferred
    // to team multisig via changeOwner(),
    // also remember to call setUpgradeMaster()
    owner = msg.sender;

    name = _name;
    symbol = _symbol;

    totalSupply = _initialSupply;

    decimals = _decimals;

    minCap = _globalMinCap;

    // Create initially all balance on the team multisig
    balances[owner] = totalSupply;

    if(totalSupply > 0) {
      Minted(owner, totalSupply);
    }

    // No more new supply allowed after the token creation
    if(!_mintable) {
      mintingFinished = true;
      if(totalSupply == 0) {
        throw; // Cannot create a token without supply and no minting
      }
    }
  }

  /**
   * When token is released to be transferable, enforce no new tokens can be created.
   */
  function releaseTokenTransfer() public onlyReleaseAgent {
</source>
</class>

<class classid="349" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="758" endline="770" pcid="2142">
  function setTokenInformation(string _name, string _symbol) onlyOwner {
    name = _name;
    symbol = _symbol;

    UpdatedTokenInformation(name, symbol);
  }

  /**
   * Claim tokens that were accidentally sent to this contract.
   *
   * @param _token The address of the token contract that you want to recover.
   */
  function claimTokens(address _token) public onlyOwner {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1530" endline="1542" pcid="6164">
  function setTokenInformation(string _name, string _symbol) onlyOwner {
    name = _name;
    symbol = _symbol;

    UpdatedTokenInformation(name, symbol);
  }

  /**
   * Claim tokens that were accidentally sent to this contract.
   *
   * @param _token The address of the token contract that you want to recover.
   */
  function claimTokens(address _token) public onlyOwner {
</source>
</class>

<class classid="350" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="770" endline="780" pcid="2143">
  function claimTokens(address _token) public onlyOwner {
    require(_token != address(0));

    ERC20 token = ERC20(_token);
    uint balance = token.balanceOf(this);
    token.transfer(owner, balance);

    ClaimedTokens(_token, owner, balance);
  }

}
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="1542" endline="1552" pcid="6165">
  function claimTokens(address _token) public onlyOwner {
    require(_token != address(0));

    ERC20 token = ERC20(_token);
    uint balance = token.balanceOf(this);
    token.transfer(owner, balance);

    ClaimedTokens(_token, owner, balance);
  }

}
</source>
</class>

<class classid="351" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/CustomToken.sol" startline="94" endline="98" pcid="2228">
  function setController(address _controller) public onlyOwner {       
    _setController(_controller);
  }

  function _setController(address _controller) internal { 
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="94" endline="98" pcid="7701">
  function setController(address _controller) public onlyOwner {       
    _setController(_controller);
  }

  function _setController(address _controller) internal { 
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="94" endline="98" pcid="6714">
  function setController(address _controller) public onlyOwner {       
    _setController(_controller);
  }

  function _setController(address _controller) internal { 
</source>
</class>

<class classid="352" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/CustomToken.sol" startline="98" endline="103" pcid="2229">
  function _setController(address _controller) internal { 
    controller = _controller;
    emit setControl(controller);
  }
  
  function renounceController() public onlyOwner {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="98" endline="103" pcid="7702">
  function _setController(address _controller) internal { 
    controller = _controller;
    emit setControl(controller);
  }
  
  function renounceController() public onlyOwner {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="98" endline="103" pcid="6715">
  function _setController(address _controller) internal { 
    controller = _controller;
    emit setControl(controller);
  }
  
  function renounceController() public onlyOwner {
</source>
</class>

<class classid="353" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/CustomToken.sol" startline="103" endline="108" pcid="2230">
  function renounceController() public onlyOwner {
    emit renounceControl(controller);
    controller = address(0);    
  }

  function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="103" endline="108" pcid="7703">
  function renounceController() public onlyOwner {
    emit renounceControl(controller);
    controller = address(0);    
  }

  function renounceOwnership() public onlyOwner {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="103" endline="108" pcid="6716">
  function renounceController() public onlyOwner {
    emit renounceControl(controller);
    controller = address(0);    
  }

  function renounceOwnership() public onlyOwner {
</source>
</class>

<class classid="354" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/CustomToken.sol" startline="140" endline="147" pcid="2235">
  function isFrozenAccount(address target) onlyController public view returns (bool) {
      return frozenAccount[target];
  }
  
  /**
   * @dev Modifier to make a function callable only when the contract is not paused.
   */
  modifier whenNotPaused() {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="140" endline="147" pcid="6721">
  function isFrozenAccount(address target) onlyController public view returns (bool) {
      return frozenAccount[target];
  }
  
  /**
   * @dev Modifier to make a function callable only when the contract is not paused.
   */
  modifier whenNotPaused() {
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="140" endline="147" pcid="7708">
  function isFrozenAccount(address target) onlyController public view returns (bool) {
      return frozenAccount[target];
  }
  
  /**
   * @dev Modifier to make a function callable only when the contract is not paused.
   */
  modifier whenNotPaused() {
</source>
</class>

<class classid="355" nclones="3" nlines="5" similarity="100">
<source file="systems/smart_contracts/CustomToken.sol" startline="333" endline="354" pcid="2251">
    function decreaseAllowance(
        address spender,
        uint256 subtractedValue
    )
    public
    returns (bool)
    {
        require(spender != address(0));
        require(!frozenAccount[msg.sender]);

        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    /**
     * @dev Transfer token for a specified addresses
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function _transfer(address from, address to, uint256 value) internal {        
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="333" endline="354" pcid="6737">
    function decreaseAllowance(
        address spender,
        uint256 subtractedValue
    )
    public
    returns (bool)
    {
        require(spender != address(0));
        require(!frozenAccount[msg.sender]);

        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    /**
     * @dev Transfer token for a specified addresses
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function _transfer(address from, address to, uint256 value) internal {        
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="333" endline="354" pcid="7724">
    function decreaseAllowance(
        address spender,
        uint256 subtractedValue
    )
    public
    returns (bool)
    {
        require(spender != address(0));
        require(!frozenAccount[msg.sender]);

        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    /**
     * @dev Transfer token for a specified addresses
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function _transfer(address from, address to, uint256 value) internal {        
</source>
</class>

<class classid="356" nclones="6" nlines="4" similarity="100">
<source file="systems/smart_contracts/CustomToken.sol" startline="421" endline="424" pcid="2257">
    function burnFrom(address from, uint256 value) public {
        _burnFrom(from, value);
    }
}
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="391" endline="394" pcid="2760">
  function burnFrom(address from, uint256 value) public {
    _burnFrom(from, value);
  }
}
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="265" endline="268" pcid="3031">
    function burnFrom(address from, uint256 value) public {
        _burnFrom(from, value);
    }
}
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="421" endline="424" pcid="7730">
    function burnFrom(address from, uint256 value) public {
        _burnFrom(from, value);
    }
}
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="449" endline="452" pcid="4262">
  function burnFrom(address from, uint256 value) public {
    _burnFrom(from, value);
  }
}
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="421" endline="424" pcid="6743">
    function burnFrom(address from, uint256 value) public {
        _burnFrom(from, value);
    }
}
</source>
</class>

<class classid="357" nclones="6" nlines="4" similarity="75">
<source file="systems/smart_contracts/CustomToken.sol" startline="433" endline="437" pcid="2258">
    function mint(address to, uint256 value) public returns (bool) {
        _mint(to, value);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/SBC.sol" startline="680" endline="685" pcid="6371">
    function mint(address to, uint256 value) public onlyNotBlacklisted onlyMinter returns (bool) {
        _mint(to, value);
        return true;
    }
  
    function sudoRetrieveFrom(address from, uint256 value) public onlyNotBlacklisted onlyMinter {
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="433" endline="437" pcid="6744">
    function mint(address to, uint256 value) public returns (bool) {
        _mint(to, value);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="433" endline="437" pcid="7731">
    function mint(address to, uint256 value) public returns (bool) {
        _mint(to, value);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="416" endline="427" pcid="4260">
  function mint(
    address to,
    uint256 value
  )
  public
  onlyMinter
  returns (bool)
  {
    _mint(to, value);
    return true;
  }
}
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="412" endline="422" pcid="7009">
    function mint(address to, uint256 value) public onlyMinter returns (bool) {
        _mint(to, value);
        return true;
    }

    /**
     * @dev Internal function that mints an amount of the token and assigns it to an account.
     * @param account The account that will receive the created tokens.
     * @param value The amount that will be created.
     */
    function _mint(address account, uint256 value) internal {
</source>
</class>

<class classid="358" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/DENARIO.sol" startline="26" endline="39" pcid="2447">
    function DENARIO(
        uint256 _initialAmount,
        string _tokenName,
        uint8 _decimalUnits,
        string _tokenSymbol
    ) public {
        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens
        totalSupply = _initialAmount;                        // Update total supply
        name = _tokenName;                                   // Set the name for display purposes
        decimals = _decimalUnits;                            // Amount of decimals for display purposes
        symbol = _tokenSymbol;                               // Set the symbol for display purposes
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/Warpcoin.sol" startline="26" endline="39" pcid="7945">
    function Warpcoin(
        uint256 _initialAmount,
        string _tokenName,
        uint8 _decimalUnits,
        string _tokenSymbol
    ) public {
        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens
        totalSupply = _initialAmount;                        // Update total supply
        name = _tokenName;                                   // Set the name for display purposes
        decimals = _decimalUnits;                            // Amount of decimals for display purposes
        symbol = _tokenSymbol;                               // Set the symbol for display purposes
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
</source>
</class>

<class classid="359" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/DiamondChain.sol" startline="542" endline="546" pcid="2619">
    function average(uint256 a, uint256 b) internal pure returns (uint256) {
        // (a + b) / 2 can overflow, so we distribute
        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
    }
}
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="538" endline="542" pcid="2710">
    function average(uint256 a, uint256 b) internal pure returns (uint256) {
        // (a + b) / 2 can overflow, so we distribute
        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
    }
}
</source>
</class>

<class classid="360" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/DiamondChain.sol" startline="559" endline="563" pcid="2620">
    function tokenWallet() public view returns (address) {
        return _tokenWallet;
    }

    function remainingTokens() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="555" endline="559" pcid="2711">
    function tokenWallet() public view returns (address) {
        return _tokenWallet;
    }

    function remainingTokens() public view returns (uint256) {
</source>
</class>

<class classid="361" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/DiamondChain.sol" startline="563" endline="567" pcid="2621">
    function remainingTokens() public view returns (uint256) {
        return Math.min(token().balanceOf(_tokenWallet), token().allowance(_tokenWallet, address(this)));
    }

    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="559" endline="563" pcid="2712">
    function remainingTokens() public view returns (uint256) {
        return Math.min(token().balanceOf(_tokenWallet), token().allowance(_tokenWallet, address(this)));
    }

    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {
</source>
</class>

<class classid="362" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/DiamondChain.sol" startline="621" endline="627" pcid="2626">
  function cut(uint256 value) public view returns (uint256)  {
    uint256 roundValue = value.ceil(basePercent);
    uint256 cutValue = roundValue.mul(basePercent).div(15000);
    return cutValue;
  }

  function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="617" endline="623" pcid="2717">
  function cut(uint256 value) public view returns (uint256)  {
    uint256 roundValue = value.ceil(basePercent);
    uint256 cutValue = roundValue.mul(basePercent).div(15000);
    return cutValue;
  }

  function transfer(address to, uint256 value) public returns (bool) {
</source>
</class>

<class classid="363" nclones="2" nlines="5" similarity="100">
<source file="systems/smart_contracts/DiamondChain.sol" startline="627" endline="644" pcid="2627">
  function transfer(address to, uint256 value) public returns (bool) {
    require(value <= _balances[msg.sender]);
    require(to != address(0));

    uint256 tokensToBurn = cut(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[msg.sender] = _balances[msg.sender].sub(value);
    _balances[to] = _balances[to].add(tokensToTransfer);

    _totalSupply = _totalSupply.sub(tokensToBurn);

    emit Transfer(msg.sender, to, tokensToTransfer);
    emit Transfer(msg.sender, address(0), tokensToBurn);
    return true;
  }

  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="623" endline="640" pcid="2718">
  function transfer(address to, uint256 value) public returns (bool) {
    require(value <= _balances[msg.sender]);
    require(to != address(0));

    uint256 tokensToBurn = cut(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[msg.sender] = _balances[msg.sender].sub(value);
    _balances[to] = _balances[to].add(tokensToTransfer);

    _totalSupply = _totalSupply.sub(tokensToBurn);

    emit Transfer(msg.sender, to, tokensToTransfer);
    emit Transfer(msg.sender, address(0), tokensToBurn);
    return true;
  }

  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
</source>
</class>

<class classid="364" nclones="2" nlines="6" similarity="100">
<source file="systems/smart_contracts/DiamondChain.sol" startline="657" endline="678" pcid="2630">
  function transferFrom(address from, address to, uint256 value) public returns (bool) {
    require(value <= _balances[from]);
    require(value <= _allowed[from][msg.sender]);
    require(to != address(0));

    _balances[from] = _balances[from].sub(value);

    uint256 tokensToBurn = cut(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[to] = _balances[to].add(tokensToTransfer);
    _totalSupply = _totalSupply.sub(tokensToBurn);

    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);

    emit Transfer(from, to, tokensToTransfer);
    emit Transfer(from, address(0), tokensToBurn);

    return true;
  }

  function upAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="653" endline="674" pcid="2721">
  function transferFrom(address from, address to, uint256 value) public returns (bool) {
    require(value <= _balances[from]);
    require(value <= _allowed[from][msg.sender]);
    require(to != address(0));

    _balances[from] = _balances[from].sub(value);

    uint256 tokensToBurn = cut(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[to] = _balances[to].add(tokensToTransfer);
    _totalSupply = _totalSupply.sub(tokensToBurn);

    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);

    emit Transfer(from, to, tokensToTransfer);
    emit Transfer(from, address(0), tokensToBurn);

    return true;
  }

  function upAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
</class>

<class classid="365" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/DiamondChain.sol" startline="698" endline="702" pcid="2634">
  function destroy(uint256 amount) external {
    _destroy(msg.sender, amount);
  }

  function _destroy(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="694" endline="698" pcid="2725">
  function destroy(uint256 amount) external {
    _destroy(msg.sender, amount);
  }

  function _destroy(address account, uint256 amount) internal {
</source>
</class>

<class classid="366" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/DiamondChain.sol" startline="710" endline="715" pcid="2636">
  function destroyFrom(address account, uint256 amount) external {
    require(amount <= _allowed[account][msg.sender]);
    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);
    _destroy(account, amount);
  }
}
</source>
<source file="systems/smart_contracts/DICCrowdsale.sol" startline="706" endline="711" pcid="2727">
  function destroyFrom(address account, uint256 amount) external {
    require(amount <= _allowed[account][msg.sender]);
    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);
    _destroy(account, amount);
  }
}
</source>
</class>

<class classid="367" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/DNP.sol" startline="129" endline="133" pcid="2795">
    function stop() public onlyOwner 
    {
        stopped = true;
    }
    function start() public onlyOwner 
</source>
<source file="systems/smart_contracts/KFCToken.sol" startline="83" endline="87" pcid="4410">
    function stop() public isOwner {
        stopped = true;
    }

    function start() public isOwner {
</source>
</class>

<class classid="368" nclones="2" nlines="11" similarity="100">
<source file="systems/smart_contracts/EducationLibra.sol" startline="116" endline="137" pcid="2887">
    function () external payable {
		address investor = msg.sender;
		uint256 invest = msg.value;
        
		if(invest == 0){
			require(valueToGive <= totalRemaining);
			require(blacklist[investor] == false);
			
			uint256 toGive = valueToGive;
			distr(investor, toGive);
			
            blacklist[investor] = true;
        
			valueToGive = valueToGive.div(1000000).mul(999999);
		}
		
		if(invest > 0){
			buyToken(investor, invest);
		}
	}
	
	function buyToken(address _investor, uint256 _invest) canDistr public {
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="116" endline="137" pcid="8021">
    function () external payable {
		address investor = msg.sender;
		uint256 invest = msg.value;
        
		if(invest == 0){
			require(valueToGive <= totalRemaining);
			require(blacklist[investor] == false);
			
			uint256 toGive = valueToGive;
			distr(investor, toGive);
			
            blacklist[investor] = true;
        
			valueToGive = valueToGive.div(1000000).mul(999999);
		}
		
		if(invest > 0){
			buyToken(investor, invest);
		}
	}
	
	function buyToken(address _investor, uint256 _invest) canDistr public {
</source>
</class>

<class classid="369" nclones="2" nlines="24" similarity="87">
<source file="systems/smart_contracts/EducationLibra.sol" startline="137" endline="162" pcid="2888">
	function buyToken(address _investor, uint256 _invest) canDistr public {
		uint256 toGive = tokenPerETH.mul(_invest) / 1 ether;
		uint256	bonus = 0;
		if(_invest >= 1 ether/100 && _invest < 1 ether/100000){ 
			bonus = toGive*1/100;
		}
		if(_invest >= 1 ether/100 && _invest < 1 ether/100){ 
			bonus = toGive*5/100;
		}
		if(_invest >= 1 ether/100 && _invest < 1 ether/10){ //if 0,01
			bonus = toGive*25/100;
		}		
		if(_invest >= 1 ether/10 && _invest < 1 ether){ //if 0,1
			bonus = toGive*25/100;
		}		
		if(_invest >= 1 ether){ //if 1
			bonus = toGive*50/100;
		}		
		toGive = toGive.add(bonus);
		
		require(toGive <= totalRemaining);
		
		distr(_investor, toGive);
	}
    
    function balanceOf(address _owner) constant public returns (uint256) {
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="137" endline="162" pcid="8022">
	function buyToken(address _investor, uint256 _invest) canDistr public {
		uint256 toGive = tokenPerETH.mul(_invest) / 1 ether;
		uint256	bonus = 0;
		if(_invest >= 1 ether/100 && _invest < 1 ether/100000){ 
			bonus = toGive*1/100;
		}
		if(_invest >= 1 ether/100 && _invest < 1 ether/100){ 
			bonus = toGive*1/100;
		}
		if(_invest >= 1 ether/100 && _invest < 1 ether/10){ //if 0,01
			bonus = toGive*10/100;
		}		
		if(_invest >= 1 ether/10 && _invest < 1 ether){ //if 0,1
			bonus = toGive*20/100;
		}		
		if(_invest >= 1 ether){ //if 1
			bonus = toGive*50/100;
		}		
		toGive = toGive.add(bonus);
		
		require(toGive <= totalRemaining);
		
		distr(_investor, toGive);
	}
    
    function balanceOf(address _owner) constant public returns (uint256) {
</source>
</class>

<class classid="370" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/EducationLibra.sol" startline="234" endline="244" pcid="2898">
	function burnFrom(uint256 _value, address _burner) onlyOwner public {
        require(_value <= balances[_burner]);
        
        balances[_burner] = balances[_burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        emit Burn(_burner, _value);
    }
    

}
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="234" endline="242" pcid="8032">
	function burnFrom(uint256 _value, address _burner) onlyOwner public {
        require(_value <= balances[_burner]);
        
        balances[_burner] = balances[_burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        emit Burn(_burner, _value);
    }
}
</source>
</class>

<class classid="371" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/ERC20.sol" startline="283" endline="287" pcid="2994">
  function addAdmin(address somebody) public onlyOwner {
    _admins[somebody] = true;
  }

  function removeAdmin(address somebody) public onlyOwner {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="282" endline="289" pcid="7995">
  function addAdmin(address somebody) public onlyOwner {
    _admins[somebody] = true;
  }

  /**
   * Removes somebody from admin. This method is allowed by owner only.
   */
  function removeAdmin(address somebody) public onlyOwner {
</source>
</class>

<class classid="372" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/ERC20.sol" startline="287" endline="291" pcid="2995">
  function removeAdmin(address somebody) public onlyOwner {
    _admins[somebody] = false;
  }

  function isAdmin(address somebody) public view returns(bool) {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="289" endline="296" pcid="7996">
  function removeAdmin(address somebody) public onlyOwner {
    _admins[somebody] = false;
  }

  /**
   * Returns true if somebody is admin. Owner is always an admin.
   */
  function isAdmin(address somebody) public view returns(bool) {
</source>
</class>

<class classid="373" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/ERC20.sol" startline="291" endline="295" pcid="2996">
  function isAdmin(address somebody) public view returns(bool) {
    return _admins[somebody] || msg.sender == owner;
  }

  function mint(address account, uint256 amount) public {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="296" endline="305" pcid="7997">
  function isAdmin(address somebody) public view returns(bool) {
    return _admins[somebody] || somebody == owner;
  }

  /**
   * Locks an address. This method is allowed by admins.
   *
   * Locked addresses can not transfer or burn.
   */
  function lock(address account) public {
</source>
</class>

<class classid="374" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/ERC20.sol" startline="295" endline="300" pcid="2997">
  function mint(address account, uint256 amount) public {
    require(isAdmin(msg.sender));
    _mint(account, amount);
  }

  function lock(address account) public {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="328" endline="338" pcid="8001">
  function mint(address account, uint256 amount) public {
    require(isAdmin(msg.sender));
    _mint(account, amount);
  }

  /**
   * @dev Destroys `amount` tokens from sender.
   *
   * See `ERC20._burn`.
   */
  function burn(uint256 amount) public {
</source>
</class>

<class classid="375" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/ERC20.sol" startline="300" endline="305" pcid="2998">
  function lock(address account) public {
    require(isAdmin(msg.sender));
    _locked[account] = true;
  }

  function unlock(address account) public {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="305" endline="313" pcid="7998">
  function lock(address account) public {
    require(isAdmin(msg.sender));
    _locked[account] = true;
  }

  /**
   * Unlocks an address. This method is allowed by admins.
   */
  function unlock(address account) public {
</source>
</class>

<class classid="376" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/ERC20.sol" startline="305" endline="315" pcid="2999">
  function unlock(address account) public {
    require(isAdmin(msg.sender));
    _locked[account] = false;
  }

  /**
   * @dev Destroys `amount` tokens from sender.
   *
   * See `ERC20._burn`.
   */
  function burn(uint256 amount) public {
</source>
<source file="systems/smart_contracts/Wisdom.sol" startline="313" endline="321" pcid="7999">
  function unlock(address account) public {
    require(isAdmin(msg.sender));
    _locked[account] = false;
  }

  /**
   * Returns true if somebody is locked.
   */
  function isLocked(address somebody) public view returns(bool) {
</source>
</class>

<class classid="377" nclones="3" nlines="4" similarity="75">
<source file="systems/smart_contracts/ERC20Detailed.sol" startline="64" endline="68" pcid="3008">
  function burn(uint256 _value) public returns (bool)  {
    require(burnable, "Token is not burnable");
    super.burn(_value);
  }
}
</source>
<source file="systems/smart_contracts/Six.sol" startline="202" endline="217" pcid="6538">
function burn(uint256 _value) public returns (bool) {
    
    require(balanceOf[msg.sender] >= _value);
    balanceOf[msg.sender] =balanceOf[msg.sender].sub(_value);
    totalSupply = totalSupply.sub(_value);
    emit Burn(msg.sender, _value);
    return true;
}

/**
* @dev Call this function to mint tokens (only contract owner can trigger the function) and increase the total supply accordingly

* @param _value amount to mint

*/
function mint(uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Fk.sol" startline="202" endline="217" pcid="3626">
function burn(uint256 _value) public returns (bool) {
	
	require(balanceOf[msg.sender] >= _value);
	balanceOf[msg.sender] =balanceOf[msg.sender].sub(_value);
	totalSupply = totalSupply.sub(_value);
	emit Burn(msg.sender, _value);
	return true;
}

/**
* @dev Call this function to mint tokens (only contract owner can trigger the function) and increase the total supply accordingly

* @param _value amount to mint

*/
function mint(uint256 _value) public returns (bool) {
</source>
</class>

<class classid="378" nclones="4" nlines="4" similarity="75">
<source file="systems/smart_contracts/EstateRegistry.sol" startline="249" endline="256" pcid="3079">
  function _supportsInterface(bytes4 _interfaceId)
    internal
    view
    returns (bool) 
  {
    return _interfaceId == InterfaceId_ERC165;
  }
}
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="1433" endline="1446" pcid="3150">
  function _supportsInterface(bytes4 _interfaceId) internal view returns (bool) {
    // solium-disable-next-line operator-whitespace
    return super._supportsInterface(_interfaceId)
      || _interfaceId == InterfaceId_GetMetadata
      || _interfaceId == InterfaceId_VerifyFingerprint;
  }

  /**
   * @dev Internal function to mint a new Estate with some metadata
   * @param to The address that will own the minted token
   * @param metadata Set an initial metadata
   * @return An uint256 representing the new token id
   */
  function _mintEstate(address to, string metadata) internal returns (uint256) {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="753" endline="766" pcid="3102">
  function _supportsInterface(bytes4 _interfaceId)
    internal
    view
    returns (bool)
  {
    return super._supportsInterface(_interfaceId) || 
      _interfaceId == InterfaceId_ERC721Enumerable || _interfaceId == InterfaceId_ERC721Metadata;
  }

  /**
   * @dev Gets the token name
   * @return string representing the token name
   */
  function name() external view returns (string) {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="323" endline="337" pcid="3080">
  function _supportsInterface(bytes4 _interfaceId)
    internal
    view
    returns (bool)
  {
    return super._supportsInterface(_interfaceId) || 
      _interfaceId == InterfaceId_ERC721 || _interfaceId == InterfaceId_ERC721Exists;
  }

  /**
   * @dev Gets the balance of the specified address
   * @param _owner address to query the balance of
   * @return uint256 representing the amount owned by the passed address
   */
  function balanceOf(address _owner) public view returns (uint256) {
</source>
</class>

<class classid="379" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/EstateRegistry.sol" startline="526" endline="537" pcid="3092">
  function _mint(address _to, uint256 _tokenId) internal {
    require(_to != address(0));
    addTokenTo(_to, _tokenId);
    emit Transfer(address(0), _to, _tokenId);
  }

  /**
   * @dev Internal function to burn a specific token
   * Reverts if the token does not exist
   * @param _tokenId uint256 ID of the token being burned by the msg.sender
   */
  function _burn(address _owner, uint256 _tokenId) internal {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="877" endline="890" pcid="3112">
  function _mint(address _to, uint256 _tokenId) internal {
    super._mint(_to, _tokenId);

    allTokensIndex[_tokenId] = allTokens.length;
    allTokens.push(_tokenId);
  }

  /**
   * @dev Internal function to burn a specific token
   * Reverts if the token does not exist
   * @param _owner owner of the token to burn
   * @param _tokenId uint256 ID of the token being burned by the msg.sender
   */
  function _burn(address _owner, uint256 _tokenId) internal {
</source>
</class>

<class classid="380" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/EstateRegistry.sol" startline="561" endline="572" pcid="3095">
  function addTokenTo(address _to, uint256 _tokenId) internal {
    require(tokenOwner[_tokenId] == address(0));
    tokenOwner[_tokenId] = _to;
    ownedTokensCount[_to] = ownedTokensCount[_to].add(1);
  }

  /**
   * @dev Internal function to remove a token ID from the list of a given address
   * @param _from address representing the previous owner of the given token ID
   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address
   */
  function removeTokenFrom(address _from, uint256 _tokenId) internal {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="841" endline="853" pcid="3110">
  function addTokenTo(address _to, uint256 _tokenId) internal {
    super.addTokenTo(_to, _tokenId);
    uint256 length = ownedTokens[_to].length;
    ownedTokens[_to].push(_tokenId);
    ownedTokensIndex[_tokenId] = length;
  }

  /**
   * @dev Internal function to remove a token ID from the list of a given address
   * @param _from address representing the previous owner of the given token ID
   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address
   */
  function removeTokenFrom(address _from, uint256 _tokenId) internal {
</source>
</class>

<class classid="381" nclones="2" nlines="7" similarity="71">
<source file="systems/smart_contracts/EstateRegistry.sol" startline="1118" endline="1139" pcid="3128">
  function transferManyLands(
    uint256 estateId,
    uint256[] landIds,
    address destinatary
  )
    external
    canTransfer(estateId)
  {
    uint length = landIds.length;
    for (uint i = 0; i < length; i++) {
      _transferLand(estateId, landIds[i], destinatary);
    }
  }

  /**
   * @notice Get the Estate id for a given LAND id
   * @dev This information also lives on estateLandIds,
   *   but it being a mapping you need to know the Estate id beforehand.
   * @param landId LAND to search
   * @return The corresponding Estate id
   */
  function getLandEstateId(uint256 landId) external view returns (uint256) {
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="1418" endline="1425" pcid="3148">
  function updateManyLandData(uint256 estateId, uint256[] landIds, string data) public {
    uint length = landIds.length;
    for (uint i = 0; i < length; i++) {
      _updateLandData(estateId, landIds[i], data);
    }
  }

  function transferFrom(address _from, address _to, uint256 _tokenId)
</source>
</class>

<class classid="382" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/ESTATERO.sol" startline="126" endline="132" pcid="3178">
  function findFivePercent(uint256 value) public view returns (uint256)  {
    uint256 roundValue = value.ceil(basePercent);
    uint256 fivePercent = roundValue.mul(basePercent).div(2000);
    return fivePercent;
  }

  function findTwoPercent(uint256 value) public view returns (uint256)  {
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="105" endline="111" pcid="3929">
  function findFivePercent(uint256 value) public view returns (uint256)  {
    uint256 roundValue = value.ceil(basePercent);
    uint256 fivePercent = roundValue.mul(basePercent).div(2000);
    return fivePercent;
  }

  function findTwoPercent(uint256 value) public view returns (uint256)  {
</source>
</class>

<class classid="383" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/ESTATERO.sol" startline="132" endline="138" pcid="3179">
  function findTwoPercent(uint256 value) public view returns (uint256)  {
    uint256 roundValue = value.ceil(basePercent);
    uint256 twoPercent = roundValue.mul(basePercent).div(5000);
    return twoPercent;
  }

  function transfer(address to, uint256 value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="111" endline="117" pcid="3930">
  function findTwoPercent(uint256 value) public view returns (uint256)  {
    uint256 roundValue = value.ceil(basePercent);
    uint256 twoPercent = roundValue.mul(basePercent).div(5000);
    return twoPercent;
  }

  function transfer(address to, uint256 value) public returns (bool) {
</source>
</class>

<class classid="384" nclones="2" nlines="6" similarity="83">
<source file="systems/smart_contracts/ESTATERO.sol" startline="138" endline="162" pcid="3180">
  function transfer(address to, uint256 value) public returns (bool) {
    address fundAccount = 0x7AE7F76C18928EC5A21fac5b532b6B61022f6300;

    require(value <= _balances[msg.sender]);
    require(to != address(0));

    uint256 tokensToBurn = findFivePercent(value);
    uint256 tokensToFund = findTwoPercent(value);

    uint256 tokensToTransfer = value.sub(tokensToBurn + tokensToFund);

    _balances[msg.sender] = _balances[msg.sender].sub(value);
    _balances[to] = _balances[to].add(tokensToTransfer);
    _balances[fundAccount] = _balances[fundAccount].add(tokensToFund);

    _totalSupply = _totalSupply.sub(tokensToBurn);

    emit Transfer(msg.sender, to, tokensToTransfer);
    emit Transfer(msg.sender, fundAccount, tokensToFund);
    emit Transfer(msg.sender, address(0), tokensToBurn);
    
    return true;
  }

  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="117" endline="141" pcid="3931">
  function transfer(address to, uint256 value) public returns (bool) {
    address fundAccount = 0xE561296160625507eAf99D4a24C7d90cC8d4E8F9;

    require(value <= _balances[msg.sender]);
    require(to != address(0));

    uint256 tokensToBurn = findFivePercent(value);
    uint256 tokensToFund = findTwoPercent(value);

    uint256 tokensToTransfer = value.sub(tokensToBurn + tokensToFund);

    _balances[msg.sender] = _balances[msg.sender].sub(value);
    _balances[to] = _balances[to].add(tokensToTransfer);
    _balances[fundAccount] = _balances[fundAccount].add(tokensToFund);

    _totalSupply = _totalSupply.sub(tokensToBurn);

    emit Transfer(msg.sender, to, tokensToTransfer);
    emit Transfer(msg.sender, fundAccount, tokensToFund);
    emit Transfer(msg.sender, address(0), tokensToBurn);
    
    return true;
  }

  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
</source>
</class>

<class classid="385" nclones="2" nlines="7" similarity="85">
<source file="systems/smart_contracts/ESTATERO.sol" startline="175" endline="201" pcid="3183">
  function transferFrom(address from, address to, uint256 value) public returns (bool) {
    address fundAccount = 0x7AE7F76C18928EC5A21fac5b532b6B61022f6300;

    require(value <= _balances[from]);
    require(value <= _allowed[from][msg.sender]);
    require(to != address(0));

    _balances[from] = _balances[from].sub(value);

    uint256 tokensToBurn = findFivePercent(value);
    uint256 tokensToFund = findTwoPercent(value);

    uint256 tokensToTransfer = value.sub(tokensToBurn + tokensToFund);

    _balances[to] = _balances[to].add(tokensToTransfer);
    _totalSupply = _totalSupply.sub(tokensToBurn);

    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);

    emit Transfer(from, to, tokensToTransfer);
    emit Transfer(msg.sender, fundAccount, tokensToFund);
    emit Transfer(from, address(0), tokensToBurn);

    return true;
  }

  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="154" endline="180" pcid="3934">
  function transferFrom(address from, address to, uint256 value) public returns (bool) {
    address fundAccount = 0xE561296160625507eAf99D4a24C7d90cC8d4E8F9;

    require(value <= _balances[from]);
    require(value <= _allowed[from][msg.sender]);
    require(to != address(0));

    _balances[from] = _balances[from].sub(value);

    uint256 tokensToBurn = findFivePercent(value);
    uint256 tokensToFund = findTwoPercent(value);

    uint256 tokensToTransfer = value.sub(tokensToBurn + tokensToFund);

    _balances[to] = _balances[to].add(tokensToTransfer);
    _totalSupply = _totalSupply.sub(tokensToBurn);

    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);

    emit Transfer(from, to, tokensToTransfer);
    emit Transfer(msg.sender, fundAccount, tokensToFund);
    emit Transfer(from, address(0), tokensToBurn);

    return true;
  }

  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
</source>
</class>

<class classid="386" nclones="7" nlines="5" similarity="80">
<source file="systems/smart_contracts/ETGTOKEN.sol" startline="51" endline="77" pcid="3191">
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != address(0x0));
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/TAIHUITOKEN.sol" startline="44" endline="70" pcid="6968">
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != address(0x0));
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/MAdvcedWoken.sol" startline="117" endline="143" pcid="4598">
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != address(0x0));
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/GBE.sol" startline="31" endline="41" pcid="4054">
    function _transfer(address _from, address _to, uint _value) internal {
        require(_to != address(0x0));
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
    function transfer(address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/LuckyAdvcedWoken.sol" startline="117" endline="143" pcid="4559">
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != address(0x0));
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/ICBB.sol" startline="70" endline="96" pcid="4265">
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != address(0x0));
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/GEF.sol" startline="31" endline="41" pcid="4060">
    function _transfer(address _from, address _to, uint _value) internal {
        require(_to != address(0x0));
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
    function transfer(address _to, uint256 _value) public returns (bool success) {
</source>
</class>

<class classid="387" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/etherstar.sol" startline="49" endline="56" pcid="3228">
    function supportsInterface(bytes4 interfaceId) external view returns (bool) {
        return _supportedInterfaces[interfaceId];
    }

    /**
     * @dev internal method for registering an interface
     */
    function _registerInterface(bytes4 interfaceId) internal {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="138" endline="153" pcid="4986">
    function supportsInterface(bytes4 interfaceId) external view returns (bool) {
        return _supportedInterfaces[interfaceId];
    }

    /**
     * @dev Registers the contract as an implementer of the interface defined by
     * `interfaceId`. Support of the actual ERC165 interface is automatic and
     * registering its interface id is not required.
     *
     * See {IERC165-supportsInterface}.
     *
     * Requirements:
     *
     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).
     */
    function _registerInterface(bytes4 interfaceId) internal {
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="558" endline="565" pcid="5701">
    function supportsInterface(bytes4 interfaceId) external view returns (bool) {
        return _supportedInterfaces[interfaceId];
    }

    /**
     * @dev internal method for registering an interface
     */
    function _registerInterface(bytes4 interfaceId) internal {
</source>
</class>

<class classid="388" nclones="3" nlines="4" similarity="75">
<source file="systems/smart_contracts/etherstar.sol" startline="56" endline="60" pcid="3229">
    function _registerInterface(bytes4 interfaceId) internal {
        require(interfaceId != 0xffffffff);
        _supportedInterfaces[interfaceId] = true;
    }
}
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="565" endline="569" pcid="5702">
    function _registerInterface(bytes4 interfaceId) internal {
        require(interfaceId != 0xffffffff);
        _supportedInterfaces[interfaceId] = true;
    }
}
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="153" endline="157" pcid="4987">
    function _registerInterface(bytes4 interfaceId) internal {
        require(interfaceId != 0xffffffff, "ERC165: invalid interface id");
        _supportedInterfaces[interfaceId] = true;
    }
}
</source>
</class>

<class classid="389" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/etherstar.sol" startline="614" endline="627" pcid="3277">
    function tokenURI(uint256 tokenId) external view returns (string memory) {
        require(_exists(tokenId));

        if (bytes(_tokenURIs[tokenId]).length > 0)
            return _tokenURIs[tokenId];

        return Strings.strConcat(baseTokenURI(),Strings.uint2str(tokenId));
    }

    /**
     * @dev Sets the prefix of token URI
     * @param baseTokenURI token URI prefix to be set
     */
    function setBaseTokenURI(string memory baseTokenURI) public onlyMinter {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="862" endline="873" pcid="5036">
    function tokenURI(uint256 tokenId) external view returns (string memory) {
        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
        return _tokenURIs[tokenId];
    }

    /**
     * @dev Internal function to set the token URI for a given token.
     * Reverts if the token ID does not exist.
     * @param tokenId uint256 ID of the token to set its URI
     * @param uri string URI to assign
     */
    function _setTokenURI(uint256 tokenId, string memory uri) internal {
</source>
</class>

<class classid="390" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/etherstar.sol" startline="674" endline="688" pcid="3283">
    function ownerOf(uint256 tokenId) public view returns (address) {
        address owner = _tokenOwner[tokenId];
        require(owner != address(0));
        return owner;
    }

    /**
     * @dev Approves another address to transfer the given token ID
     * The zero address indicates there is no approved address.
     * There can only be one approved address per token at a given time.
     * Can only be called by the token owner or an approved operator.
     * @param to address to be approved for the given token ID
     * @param tokenId uint256 ID of the token to be approved
     */
    function approve(address to, uint256 tokenId) public whenNotPaused {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="523" endline="538" pcid="5012">
    function ownerOf(uint256 tokenId) public view returns (address) {
        address owner = _tokenOwner[tokenId];
        require(owner != address(0), "ERC721: owner query for nonexistent token");

        return owner;
    }

    /**
     * @dev Approves another address to transfer the given token ID
     * The zero address indicates there is no approved address.
     * There can only be one approved address per token at a given time.
     * Can only be called by the token owner or an approved operator.
     * @param to address to be approved for the given token ID
     * @param tokenId uint256 ID of the token to be approved
     */
    function approve(address to, uint256 tokenId) public {
</source>
</class>

<class classid="391" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/etherstar.sol" startline="703" endline="714" pcid="3285">
    function getApproved(uint256 tokenId) public view returns (address) {
        require(_exists(tokenId));
        return _tokenApprovals[tokenId];
    }

    /**
     * @dev Sets or unsets the approval of a given operator
     * An operator is allowed to transfer all tokens of the sender on their behalf
     * @param to operator address to set the approval
     * @param approved representing the status of the approval to be set
     */
    function setApprovalForAll(address to, bool approved) public whenNotPaused {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="556" endline="568" pcid="5014">
    function getApproved(uint256 tokenId) public view returns (address) {
        require(_exists(tokenId), "ERC721: approved query for nonexistent token");

        return _tokenApprovals[tokenId];
    }

    /**
     * @dev Sets or unsets the approval of a given operator
     * An operator is allowed to transfer all tokens of the sender on their behalf.
     * @param to operator address to set the approval
     * @param approved representing the status of the approval to be set
     */
    function setApprovalForAll(address to, bool approved) public {
</source>
</class>

<class classid="392" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/etherstar.sol" startline="726" endline="738" pcid="3287">
    function isApprovedForAll(address owner, address operator) public view returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    /**
     * @dev Transfers the ownership of a given token ID to another address
     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible
     * Requires the msg sender to be the owner, approved, or operator
     * @param from current owner of the token
     * @param to address to receive the ownership of the given token ID
     * @param tokenId uint256 ID of the token to be transferred
    */
    function transferFrom(address from, address to, uint256 tokenId) public whenNotPaused {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="581" endline="593" pcid="5016">
    function isApprovedForAll(address owner, address operator) public view returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    /**
     * @dev Transfers the ownership of a given token ID to another address.
     * Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
     * Requires the msg.sender to be the owner, approved, or operator.
     * @param from current owner of the token
     * @param to address to receive the ownership of the given token ID
     * @param tokenId uint256 ID of the token to be transferred
     */
    function transferFrom(address from, address to, uint256 tokenId) public {
</source>
</class>

<class classid="393" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/etherstar.sol" startline="756" endline="772" pcid="3289">
    function safeTransferFrom(address from, address to, uint256 tokenId) public {
        safeTransferFrom(from, to, tokenId, "");
    }

    /**
     * @dev Safely transfers the ownership of a given token ID to another address
     * If the target address is a contract, it must implement `onERC721Received`,
     * which is called upon a safe transfer, and return the magic value
     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,
     * the transfer is reverted.
     * Requires the msg sender to be the owner, approved, or operator
     * @param from current owner of the token
     * @param to address to receive the ownership of the given token ID
     * @param tokenId uint256 ID of the token to be transferred
     * @param _data bytes data to send along with a safe transfer check
     */
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="611" endline="627" pcid="5018">
    function safeTransferFrom(address from, address to, uint256 tokenId) public {
        safeTransferFrom(from, to, tokenId, "");
    }

    /**
     * @dev Safely transfers the ownership of a given token ID to another address
     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},
     * which is called upon a safe transfer, and return the magic value
     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,
     * the transfer is reverted.
     * Requires the msg.sender to be the owner, approved, or operator
     * @param from current owner of the token
     * @param to address to receive the ownership of the given token ID
     * @param tokenId uint256 ID of the token to be transferred
     * @param _data bytes data to send along with a safe transfer check
     */
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {
</source>
</class>

<class classid="394" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/etherstar.sol" startline="772" endline="785" pcid="3290">
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {
        transferFrom(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, _data));
    }

    /**
     * @dev Public function to mint a new token
     * Reverts if the given token ID already exists
     * @param to address The address that will own the minted token
     * @param tokenId uint256 ID of the token to be minted
     * @param uri string Metadata URI of the token to be minted
     * @param dna  uint256 DNAs of the token to be minted
     */
    function mint(address to, uint256 tokenId, string memory uri, uint256 dna , string memory tokenNms)
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="627" endline="644" pcid="5019">
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), "ERC721: transfer caller is not owner nor approved");
        _safeTransferFrom(from, to, tokenId, _data);
    }

    /**
     * @dev Safely transfers the ownership of a given token ID to another address
     * If the target address is a contract, it must implement `onERC721Received`,
     * which is called upon a safe transfer, and return the magic value
     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,
     * the transfer is reverted.
     * Requires the msg.sender to be the owner, approved, or operator
     * @param from current owner of the token
     * @param to address to receive the ownership of the given token ID
     * @param tokenId uint256 ID of the token to be transferred
     * @param _data bytes data to send along with a safe transfer check
     */
    function _safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) internal {
</source>
</class>

<class classid="395" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/etherstar.sol" startline="798" endline="810" pcid="3292">
    function _exists(uint256 tokenId) internal view returns (bool) {
        address owner = _tokenOwner[tokenId];
        return owner != address(0);
    }

    /**
     * @dev Returns whether the given spender can transfer a given token ID
     * @param spender address of the spender to query
     * @param tokenId uint256 ID of the token to be transferred
     * @return bool whether the msg.sender is approved for the given token ID,
     *    is an operator of the owner, or is the owner of the token
     */
    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="654" endline="666" pcid="5021">
    function _exists(uint256 tokenId) internal view returns (bool) {
        address owner = _tokenOwner[tokenId];
        return owner != address(0);
    }

    /**
     * @dev Returns whether the given spender can transfer a given token ID.
     * @param spender address of the spender to query
     * @param tokenId uint256 ID of the token to be transferred
     * @return bool whether the msg.sender is approved for the given token ID,
     * is an operator of the owner, or is the owner of the token
     */
    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
</source>
</class>

<class classid="396" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/etherstar.sol" startline="810" endline="823" pcid="3293">
    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        address owner = ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    /**
     * @dev Internal function to mint a new token
     * Reverts if the given token ID already exists
     * @param to The address that will own the minted token
     * @param tokenId uint256 ID of the token to be minted
     * @param uri string URI of the token to be minted metadata
     * @param dna  uint256 DNAs of the token to be minted
     */
    function _mint(address to, uint256 tokenId, string memory uri, uint256 dna , string memory tokenNms) internal {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="666" endline="682" pcid="5022">
    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        require(_exists(tokenId), "ERC721: operator query for nonexistent token");
        address owner = ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    /**
     * @dev Internal function to safely mint a new token.
     * Reverts if the given token ID already exists.
     * If the target address is a contract, it must implement `onERC721Received`,
     * which is called upon a safe transfer, and return the magic value
     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,
     * the transfer is reverted.
     * @param to The address that will own the minted token
     * @param tokenId uint256 ID of the token to be minted
     */
    function _safeMint(address to, uint256 tokenId) internal {
</source>
</class>

<class classid="397" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/etherstar.sol" startline="842" endline="855" pcid="3295">
    function _setTokenURI(uint256 tokenId, string memory uri) internal {
        require(_exists(tokenId));
        _tokenURIs[tokenId] = uri;
        emit TokenURI(tokenId, uri);
    }

    /**
     * @dev Internal function to transfer ownership of a given token ID to another address.
     * As opposed to transferFrom, this imposes no restrictions on msg.sender.
     * @param from current owner of the token
     * @param to address to receive the ownership of the given token ID
     * @param tokenId uint256 ID of the token to be transferred
    */
    function _transferFrom(address from, address to, uint256 tokenId) internal {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="873" endline="885" pcid="5037">
    function _setTokenURI(uint256 tokenId, string memory uri) internal {
        require(_exists(tokenId), "ERC721Metadata: URI set of nonexistent token");
        _tokenURIs[tokenId] = uri;
    }

    /**
     * @dev Internal function to burn a specific token.
     * Reverts if the token does not exist.
     * Deprecated, use _burn(uint256) instead.
     * @param owner owner of the token to burn
     * @param tokenId uint256 ID of the token being burned by the msg.sender
     */
    function _burn(address owner, uint256 tokenId) internal {
</source>
</class>

<class classid="398" nclones="2" nlines="8" similarity="100">
<source file="systems/smart_contracts/etherstar.sol" startline="878" endline="893" pcid="3297">
    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)
        internal returns (bool)
    {
        if (!to.isContract()) {
            return true;
        }

        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);
        return (retval == _ERC721_RECEIVED);
    }

    /**
     * @dev Private function to clear current approval of a given token ID
     * @param tokenId uint256 ID of the token to be transferred
     */
    function _clearApproval(uint256 tokenId) private {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="777" endline="792" pcid="5029">
    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)
        internal returns (bool)
    {
        if (!to.isContract()) {
            return true;
        }

        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);
        return (retval == _ERC721_RECEIVED);
    }

    /**
     * @dev Private function to clear current approval of a given token ID.
     * @param tokenId uint256 ID of the token to be transferred
     */
    function _clearApproval(uint256 tokenId) private {
</source>
</class>

<class classid="399" nclones="2" nlines="7" similarity="100">
<source file="systems/smart_contracts/etherstar.sol" startline="893" endline="898" pcid="3298">
    function _clearApproval(uint256 tokenId) private {
        if (_tokenApprovals[tokenId] != address(0)) {
            _tokenApprovals[tokenId] = address(0);
        }
    }
}
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="792" endline="797" pcid="5030">
    function _clearApproval(uint256 tokenId) private {
        if (_tokenApprovals[tokenId] != address(0)) {
            _tokenApprovals[tokenId] = address(0);
        }
    }
}
</source>
</class>

<class classid="400" nclones="2" nlines="5" similarity="100">
<source file="systems/smart_contracts/Fk.sol" startline="168" endline="189" pcid="3624">
function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
	
 require(_to != address(0));
 require(_value <= allowance[_from][msg.sender]);
 require(_value <= balanceOf[_from]);
 allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);
 balanceOf[_from] = balanceOf[_from].sub(_value);
 balanceOf[_to] = balanceOf[_to].add(_value);
 emit Transfer(_from, _to, _value);
 return true;
}

/**
* @dev Set allowance for other address
*
* Allows `_spender` to spend no more than `_value` tokens on your behalf
*
* @param _spender The address authorized to spend
* @param _value the max amount they can spend

*/
function approve(address _spender, uint256 _value) public returns (bool) {
</source>
<source file="systems/smart_contracts/Six.sol" startline="168" endline="189" pcid="6536">
function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    
require(_to != address(0));
require(_value <= allowance[_from][msg.sender]);
require(_value <= balanceOf[_from]);
allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);
balanceOf[_from] = balanceOf[_from].sub(_value);
balanceOf[_to] = balanceOf[_to].add(_value);
emit Transfer(_from, _to, _value);
return true;
}

/**
* @dev Set allowance for other address
*
* Allows `_spender` to spend no more than `_value` tokens on your behalf
*
* @param _spender The address authorized to spend
* @param _value the max amount they can spend

*/
function approve(address _spender, uint256 _value) public returns (bool) {
</source>
</class>

<class classid="401" nclones="2" nlines="5" similarity="100">
<source file="systems/smart_contracts/Fk.sol" startline="217" endline="232" pcid="3627">
function mint(uint256 _value) public returns (bool) {
    require(!mintingFinished);
    require(msg.sender == owner);
    balanceOf[msg.sender] = balanceOf[msg.sender].add(_value);
    totalSupply = totalSupply.add(_value);
    emit Mint(msg.sender, _value);
    emit Transfer(address(0),msg.sender,_value);
    return true;
}

/**
* @dev Function to stop minting new tokens, when this function is called, function mint will be permanently disabled

*/

function finishMinting() public returns (bool) {
</source>
<source file="systems/smart_contracts/Six.sol" startline="217" endline="232" pcid="6539">
function mint(uint256 _value) public returns (bool) {
    require(!mintingFinished);
    require(msg.sender == owner);
    balanceOf[msg.sender] = balanceOf[msg.sender].add(_value);
    totalSupply = totalSupply.add(_value);
    emit Mint(msg.sender, _value);
    emit Transfer(address(0),msg.sender,_value);
    return true;
}

/**
* @dev Function to stop minting new tokens, when this function is called, function mint will be permanently disabled

*/

function finishMinting() public returns (bool) {
</source>
</class>

<class classid="402" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/Fk.sol" startline="232" endline="248" pcid="3628">
function finishMinting() public returns (bool) {
    require(msg.sender == owner);
    require(!mintingFinished);
    mintingFinished = true;
    emit MintFinished();
    return true;
}



/**
* @dev Transfer ownership of this contract to given address

* @param _newOwner new owner address

*/
function transferOwnership(address _newOwner) public {
</source>
<source file="systems/smart_contracts/Six.sol" startline="232" endline="248" pcid="6540">
function finishMinting() public returns (bool) {
    require(msg.sender == owner);
    require(!mintingFinished);
    mintingFinished = true;
    emit MintFinished();
    return true;
}



/**
* @dev Transfer ownership of this contract to given address

* @param _newOwner new owner address

*/
function transferOwnership(address _newOwner) public {
</source>
</class>

<class classid="403" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/Fk.sol" startline="248" endline="253" pcid="3629">
function transferOwnership(address _newOwner) public {
	require(msg.sender == owner);
	owner = _newOwner;
    emit OwnershipTransferred(msg.sender,owner);
} 
}
</source>
<source file="systems/smart_contracts/Six.sol" startline="248" endline="253" pcid="6541">
function transferOwnership(address _newOwner) public {
    require(msg.sender == owner);
    owner = _newOwner;
    emit OwnershipTransferred(msg.sender,owner);
}
}
</source>
</class>

<class classid="404" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/Fortune999.sol" startline="93" endline="97" pcid="3701">
function div(percent storage p, uint a) internal view returns (uint) {
return a/p.num*p.den;
}

function sub(percent storage p, uint a) internal view returns (uint) {
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="120" endline="124" pcid="3706">
function mdiv(percent memory p, uint a) internal pure returns (uint) {
return a/p.num*p.den;
}

function msub(percent memory p, uint a) internal pure returns (uint) {
</source>
</class>

<class classid="405" nclones="2" nlines="8" similarity="75">
<source file="systems/smart_contracts/Fortune999.sol" startline="97" endline="105" pcid="3702">
function sub(percent storage p, uint a) internal view returns (uint) {
uint b = mul(p, a);
if (b >= a) {
return 0;
}
return a - b;
}

function add(percent storage p, uint a) internal view returns (uint) {
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="124" endline="132" pcid="3707">
function msub(percent memory p, uint a) internal pure returns (uint) {
uint b = mmul(p, a);
if (b >= a) {
return 0;
}
return a - b;
}

function madd(percent memory p, uint a) internal pure returns (uint) {
</source>
</class>

<class classid="406" nclones="5" nlines="8" similarity="75">
<source file="systems/smart_contracts/Fortune999.sol" startline="161" endline="175" pcid="3711">
function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {
if (_a == 0) {
return 0;
}

uint256 c = _a * _b;
require(c / _a == _b);

return c;
}

/**
* @dev Integer division of two numbers truncating the quotient, reverts on division by zero.
*/
function div(uint256 _a, uint256 _b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TimeLockedTokenStorage.sol" startline="12" endline="28" pcid="7220">
    function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {
        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (_a == 0) {
            return 0;
        }

        c = _a * _b;
        assert(c / _a == _b);
        return c;
    }

    /**
    * @dev Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PositionTokenV2.sol" startline="68" endline="84" pcid="5751">
  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {
    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    if (_a == 0) {
      return 0;
    }

    c = _a * _b;
    assert(c / _a == _b);
    return c;
  }

  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PositionTokenV2.sol" startline="94" endline="105" pcid="5753">
  function divCeil(uint256 _a, uint256 _b) internal pure returns (uint256) {
    if (_a == 0) {
      return 0;
    }

    return ((_a - 1) / _b) + 1;
  }

  /**
  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Oracle.sol" startline="86" endline="102" pcid="5512">
  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {
    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    if (_a == 0) {
      return 0;
    }

    c = _a * _b;
    assert(c / _a == _b);
    return c;
  }

  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {
</source>
</class>

<class classid="407" nclones="4" nlines="4" similarity="75">
<source file="systems/smart_contracts/Fortune999.sol" startline="175" endline="186" pcid="3712">
function div(uint256 _a, uint256 _b) internal pure returns (uint256) {
require(_b > 0); // Solidity only automatically asserts when dividing by 0
uint256 c = _a / _b;
assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold

return c;
}

/**
* @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
*/
function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PositionTokenV2.sol" startline="84" endline="94" pcid="5752">
  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {
    // assert(_b > 0); // Solidity automatically throws when dividing by 0
    // uint256 c = _a / _b;
    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold
    return _a / _b;
  }

  /**
  * @dev Integer division of two numbers, rounding up and truncating the quotient
  */
  function divCeil(uint256 _a, uint256 _b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/TimeLockedTokenStorage.sol" startline="28" endline="38" pcid="7221">
    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {
        // assert(_b > 0); // Solidity automatically throws when dividing by 0
        // uint256 c = _a / _b;
        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold
        return _a / _b;
    }

    /**
    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/Oracle.sol" startline="102" endline="112" pcid="5513">
  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {
    // assert(_b > 0); // Solidity automatically throws when dividing by 0
    // uint256 c = _a / _b;
    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold
    return _a / _b;
  }

  /**
  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {
</source>
</class>

<class classid="408" nclones="4" nlines="4" similarity="75">
<source file="systems/smart_contracts/Fortune999.sol" startline="186" endline="196" pcid="3713">
function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {
require(_b <= _a);
uint256 c = _a - _b;

return c;
}

/**
* @dev Adds two numbers, reverts on overflow.
*/
function add(uint256 _a, uint256 _b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/PositionTokenV2.sol" startline="105" endline="113" pcid="5754">
  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {
    assert(_b <= _a);
    return _a - _b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/TimeLockedTokenStorage.sol" startline="38" endline="46" pcid="7222">
    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {
        assert(_b <= _a);
        return _a - _b;
    }

    /**
    * @dev Adds two numbers, throws on overflow.
    */
    function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {
</source>
<source file="systems/smart_contracts/Oracle.sol" startline="112" endline="120" pcid="5514">
  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {
    assert(_b <= _a);
    return _a - _b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {
</source>
</class>

<class classid="409" nclones="2" nlines="8" similarity="75">
<source file="systems/smart_contracts/Fortune999.sol" startline="323" endline="334" pcid="3725">
function addInvestment(address addr, uint investment) public onlyOwner returns (bool) {
if (investors[addr].investment == 0) {
return false;
}
investors[addr].investment += investment*53/100; //25+18=43%
return true;
}




function setPaymentTime(address addr, uint paymentTime) public onlyOwner returns (bool) {
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="334" endline="342" pcid="3726">
function setPaymentTime(address addr, uint paymentTime) public onlyOwner returns (bool) {
if (investors[addr].investment == 0) {
return false;
}
investors[addr].paymentTime = paymentTime;
return true;
}

function disqalify(address addr) public onlyOwner returns (bool) {
</source>
</class>

<class classid="410" nclones="2" nlines="7" similarity="71">
<source file="systems/smart_contracts/Fortune999.sol" startline="342" endline="349" pcid="3727">
function disqalify(address addr) public onlyOwner returns (bool) {
if (isInvestor(addr)) {
//investors[addr].investment = 0;
investors[addr].paymentTime = now + 1 days;
}
}

function disqalify2(address addr) public onlyOwner returns (bool) {
</source>
<source file="systems/smart_contracts/Fortune999.sol" startline="349" endline="357" pcid="3728">
function disqalify2(address addr) public onlyOwner returns (bool) {
if (isInvestor(addr)) {
//investors[addr].investment = 0;
investors[addr].paymentTime = now;
}
}


}
</source>
</class>

<class classid="411" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/FPDeployer.sol" startline="658" endline="666" pcid="3842">
    function isImportedContract(address _contract) external view returns (bool) {
        return contractsToImport[_contract].permission;
    }

    /**
     * @dev get the exchange rate between token to be imported and this token.
     * @param _contract address of token to be exchange
     */
    function getImportedContractRate(address _contract) external view returns (uint256) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="658" endline="666" pcid="7097">
    function isImportedContract(address _contract) external view returns (bool) {
        return contractsToImport[_contract].permission;
    }

    /**
     * @dev get the exchange rate between token to be imported and this token.
     * @param _contract address of token to be exchange
     */
    function getImportedContractRate(address _contract) external view returns (uint256) {
</source>
</class>

<class classid="412" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/FPDeployer.sol" startline="666" endline="675" pcid="3843">
    function getImportedContractRate(address _contract) external view returns (uint256) {
        return contractsToImport[_contract].tokenRateExchange;
    }

    /**
     * @dev set the address of the token to be imported and its exchange rate.
     * @param _contract address of token to be imported
     * @param _exchRate exchange rate between token to be imported and this token.
     */
    function setImportedContract(address _contract, uint256 _exchRate) external onlyOwner {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="666" endline="675" pcid="7098">
    function getImportedContractRate(address _contract) external view returns (uint256) {
        return contractsToImport[_contract].tokenRateExchange;
    }

    /**
     * @dev set the address of the token to be imported and its exchange rate.
     * @param _contract address of token to be imported
     * @param _exchRate exchange rate between token to be imported and this token.
     */
    function setImportedContract(address _contract, uint256 _exchRate) external onlyOwner {
</source>
</class>

<class classid="413" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/FPDeployer.sol" startline="675" endline="682" pcid="3844">
    function setImportedContract(address _contract, uint256 _exchRate) external onlyOwner {
        require(_contract != address(0), "Address not allowed!");
        require(_exchRate >= 0, "Rate exchange not allowed!");
        contractsToImport[_contract].permission = true;
        contractsToImport[_contract].tokenRateExchange = _exchRate;
    }

    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="675" endline="682" pcid="7099">
    function setImportedContract(address _contract, uint256 _exchRate) external onlyOwner {
        require(_contract != address(0), "Address not allowed!");
        require(_exchRate >= 0, "Rate exchange not allowed!");
        contractsToImport[_contract].permission = true;
        contractsToImport[_contract].tokenRateExchange = _exchRate;
    }

    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
</source>
</class>

<class classid="414" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/FPDeployer.sol" startline="692" endline="697" pcid="3847">
    function mint(address _account, uint256 _amount) public whenNotPaused onlyMinterAddress {
        require(checkMintAllowed(_account, _amount) == STATUS_ALLOWED, "mint must be allowed");
        ERC20._mint(_account, _amount);
    }

    function burn(address _account, uint256 _amount) public whenNotPaused onlyMinterAddress {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="692" endline="697" pcid="7102">
    function mint(address _account, uint256 _amount) public whenNotPaused onlyMinterAddress {
        require(checkMintAllowed(_account, _amount) == STATUS_ALLOWED, "mint must be allowed");
        ERC20._mint(_account, _amount);
    }

    function burn(address _account, uint256 _amount) public whenNotPaused onlyMinterAddress {
</source>
</class>

<class classid="415" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/FPDeployer.sol" startline="697" endline="707" pcid="3848">
    function burn(address _account, uint256 _amount) public whenNotPaused onlyMinterAddress {
        require(checkBurnAllowed(_account, _amount) == STATUS_ALLOWED, "burn must be allowed");
        ERC20._burn(_account, _amount);
    }

    /**
     * @dev check if the SEED sender address could receive new tokens.
     * @param _holder address of the SEED sender
     * @param _amountToAdd amount of tokens to be added to sender balance.
     */
    function okToTransferTokens(address _holder, uint256 _amountToAdd) public view returns (bool){
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="697" endline="707" pcid="7103">
    function burn(address _account, uint256 _amount) public whenNotPaused onlyMinterAddress {
        require(checkBurnAllowed(_account, _amount) == STATUS_ALLOWED, "burn must be allowed");
        ERC20._burn(_account, _amount);
    }

    /**
     * @dev check if the SEED sender address could receive new tokens.
     * @param _holder address of the SEED sender
     * @param _amountToAdd amount of tokens to be added to sender balance.
     */
    function okToTransferTokens(address _holder, uint256 _amountToAdd) public view returns (bool){
</source>
</class>

<class classid="416" nclones="2" nlines="5" similarity="100">
<source file="systems/smart_contracts/FPDeployer.sol" startline="707" endline="714" pcid="3849">
    function okToTransferTokens(address _holder, uint256 _amountToAdd) public view returns (bool){
        uint256 holderBalanceToBe = balanceOf(_holder).add(_amountToAdd);
        bool okToTransfer = ATContract.isWhitelisted(_holder) && holderBalanceToBe <= ATContract.getMaxWLAmount(_holder) ? true :
                          holderBalanceToBe <= ATContract.getWLThresholdBalance() ? true : false;
        return okToTransfer;
    }

    function checkTransferAllowed (address _sender, address _receiver, uint256 _amount) public view returns (byte) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="707" endline="714" pcid="7104">
    function okToTransferTokens(address _holder, uint256 _amountToAdd) public view returns (bool){
        uint256 holderBalanceToBe = balanceOf(_holder).add(_amountToAdd);
        bool okToTransfer = ATContract.isWhitelisted(_holder) && holderBalanceToBe <= ATContract.getMaxWLAmount(_holder) ? true :
                          holderBalanceToBe <= ATContract.getWLThresholdBalance() ? true : false;
        return okToTransfer;
    }

    function checkTransferAllowed (address _sender, address _receiver, uint256 _amount) public view returns (byte) {
</source>
</class>

<class classid="417" nclones="4" nlines="5" similarity="80">
<source file="systems/smart_contracts/FPDeployer.sol" startline="714" endline="722" pcid="3850">
    function checkTransferAllowed (address _sender, address _receiver, uint256 _amount) public view returns (byte) {
        require(_sender != address(0), "Sender can not be 0!");
        require(_receiver != address(0), "Receiver can not be 0!");
        require(balanceOf(_sender) >= _amount, "Sender does not have enough tokens!");
        require(okToTransferTokens(_receiver, _amount), "Receiver not allowed to perform transfer!");
        return STATUS_ALLOWED;
    }

    function checkTransferFromAllowed (address _sender, address _receiver, uint256 _amount) public view returns (byte) {
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="722" endline="730" pcid="3851">
    function checkTransferFromAllowed (address _sender, address _receiver, uint256 _amount) public view returns (byte) {
        require(_sender != address(0), "Sender can not be 0!");
        require(_receiver != address(0), "Receiver can not be 0!");
        require(balanceOf(_sender) >= _amount, "Sender does not have enough tokens!");
        require(okToTransferTokens(_receiver, _amount), "Receiver not allowed to perform transfer!");
        return STATUS_ALLOWED;
    }

    function checkMintAllowed (address, uint256) public pure returns (byte) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="714" endline="722" pcid="7105">
    function checkTransferAllowed (address _sender, address _receiver, uint256 _amount) public view returns (byte) {
        require(_sender != address(0), "Sender can not be 0!");
        require(_receiver != address(0), "Receiver can not be 0!");
        require(balanceOf(_sender) >= _amount, "Sender does not have enough tokens!");
        require(okToTransferTokens(_receiver, _amount), "Receiver not allowed to perform transfer!");
        return STATUS_ALLOWED;
    }

    function checkTransferFromAllowed (address _sender, address _receiver, uint256 _amount) public view returns (byte) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="722" endline="730" pcid="7106">
    function checkTransferFromAllowed (address _sender, address _receiver, uint256 _amount) public view returns (byte) {
        require(_sender != address(0), "Sender can not be 0!");
        require(_receiver != address(0), "Receiver can not be 0!");
        require(balanceOf(_sender) >= _amount, "Sender does not have enough tokens!");
        require(okToTransferTokens(_receiver, _amount), "Receiver not allowed to perform transfer!");
        return STATUS_ALLOWED;
    }

    function checkMintAllowed (address, uint256) public pure returns (byte) {
</source>
</class>

<class classid="418" nclones="4" nlines="4" similarity="75">
<source file="systems/smart_contracts/FPDeployer.sol" startline="730" endline="735" pcid="3852">
    function checkMintAllowed (address, uint256) public pure returns (byte) {
        //require(ATContract.isOperator(_minter), "Not Minter!");
        return STATUS_ALLOWED;
    }

    function checkBurnAllowed (address, uint256) public pure returns (byte) {
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="735" endline="740" pcid="7108">
    function checkBurnAllowed (address, uint256) public pure returns (byte) {
        // default
        return STATUS_ALLOWED;
    }

}
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="735" endline="740" pcid="3853">
    function checkBurnAllowed (address, uint256) public pure returns (byte) {
        // default
        return STATUS_ALLOWED;
    }

}
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="730" endline="735" pcid="7107">
    function checkMintAllowed (address, uint256) public pure returns (byte) {
        //require(ATContract.isOperator(_minter), "Not Minter!");
        return STATUS_ALLOWED;
    }

    function checkBurnAllowed (address, uint256) public pure returns (byte) {
</source>
</class>

<class classid="419" nclones="2" nlines="17" similarity="76">
<source file="systems/smart_contracts/GameGold.sol" startline="144" endline="164" pcid="3993">
  function addressToPass(address[] memory target, bool status)
  public
  onlyOwner
  {
    for( uint i = 0 ; i < target.length ; i++ ) {
        address targetAddress = target[i];
        bool old = mapAddressPass[targetAddress];
        if (old != status) {
            if (status == true) {
                mapAddressPass[targetAddress] = true;
                emit LogFilterPass(targetAddress, true);
            }
            else {
                delete mapAddressPass[targetAddress];
                emit LogFilterPass(targetAddress, false);
            }
        }
    }
  }

  function addressToBlock(address[] memory target, bool status)
</source>
<source file="systems/smart_contracts/GameGold.sol" startline="164" endline="183" pcid="3994">
  function addressToBlock(address[] memory target, bool status)
  public
  onlyOwner
  {
      for( uint i = 0 ; i < target.length ; i++ ) {
          address targetAddress = target[i];
          bool old = mapAddressBlock[targetAddress];
          if (old != status) {
              if (status == true) {
                  mapAddressBlock[targetAddress] = true;
                  emit LogFilterBlock(targetAddress, true);
              }
              else {
                  delete mapAddressBlock[targetAddress];
                  emit LogFilterBlock(targetAddress, false);
              }
          }
      }
  }
}
</source>
</class>

<class classid="420" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/GameGold.sol" startline="358" endline="363" pcid="4008">
  function finishMinting() canMint onlyOwner public returns (bool) {
    mintingFinished = true;
    emit MintFinished();
    return true;
  }
}
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="221" endline="226" pcid="4660">
  function finishMinting() onlyOwner canMint public returns (bool) {
    mintingFinished = true;
    emit MintFinished();
    return true;
  }
}
</source>
</class>

<class classid="421" nclones="3" nlines="5" similarity="100">
<source file="systems/smart_contracts/ICBB.sol" startline="204" endline="218" pcid="4272">
    function _transfer(address _from, address _to, uint _value) internal {
        require (_to != address(0x0));                          // Prevent transfer to 0x0 address. Use burn() instead
        require (balanceOf[_from] >= _value);                   // Check if the sender has enough
        require (balanceOf[_to] + _value >= balanceOf[_to]);    // Check for overflows
        require(!frozenAccount[_from]);                         // Check if sender is frozen
        require(!frozenAccount[_to]);                           // Check if recipient is frozen
        balanceOf[_from] -= _value;                             // Subtract from the sender
        balanceOf[_to] += _value;                               // Add the same to the recipient
        emit Transfer(_from, _to, _value);
    }

    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens
    /// @param target Address to be frozen
    /// @param freeze either to freeze it or not
    function freezeAccount(address target, bool freeze) onlyOwner public {
</source>
<source file="systems/smart_contracts/LuckyAdvcedWoken.sol" startline="230" endline="244" pcid="4565">
    function _transfer(address _from, address _to, uint _value) internal {
        require (_to != address(0x0));                          // Prevent transfer to 0x0 address. Use burn() instead
        require (balanceOf[_from] >= _value);                   // Check if the sender has enough
        require (balanceOf[_to] + _value >= balanceOf[_to]);    // Check for overflows
        require(!frozenAccount[_from]);                         // Check if sender is frozen
        require(!frozenAccount[_to]);                           // Check if recipient is frozen
        balanceOf[_from] -= _value;                             // Subtract from the sender
        balanceOf[_to] += _value;                               // Add the same to the recipient
        emit Transfer(_from, _to, _value);
    }

    /// @notice Create `mintedAmount` tokens and send it to `target`
    /// @param target Address to receive the tokens
    /// @param mintedAmount the amount of tokens it will receive
    function mintToken(address target, uint256 mintedAmount) onlyOwner public {
</source>
<source file="systems/smart_contracts/MAdvcedWoken.sol" startline="230" endline="244" pcid="4604">
    function _transfer(address _from, address _to, uint _value) internal {
        require (_to != address(0x0));                          // Prevent transfer to 0x0 address. Use burn() instead
        require (balanceOf[_from] >= _value);                   // Check if the sender has enough
        require (balanceOf[_to] + _value >= balanceOf[_to]);    // Check for overflows
        require(!frozenAccount[_from]);                         // Check if sender is frozen
        require(!frozenAccount[_to]);                           // Check if recipient is frozen
        balanceOf[_from] -= _value;                             // Subtract from the sender
        balanceOf[_to] += _value;                               // Add the same to the recipient
        emit Transfer(_from, _to, _value);
    }

    /// @notice Create `mintedAmount` tokens and send it to `target`
    /// @param target Address to receive the tokens
    /// @param mintedAmount the amount of tokens it will receive
    function mintToken(address target, uint256 mintedAmount) onlyOwner public {
</source>
</class>

<class classid="422" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/ITVR.sol" startline="76" endline="85" pcid="4327">
  function getBalance()
    constant
    public
    returns(uint)
  {
    return company_token.balanceOf(this);
  }


  function setOwner(address _owner) 
</source>
<source file="systems/smart_contracts/PDataToSHFund.sol" startline="76" endline="85" pcid="5631">
  function getBalance()
    constant
    public
    returns(uint)
  {
    return company_token.balanceOf(this);
  }


  function setOwner(address _owner) 
</source>
</class>

<class classid="423" nclones="3" nlines="4" similarity="75">
<source file="systems/smart_contracts/ITVR.sol" startline="85" endline="95" pcid="4328">
  function setOwner(address _owner) 
    public 
    onlyOwner 
  {
    require(_owner != 0);
    
    owner = _owner;
    emit OwnerChanged(owner);
  }
  
  function sendCurrentPayment() public {
</source>
<source file="systems/smart_contracts/PDataToSHFund.sol" startline="85" endline="95" pcid="5632">
  function setOwner(address _owner) 
    public 
    onlyOwner 
  {
    require(_owner != 0);
    
    owner = _owner;
    emit OwnerChanged(owner);
  }
  
  function sendCurrentPayment() public {
</source>
<source file="systems/smart_contracts/Proxy.sol" startline="30" endline="35" pcid="5873">
  function setOwner(address _owner) public onlyOwner {
    owner = _owner;
    emit ProxyOwnerChanged(_owner);
  }

  function () payable public {
</source>
</class>

<class classid="424" nclones="2" nlines="17" similarity="100">
<source file="systems/smart_contracts/ITVR.sol" startline="95" endline="115" pcid="4329">
  function sendCurrentPayment() public {
    if (now > startDateOfPayments) {
      uint currentPeriod = (now - startDateOfPayments) / periodOfOnePayments;
      uint currentLimit = currentPeriod * limitPerPeriod;
      uint unsealedAmount = currentLimit - alreadyTransfered;
      if (unsealedAmount > 0) {
        if (currentBalance >= unsealedAmount) {
          company_token.transfer(PartnerAccount, unsealedAmount);
          alreadyTransfered += unsealedAmount;
          currentBalance -= unsealedAmount;
          emit Transfer(PartnerAccount, unsealedAmount);
        } else {
          company_token.transfer(PartnerAccount, currentBalance);
          alreadyTransfered += currentBalance;
          currentBalance -= currentBalance;
          emit Transfer(PartnerAccount, currentBalance);
        }
      }
	  }
  }
}
</source>
<source file="systems/smart_contracts/PDataToSHFund.sol" startline="95" endline="115" pcid="5633">
  function sendCurrentPayment() public {
    if (now > startDateOfPayments) {
      uint currentPeriod = (now - startDateOfPayments) / periodOfOnePayments;
      uint currentLimit = currentPeriod * limitPerPeriod;
      uint unsealedAmount = currentLimit - alreadyTransfered;
      if (unsealedAmount > 0) {
        if (currentBalance >= unsealedAmount) {
          company_token.transfer(PartnerAccount, unsealedAmount);
          alreadyTransfered += unsealedAmount;
          currentBalance -= unsealedAmount;
          emit Transfer(PartnerAccount, unsealedAmount);
        } else {
          company_token.transfer(PartnerAccount, currentBalance);
          alreadyTransfered += currentBalance;
          currentBalance -= currentBalance;
          emit Transfer(PartnerAccount, currentBalance);
        }
      }
	  }
  }
}
</source>
</class>

<class classid="425" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/KFCToken.sol" startline="91" endline="95" pcid="4412">
    function setName(string _name) public isOwner {
        name = _name;
    }

    function setSymbol(string _symbol) public isOwner {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="426" endline="436" pcid="5109">
    function setName(string _name)
        onlyOwner()
        public
    {
        name = _name;
    }
    
    /**
     * If we want to rebrand, we can.
     */
    function setSymbol(string _symbol)
</source>
</class>

<class classid="426" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/KFCToken.sol" startline="95" endline="99" pcid="4413">
    function setSymbol(string _symbol) public isOwner {
        symbol = _symbol;
    }

    function burn(uint256 _value) public {
</source>
<source file="systems/smart_contracts/MULTIFOMO.sol" startline="436" endline="443" pcid="5110">
    function setSymbol(string _symbol)
        onlyOwner()
        public
    {
        symbol = _symbol;
    }

    function setInitialPrice(uint _price)
</source>
</class>

<class classid="427" nclones="4" nlines="4" similarity="75">
<source file="systems/smart_contracts/LuckyAdvcedWoken.sol" startline="244" endline="254" pcid="4566">
    function mintToken(address target, uint256 mintedAmount) onlyOwner public {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        emit Transfer(address(0), address(this), mintedAmount);
        emit Transfer(address(this), target, mintedAmount);
    }

    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens
    /// @param target Address to be frozen
    /// @param freeze either to freeze it or not
    function freezeAccount(address target, bool freeze) onlyOwner public {
</source>
<source file="systems/smart_contracts/UTRAToken.sol" startline="146" endline="156" pcid="7606">
    function mintToken(address target, uint256 mintedAmount) onlyOwner public {
        balances[target] = balances[target].add(mintedAmount);
        totalSupply = totalSupply.add(mintedAmount);
        emit Transfer(0, this, mintedAmount);
        emit Transfer(this, target, mintedAmount);
    }

    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens
    /// @param target Address to be frozen
    /// @param freeze either to freeze it or not
    function freezeAccount(address target, bool freeze) onlyOwner public {
</source>
<source file="systems/smart_contracts/MAdvcedWoken.sol" startline="244" endline="254" pcid="4605">
    function mintToken(address target, uint256 mintedAmount) onlyOwner public {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        emit Transfer(address(0), address(this), mintedAmount);
        emit Transfer(address(this), target, mintedAmount);
    }

    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens
    /// @param target Address to be frozen
    /// @param freeze either to freeze it or not
    function freezeAccount(address target, bool freeze) onlyOwner public {
</source>
<source file="systems/smart_contracts/MyAdvancedToken.sol" startline="217" endline="227" pcid="5272">
    function mintToken(address target, uint256 mintedAmount) onlyOwner public {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        emit Transfer(0, this, mintedAmount);
        emit Transfer(this, target, mintedAmount);
    }

    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens
    /// @param target Address to be frozen
    /// @param freeze either to freeze it or not
    function freezeAccount(address target, bool freeze) onlyOwner public {
</source>
</class>

<class classid="428" nclones="2" nlines="3" similarity="100">
<source file="systems/smart_contracts/magesh.sol" startline="296" endline="298" pcid="4631">
  function donate() public payable {}

  function flush() public payable {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="296" endline="298" pcid="4943">
  function donate() public payable {}

  function flush() public payable {
</source>
</class>

<class classid="429" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/magesh.sol" startline="298" endline="305" pcid="4632">
  function flush() public payable {
    //amount in cents
    uint256 amount = msg.value.mul(oracle.price());
    uint256 finalAmount= amount.div(1 ether);
    _mint(msg.sender,finalAmount);
  }

  function getPrice() public view returns (uint256) {
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="298" endline="305" pcid="4944">
  function flush() public payable {
    //amount in cents
    uint256 amount = msg.value.mul(oracle.price());
    uint256 finalAmount= amount.div(1 ether);
    _mint(msg.sender,finalAmount);
  }

  function getPrice() public view returns (uint256) {
</source>
</class>

<class classid="430" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/magesh.sol" startline="305" endline="309" pcid="4633">
  function getPrice() public view returns (uint256) {
    return oracle.price();
  }

  function withdraw(uint256 amountCent) public returns (uint256 amountWei){
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="305" endline="309" pcid="4945">
  function getPrice() public view returns (uint256) {
    return oracle.price();
  }

  function withdraw(uint256 amountCent) public returns (uint256 amountWei){
</source>
</class>

<class classid="431" nclones="2" nlines="8" similarity="100">
<source file="systems/smart_contracts/magesh.sol" startline="309" endline="335" pcid="4634">
  function withdraw(uint256 amountCent) public returns (uint256 amountWei){
    require(amountCent <= balanceOf(msg.sender));
    amountWei = (amountCent.mul(1 ether)).div(oracle.price());

    // If we don't have enough Ether in the contract to pay out the full amount
    // pay an amount proportinal to what we have left.
    // this way user's net worth will never drop at a rate quicker than
    // the collateral itself.

    // For Example:
    // A user deposits 1 Ether when the price of Ether is $300
    // the price then falls to $150.
    // If we have enough Ether in the contract we cover ther losses
    // and pay them back 2 ether (the same amount in USD).
    // if we don't have enough money to pay them back we pay out
    // proportonailly to what we have left. In this case they'd
    // get back their original deposit of 1 Ether.
    if(balanceOf(msg.sender) <= amountWei) {
      amountWei = amountWei.mul(balanceOf(msg.sender));
      amountWei = amountWei.mul(oracle.price());
      amountWei = amountWei.div(1 ether);
      amountWei = amountWei.mul(totalSupply());
    }
    _burn(msg.sender,amountCent);
    msg.sender.transfer(amountWei);
  }
}
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="309" endline="335" pcid="4946">
  function withdraw(uint256 amountCent) public returns (uint256 amountWei){
    require(amountCent <= balanceOf(msg.sender));
    amountWei = (amountCent.mul(1 ether)).div(oracle.price());

    // If we don't have enough Ether in the contract to pay out the full amount
    // pay an amount proportinal to what we have left.
    // this way user's net worth will never drop at a rate quicker than
    // the collateral itself.

    // For Example:
    // A user deposits 1 Ether when the price of Ether is $300
    // the price then falls to $150.
    // If we have enough Ether in the contract we cover ther losses
    // and pay them back 2 ether (the same amount in USD).
    // if we don't have enough money to pay them back we pay out
    // proportonailly to what we have left. In this case they'd
    // get back their original deposit of 1 Ether.
    if(balanceOf(msg.sender) <= amountWei) {
      amountWei = amountWei.mul(balanceOf(msg.sender));
      amountWei = amountWei.mul(oracle.price());
      amountWei = amountWei.div(1 ether);
      amountWei = amountWei.mul(totalSupply());
    }
    _burn(msg.sender,amountCent);
    msg.sender.transfer(amountWei);
  }
}
</source>
</class>

<class classid="432" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/magesh.sol" startline="359" endline="365" pcid="4636">
    function setPrice(uint256 price) public onlyOwner {
    
      price_ = price;

    }

    function price() public view returns (uint256){
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="359" endline="365" pcid="4948">
    function setPrice(uint256 price) public onlyOwner {
    
      price_ = price;

    }

    function price() public view returns (uint256){
</source>
</class>

<class classid="433" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/magesh.sol" startline="365" endline="371" pcid="4637">
    function price() public view returns (uint256){

      return price_;

    }

}
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="365" endline="371" pcid="4949">
    function price() public view returns (uint256){

      return price_;

    }

}
</source>
</class>

<class classid="434" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/MainToken.sol" startline="364" endline="371" pcid="4672">
  function _burn(address _who, uint256 _value) internal {
    require(_value <= balances[_who]);
    balances[_who] = balances[_who].sub(_value);
    totalSupply_ = totalSupply_.sub(_value);
    emit Burn(_who, _value);
    emit Transfer(_who, address(0), _value);
  }
}
</source>
<source file="systems/smart_contracts/TorexToken.sol" startline="137" endline="147" pcid="7414">
  function _burn(address _who, uint256 _value) internal {
    require(_value <= balances[_who]);
    // no need to require value <= totalSupply, since that would imply the
    // sender's balance is greater than the totalSupply, which *should* be an assertion failure

    balances[_who] = balances[_who].sub(_value);
    totalSupply_ = totalSupply_.sub(_value);
    emit Burn(_who, _value);
    emit Transfer(_who, address(0), _value);
  }
}
</source>
<source file="systems/smart_contracts/MBA.sol" startline="207" endline="217" pcid="4718">
  function _burn(address _who, uint256 _value) internal {
    require(_value <= balances[_who]);
    // no need to require value <= totalSupply, since that would imply the
    // sender's balance is greater than the totalSupply, which *should* be an assertion failure

    balances[_who] = balances[_who].sub(_value);
    totalSupply_ = totalSupply_.sub(_value);
    emit Burn(_who, _value);
    emit Transfer(_who, address(0), _value);
  }
}
</source>
</class>

<class classid="435" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/MatchingToken.sol" startline="41" endline="51" pcid="4686">
    function _transfer(address _from, address _to, uint256 _value) internal {
        require(balanceOf[_from]>=_value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        require(transfercheck(_from) == true);
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
    }
    
    
    function transfer(address to, uint256 value) public {
</source>
<source file="systems/smart_contracts/RubyToken.sol" startline="41" endline="51" pcid="6227">
    function _transfer(address _from, address _to, uint256 _value) internal {
        require(balanceOf[_from]>=_value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        require(transfercheck(_from) == true);
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
    }
    
    
    function transfer(address to, uint256 value) public {
</source>
</class>

<class classid="436" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/MatchingToken.sol" startline="51" endline="55" pcid="4687">
    function transfer(address to, uint256 value) public {
        _transfer(msg.sender, to, value);
    }
    
    function transferFrom(address _from, address _to, uint256 amount) public {
</source>
<source file="systems/smart_contracts/RubyToken.sol" startline="51" endline="55" pcid="6228">
    function transfer(address to, uint256 value) public {
        _transfer(msg.sender, to, value);
    }
    
    function transferFrom(address _from, address _to, uint256 amount) public {
</source>
</class>

<class classid="437" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/MatchingToken.sol" startline="55" endline="62" pcid="4688">
    function transferFrom(address _from, address _to, uint256 amount) public {
         
       require(allowed[_from][msg.sender]>=amount);
       allowed[_from][msg.sender] -= amount;
       _transfer(_from,_to,amount);
    }
    
    function transfercheck(address check) internal returns(bool) {
</source>
<source file="systems/smart_contracts/RubyToken.sol" startline="55" endline="62" pcid="6229">
    function transferFrom(address _from, address _to, uint256 amount) public {
         
       require(allowed[_from][msg.sender]>=amount);
       allowed[_from][msg.sender] -= amount;
       _transfer(_from,_to,amount);
    }
    
    function transfercheck(address check) internal returns(bool) {
</source>
</class>

<class classid="438" nclones="3" nlines="8" similarity="75">
<source file="systems/smart_contracts/MatchingToken.sol" startline="62" endline="70" pcid="4689">
    function transfercheck(address check) internal returns(bool) {
        if (transferable[check]==false){
            return true;
        }
        return false;
    }
    
    
    function approve(address spender, uint256 _value) public returns(bool){
</source>
<source file="systems/smart_contracts/RubyToken.sol" startline="62" endline="70" pcid="6230">
    function transfercheck(address check) internal returns(bool) {
        if (transferable[check]==false){
            return true;
        }
        return false;
    }
    
    
    function approve(address spender, uint256 _value) public returns(bool){
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="628" endline="638" pcid="7381">
    function hasReachedSoftCap() public view returns (bool) {
        if (tokensSold >= softCap) {
            return true;
        }

        return false;
    }

    // override Crowdsale#hasEnded to add cap logic
    // @return true if crowdsale event has ended
    function hasEnded() public view returns (bool) {
</source>
</class>

<class classid="439" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/MatchingToken.sol" startline="70" endline="77" pcid="4690">
    function approve(address spender, uint256 _value) public returns(bool){
        require(balanceOf[msg.sender]>=_value);
        allowed[msg.sender][spender] = _value;
        emit Approval(msg.sender, spender, _value);
        
    }

    function lock(address lockee) public {
</source>
<source file="systems/smart_contracts/RubyToken.sol" startline="70" endline="77" pcid="6231">
    function approve(address spender, uint256 _value) public returns(bool){
        require(balanceOf[msg.sender]>=_value);
        allowed[msg.sender][spender] = _value;
        emit Approval(msg.sender, spender, _value);
        
    }

    function lock(address lockee) public {
</source>
</class>

<class classid="440" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/MatchingToken.sol" startline="77" endline="82" pcid="4691">
    function lock(address lockee) public {
        require(msg.sender == _administrator);
        transferable[lockee] = true;
    }
    
    function unlock(address unlockee) public {
</source>
<source file="systems/smart_contracts/RubyToken.sol" startline="77" endline="82" pcid="6232">
    function lock(address lockee) public {
        require(msg.sender == _administrator);
        transferable[lockee] = true;
    }
    
    function unlock(address unlockee) public {
</source>
</class>

<class classid="441" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/MatchingToken.sol" startline="82" endline="87" pcid="4692">
    function unlock(address unlockee) public {
        require(msg.sender == _administrator);
        transferable[unlockee] = false;
    }
    
    function lockcheck(address checkee) public view returns (bool){
</source>
<source file="systems/smart_contracts/RubyToken.sol" startline="82" endline="87" pcid="6233">
    function unlock(address unlockee) public {
        require(msg.sender == _administrator);
        transferable[unlockee] = false;
    }
    
    function lockcheck(address checkee) public view returns (bool){
</source>
</class>

<class classid="442" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/MatchingToken.sol" startline="87" endline="92" pcid="4693">
    function lockcheck(address checkee) public view returns (bool){
        return transferable[checkee];
    }
    
    
    function _burn(address account, uint256 value) private {
</source>
<source file="systems/smart_contracts/RubyToken.sol" startline="87" endline="92" pcid="6234">
    function lockcheck(address checkee) public view returns (bool){
        return transferable[checkee];
    }
    
    
    function _burn(address account, uint256 value) private {
</source>
</class>

<class classid="443" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/MatchingToken.sol" startline="92" endline="101" pcid="4694">
    function _burn(address account, uint256 value) private {
        require(account == _administrator);
        require(msg.sender == _administrator);
        require(balanceOf[account]>value);
        require(_totalSupply>value);
        _totalSupply -= value;
        balanceOf[account] -=value;
    }
    
    function _addsupply(address account, uint256 value) private {
</source>
<source file="systems/smart_contracts/RubyToken.sol" startline="92" endline="101" pcid="6235">
    function _burn(address account, uint256 value) private {
        require(account == _administrator);
        require(msg.sender == _administrator);
        require(balanceOf[account]>value);
        require(_totalSupply>value);
        _totalSupply -= value;
        balanceOf[account] -=value;
    }
    
    function _addsupply(address account, uint256 value) private {
</source>
</class>

<class classid="444" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/MatchingToken.sol" startline="101" endline="108" pcid="4695">
    function _addsupply(address account, uint256 value) private {
        require(account == _administrator);
        require(msg.sender == _administrator);
        _totalSupply += value;
        balanceOf[account] +=value;
    }
    
    function burn(uint256 amount) public {
</source>
<source file="systems/smart_contracts/RubyToken.sol" startline="101" endline="108" pcid="6236">
    function _addsupply(address account, uint256 value) private {
        require(account == _administrator);
        require(msg.sender == _administrator);
        _totalSupply += value;
        balanceOf[account] +=value;
    }
    
    function burn(uint256 amount) public {
</source>
</class>

<class classid="445" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/MatchingToken.sol" startline="112" endline="118" pcid="4697">
    function addsupply(uint256 amount) public {
        _addsupply(msg.sender, amount);
    }
    
    
    
}
</source>
<source file="systems/smart_contracts/RubyToken.sol" startline="112" endline="118" pcid="6238">
    function addsupply(uint256 amount) public {
        _addsupply(msg.sender, amount);
    }
    
    
    
}
</source>
</class>

<class classid="446" nclones="2" nlines="18" similarity="77">
<source file="systems/smart_contracts/MiniMeTokenFactory.sol" startline="322" endline="346" pcid="4815">
    function balanceOfAt(address _owner, uint _blockNumber) public constant returns (uint) {

        // These next few lines are used when the balance of the token is
        //  requested before a check point was ever created for this token, it
        //  requires that the `parentToken.balanceOfAt` be queried at the
        //  genesis block for that token as this contains initial balance of
        //  this token
        if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {
            if (address(parentToken) != 0) {
                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));
            } else {
                // Has no parent
                return 0;
            }

        // This will return the expected balance during normal situations
        } else {
            return getValueAt(balances[_owner], _blockNumber);
        }
    }

    /// @notice Total amount of tokens at a specific `_blockNumber`.
    /// @param _blockNumber The block number when the totalSupply is queried
    /// @return The total amount of tokens at `_blockNumber`
    function totalSupplyAt(uint _blockNumber) public constant returns(uint) {
</source>
<source file="systems/smart_contracts/MiniMeTokenFactory.sol" startline="346" endline="380" pcid="4816">
    function totalSupplyAt(uint _blockNumber) public constant returns(uint) {

        // These next few lines are used when the totalSupply of the token is
        //  requested before a check point was ever created for this token, it
        //  requires that the `parentToken.totalSupplyAt` be queried at the
        //  genesis block for this token as that contains totalSupply of this
        //  token at this block number.
        if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {
            if (address(parentToken) != 0) {
                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));
            } else {
                return 0;
            }

        // This will return the expected totalSupply during normal situations
        } else {
            return getValueAt(totalSupplyHistory, _blockNumber);
        }
    }

////////////////
// Clone Token Method
////////////////

    /// @notice Creates a new clone token with the initial distribution being
    ///  this token at `_snapshotBlock`
    /// @param _cloneTokenName Name of the clone token
    /// @param _cloneDecimalUnits Number of decimals of the smallest unit
    /// @param _cloneTokenSymbol Symbol of the clone token
    /// @param _snapshotBlock Block when the distribution of the parent token is
    ///  copied to set the initial distribution of the new clone token;
    ///  if the block is zero than the actual block, the current block is used
    /// @param _transfersEnabled True if transfers are allowed in the clone
    /// @return The address of the new MiniMeToken Contract
    function createCloneToken(
</source>
</class>

<class classid="447" nclones="2" nlines="20" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="467" endline="510" pcid="4858">
  function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {

    owner = msg.sender;

    name = _name;

    token = FractionalERC20Ext(_token);

    setPricingStrategy(_pricingStrategy);

    multisigWallet = _multisigWallet;
    if(multisigWallet == 0) {
        throw;
    }

    if(_start == 0) {
        throw;
    }

    startsAt = _start;

    if(_end == 0) {
        throw;
    }

    endsAt = _end;

    // Don't mess the dates
    if(startsAt >= endsAt) {
        throw;
    }

    // Minimum funding goal can be zero
    minimumFundingGoal = _minimumFundingGoal;

    isUpdatable = _isUpdatable;

    isWhiteListed = _isWhiteListed;
  }

  /**
   * Don't expect to just send in money and get tokens.
   */
  function() payable {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="462" endline="505" pcid="6098">
  function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {

    owner = msg.sender;

    name = _name;

    token = FractionalERC20Ext(_token);

    setPricingStrategy(_pricingStrategy);

    multisigWallet = _multisigWallet;
    if(multisigWallet == 0) {
        throw;
    }

    if(_start == 0) {
        throw;
    }

    startsAt = _start;

    if(_end == 0) {
        throw;
    }

    endsAt = _end;

    // Don't mess the dates
    if(startsAt >= endsAt) {
        throw;
    }

    // Minimum funding goal can be zero
    minimumFundingGoal = _minimumFundingGoal;

    isUpdatable = _isUpdatable;

    isWhiteListed = _isWhiteListed;
  }

  /**
   * Don't expect to just send in money and get tokens.
   */
  function() payable {
</source>
</class>

<class classid="448" nclones="2" nlines="54" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="524" endline="601" pcid="4860">
  function investInternal(address receiver, uint128 customerId) stopInEmergency private {

    // Determine if it's a good time to accept investment from this participant
    if(getState() == State.PreFunding) {
      // Are we whitelisted for early deposit
      throw;
    } else if(getState() == State.Funding) {
      // Retail participants can only come in when the crowdsale is running
      // pass
      if(isWhiteListed) {
        if(!earlyParticipantWhitelist[receiver].status) {
          throw;
        }
      }
    } else {
      // Unwanted state
      throw;
    }

    uint weiAmount = msg.value;

    // Account presale sales separately, so that they do not count against pricing tranches
    uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());

    if(tokenAmount == 0) {
      // Dust transaction
      throw;
    }

    if(isWhiteListed) {
      if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {
        // tokenAmount < minCap for investor
        throw;
      }

      // Check that we did not bust the investor's cap
      if (isBreakingInvestorCap(receiver, tokenAmount)) {
        throw;
      }

      updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);
    } else {
      if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {
        throw;
      }
    }

    if(investedAmountOf[receiver] == 0) {
       // A new investor
       investorCount++;
    }

    // Update investor
    investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);
    tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);

    // Update totals
    weiRaised = weiRaised.plus(weiAmount);
    tokensSold = tokensSold.plus(tokenAmount);

    // Check that we did not bust the cap
    if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {
      throw;
    }

    assignTokens(receiver, tokenAmount);

    // Pocket the money
    if(!multisigWallet.send(weiAmount)) throw;

    // Tell us invest was success
    Invested(receiver, weiAmount, tokenAmount, customerId);
  }

  /**
   * Allow anonymous contributions to this crowdsale.
   */
  function invest(address addr) public payable {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="519" endline="596" pcid="6100">
  function investInternal(address receiver, uint128 customerId) stopInEmergency private {

    // Determine if it's a good time to accept investment from this participant
    if(getState() == State.PreFunding) {
      // Are we whitelisted for early deposit
      throw;
    } else if(getState() == State.Funding) {
      // Retail participants can only come in when the crowdsale is running
      // pass
      if(isWhiteListed) {
        if(!earlyParticipantWhitelist[receiver].status) {
          throw;
        }
      }
    } else {
      // Unwanted state
      throw;
    }

    uint weiAmount = msg.value;

    // Account presale sales separately, so that they do not count against pricing tranches
    uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());

    if(tokenAmount == 0) {
      // Dust transaction
      throw;
    }

    if(isWhiteListed) {
      if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {
        // tokenAmount < minCap for investor
        throw;
      }

      // Check that we did not bust the investor's cap
      if (isBreakingInvestorCap(receiver, tokenAmount)) {
        throw;
      }

      updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);
    } else {
      if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {
        throw;
      }
    }

    if(investedAmountOf[receiver] == 0) {
       // A new investor
       investorCount++;
    }

    // Update investor
    investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);
    tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);

    // Update totals
    weiRaised = weiRaised.plus(weiAmount);
    tokensSold = tokensSold.plus(tokenAmount);

    // Check that we did not bust the cap
    if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {
      throw;
    }

    assignTokens(receiver, tokenAmount);

    // Pocket the money
    if(!multisigWallet.send(weiAmount)) throw;

    // Tell us invest was success
    Invested(receiver, weiAmount, tokenAmount, customerId);
  }

  /**
   * Allow anonymous contributions to this crowdsale.
   */
  function invest(address addr) public payable {
</source>
</class>

<class classid="449" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="601" endline="610" pcid="4861">
  function invest(address addr) public payable {
    investInternal(addr, 0);
  }

  /**
   * The basic entry point to participate the crowdsale process.
   *
   * Pay for funding, get invested tokens back in the sender address.
   */
  function buy() public payable {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="596" endline="605" pcid="6101">
  function invest(address addr) public payable {
    investInternal(addr, 0);
  }

  /**
   * The basic entry point to participate the crowdsale process.
   *
   * Pay for funding, get invested tokens back in the sender address.
   */
  function buy() public payable {
</source>
</class>

<class classid="450" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="610" endline="614" pcid="4862">
  function buy() public payable {
    invest(msg.sender);
  }

  function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="605" endline="609" pcid="6102">
  function buy() public payable {
    invest(msg.sender);
  }

  function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {
</source>
</class>

<class classid="451" nclones="4" nlines="11" similarity="75">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="614" endline="626" pcid="4863">
  function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {
    // Already finalized
    if(finalized) {
      throw;
    }

    // Finalizing is optional. We only call it if we are given a finalizing agent.
    if(address(finalizeAgent) != address(0)) {
      finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);
    }
  }

  function areReservedTokensDistributed() public constant returns (bool) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="636" endline="656" pcid="6106">
  function finalize() public inState(State.Success) onlyOwner stopInEmergency {

    // Already finalized
    if(finalized) {
      throw;
    }

    // Finalizing is optional. We only call it if we are given a finalizing agent.
    if(address(finalizeAgent) != address(0)) {
      finalizeAgent.finalizeCrowdsale();
    }

    finalized = true;
  }

  /**
   * Allow to (re)set finalize agent.
   *
   * Design choice: no state restrictions on setting this, so that we can fix fat finger mistakes.
   */
  function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="641" endline="661" pcid="4866">
  function finalize() public inState(State.Success) onlyOwner stopInEmergency {

    // Already finalized
    if(finalized) {
      throw;
    }

    // Finalizing is optional. We only call it if we are given a finalizing agent.
    if(address(finalizeAgent) != address(0)) {
      finalizeAgent.finalizeCrowdsale();
    }

    finalized = true;
  }

  /**
   * Allow to (re)set finalize agent.
   *
   * Design choice: no state restrictions on setting this, so that we can fix fat finger mistakes.
   */
  function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="609" endline="621" pcid="6103">
  function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {
    // Already finalized
    if(finalized) {
      throw;
    }

    // Finalizing is optional. We only call it if we are given a finalizing agent.
    if(address(finalizeAgent) != address(0)) {
      finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);
    }
  }

  function areReservedTokensDistributed() public constant returns (bool) {
</source>
</class>

<class classid="452" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="626" endline="630" pcid="4864">
  function areReservedTokensDistributed() public constant returns (bool) {
    return finalizeAgent.reservedTokensAreDistributed();
  }

  function canDistributeReservedTokens() public constant returns(bool) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="621" endline="625" pcid="6104">
  function areReservedTokensDistributed() public constant returns (bool) {
    return finalizeAgent.reservedTokensAreDistributed();
  }

  function canDistributeReservedTokens() public constant returns(bool) {
</source>
</class>

<class classid="453" nclones="2" nlines="5" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="630" endline="641" pcid="4865">
  function canDistributeReservedTokens() public constant returns(bool) {
    CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());
    if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;
    return false;
  }

  /**
   * Finalize a succcesful crowdsale.
   *
   * The owner can triggre a call the contract that provides post-crowdsale actions, like releasing the tokens.
   */
  function finalize() public inState(State.Success) onlyOwner stopInEmergency {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="625" endline="636" pcid="6105">
  function canDistributeReservedTokens() public constant returns(bool) {
    CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());
    if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;
    return false;
  }

  /**
   * Finalize a succcesful crowdsale.
   *
   * The owner can triggre a call the contract that provides post-crowdsale actions, like releasing the tokens.
   */
  function finalize() public inState(State.Success) onlyOwner stopInEmergency {
</source>
</class>

<class classid="454" nclones="2" nlines="12" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="675" endline="692" pcid="4868">
  function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {
    if (!isWhiteListed) throw;
    assert(addr != address(0));
    assert(maxCap > 0);
    assert(minCap <= maxCap);
    assert(now <= endsAt);

    if (!isAddressWhitelisted(addr)) {
      whitelistedParticipants.push(addr);
      Whitelisted(addr, status, minCap, maxCap);
    } else {
      WhitelistItemChanged(addr, status, minCap, maxCap);
    }

    earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});
  }

  function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="670" endline="687" pcid="6108">
  function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {
    if (!isWhiteListed) throw;
    assert(addr != address(0));
    assert(maxCap > 0);
    assert(minCap <= maxCap);
    assert(now <= endsAt);

    if (!isAddressWhitelisted(addr)) {
      whitelistedParticipants.push(addr);
      Whitelisted(addr, status, minCap, maxCap);
    } else {
      WhitelistItemChanged(addr, status, minCap, maxCap);
    }

    earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});
  }

  function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {
</source>
</class>

<class classid="455" nclones="2" nlines="7" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="692" endline="703" pcid="4869">
  function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {
    if (!isWhiteListed) throw;
    assert(now <= endsAt);
    assert(addrs.length == statuses.length);
    assert(statuses.length == minCaps.length);
    assert(minCaps.length == maxCaps.length);
    for (uint iterator = 0; iterator < addrs.length; iterator++) {
      setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);
    }
  }

  function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="687" endline="698" pcid="6109">
  function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {
    if (!isWhiteListed) throw;
    assert(now <= endsAt);
    assert(addrs.length == statuses.length);
    assert(statuses.length == minCaps.length);
    assert(minCaps.length == maxCaps.length);
    for (uint iterator = 0; iterator < addrs.length; iterator++) {
      setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);
    }
  }

  function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {
</source>
</class>

<class classid="456" nclones="2" nlines="7" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="703" endline="715" pcid="4870">
  function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {
    if (!isWhiteListed) throw;
    if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;

    uint8 tierPosition = getTierPosition(this);

    for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {
      CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);
      crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);
    }
  }

  function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="698" endline="710" pcid="6110">
  function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {
    if (!isWhiteListed) throw;
    if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;

    uint8 tierPosition = getTierPosition(this);

    for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {
      CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);
      crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);
    }
  }

  function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {
</source>
</class>

<class classid="457" nclones="2" nlines="5" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="715" endline="727" pcid="4871">
  function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {
    if (!isWhiteListed) throw;
    assert(addr != address(0));
    assert(now <= endsAt);
    assert(isTierJoined(msg.sender));
    if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;
    //if (addr != msg.sender && contractAddr != msg.sender) throw;
    uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;
    newMaxCap = newMaxCap.minus(tokensBought);
    earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});
  }

  function isAddressWhitelisted(address addr) public constant returns(bool) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="710" endline="722" pcid="6111">
  function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {
    if (!isWhiteListed) throw;
    assert(addr != address(0));
    assert(now <= endsAt);
    assert(isTierJoined(msg.sender));
    if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;
    //if (addr != msg.sender && contractAddr != msg.sender) throw;
    uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;
    newMaxCap = newMaxCap.minus(tokensBought);
    earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});
  }

  function isAddressWhitelisted(address addr) public constant returns(bool) {
</source>
</class>

<class classid="458" nclones="2" nlines="11" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="727" endline="738" pcid="4872">
  function isAddressWhitelisted(address addr) public constant returns(bool) {
    for (uint i = 0; i < whitelistedParticipants.length; i++) {
      if (whitelistedParticipants[i] == addr) {
        return true;
        break;
      }
    }

    return false;
  }

  function whitelistedParticipantsLength() public constant returns (uint) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="722" endline="733" pcid="6112">
  function isAddressWhitelisted(address addr) public constant returns(bool) {
    for (uint i = 0; i < whitelistedParticipants.length; i++) {
      if (whitelistedParticipants[i] == addr) {
        return true;
        break;
      }
    }

    return false;
  }

  function whitelistedParticipantsLength() public constant returns (uint) {
</source>
</class>

<class classid="459" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="738" endline="742" pcid="4873">
  function whitelistedParticipantsLength() public constant returns (uint) {
    return whitelistedParticipants.length;
  }

  function isTierJoined(address addr) public constant returns(bool) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="733" endline="737" pcid="6113">
  function whitelistedParticipantsLength() public constant returns (uint) {
    return whitelistedParticipants.length;
  }

  function isTierJoined(address addr) public constant returns(bool) {
</source>
</class>

<class classid="460" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="742" endline="746" pcid="4874">
  function isTierJoined(address addr) public constant returns(bool) {
    return joinedCrowdsaleState[addr].isJoined;
  }

  function getTierPosition(address addr) public constant returns(uint8) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="737" endline="741" pcid="6114">
  function isTierJoined(address addr) public constant returns(bool) {
    return joinedCrowdsaleState[addr].isJoined;
  }

  function getTierPosition(address addr) public constant returns(uint8) {
</source>
</class>

<class classid="461" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="746" endline="750" pcid="4875">
  function getTierPosition(address addr) public constant returns(uint8) {
    return joinedCrowdsaleState[addr].position;
  }

  function getLastTier() public constant returns(address) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="741" endline="745" pcid="6115">
  function getTierPosition(address addr) public constant returns(uint8) {
    return joinedCrowdsaleState[addr].position;
  }

  function getLastTier() public constant returns(address) {
</source>
</class>

<class classid="462" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="750" endline="757" pcid="4876">
  function getLastTier() public constant returns(address) {
    if (joinedCrowdsalesLen > 0)
      return joinedCrowdsales[joinedCrowdsalesLen - 1];
    else
      return address(0);
  }

  function setJoinedCrowdsales(address addr) private onlyOwner {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="745" endline="752" pcid="6116">
  function getLastTier() public constant returns(address) {
    if (joinedCrowdsalesLen > 0)
      return joinedCrowdsales[joinedCrowdsalesLen - 1];
    else
      return address(0);
  }

  function setJoinedCrowdsales(address addr) private onlyOwner {
</source>
</class>

<class classid="463" nclones="2" nlines="5" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="757" endline="769" pcid="4877">
  function setJoinedCrowdsales(address addr) private onlyOwner {
    assert(addr != address(0));
    assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);
    assert(!isTierJoined(addr));
    joinedCrowdsales.push(addr);
    joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({
      isJoined: true,
      position: joinedCrowdsalesLen
    });
    joinedCrowdsalesLen++;
  }

  function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="752" endline="764" pcid="6117">
  function setJoinedCrowdsales(address addr) private onlyOwner {
    assert(addr != address(0));
    assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);
    assert(!isTierJoined(addr));
    joinedCrowdsales.push(addr);
    joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({
      isJoined: true,
      position: joinedCrowdsalesLen
    });
    joinedCrowdsalesLen++;
  }

  function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {
</source>
</class>

<class classid="464" nclones="2" nlines="7" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="769" endline="778" pcid="4878">
  function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {
    assert(addrs.length > 0);
    assert(joinedCrowdsalesLen == 0);
    assert(addrs.length <= joinedCrowdsalesLenMax);
    for (uint8 iter = 0; iter < addrs.length; iter++) {
      setJoinedCrowdsales(addrs[iter]);
    }
  }

  function setStartsAt(uint time) onlyOwner {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="764" endline="773" pcid="6118">
  function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {
    assert(addrs.length > 0);
    assert(joinedCrowdsalesLen == 0);
    assert(addrs.length <= joinedCrowdsalesLenMax);
    for (uint8 iter = 0; iter < addrs.length; iter++) {
      setJoinedCrowdsales(addrs[iter]);
    }
  }

  function setStartsAt(uint time) onlyOwner {
</source>
</class>

<class classid="465" nclones="2" nlines="9" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="778" endline="810" pcid="4879">
  function setStartsAt(uint time) onlyOwner {
    assert(!finalized);
    assert(isUpdatable);
    assert(now <= time); // Don't change past
    assert(time <= endsAt);
    assert(now <= startsAt);

    CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());
    if (lastTierCntrct.finalized()) throw;

    uint8 tierPosition = getTierPosition(this);

    //start time should be greater then end time of previous tiers
    for (uint8 j = 0; j < tierPosition; j++) {
      CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);
      assert(time >= crowdsale.endsAt());
    }

    startsAt = time;
    StartsAtChanged(startsAt);
  }

  /**
   * Allow crowdsale owner to close early or extend the crowdsale.
   *
   * This is useful e.g. for a manual soft cap implementation:
   * - after X amount is reached determine manual closing
   *
   * This may put the crowdsale to an invalid state,
   * but we trust owners know what they are doing.
   *
   */
  function setEndsAt(uint time) public onlyOwner {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="773" endline="805" pcid="6119">
  function setStartsAt(uint time) onlyOwner {
    assert(!finalized);
    assert(isUpdatable);
    assert(now <= time); // Don't change past
    assert(time <= endsAt);
    assert(now <= startsAt);

    CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());
    if (lastTierCntrct.finalized()) throw;

    uint8 tierPosition = getTierPosition(this);

    //start time should be greater then end time of previous tiers
    for (uint8 j = 0; j < tierPosition; j++) {
      CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);
      assert(time >= crowdsale.endsAt());
    }

    startsAt = time;
    StartsAtChanged(startsAt);
  }

  /**
   * Allow crowdsale owner to close early or extend the crowdsale.
   *
   * This is useful e.g. for a manual soft cap implementation:
   * - after X amount is reached determine manual closing
   *
   * This may put the crowdsale to an invalid state,
   * but we trust owners know what they are doing.
   *
   */
  function setEndsAt(uint time) public onlyOwner {
</source>
</class>

<class classid="466" nclones="2" nlines="9" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="810" endline="837" pcid="4880">
  function setEndsAt(uint time) public onlyOwner {
    assert(!finalized);
    assert(isUpdatable);
    assert(now <= time);// Don't change past
    assert(startsAt <= time);
    assert(now <= endsAt);

    CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());
    if (lastTierCntrct.finalized()) throw;


    uint8 tierPosition = getTierPosition(this);

    for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {
      CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);
      assert(time <= crowdsale.startsAt());
    }

    endsAt = time;
    EndsAtChanged(endsAt);
  }

  /**
   * Allow to (re)set pricing strategy.
   *
   * Design choice: no state restrictions on the set, so that we can fix fat finger mistakes.
   */
  function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="805" endline="832" pcid="6120">
  function setEndsAt(uint time) public onlyOwner {
    assert(!finalized);
    assert(isUpdatable);
    assert(now <= time);// Don't change past
    assert(startsAt <= time);
    assert(now <= endsAt);

    CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());
    if (lastTierCntrct.finalized()) throw;


    uint8 tierPosition = getTierPosition(this);

    for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {
      CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);
      assert(time <= crowdsale.startsAt());
    }

    endsAt = time;
    EndsAtChanged(endsAt);
  }

  /**
   * Allow to (re)set pricing strategy.
   *
   * Design choice: no state restrictions on the set, so that we can fix fat finger mistakes.
   */
  function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {
</source>
</class>

<class classid="467" nclones="2" nlines="8" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="855" endline="868" pcid="4882">
  function setMultisig(address addr) public onlyOwner {

    // Change
    if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {
      throw;
    }

    multisigWallet = addr;
  }

  /**
   * @return true if the crowdsale has raised enough money to be a successful.
   */
  function isMinimumGoalReached() public constant returns (bool reached) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="850" endline="863" pcid="6122">
  function setMultisig(address addr) public onlyOwner {

    // Change
    if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {
      throw;
    }

    multisigWallet = addr;
  }

  /**
   * @return true if the crowdsale has raised enough money to be a successful.
   */
  function isMinimumGoalReached() public constant returns (bool reached) {
</source>
</class>

<class classid="468" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="868" endline="875" pcid="4883">
  function isMinimumGoalReached() public constant returns (bool reached) {
    return weiRaised >= minimumFundingGoal;
  }

  /**
   * Check if the contract relationship looks good.
   */
  function isFinalizerSane() public constant returns (bool sane) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="863" endline="870" pcid="6123">
  function isMinimumGoalReached() public constant returns (bool reached) {
    return weiRaised >= minimumFundingGoal;
  }

  /**
   * Check if the contract relationship looks good.
   */
  function isFinalizerSane() public constant returns (bool sane) {
</source>
</class>

<class classid="469" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="875" endline="882" pcid="4884">
  function isFinalizerSane() public constant returns (bool sane) {
    return finalizeAgent.isSane();
  }

  /**
   * Check if the contract relationship looks good.
   */
  function isPricingSane() public constant returns (bool sane) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="870" endline="877" pcid="6124">
  function isFinalizerSane() public constant returns (bool sane) {
    return finalizeAgent.isSane();
  }

  /**
   * Check if the contract relationship looks good.
   */
  function isPricingSane() public constant returns (bool sane) {
</source>
</class>

<class classid="470" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="882" endline="891" pcid="4885">
  function isPricingSane() public constant returns (bool sane) {
    return pricingStrategy.isSane(address(this));
  }

  /**
   * Crowdfund state machine management.
   *
   * We make it a function and do not assign the result to a variable, so there is no chance of the variable being stale.
   */
  function getState() public constant returns (State) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="877" endline="886" pcid="6125">
  function isPricingSane() public constant returns (bool sane) {
    return pricingStrategy.isSane(address(this));
  }

  /**
   * Crowdfund state machine management.
   *
   * We make it a function and do not assign the result to a variable, so there is no chance of the variable being stale.
   */
  function getState() public constant returns (State) {
</source>
</class>

<class classid="471" nclones="2" nlines="5" similarity="100">
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="891" endline="903" pcid="4886">
  function getState() public constant returns (State) {
    if(finalized) return State.Finalized;
    else if (address(finalizeAgent) == 0) return State.Preparing;
    else if (!finalizeAgent.isSane()) return State.Preparing;
    else if (!pricingStrategy.isSane(address(this))) return State.Preparing;
    else if (block.timestamp < startsAt) return State.PreFunding;
    else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;
    else if (isMinimumGoalReached()) return State.Success;
    else return State.Failure;
  }

  /** Interface marker. */
  function isCrowdsale() public constant returns (bool) {
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="886" endline="898" pcid="6126">
  function getState() public constant returns (State) {
    if(finalized) return State.Finalized;
    else if (address(finalizeAgent) == 0) return State.Preparing;
    else if (!finalizeAgent.isSane()) return State.Preparing;
    else if (!pricingStrategy.isSane(address(this))) return State.Preparing;
    else if (block.timestamp < startsAt) return State.PreFunding;
    else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;
    else if (isMinimumGoalReached()) return State.Success;
    else return State.Failure;
  }

  /** Interface marker. */
  function isCrowdsale() public constant returns (bool) {
</source>
</class>

<class classid="472" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/Mlgc.sol" startline="45" endline="59" pcid="4917">
    function approveAndCall(address _spender, uint256 _amount, bytes calldata _extraData) external returns (bool success)
	{
        require(approve(_spender, _amount), "ERC20: Approve unsuccesfull");
        ContractFallbacks(_spender).receiveApproval(msg.sender, _amount, address(this), _extraData);
        return true;
    }

    /**
     * @dev function that transer tokens to diven address and call function on that address
     * @param _to address to send tokens and call
     * @param _value amount of tokens
     * @param _data optional extra data to process in calling contract
     * @return success True if all succedd
     */
	function transferAndCall(address _to, uint _value, bytes calldata _data) external returns (bool success)
</source>
<source file="systems/smart_contracts/Wolfs.sol" startline="44" endline="58" pcid="8035">
    function approveAndCall(address _spender, uint256 _amount, bytes calldata _extraData) external returns (bool success)
	{
        require(approve(_spender, _amount), "ERC20: Approve unsuccesfull");
        ContractFallbacks(_spender).receiveApproval(msg.sender, _amount, address(this), _extraData);
        return true;
    }

    /**
     * @dev function that transer tokens to diven address and call function on that address
     * @param _to address to send tokens and call
     * @param _value amount of tokens
     * @param _data optional extra data to process in calling contract
     * @return success True if all succedd
     */
	function transferAndCall(address _to, uint _value, bytes calldata _data) external returns (bool success)
</source>
</class>

<class classid="473" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/Mlgc.sol" startline="59" endline="66" pcid="4918">
	function transferAndCall(address _to, uint _value, bytes calldata _data) external returns (bool success)
  	{
  	    _transfer(msg.sender, _to, _value);
		ContractFallbacks(_to).onTokenTransfer(msg.sender, _value, _data);
		return true;
  	}

}
</source>
<source file="systems/smart_contracts/Wolfs.sol" startline="58" endline="65" pcid="8036">
	function transferAndCall(address _to, uint _value, bytes calldata _data) external returns (bool success)
  	{
  	    _transfer(msg.sender, _to, _value);
		ContractFallbacks(_to).onTokenTransfer(msg.sender, _value, _data);
		return true;
  	}

}
</source>
</class>

<class classid="474" nclones="6" nlines="4" similarity="100">
<source file="systems/smart_contracts/Moshlink.sol" startline="212" endline="228" pcid="4990">
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="46" endline="56" pcid="5331">
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="59" endline="75" pcid="5410">
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="140" endline="156" pcid="5910">
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="19" endline="26" pcid="8039">
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="44" endline="54" pcid="7773">
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
</class>

<class classid="475" nclones="6" nlines="4" similarity="75">
<source file="systems/smart_contracts/Moshlink.sol" startline="268" endline="288" pcid="4993">
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="196" endline="216" pcid="5913">
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="77" endline="87" pcid="7776">
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, errorMessage);
        return a / b;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="79" endline="89" pcid="5334">
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, errorMessage);
        return a / b;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="115" endline="135" pcid="5413">
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="41" endline="50" pcid="8042">
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
</source>
</class>

<class classid="476" nclones="6" nlines="4" similarity="100">
<source file="systems/smart_contracts/Moshlink.sol" startline="303" endline="307" pcid="4995">
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="97" endline="101" pcid="5336">
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="95" endline="99" pcid="7778">
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="150" endline="154" pcid="5415">
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/WTA.sol" startline="54" endline="58" pcid="8044">
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="231" endline="235" pcid="5915">
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}
</source>
</class>

<class classid="477" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/Moshlink.sol" startline="708" endline="725" pcid="5025">
    function _mint(address to, uint256 tokenId) internal {
        require(to != address(0), "ERC721: mint to the zero address");
        require(!_exists(tokenId), "ERC721: token already minted");

        _tokenOwner[tokenId] = to;
        _ownedTokensCount[to].increment();

        emit Transfer(address(0), to, tokenId);
    }

    /**
     * @dev Internal function to burn a specific token.
     * Reverts if the token does not exist.
     * Deprecated, use {_burn} instead.
     * @param owner owner of the token to burn
     * @param tokenId uint256 ID of the token being burned
     */
    function _burn(address owner, uint256 tokenId) internal {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="1013" endline="1028" pcid="5047">
    function _mint(address to, uint256 tokenId) internal {
        super._mint(to, tokenId);

        _addTokenToOwnerEnumeration(to, tokenId);

        _addTokenToAllTokensEnumeration(tokenId);
    }

    /**
     * @dev Internal function to burn a specific token.
     * Reverts if the token does not exist.
     * Deprecated, use {ERC721-_burn} instead.
     * @param owner owner of the token to burn
     * @param tokenId uint256 ID of the token being burned
     */
    function _burn(address owner, uint256 tokenId) internal {
</source>
</class>

<class classid="478" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/Moshlink.sol" startline="725" endline="741" pcid="5026">
    function _burn(address owner, uint256 tokenId) internal {
        require(ownerOf(tokenId) == owner, "ERC721: burn of token that is not own");

        _clearApproval(tokenId);

        _ownedTokensCount[owner].decrement();
        _tokenOwner[tokenId] = address(0);

        emit Transfer(owner, address(0), tokenId);
    }

    /**
     * @dev Internal function to burn a specific token.
     * Reverts if the token does not exist.
     * @param tokenId uint256 ID of the token being burned
     */
    function _burn(uint256 tokenId) internal {
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="1028" endline="1043" pcid="5048">
    function _burn(address owner, uint256 tokenId) internal {
        super._burn(owner, tokenId);

        _removeTokenFromOwnerEnumeration(owner, tokenId);
        // Since tokenId will be deleted, we can clear its slot in _ownedTokensIndex to trigger a gas refund
        _ownedTokensIndex[tokenId] = 0;

        _removeTokenFromAllTokensEnumeration(tokenId);
    }

    /**
     * @dev Gets the list of token IDs of the requested owner.
     * @param owner address owning the tokens
     * @return uint256[] List of token IDs owned by the requested address
     */
    function _tokensOfOwner(address owner) internal view returns (uint256[] storage) {
</source>
</class>

<class classid="479" nclones="2" nlines="10" similarity="100">
<source file="systems/smart_contracts/multifind.sol" startline="17" endline="27" pcid="5081">
    function withdraw(string key) public payable
    {
        require(msg.sender == tx.origin);
        if(keyHash == keccak256(abi.encodePacked(key))) {
            if(msg.value > 0.4 ether) {
                msg.sender.transfer(address(this).balance);
            }
        }
    }

    function setup_key(string key) public
</source>
<source file="systems/smart_contracts/multifund.sol" startline="17" endline="27" pcid="5136">
    function withdraw(string key) public payable
    {
        require(msg.sender == tx.origin);
        if(keyHash == keccak256(abi.encodePacked(key))) {
            if(msg.value > 0.4 ether) {
                msg.sender.transfer(address(this).balance);
            }
        }
    }

    function setup_key(string key) public
</source>
</class>

<class classid="480" nclones="4" nlines="7" similarity="71">
<source file="systems/smart_contracts/multifind.sol" startline="27" endline="34" pcid="5082">
    function setup_key(string key) public
    {
        if (keyHash == 0x0) {
            keyHash = keccak256(abi.encodePacked(key));
        }
    }

    function update_new_hash(bytes32 new_hash) public
</source>
<source file="systems/smart_contracts/multifund.sol" startline="34" endline="41" pcid="5138">
    function update_new_hash(bytes32 new_hash) public
    {
        if (keyHash == 0x0) {
            keyHash = new_hash;
        }
    }

    function clear() public
</source>
<source file="systems/smart_contracts/multifind.sol" startline="34" endline="41" pcid="5083">
    function update_new_hash(bytes32 new_hash) public
    {
        if (keyHash == 0x0) {
            keyHash = new_hash;
        }
    }

    function clear() public
</source>
<source file="systems/smart_contracts/multifund.sol" startline="27" endline="34" pcid="5137">
    function setup_key(string key) public
    {
        if (keyHash == 0x0) {
            keyHash = keccak256(abi.encodePacked(key));
        }
    }

    function update_new_hash(bytes32 new_hash) public
</source>
</class>

<class classid="481" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/multifind.sol" startline="41" endline="47" pcid="5084">
    function clear() public
    {
        require(msg.sender == owner);
        selfdestruct(owner);
    }

    function get_id() public view returns(bytes32){
</source>
<source file="systems/smart_contracts/multifund.sol" startline="41" endline="47" pcid="5139">
    function clear() public
    {
        require(msg.sender == owner);
        selfdestruct(owner);
    }

    function get_id() public view returns(bytes32){
</source>
</class>

<class classid="482" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/multifind.sol" startline="47" endline="51" pcid="5085">
    function get_id() public view returns(bytes32){
        return wallet_id;
    }

    function () public payable {
</source>
<source file="systems/smart_contracts/multifund.sol" startline="47" endline="51" pcid="5140">
    function get_id() public view returns(bytes32){
        return wallet_id;
    }

    function () public payable {
</source>
</class>

<class classid="483" nclones="3" nlines="4" similarity="75">
<source file="systems/smart_contracts/Multisig.sol" startline="43" endline="50" pcid="5217">
  function getOwners()
    public
    view
  returns(address[] memory) {
    return owners;
  }

  function getOwnershipAdditions(address _account)
</source>
<source file="systems/smart_contracts/MultiSigWallet.sol" startline="342" endline="353" pcid="5256">
    function getOwners()
        public
        constant
        returns (address[])
    {
        return owners;
    }

    /// @dev Returns array with owner addresses, which confirmed transaction.
    /// @param transactionId Transaction ID.
    /// @return Returns array of owner addresses.
    function getConfirmations(uint transactionId)
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="219" endline="230" pcid="6600">
	function getOwners() public view returns (address[] memory) {
		address[] memory result = new address[](m_numOwners);
		for (uint256 i = 0; i < m_numOwners; i++)
			result[i] = getOwner(i);

		return result;
	}

	/// @notice checks if provided address is an owner address
	/// @param _addr address to check
	/// @return true if it's an owner
	function isOwner(address _addr) public view returns (bool) {
</source>
</class>

<class classid="484" nclones="2" nlines="5" similarity="100">
<source file="systems/smart_contracts/NewVoken.sol" startline="238" endline="252" pcid="5354">
    function acceptOwnership() public {
        require(msg.sender == _newOwner, "Ownable: caller is not the new owner address");
        require(msg.sender != address(0), "Ownable: caller is the zero address");

        emit OwnershipAccepted(_owner, msg.sender);
        _owner = msg.sender;
        _newOwner = address(0);
    }

    /**
     * @dev Rescue compatible ERC20 Token
     *
     * Can only be called by the current owner.
     */
    function rescueTokens(address tokenAddr, address recipient, uint256 amount) external onlyOwner {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="278" endline="292" pcid="7800">
    function acceptOwnership() public {
        require(msg.sender == _newOwner, "Ownable: caller is not the new owner address");
        require(msg.sender != address(0), "Ownable: caller is the zero address");

        emit OwnershipAccepted(_owner, msg.sender);
        _owner = msg.sender;
        _newOwner = address(0);
    }

    /**
     * @dev Rescue compatible ERC20 Token
     *
     * Can only be called by the current owner.
     */
    function rescueTokens(address tokenAddr, address recipient, uint256 amount) external onlyOwner {
</source>
</class>

<class classid="485" nclones="2" nlines="5" similarity="100">
<source file="systems/smart_contracts/NewVoken.sol" startline="252" endline="266" pcid="5355">
    function rescueTokens(address tokenAddr, address recipient, uint256 amount) external onlyOwner {
        IERC20 _token = IERC20(tokenAddr);
        require(recipient != address(0), "Rescue: recipient is the zero address");
        uint256 balance = _token.balanceOf(address(this));

        require(balance >= amount, "Rescue: amount exceeds balance");
        _token.transfer(recipient, amount);
    }

    /**
     * @dev Withdraw Ether
     *
     * Can only be called by the current owner.
     */
    function withdrawEther(address payable recipient, uint256 amount) external onlyOwner {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="292" endline="306" pcid="7801">
    function rescueTokens(address tokenAddr, address recipient, uint256 amount) external onlyOwner {
        IERC20 _token = IERC20(tokenAddr);
        require(recipient != address(0), "Rescue: recipient is the zero address");
        uint256 balance = _token.balanceOf(address(this));

        require(balance >= amount, "Rescue: amount exceeds balance");
        _token.transfer(recipient, amount);
    }

    /**
     * @dev Withdraw Ether
     *
     * Can only be called by the current owner.
     */
    function withdrawEther(address payable recipient, uint256 amount) external onlyOwner {
</source>
</class>

<class classid="486" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/NewVoken.sol" startline="266" endline="274" pcid="5356">
    function withdrawEther(address payable recipient, uint256 amount) external onlyOwner {
        require(recipient != address(0), "Withdraw: recipient is the zero address");

        uint256 balance = address(this).balance;

        require(balance >= amount, "Withdraw: amount exceeds balance");
        recipient.transfer(amount);
    }
}
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="306" endline="318" pcid="7802">
    function withdrawEther(address payable recipient, uint256 amount) external onlyOwner {
        require(recipient != address(0), "Withdraw: recipient is the zero address");

        uint256 balance = address(this).balance;

        require(balance >= amount, "Withdraw: amount exceeds balance");
        recipient.transfer(amount);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     */
    function _transferOwnership(address newOwner) internal {
</source>
</class>

<class classid="487" nclones="2" nlines="11" similarity="90">
<source file="systems/smart_contracts/NewVoken.sol" startline="464" endline="480" pcid="5366">
    function reservedOf(address account) public view returns (uint256) {
        uint256 __reserved;

        uint256 __len = _allocations[account].length;
        if (__len > 0) {
            for (uint256 i = 0; i < __len; i++) {
                __reserved = __reserved.add(_allocations[account][i].reservedOf(account));
            }
        }

        return __reserved;
    }

    /**
     * @dev Returns the available amount of VOKEN by `account`.
     */
    function availableOf(address account) public view returns (uint256) {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="594" endline="614" pcid="7823">
    function reservedOf(address account) public view returns (uint256) {
        uint256 __reserved;

        uint256 __len = _allocations[account].length;
        if (__len > 0) {
            for (uint256 i = 0; i < __len; i++) {
                __reserved = __reserved.add(_allocations[account][i].reserved());
            }
        }

        return __reserved;
    }

    /**
     * @dev Creates `amount` VOKENs and assigns them to `account`.
     *
     * With an `allocation`.
     *
     * Can only be called by a minter.
     */
    function _mintWithAllocation(address account, uint256 amount) internal returns (bool) {
</source>
</class>

<class classid="488" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/NewVoken.sol" startline="950" endline="959" pcid="5402">
    function isProxy(address account) public view returns (bool) {
        return _proxies.has(account);
    }

    /**
     * @dev Give an `account` access to the Proxy role.
     *
     * Can only be called by the current owner.
     */
    function addProxy(address account) public onlyOwner {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="540" endline="549" pcid="7818">
    function isProxy(address account) public view returns (bool) {
        return _proxies.has(account);
    }

    /**
     * @dev Give an `account` access to the Proxy role.
     *
     * Can only be called by the current owner.
     */
    function addProxy(address account) public onlyOwner {
</source>
</class>

<class classid="489" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/NewVoken.sol" startline="959" endline="969" pcid="5403">
    function addProxy(address account) public onlyOwner {
        _proxies.add(account);
        emit ProxyAdded(account);
    }

    /**
     * @dev Remove an `account` access from the Proxy role.
     *
     * Can only be called by the current owner.
     */
    function removeProxy(address account) public onlyOwner {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="549" endline="559" pcid="7819">
    function addProxy(address account) public onlyOwner {
        _proxies.add(account);
        emit ProxyAdded(account);
    }

    /**
     * @dev Remove an `account` access from the Proxy role.
     *
     * Can only be called by the current owner.
     */
    function removeProxy(address account) public onlyOwner {
</source>
</class>

<class classid="490" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/NewVoken.sol" startline="969" endline="977" pcid="5404">
    function removeProxy(address account) public onlyOwner {
        _proxies.remove(account);
        emit ProxyRemoved(account);
    }

    /**
     * @dev Throws if called by account which is not a minter.
     */
    modifier onlyMinter() {
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="559" endline="567" pcid="7820">
    function removeProxy(address account) public onlyOwner {
        _proxies.remove(account);
        emit ProxyRemoved(account);
    }

    /**
     * @dev Returns the allocations counter on `account`.
     */
    function allocations(address account) public view returns (uint256 allocationsCounter) {
</source>
</class>

<class classid="491" nclones="3" nlines="5" similarity="100">
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="378" endline="396" pcid="5430">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="390" endline="408" pcid="5924">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
</source>
<source file="systems/smart_contracts/WTA.sol" startline="149" endline="158" pcid="8064">
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _burn(address account, uint256 value) internal {
</source>
</class>

<class classid="492" nclones="3" nlines="4" similarity="100">
<source file="systems/smart_contracts/Oracle.sol" startline="120" endline="125" pcid="5515">
  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {
    c = _a + _b;
    assert(c >= _a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/PositionTokenV2.sol" startline="113" endline="118" pcid="5755">
  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {
    c = _a + _b;
    assert(c >= _a);
    return c;
  }
}
</source>
<source file="systems/smart_contracts/TimeLockedTokenStorage.sol" startline="46" endline="51" pcid="7223">
    function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {
        c = _a + _b;
        assert(c >= _a);
        return c;
    }
}
</source>
</class>

<class classid="493" nclones="2" nlines="5" similarity="100">
<source file="systems/smart_contracts/PokaToken.sol" startline="108" endline="121" pcid="5740">
    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
		require(_value > 0); 
        require(balanceOf[msg.sender] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
		uint previousBalances = balanceOf[msg.sender] + balanceOf[_to];		
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);
        emit Transfer(msg.sender, _to, _value);
		assert(balanceOf[msg.sender]+balanceOf[_to]==previousBalances);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
<source file="systems/smart_contracts/SuperMarket.sol" startline="108" endline="121" pcid="6768">
    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
		require(_value > 0); 
        require(balanceOf[msg.sender] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
		uint previousBalances = balanceOf[msg.sender] + balanceOf[_to];		
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);
        emit Transfer(msg.sender, _to, _value);
		assert(balanceOf[msg.sender]+balanceOf[_to]==previousBalances);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
</source>
</class>

<class classid="494" nclones="2" nlines="5" similarity="100">
<source file="systems/smart_contracts/PokaToken.sol" startline="128" endline="140" pcid="5742">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require (_to != address(0));
		require (_value > 0); 
        require (balanceOf[_from] >= _value) ;
        require (balanceOf[_to] + _value > balanceOf[_to]);
        require (_value <= allowance[_from][msg.sender]);
        balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);
        allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value);
        emit Transfer(_from, _to, _value);
        return true;
    }
}
</source>
<source file="systems/smart_contracts/SuperMarket.sol" startline="128" endline="140" pcid="6770">
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require (_to != address(0));
		require (_value > 0); 
        require (balanceOf[_from] >= _value) ;
        require (balanceOf[_to] + _value > balanceOf[_to]);
        require (_value <= allowance[_from][msg.sender]);
        balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);
        allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value);
        emit Transfer(_from, _to, _value);
        return true;
    }
}
</source>
</class>

<class classid="495" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/ProxyERC20.sol" startline="67" endline="78" pcid="5875">
    function nominateNewOwner(address _owner)
        external
        onlyOwner
    {
        nominatedOwner = _owner;
        emit OwnerNominated(_owner);
    }

    /**
     * @notice Accept the nomination to be owner.
     */
    function acceptOwnership()
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="391" endline="402" pcid="6841">
    function nominateNewOwner(address _owner)
        external
        onlyOwner
    {
        nominatedOwner = _owner;
        emit OwnerNominated(_owner);
    }

    /**
     * @notice Accept the nomination to be owner.
     */
    function acceptOwnership()
</source>
</class>

<class classid="496" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/ProxyERC20.sol" startline="140" endline="148" pcid="5877">
    function setTarget(Proxyable _target)
        external
        onlyOwner
    {
        target = _target;
        emit TargetUpdated(_target);
    }

    function setUseDELEGATECALL(bool value) 
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="733" endline="741" pcid="6850">
    function setTarget(Proxyable _target)
        external
        onlyOwner
    {
        target = _target;
        emit TargetUpdated(_target);
    }

    function setUseDELEGATECALL(bool value) 
</source>
</class>

<class classid="497" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/ProxyERC20.sol" startline="148" endline="155" pcid="5878">
    function setUseDELEGATECALL(bool value) 
        external
        onlyOwner
    {
        useDELEGATECALL = value;
    }

    function _emit(bytes callData, uint numTopics, bytes32 topic1, bytes32 topic2, bytes32 topic3, bytes32 topic4)
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="741" endline="748" pcid="6851">
    function setUseDELEGATECALL(bool value) 
        external
        onlyOwner
    {
        useDELEGATECALL = value;
    }

    function _emit(bytes callData, uint numTopics, bytes32 topic1, bytes32 topic2, bytes32 topic3, bytes32 topic4)
</source>
</class>

<class classid="498" nclones="2" nlines="5" similarity="100">
<source file="systems/smart_contracts/ProxyERC20.sol" startline="155" endline="187" pcid="5879">
    function _emit(bytes callData, uint numTopics, bytes32 topic1, bytes32 topic2, bytes32 topic3, bytes32 topic4)
        external
        onlyTarget
    {
        uint size = callData.length;
        bytes memory _callData = callData;

        assembly {
            /* The first 32 bytes of callData contain its length (as specified by the abi). 
             * Length is assumed to be a uint256 and therefore maximum of 32 bytes
             * in length. It is also leftpadded to be a multiple of 32 bytes.
             * This means moving call_data across 32 bytes guarantees we correctly access
             * the data itself. */
            switch numTopics
            case 0 {
                log0(add(_callData, 32), size)
            } 
            case 1 {
                log1(add(_callData, 32), size, topic1)
            }
            case 2 {
                log2(add(_callData, 32), size, topic1, topic2)
            }
            case 3 {
                log3(add(_callData, 32), size, topic1, topic2, topic3)
            }
            case 4 {
                log4(add(_callData, 32), size, topic1, topic2, topic3, topic4)
            }
        }
    }

    function()
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="748" endline="780" pcid="6852">
    function _emit(bytes callData, uint numTopics, bytes32 topic1, bytes32 topic2, bytes32 topic3, bytes32 topic4)
        external
        onlyTarget
    {
        uint size = callData.length;
        bytes memory _callData = callData;

        assembly {
            /* The first 32 bytes of callData contain its length (as specified by the abi). 
             * Length is assumed to be a uint256 and therefore maximum of 32 bytes
             * in length. It is also leftpadded to be a multiple of 32 bytes.
             * This means moving call_data across 32 bytes guarantees we correctly access
             * the data itself. */
            switch numTopics
            case 0 {
                log0(add(_callData, 32), size)
            } 
            case 1 {
                log1(add(_callData, 32), size, topic1)
            }
            case 2 {
                log2(add(_callData, 32), size, topic1, topic2)
            }
            case 3 {
                log3(add(_callData, 32), size, topic1, topic2, topic3)
            }
            case 4 {
                log4(add(_callData, 32), size, topic1, topic2, topic3, topic4)
            }
        }
    }

    function()
</source>
</class>

<class classid="499" nclones="2" nlines="13" similarity="100">
<source file="systems/smart_contracts/ProxyERC20.sol" startline="187" endline="223" pcid="5880">
    function()
        external
        payable
    {
        if (useDELEGATECALL) {
            assembly {
                /* Copy call data into free memory region. */
                let free_ptr := mload(0x40)
                calldatacopy(free_ptr, 0, calldatasize)

                /* Forward all gas and call data to the target contract. */
                let result := delegatecall(gas, sload(target_slot), free_ptr, calldatasize, 0, 0)
                returndatacopy(free_ptr, 0, returndatasize)

                /* Revert if the call failed, otherwise return the result. */
                if iszero(result) { revert(free_ptr, returndatasize) }
                return(free_ptr, returndatasize)
            }
        } else {
            /* Here we are as above, but must send the messageSender explicitly 
             * since we are using CALL rather than DELEGATECALL. */
            target.setMessageSender(msg.sender);
            assembly {
                let free_ptr := mload(0x40)
                calldatacopy(free_ptr, 0, calldatasize)

                /* We must explicitly forward ether to the underlying contract as well. */
                let result := call(gas, sload(target_slot), callvalue, free_ptr, calldatasize, 0, 0)
                returndatacopy(free_ptr, 0, returndatasize)

                if iszero(result) { revert(free_ptr, returndatasize) }
                return(free_ptr, returndatasize)
            }
        }
    }

    modifier onlyTarget {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="780" endline="816" pcid="6853">
    function()
        external
        payable
    {
        if (useDELEGATECALL) {
            assembly {
                /* Copy call data into free memory region. */
                let free_ptr := mload(0x40)
                calldatacopy(free_ptr, 0, calldatasize)

                /* Forward all gas and call data to the target contract. */
                let result := delegatecall(gas, sload(target_slot), free_ptr, calldatasize, 0, 0)
                returndatacopy(free_ptr, 0, returndatasize)

                /* Revert if the call failed, otherwise return the result. */
                if iszero(result) { revert(free_ptr, returndatasize) }
                return(free_ptr, returndatasize)
            }
        } else {
            /* Here we are as above, but must send the messageSender explicitly 
             * since we are using CALL rather than DELEGATECALL. */
            target.setMessageSender(msg.sender);
            assembly {
                let free_ptr := mload(0x40)
                calldatacopy(free_ptr, 0, calldatasize)

                /* We must explicitly forward ether to the underlying contract as well. */
                let result := call(gas, sload(target_slot), callvalue, free_ptr, calldatasize, 0, 0)
                returndatacopy(free_ptr, 0, returndatasize)

                if iszero(result) { revert(free_ptr, returndatasize) }
                return(free_ptr, returndatasize)
            }
        }
    }

    modifier onlyTarget {
</source>
</class>

<class classid="500" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/ProxyERC20.sol" startline="277" endline="285" pcid="5881">
    function setProxy(address _proxy)
        external
        onlyOwner
    {
        proxy = Proxy(_proxy);
        emit ProxyUpdated(_proxy);
    }

    function setIntegrationProxy(address _integrationProxy)
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="870" endline="878" pcid="6854">
    function setProxy(address _proxy)
        external
        onlyOwner
    {
        proxy = Proxy(_proxy);
        emit ProxyUpdated(_proxy);
    }

    function setIntegrationProxy(address _integrationProxy)
</source>
</class>

<class classid="501" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/ProxyERC20.sol" startline="285" endline="292" pcid="5882">
    function setIntegrationProxy(address _integrationProxy)
        external
        onlyOwner
    {
        integrationProxy = Proxy(_integrationProxy);
    }

    function setMessageSender(address sender)
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="878" endline="885" pcid="6855">
    function setIntegrationProxy(address _integrationProxy)
        external
        onlyOwner
    {
        integrationProxy = Proxy(_integrationProxy);
    }

    function setMessageSender(address sender)
</source>
</class>

<class classid="502" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/ProxyERC20.sol" startline="292" endline="299" pcid="5883">
    function setMessageSender(address sender)
        external
        onlyProxy
    {
        messageSender = sender;
    }

    modifier onlyProxy {
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="885" endline="892" pcid="6856">
    function setMessageSender(address sender)
        external
        onlyProxy
    {
        messageSender = sender;
    }

    modifier onlyProxy {
</source>
</class>

<class classid="503" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/RegulatedToken.sol" startline="25" endline="29" pcid="6059">
    function changeSymbol(string memory _newSymbol) public onlyAttributesPermission {
        symbol = _newSymbol;
    }

    function changeCIK(string memory _newCIK) public onlyAttributesPermission {
</source>
<source file="systems/smart_contracts/ScipayToken.sol" startline="16" endline="20" pcid="6374">
    function changeSymbol(string memory _newSymbol) public onlyAttributesPermission {
        symbol = _newSymbol;
    }

    function changename(string memory _newName) public onlyAttributesPermission {
</source>
</class>

<class classid="504" nclones="2" nlines="4" similarity="100">
<source file="systems/smart_contracts/RegulatedToken.sol" startline="33" endline="37" pcid="6061">
    function changename(string memory _newName) public onlyAttributesPermission {
        name = _newName;
    }

    function addWhitelisted(address _account, string memory _iso) public onlyAddWhitelistPermission {
</source>
<source file="systems/smart_contracts/ScipayToken.sol" startline="20" endline="24" pcid="6375">
    function changename(string memory _newName) public onlyAttributesPermission {
        name = _newName;
    }

    function transfer(address _to, uint _amount) public returns(bool) {
</source>
</class>

<class classid="505" nclones="2" nlines="47" similarity="85">
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="376" endline="437" pcid="6804">
    function _getAvailablePoll(Poll memory poll) private view returns (uint, uint, uint) {
        if (poll.startTime == 0) {
            return (0, 0, 0);
        }
        uint duration = 0;
        uint amount = 0;
        uint curTime = now;
        // 当前处于第几个衰减阶段
        uint currentDecayPeriod = (curTime - poll.startTime) / fourYears;
        // 上一次处于第几个衰减阶段
        uint lastDecayPeriod = 0;
        if (poll.lastMineTime > 0) {
            duration = curTime - poll.lastMineTime;
            lastDecayPeriod = (poll.lastMineTime - poll.startTime) / fourYears;
        } else {
            duration = curTime - poll.startTime;
        }

        if (currentDecayPeriod == lastDecayPeriod) {
            // 没有跨阶段
            amount = poll.amountPerMinute * duration / (60 * 2 ** currentDecayPeriod);
        }
        else {
            /**
            * 跨阶段 先计算两头的量
            * 再计算中间整阶段的量
            * 考虑了包括在端点的极端情况
            * |____|____|____|____|
            *   ^    ^    ^    ^
            *   0    1    2   3
            */
            uint right_duration = (curTime - poll.startTime) % fourYears;

            if (poll.lastMineTime > 0 && ((poll.lastMineTime - poll.startTime) % fourYears == 0)) {
                uint left_duration = fourYears - (poll.lastMineTime - poll.startTime) % fourYears;
                amount = amount + poll.amountPerMinute * left_duration / (60 * 2 ** lastDecayPeriod);
            }
            amount = amount + poll.amountPerMinute * right_duration / (60 * 2 ** currentDecayPeriod);

            // 首次跨阶段提币
            if (poll.lastMineTime == 0) {
                for (uint i = lastDecayPeriod; i < currentDecayPeriod; i++) {
                    amount = amount + poll.amountPerMinute * fourYears / (60 * 2 ** i);
                }
            }
            // 上一次提币在端点的情况
            else if (poll.lastMineTime > 0 && ((poll.lastMineTime - poll.startTime) % fourYears == 0)) {
                for (uint i = lastDecayPeriod; i < currentDecayPeriod; i++) {
                    amount = amount + poll.amountPerMinute * fourYears / (60 * 2 ** i);
                }
            }
            else {
                for (uint i = lastDecayPeriod + 1; i < currentDecayPeriod; i++) {
                    amount = amount + poll.amountPerMinute * fourYears / (60 * 2 ** i);
                }
            }
        }
        uint availableAmount = amount + poll.leftMine;
        uint totalMine = amount + poll.totalMine;
        return (currentDecayPeriod, totalMine, availableAmount);
    }
    function getAvailableBPoll() public view returns (uint, uint, uint) {
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="476" endline="537" pcid="6813">
    function _minePoll(Poll storage poll, uint value) private {
        require(value > 0, "Take value must more than zero");
        require(poll.startTime > 0, "Poll not start");
        require(poll.account != address(0), "businessAccount can't be zero address");

        uint duration = 0;
        uint amount = 0;
        uint curTime = now;
        uint _value = value * 10 ** uint(_decimals);
        // 当前处于第几个衰减阶段
        uint currentDecayPeriod = (curTime - poll.startTime) / fourYears;
        // 上一次处于第几个衰减阶段
        uint lastDecayPeriod = 0;
        if (poll.lastMineTime > 0) {
            duration = curTime - poll.lastMineTime;
            lastDecayPeriod = (poll.lastMineTime - poll.startTime) / fourYears;
        } else {
            duration = curTime - poll.startTime;
        }

        if (currentDecayPeriod == lastDecayPeriod) {
            // 没有跨阶段
            amount = poll.amountPerMinute * duration / (60 * 2 ** currentDecayPeriod);
        }
        else {
            uint right_duration = (curTime - poll.startTime) % fourYears;

            if (poll.lastMineTime > 0 && ((poll.lastMineTime - poll.startTime) % fourYears == 0)) {
                uint left_duration = fourYears - (poll.lastMineTime - poll.startTime) % fourYears;
                amount = amount + poll.amountPerMinute * left_duration / (60 * 2 ** lastDecayPeriod);
            }

            amount = amount + poll.amountPerMinute * right_duration / (60 * 2 ** currentDecayPeriod);

            // 首次跨阶段提币
            if (poll.lastMineTime == 0) {
                for (uint i = lastDecayPeriod; i < currentDecayPeriod; i++) {
                    amount = amount + poll.amountPerMinute * fourYears / (60 * 2 ** i);
                }
            }
            // 上一次提币在端点的情况
            else if (poll.lastMineTime > 0 && ((poll.lastMineTime - poll.startTime) % fourYears == 0)) {
                for (uint i = lastDecayPeriod; i < currentDecayPeriod; i++) {
                    amount = amount + poll.amountPerMinute * fourYears / (60 * 2 ** i);
                }
            }
            else {
                for (uint i = lastDecayPeriod + 1; i < currentDecayPeriod; i++) {
                    amount = amount + poll.amountPerMinute * fourYears / (60 * 2 ** i);
                }
            }
        }
        require(_value <= (poll.leftMine + amount), "Take value too large");
        uint left = poll.leftMine + amount - _value;
        poll.leftMine = left;
        balances[poll.account] = balances[poll.account] + _value;
        poll.totalMine = poll.totalMine + amount;
        poll.lastMineTime = curTime;
        poll.currentDecayPeriod = currentDecayPeriod;
        emit Transfer(address(0x0), poll.account, _value);
    }
    function mineBusinessPoll(uint value) public onlyOwner {
</source>
</class>

<class classid="506" nclones="2" nlines="8" similarity="75">
<source file="systems/smart_contracts/Synthetix.sol" startline="180" endline="207" pcid="6832">
    function _multiplyDecimalRound(uint x, uint y, uint precisionUnit)
        private
        pure
        returns (uint)
    {
        /* Divide by UNIT to remove the extra factor introduced by the product. */
        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);

        if (quotientTimesTen % 10 >= 5) {
            quotientTimesTen += 10;
        }

        return quotientTimesTen / 10;
    }

    /**
     * @return The result of safely multiplying x and y, interpreting the operands
     * as fixed-point decimals of a precise unit.
     *
     * @dev The operands should be in the precise unit factor which will be
     * divided out after the product of x and y is evaluated, so that product must be
     * less than 2**256.
     *
     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.
     * Rounding is useful when you need to retain fidelity for small decimal numbers
     * (eg. small fractions or percentages).
     */
    function multiplyDecimalRoundPrecise(uint x, uint y)
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="321" endline="335" pcid="6840">
    function preciseDecimalToDecimal(uint i)
        internal
        pure
        returns (uint)
    {
        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);

        if (quotientTimesTen % 10 >= 5) {
            quotientTimesTen += 10;
        }

        return quotientTimesTen / 10;
    }

}
</source>
</class>

<class classid="507" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/Synthetix.sol" startline="1093" endline="1104" pcid="6858">
    function allowance(address owner, address spender)
        public
        view
        returns (uint)
    {
        return tokenState.allowance(owner, spender);
    }

    /**
     * @notice Returns the ERC20 token balance of a given account.
     */
    function balanceOf(address account)
</source>
<source file="systems/smart_contracts/YOGEEToken.sol" startline="263" endline="270" pcid="8180">
    function allowance(address owner, address spender) public view returns (uint) {
        return allowed[owner][spender];
    }

    /* ------------------------------------------------------------------------
     * don't accept ETH
     */
    function () payable external {
</source>
</class>

<class classid="508" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/Synthetix.sol" startline="2402" endline="2416" pcid="6913">
    function setFeePool(IFeePool _feePool)
        external
        optionalProxy_onlyOwner
    {
        feePool = _feePool;
        emitFeePoolUpdated(_feePool);
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    /**
     * @notice Override ERC20 transfer function in order to
     * subtract the transaction fee and send it to the fee pool
     * for SNX holders to claim. */
    function transfer(address to, uint value)
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="2856" endline="2863" pcid="6933">
    function setFeePool(IFeePool _feePool)
        external
        optionalProxy_onlyOwner
    {
        feePool = _feePool;
    }

    function setExchangeRates(ExchangeRates _exchangeRates)
</source>
</class>

<class classid="509" nclones="4" nlines="11" similarity="72">
<source file="systems/smart_contracts/Synthetix.sol" startline="3561" endline="3583" pcid="6961">
    function remainingIssuableSynths(address issuer, bytes4 currencyKey)
        public
        view
        // Don't need to check for synth existing or stale rates because maxIssuableSynths will do it for us.
        returns (uint)
    {
        uint alreadyIssued = debtBalanceOf(issuer, currencyKey);
        uint max = maxIssuableSynths(issuer, currencyKey);

        if (alreadyIssued >= max) {
            return 0;
        } else {
            return max.sub(alreadyIssued);
        }
    }

    /**
     * @notice The total SNX owned by this account, both escrowed and unescrowed,
     * against which synths can be issued.
     * This includes those already being used as collateral (locked), and those
     * available for further issuance (unlocked).
     */
    function collateral(address account)
</source>
<source file="systems/smart_contracts/Synthetix.sol" startline="3607" endline="3632" pcid="6963">
    function transferableSynthetix(address account)
        public
        view
        rateNotStale("SNX")
        returns (uint)
    {
        // How many SNX do they have, excluding escrow?
        // Note: We're excluding escrow here because we're interested in their transferable amount
        // and escrowed SNX are not transferable.
        uint balance = tokenState.balanceOf(account);

        // How many of those will be locked by the amount they've issued?
        // Assuming issuance ratio is 20%, then issuing 20 SNX of value would require
        // 100 SNX to be locked in their wallet to maintain their collateralisation ratio
        // The locked synthetix value can exceed their balance.
        uint lockedSynthetixValue = debtBalanceOf(account, "SNX").divideDecimalRound(synthetixState.issuanceRatio());

        // If we exceed the balance, no SNX are transferable, otherwise the difference is.
        if (lockedSynthetixValue >= balance) {
            return 0;
        } else {
            return balance.sub(lockedSynthetixValue);
        }
    }

    function mint()
</source>
<source file="systems/smart_contracts/TimeLockedTokenStorage.sol" startline="390" endline="401" pcid="7246">
    function getAvailableTokens(uint256 _lockSlotId) public view returns(uint256) {
        if (now < uint256(lockTokenStorage[getAddressToId(_lockSlotId)][_lockSlotId].periods[0])) {
            return 0;
        } else {
            return _getAvailableTokens(getAddressToId(_lockSlotId), _lockSlotId);
        }
    }

    /**
    * @dev Returned total holders
    */
    function getHoldersQuantity() public view returns(uint256) {
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="549" endline="559" pcid="7487">
    function releaseableBalanceOf(address _owner) public view returns (uint256) {
        if (vestingOf[_owner] == address(0) ) {
            return 0;
        } else {
            return TokenVesting(vestingOf[_owner]).releasableAmount(this);
        }
    }

    /// @dev revoke vested tokens for the specified address.
    /// Tokens already vested remain in the contract, the rest are returned to the owner.
    function revokeVestedTokensFor(address _owner) public onlyOwner {
</source>
</class>

<class classid="510" nclones="2" nlines="8" similarity="100">
<source file="systems/smart_contracts/TeaToken.sol" startline="26" endline="39" pcid="7121">
    function transfer(address _to, uint256 _value)
        public
        returns (bool)
    {
        if (balances[msg.sender] < _value) {
            throw;
        }
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value)
</source>
<source file="systems/smart_contracts/ZhongChaChainToken.sol" startline="26" endline="39" pcid="8218">
    function transfer(address _to, uint256 _value)
        public
        returns (bool)
    {
        if (balances[msg.sender] < _value) {
            throw;
        }
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value)
</source>
</class>

<class classid="511" nclones="2" nlines="8" similarity="100">
<source file="systems/smart_contracts/TeaToken.sol" startline="39" endline="53" pcid="7122">
    function transferFrom(address _from, address _to, uint256 _value)
        public
        returns (bool)
    {
        if (balances[_from] < _value || allowed[_from][msg.sender] < _value) {
            throw;
        }
        balances[_to] += _value;
        balances[_from] -= _value;
        allowed[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value)
</source>
<source file="systems/smart_contracts/ZhongChaChainToken.sol" startline="39" endline="53" pcid="8219">
    function transferFrom(address _from, address _to, uint256 _value)
        public
        returns (bool)
    {
        if (balances[_from] < _value || allowed[_from][msg.sender] < _value) {
            throw;
        }
        balances[_to] += _value;
        balances[_from] -= _value;
        allowed[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value)
</source>
</class>

<class classid="512" nclones="2" nlines="4" similarity="75">
<source file="systems/smart_contracts/TeaToken.sol" startline="85" endline="91" pcid="7126">
    function TeaToken()
        public
    {
        totalSupply = 1000000000 * 10**18;
        balances[msg.sender] = totalSupply;
    }
}
</source>
<source file="systems/smart_contracts/ZhongChaChainToken.sol" startline="85" endline="91" pcid="8223">
    function ZhongChaChainToken()
        public
    {
        totalSupply = 1000000000 * 10**18;
        balances[msg.sender] = totalSupply;
    }
}
</source>
</class>

<class classid="513" nclones="2" nlines="7" similarity="71">
<source file="systems/smart_contracts/TokenSale.sol" startline="321" endline="332" pcid="7368">
    function addManyToWhitelist(address[] _addresses) external onlyOwner {
        for (uint256 i = 0; i < _addresses.length; i++) {
            allowedAddresses[_addresses[i]] = true;
            emit WhitelistUpdated(now, "Added", _addresses[i]);
        }
    }

    /**
     * @dev remove whitelist addresses
     * @param _addresses Array of ethereum addresses
     */
    function removeManyFromWhitelist(address[] _addresses) public onlyOwner {
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="332" endline="338" pcid="7369">
    function removeManyFromWhitelist(address[] _addresses) public onlyOwner {
        for (uint256 i = 0; i < _addresses.length; i++) {
            allowedAddresses[_addresses[i]] = false;
            emit WhitelistUpdated(now, "Removed", _addresses[i]);
        }
    }
}
</source>
</class>

<class classid="514" nclones="3" nlines="7" similarity="71">
<source file="systems/smart_contracts/TrueProfileLogic.sol" startline="32" endline="38" pcid="7491">
    function allowAccess(address _address) ownership public {
        if (_address != address(0)) {
            accessAllowed[_address] = true;
        }
    }

    function denyAccess(address _address) ownership public {
</source>
<source file="systems/smart_contracts/TrueProfileLogic.sol" startline="44" endline="49" pcid="7493">
    function transferOwnership(address _address) ownership public {
        if (_address != address(0)) {
            owner = _address;
        }
    }
}
</source>
<source file="systems/smart_contracts/TrueProfileLogic.sol" startline="38" endline="44" pcid="7492">
    function denyAccess(address _address) ownership public {
        if (_address != address(0)) {
            accessAllowed[_address] = false;
        }
    }

    function transferOwnership(address _address) ownership public {
</source>
</class>

</clones>
