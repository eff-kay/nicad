allowance(address tokenOwner, address spender) public view returns(uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
            return allowed[tokenOwner][spender];
        }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {

        return allowed[tokenOwner][spender];

    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender)public constant returns (uint remaining) {
		return allowed[tokenOwner][spender];
	}
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address _owner, address _spender)public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender)public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender)public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender)public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender)public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender)public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender)public view returns (uint256 remaining) {
      return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval}
allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval}
allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="270" endline="272" pcid="7290">
  function allowance(address owner, address spender) external view returns (uint256);

  function transfer(address to, uint256 value) external;
</source>
<source file="systems/smart_contracts/BANG.sol" startline="14" endline="15" pcid="1037">
  function allowance(address owner, address spender) external view returns (uint256);
  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/NewVoken.sol" startline="153" endline="155" pcid="5348">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="236" endline="239" pcid="7284">
  function allowance(address owner, address spender)
    external view returns (uint256);

  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="269" endline="285" pcid="3807">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/Byte.sol" startline="12" endline="13" pcid="1567">
  function allowance(address owner, address spender) external view returns (uint256);
  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="90" endline="93" pcid="4236">
  function allowance(address owner, address spender)
  external view returns (uint256);

  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="211" endline="227" pcid="7180">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="10" endline="11" pcid="7312">
  function allowance(address owner, address spender) external view returns (uint256);
  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/GFNX.sol" startline="15" endline="18" pcid="4094">
  function allowance(address owner, address spender)
    external view returns (uint256);

  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="150" endline="166" pcid="4423">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/MultipleArbitrableTokenTransaction.sol" startline="284" endline="300" pcid="5159">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="144" endline="160" pcid="4034">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/LuckyAdvcedWoken.sol" startline="19" endline="21" pcid="4553">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/MAdvcedWoken.sol" startline="19" endline="21" pcid="4592">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/TokenSwap.sol" startline="158" endline="160" pcid="7400">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="31" endline="32" pcid="3163">
  function allowance(address owner, address spender) external view returns (uint256);
  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="38" endline="40" pcid="7640">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="183" endline="186" pcid="7713">
    function allowance(address owner, address spender)
    external view returns (uint256);

    function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="193" endline="194" pcid="7790">
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="145" endline="161" pcid="7903">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/PokaToken.sol" startline="18" endline="20" pcid="5730">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/WTA.sol" startline="64" endline="65" pcid="8048">
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="27" endline="29" pcid="3014">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="144" endline="160" pcid="8193">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="42" endline="58" pcid="8227">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="183" endline="186" pcid="2240">
    function allowance(address owner, address spender)
    external view returns (uint256);

    function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="43" endline="59" pcid="7014">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="14" endline="15" pcid="2388">
  function allowance(address owner, address spender) external view returns (uint256);
  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/NSTTeamLock.sol" startline="20" endline="22" pcid="5456">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/magesh.sol" startline="85" endline="87" pcid="4617">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="80" endline="81" pcid="6984">
    function allowance(address owner, address spender) external view returns (uint256);
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/SuperMarket.sol" startline="18" endline="20" pcid="6758">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="183" endline="186" pcid="6726">
    function allowance(address owner, address spender)
    external view returns (uint256);

    function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/Factory.sol" startline="201" endline="202" pcid="3448">
    function allowance(address owner, address spender) external view returns (uint256);
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="34" endline="50" pcid="5772">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval}
allowance(address owner, address spender) external view returns (uint256);

    function okToTransferTokens(address _holder, uint256 _amountToAdd) external view returns (bool);
</source>
<source file="systems/smart_contracts/SBC.sol" startline="293" endline="295" pcid="6334">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="85" endline="87" pcid="4929">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="10" endline="11" pcid="6197">
  function allowance(address owner, address spender) external view returns (uint256);
  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="253" endline="255" pcid="3566">
    function allowance(address owner, address spender) external view returns (uint256);

    function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="118" endline="134" pcid="2461">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="10" endline="11" pcid="3914">
  function allowance(address owner, address spender) external view returns (uint256);
  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/FPDeployer.sol" startline="776" endline="777" pcid="3882">
    function allowance(address owner, address spender) external view returns (uint256);
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/CNG.sol" startline="16" endline="19" pcid="1842">
  function allowance(address owner, address spender)
    external view returns (uint256);

  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="118" endline="134" pcid="6020">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="12" endline="13" pcid="5986">
  function allowance(address owner, address spender) external view returns (uint256);
  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="168" endline="184" pcid="5957">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="40" endline="56" pcid="5905">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval}
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowances[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowances[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender)
        constant
        public
        returns (uint256)
    {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender)
        constant
        public
        returns (uint256)
    {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(
    address owner,
    address spender
   )
    public
    view
    returns (uint256)
  {
    return _allowed[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(
        address owner,
        address spender
    )
    public
    view
    returns (uint256)
    {
        return _allowed[owner][spender];
    }
allowance(
    address owner,
    address spender
  )
  public
  view
  returns (uint256)
  {
    return _allowed[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(
    address owner,
    address spender
   )
    public
    view
    returns (uint256)
  {
    return _allowed[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256) 
    {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
allowance(
    address _owner,
    address _spender
   )
    public
    view
    returns (uint256)
  {
    return allowed[_owner][_spender];
  }
allowance(
		address _owner,
		address _spender
	)
	public
	view
	returns (uint256)
	{
		return allowed[_owner][_spender];
	}
allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
     }
allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
allowance(
    address _owner,
    address _spender
   )
    public
    view
    returns (uint256)
  {
    return allowed[_owner][_spender];
  }
allowance(
    address _owner,
    address _spender
   )
    public
    view
    returns (uint256)
  {
    return allowed[_owner][_spender];
  }
allowance(
        address _owner,
        address _spender
    )
    public
    view
    returns (uint256)
    {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
allowance(
        address _owner,
        address _spender
    )
    public
    view
    returns (uint256)
    {
        return allowed[_owner][_spender];
    }
allowance(
        address _owner,
        address _spender
    )
    public
    view
    returns (uint256)
    {
        return allowed[_owner][_spender];
    }
allowance(
    address _owner,
    address _spender
   )
    public
    view
    returns (uint256)
  {
    return allowed[_owner][_spender];
  }
allowance(
    address _owner,
    address _spender
   )
    public
    view
    returns (uint256)
  {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender)
        public
        constant
        returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) constant returns (uint remaining) {}
allowance(address _owner, address _spender) constant returns (uint remaining) {}
allowance(address _owner, address _spender) constant returns (uint remaining) {}
allowance(address _owner, address _spender) constant returns (uint) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) constant returns (uint) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) constant returns (uint) {
        return allowed[_owner][_spender];
    }
allowance(address _holder, address _spender) public view returns (uint256) {
        return allowed[_holder][_spender];
    }
allowance(address _holder, address _spender) public view returns (uint256) {
        return allowed[_holder][_spender];
    }
allowance(address _owner, address _spender) constant returns (uint remaining) {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender) constant returns (uint remaining) {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender) constant returns (uint remaining) {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender) constant returns (uint remaining) {
    return allowed[_owner][_spender];
  }
allowance(address _from, address _spender) public view returns (uint256){
        return operator.token_allowance(_from, _spender);
    }
allowance(address owner, address spender)
        public
        view
        returns (uint)
    {
        return tokenState.allowance(owner, spender);
    }
allowance(address _from, address _spender) public view returns (uint256);

    function transfer(address _to, uint256 _value) public returns (bool success);
</source>
<source file="systems/smart_contracts/Byte.sol" startline="12" endline="13" pcid="1567">
  function allowance(address owner, address spender) external view returns (uint256);
  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/BoleToken.sol" startline="73" endline="74" pcid="1436">
    function allowance(address owner, address spender) public constant returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/DAITOKEN.sol" startline="13" endline="15" pcid="2298">
  function allowance(address owner, address spender) external view returns (uint256);

  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/CrowdsaleTokenExt.sol" startline="142" endline="143" pcid="2103">
  function allowance(address owner, address spender) public constant returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/AoraCoin.sol" startline="20" endline="23" pcid="726">
  function allowance(address owner, address spender)
    external view returns (uint256);

  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/AronCoin.sol" startline="24" endline="25" pcid="758">
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/CST_TOKEN.sol" startline="9" endline="10" pcid="2193">
  function allowance(address _owner, address _spender) external view returns (uint256);
  function transfer(address _to, uint256 _value) external returns (bool);
</source>
<source file="systems/smart_contracts/ankara.sol" startline="29" endline="31" pcid="680">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/AMAToken.sol" startline="40" endline="56" pcid="645">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/ALBToken.sol" startline="199" endline="201" pcid="581">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/Crowdsale.sol" startline="49" endline="52" pcid="2043">
    function allowance(address owner, address spender)
        public view returns (uint256);

    function transferFrom(address from, address to, uint256 value)
</source>
<source file="systems/smart_contracts/AkropolisTokenVesting.sol" startline="40" endline="56" pcid="518">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/Authorization.sol" startline="118" endline="134" pcid="948">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/AkropolisTimeLock.sol" startline="40" endline="56" pcid="478">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/Aigopay.sol" startline="78" endline="79" pcid="448">
    function allowance(address owner, address spender) public constant returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/EducationLibra.sol" startline="43" endline="44" pcid="2880">
    function allowance(address owner, address spender) public constant returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/BlockPoolToken.sol" startline="128" endline="129" pcid="1417">
    function allowance(address owner, address spender) public view returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/CoinDumper.sol" startline="200" endline="201" pcid="1892">
    function allowance(address owner, address spender) public constant returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/BFGToken.sol" startline="54" endline="55" pcid="1184">
  function allowance(address owner, address agent) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/DABANKING_SWAP.sol" startline="20" endline="22" pcid="2271">
    function allowance(address owner, address spender) public view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="63" endline="65" pcid="2828">
    function allowance(address _from, address _spender) public view returns (uint256);

    function transfer(address _to, uint256 _value) public returns (bool success);
</source>
<source file="systems/smart_contracts/CustomToken.sol" startline="183" endline="186" pcid="2240">
    function allowance(address owner, address spender)
    external view returns (uint256);

    function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/CRUSH.sol" startline="10" endline="11" pcid="2146">
  function allowance(address owner, address spender) external view returns (uint256);
  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/DummyToken.sol" startline="98" endline="100" pcid="2845">
    function token_allowance(address _from, address _spender) public view returns (uint256);

    function token_transfer(address _from, address _to, uint256 _value) public returns (bool success);
</source>
<source file="systems/smart_contracts/BKN.sol" startline="18" endline="19" pcid="1321">
    function allowance(address owner, address spender) public constant returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/ABCToken.sol" startline="38" endline="54" pcid="302">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval}
allowance(address owner, address spender) public constant returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/CASTWEETTOKEN.sol" startline="101" endline="102" pcid="1630">
    function allowance(address owner, address spender) public view returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/BANG.sol" startline="14" endline="15" pcid="1037">
  function allowance(address owner, address spender) external view returns (uint256);
  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/BOMBv3.sol" startline="14" endline="15" pcid="1461">
  function allowance(address owner, address spender) external view returns (uint256);
  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/DepositRegistry.sol" startline="118" endline="134" pcid="2461">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/DiamondChain.sol" startline="14" endline="15" pcid="2548">
  function allowance(address owner, address spender) external view returns (uint256);
  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/GoldenRings.sol" startline="46" endline="47" pcid="4172">
    function allowance(address owner, address spender) public view returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/HupayX.sol" startline="90" endline="93" pcid="4236">
  function allowance(address owner, address spender)
  external view returns (uint256);

  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/ILLUSION.sol" startline="77" endline="78" pcid="4301">
    function allowance(address owner, address spender) public constant returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/DigitalBitsToken.sol" startline="18" endline="21" pcid="2735">
  function allowance(address owner, address spender)
    external view returns (uint256);

  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/GFNX.sol" startline="15" endline="18" pcid="4094">
  function allowance(address owner, address spender)
    external view returns (uint256);

  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/BDAM.sol" startline="173" endline="174" pcid="1122">
  function allowance(address owner, address spender) public constant returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/KAKITOKEN.sol" startline="102" endline="103" pcid="4384">
    function allowance(address owner, address spender) public view returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/BlockbidLiquidity.sol" startline="24" endline="26" pcid="1364">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/KGCMortage.sol" startline="150" endline="166" pcid="4423">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/GAToken.sol" startline="144" endline="160" pcid="4034">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/LBBT.sol" startline="44" endline="47" pcid="4539">
  function allowance(address owner, address spender)
    public view returns (uint256);

  function approve(address spender, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/LuckyAdvcedWoken.sol" startline="19" endline="21" pcid="4553">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/MAdvcedWoken.sol" startline="19" endline="21" pcid="4592">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/magesh.sol" startline="85" endline="87" pcid="4617">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/GameGold.sol" startline="194" endline="195" pcid="3997">
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/ZPayToken.sol" startline="42" endline="58" pcid="8227">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/YottaBytes.sol" startline="144" endline="160" pcid="8193">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/CMRPDCrowdsale.sol" startline="40" endline="56" pcid="1747">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/ERC20TOKEN.sol" startline="27" endline="29" pcid="3014">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/MainToken.sol" startline="70" endline="73" pcid="4648">
  function allowance(address owner, address spender)
    public view returns (uint256);

  function transferFrom(address from, address to, uint256 value)
</source>
<source file="systems/smart_contracts/XGP.sol" startline="78" endline="79" pcid="8105">
    function allowance(address owner, address spender) public constant returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/XCToken.sol" startline="15" endline="16" pcid="8071">
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/bitforedex.sol" startline="65" endline="66" pcid="1273">
    function allowance(address owner, address spender) public constant returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/EnergiPlus.sol" startline="66" endline="67" pcid="2953">
    function allowance(address owner, address spender) public constant returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/WTA.sol" startline="64" endline="65" pcid="8048">
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/WizardCashCoin.sol" startline="43" endline="44" pcid="8014">
    function allowance(address owner, address spender) public constant returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/EstateRegistry.sol" startline="59" endline="62" pcid="3062">
  function isApprovedForAll(address _owner, address _operator)
    public view returns (bool);

  function transferFrom(address _from, address _to, uint256 _tokenId) public;
</source>
<source file="systems/smart_contracts/WantMarketplacesUtilityTokenCrowdsale.sol" startline="145" endline="161" pcid="7903">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/VokenShareholders.sol" startline="193" endline="194" pcid="7790">
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/VisionBitcoinCash.sol" startline="24" endline="25" pcid="7742">
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/VictorToken.sol" startline="183" endline="186" pcid="7713">
    function allowance(address owner, address spender)
    external view returns (uint256);

    function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/VantaToken.sol" startline="38" endline="40" pcid="7640">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/MBA.sol" startline="103" endline="106" pcid="4708">
  function allowance(address owner, address spender)
    public view returns (uint256);

  function transferFrom(address from, address to, uint256 value)
</source>
<source file="systems/smart_contracts/UTC.sol" startline="123" endline="124" pcid="7581">
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/ESTATERO.sol" startline="31" endline="32" pcid="3163">
  function allowance(address owner, address spender) external view returns (uint256);
  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/UGCoin.sol" startline="39" endline="40" pcid="7529">
    function allowance(address owner, address spender) public constant returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/TRT_Token.sol" startline="115" endline="116" pcid="7458">
    function allowance(address owner, address spender) public view returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/DNP.sol" startline="72" endline="73" pcid="2788">
    function allowance(address owner, address spender) public view returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/TorexToken.sol" startline="156" endline="159" pcid="7415">
  function allowance(address owner, address spender)
    public view returns (uint256);

  function transferFrom(address from, address to, uint256 value)
</source>
<source file="systems/smart_contracts/TokenSwap.sol" startline="158" endline="160" pcid="7400">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/TokenSale.sol" startline="276" endline="277" pcid="7354">
    function allowance(address owner, address spender) public view returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/Tokeniso.sol" startline="10" endline="11" pcid="7312">
  function allowance(address owner, address spender) external view returns (uint256);
  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/etherstar.sol" startline="102" endline="104" pcid="3236">
    function isApprovedForAll(address owner, address operator) public view returns (bool);

    function transferFrom(address from, address to, uint256 tokenId) public;
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="270" endline="272" pcid="7290">
  function allowance(address owner, address spender) external view returns (uint256);

  function transfer(address to, uint256 value) external;
</source>
<source file="systems/smart_contracts/TokenBank.sol" startline="236" endline="239" pcid="7284">
  function allowance(address owner, address spender)
    external view returns (uint256);

  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/TigerCash.sol" startline="211" endline="227" pcid="7180">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/tharDex.sol" startline="15" endline="16" pcid="7143">
     function allowance(address _owner, address _spender)external view returns(uint256);
}
</source>
<source file="systems/smart_contracts/Gacha.sol" startline="61" endline="63" pcid="3969">
    function isApprovedForAll(address owner, address operator) public view returns (bool);

    function transfer(address to, uint256 tokenId) public;
</source>
<source file="systems/smart_contracts/DcorpDissolvementProposal.sol" startline="73" endline="74" pcid="2333">
    function allowance(address _owner, address _spender) external view returns (uint);
}
</source>
<source file="systems/smart_contracts/MBFToken.sol" startline="461" endline="465" pcid="4765">
    function allowance(address _owner, address _spender)
        external
        view
        returns (uint256);
}
</source>
<source file="systems/smart_contracts/BountyBoard.sol" startline="117" endline="118" pcid="1494">
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/$martFund.sol" startline="104" endline="106" pcid="39">
    function token_allowance(address _from, address _spender) public view returns (uint256);

    function token_transfer(address _from, address _to, uint256 _value) public returns (bool success);
</source>
<source file="systems/smart_contracts/TDeployer.sol" startline="43" endline="59" pcid="7014">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/MintedTokenCappedCrowdsaleExt.sol" startline="334" endline="335" pcid="4855">
  function allowance(address owner, address spender) public constant returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/TDCToken.sol" startline="80" endline="81" pcid="6984">
    function allowance(address owner, address spender) external view returns (uint256);
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/SuperPointsToken.sol" startline="186" endline="187" pcid="6782">
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/MockOracle.sol" startline="85" endline="87" pcid="4929">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/SuperMarket.sol" startline="18" endline="20" pcid="6758">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/STPCToken.sol" startline="183" endline="186" pcid="6726">
    function allowance(address owner, address spender)
    external view returns (uint256);

    function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/Stakeo.sol" startline="71" endline="72" pcid="6682">
    function allowance(address owner, address spender) public constant returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/Fuelcoin.sol" startline="10" endline="11" pcid="3914">
  function allowance(address owner, address spender) external view returns (uint256);
  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/SparksterTokenSwap.sol" startline="530" endline="532" pcid="6622">
	function allowance(address owner, address spender) public view returns (uint256);

	function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/SmokeCoinV_2.sol" startline="66" endline="67" pcid="6550">
    function allowance(address owner, address spender) public constant returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/SistContract.sol" startline="48" endline="49" pcid="6518">
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/ShekzCoin.sol" startline="69" endline="70" pcid="6484">
    function allowance(address owner, address spender) public constant returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/Deflacoin.sol" startline="14" endline="15" pcid="2388">
  function allowance(address owner, address spender) external view returns (uint256);
  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/SellableToken.sol" startline="42" endline="43" pcid="6461">
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/Factory.sol" startline="201" endline="202" pcid="3448">
    function allowance(address owner, address spender) external view returns (uint256);
    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/SeedDex.sol" startline="27" endline="29" pcid="6410">
    function allowance(address owner, address spender) external view returns (uint256);

    function okToTransferTokens(address _holder, uint256 _amountToAdd) external view returns (bool);
</source>
<source file="systems/smart_contracts/SBC.sol" startline="293" endline="295" pcid="6334">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/Fair7Token.sol" startline="62" endline="63" pcid="3520">
    function allowance(address owner, address spender) public constant returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/MonereumNetwork.sol" startline="65" endline="66" pcid="4958">
    function allowance(address owner, address spender) public constant returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/ROCKEX.sol" startline="10" endline="11" pcid="6197">
  function allowance(address owner, address spender) external view returns (uint256);
  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/RETC.sol" startline="39" endline="40" pcid="6180">
    function allowance(address owner, address spender) public constant returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/ReservedTokensFinalizeAgent.sol" startline="329" endline="330" pcid="6095">
  function allowance(address owner, address spender) public constant returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/Faireum.sol" startline="253" endline="255" pcid="3566">
    function allowance(address owner, address spender) external view returns (uint256);

    function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/ReferralTracker.sol" startline="118" endline="134" pcid="6020">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/RDTv1.sol" startline="12" endline="13" pcid="5986">
  function allowance(address owner, address spender) external view returns (uint256);
  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/RaffleTicket.sol" startline="168" endline="184" pcid="5957">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
</source>
<source file="systems/smart_contracts/QTChain.sol" startline="40" endline="56" pcid="5905">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval}
allowance(address owner, address spender)
    external view returns (uint256);

  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/ProxyERC20.sol" startline="334" endline="336" pcid="5886">
    function allowance(address owner, address spender) public view returns (uint);

    function transfer(address to, uint value) public returns (bool);
</source>
<source file="systems/smart_contracts/Comet.sol" startline="10" endline="11" pcid="1914">
  function allowance(address owner, address spender) external view returns (uint256);
  function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/PropertyToken.sol" startline="82" endline="85" pcid="5839">
    function allowance(address owner, address spender)
    external view returns (uint256);

    function transfer(address to, uint256 value) external returns (bool);
</source>
<source file="systems/smart_contracts/Moshlink.sol" startline="454" endline="457" pcid="5009">
    function isApprovedForAll(address owner, address operator) public view returns (bool);


    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;
</source>
<source file="systems/smart_contracts/PPLL.sol" startline="34" endline="50" pcid="5772">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval}
allowance(address _owner, address _spender)
    public view returns (uint256);

  function transferFrom(address _from, address _to, uint256 _value)
</source>
<source file="systems/smart_contracts/FMT.sol" startline="17" endline="18" pcid="3648">
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
</source>
<source file="systems/smart_contracts/PokaToken.sol" startline="18" endline="20" pcid="5730">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/PoaOperator.sol" startline="317" endline="319" pcid="5687">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/NSTTeamLock.sol" startline="20" endline="22" pcid="5456">
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);
</source>
<source file="systems/smart_contracts/NibiruGovernanceToken.sol" startline="186" endline="202" pcid="5419">
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval}
allowance(address tokenOwner, address spender) public view returns(uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
            return allowed[tokenOwner][spender];
        }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender)public constant returns (uint remaining) {
		return allowed[tokenOwner][spender];
	}
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {

        return allowed[tokenOwner][spender];

    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return _allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address _owner, address _spender)public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender)public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender)
        public
        constant
        returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender)public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender)public view returns (uint256 remaining) {
      return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint256 remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address _owner, address _spender) public view returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view
  returns (uint256 remaining) {
    return allowances [_owner][_spender];
  }
allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender)public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender)public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender)public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address owner, address agent) public view returns (uint256) {
    return _allowances[owner][agent];
  }
allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _holder, address _spender) public view returns (uint256) {
        return allowed[_holder][_spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(address _owner, address _spender) public view returns (uint256) {
    return _allowed[_owner][_spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(
    address owner,
    address spender
  )
  public
  view
  returns (uint256)
  {
    return _allowed[owner][spender];
  }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowances[owner][spender];
  }
allowance(
        address _owner,
        address _spender
    )
    public
    view
    returns (uint256)
    {
        return allowed[_owner][_spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender)
        constant
        public
        returns (uint256)
    {
        return allowed[_owner][_spender];
    }
allowance(
        address owner,
        address spender
    )
    public
    view
    returns (uint256)
    {
        return _allowed[owner][spender];
    }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowances[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(
        address _owner,
        address _spender
    )
    public
    view
    returns (uint256)
    {
        return allowed[_owner][_spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address from, address delegate) public view returns (uint) {
        return allowed[from][delegate];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(
    address _owner,
    address _spender
   )
    public
    view
    returns (uint256)
  {
    return allowed[_owner][_spender];
  }
allowance(address _holder, address _spender) public view returns (uint256) {
        return allowed[_holder][_spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(
    address _owner,
    address _spender
   )
    public
    view
    returns (uint256)
  {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(
    address _owner,
    address _spender
   )
    public
    view
    returns (uint256)
  {
    return allowed[_owner][_spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
     }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
allowance(address owner, address spender) public view returns (uint) {
        return allowed[owner][spender];
    }
allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(
        address _owner,
        address _spender
    )
    public
    view
    returns (uint256)
    {
        return allowed[_owner][_spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(
    address owner,
    address spender
   )
    public
    view
    returns (uint256)
  {
    return _allowed[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(
    address _owner,
    address _spender
   )
    public
    view
    returns (uint256)
  {
    return allowed[_owner][_spender];
  }
allowance(
    address _owner,
    address _spender
   )
    public
    view
    returns (uint256)
  {
    return allowed[_owner][_spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(
    address owner,
    address spender
   )
    public
    view
    returns (uint256)
  {
    return _allowed[owner][spender];
  }
allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256) 
    {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(
		address _owner,
		address _spender
	)
	public
	view
	returns (uint256)
	{
		return allowed[_owner][_spender];
	}
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address tokenOwner, address spender) public view returns(uint){
        return allowed[tokenOwner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(address _owner, address _spender)
        constant
        public
        returns (uint256)
    {
        return allowed[_owner][_spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address src, address guy) public constant returns (uint256) {
        return _approvals[src][guy];
    }
allowance(address _owner, address _spender)public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
     }
allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(
        address _owner,
        address _spender
    )
    public
    view
    returns (uint256)
    {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender)public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(
    address _owner,
    address _spender
   )
    public
    view
    returns (uint256)
  {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(
    address _owner,
    address _spender
   )
    public
    view
    returns (uint256)
  {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender)public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender) constant returns (uint) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(
        address _owner,
        address _spender
    )
    public
    view
    returns (uint256)
    {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender)
        constant
        public
        returns (uint256)
    {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender)
        public
        constant
        returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender)public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(
    address _owner,
    address _spender
   )
    public
    view
    returns (uint256)
  {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender)public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256) 
    {
        return allowed[_owner][_spender];
    }
allowance(
		address _owner,
		address _spender
	)
	public
	view
	returns (uint256)
	{
		return allowed[_owner][_spender];
	}
allowance(address _owner, address _spender) constant returns (uint remaining) {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(
        address _owner,
        address _spender
    )
    public
    view
    returns (uint256)
    {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender) public onlyPayloadSize(2) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view
  returns (uint256 remaining) {
    return allowances [_owner][_spender];
  }
allowance(address _owner, address _spender) constant returns (uint) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender)public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(
    address _owner,
    address _spender
   )
    public
    view
    returns (uint256)
  {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) constant returns (uint remaining) {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender) constant returns (uint remaining) {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender)public view returns (uint256 remaining) {
      return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(
    address _owner,
    address _spender
   )
    public
    view
    returns (uint256)
  {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) constant returns (uint remaining) {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender)
        constant
        public
        returns (uint256)
    {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender) constant returns (uint) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
allowance(
        address _owner,
        address _spender)
        public
        view
        returns (uint256)
    {
        return denormalize(allowed[_owner][_spender]);
    }
allowance(address _owner, address _spender) public view returns (uint256) {
    return _allowed[_owner][_spender];
  }
allowance(address _owner, address _spender) constant returns (uint256 remaining) {}
allowance(address _owner, address _spender) constant returns (uint remaining) {}
allowance(address _owner, address _spender) constant returns (uint remaining) {}
allowance(address _owner, address _spender) constant returns (uint remaining) {}
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(
        address owner,
        address spender
    )
        public
        view
        returns (uint256)
    {
        // Immutable static call from target contract
        return IERC20(target).allowance(owner, spender);
    }
allowance(
        address owner,
        address spender
    )
    public
    view
    returns (uint256)
    {
        return _allowed[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowances[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(
    address owner,
    address spender
  )
  public
  view
  returns (uint256)
  {
    return _allowed[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(
    address owner,
    address spender
   )
    public
    view
    returns (uint256)
  {
    return _allowed[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(
    address owner,
    address spender
   )
    public
    view
    returns (uint256)
  {
    return _allowed[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowances[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }
allowance(address tokenOwner, address spender) public view returns(uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {

        return allowed[tokenOwner][spender];

    }
allowance(address _owner, address _spender)public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
            return allowed[tokenOwner][spender];
        }
allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint256 remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address _owner, address _spender) constant returns (uint) {
        return allowed[_owner][_spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address _owner, address _spender) public view returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender) public view
  returns (uint256 remaining) {
    return allowances [_owner][_spender];
  }
allowance(address _owner, address _spender)public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender)public constant returns (uint remaining) {
		return allowed[tokenOwner][spender];
	}
allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address _owner, address _spender)public view returns (uint256 remaining) {
      return allowed[_owner][_spender];
  }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address _owner, address _spender)
        public
        constant
        returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address _owner, address _spender) constant returns (uint) {
        return allowed[_owner][_spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return _allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address _owner, address _spender)public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address _owner, address _spender) constant returns (uint) {
        return allowed[_owner][_spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender)public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender)public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
allowance(address _owner, address _spender)public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
